   1               		.file	"main.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               	.global	USART_Receive
  12               	USART_Receive:
  13               	.LFB12:
  14               		.file 1 "setup.c"
   1:setup.c       **** /*
   2:setup.c       ****  GBxCart RW
   3:setup.c       ****  PCB version: 1.1 or 1.2
   4:setup.c       ****  Firmware version: R11
   5:setup.c       ****  Author: Alex from insideGadgets (www.insidegadgets.com)
   6:setup.c       ****  Created: 7/11/2016
   7:setup.c       ****  Last Modified: 14/09/2018
   8:setup.c       ****  
   9:setup.c       ****  */
  10:setup.c       ****  
  11:setup.c       **** #ifndef cbi
  12:setup.c       **** #define cbi(sfr, bit) (_SFR_BYTE(sfr) &= ~_BV(bit))
  13:setup.c       **** #endif
  14:setup.c       **** #ifndef sbi
  15:setup.c       **** #define sbi(sfr, bit) (_SFR_BYTE(sfr) |= _BV(bit))
  16:setup.c       **** #endif
  17:setup.c       **** 
  18:setup.c       **** #ifndef NULL
  19:setup.c       **** #define NULL ((void *)0)
  20:setup.c       **** #endif
  21:setup.c       **** 
  22:setup.c       **** #define LOW 0
  23:setup.c       **** #define HIGH 1
  24:setup.c       **** #define false 0
  25:setup.c       **** #define true 1
  26:setup.c       **** 
  27:setup.c       **** #define SWITCH_DETECT PD2
  28:setup.c       **** #define ACTIVITY_LED PD3
  29:setup.c       **** #define LED_5V PD7
  30:setup.c       **** #define LED_3V PE0
  31:setup.c       **** 
  32:setup.c       **** #define WR_PIN PD6
  33:setup.c       **** #define RD_PIN PD5
  34:setup.c       **** #define CS_MREQ_PIN PD4
  35:setup.c       **** #define CS2_PIN PE2
  36:setup.c       **** #define AUDIO_PIN PE1
  37:setup.c       **** 
  38:setup.c       **** #define wrPin_high	PORTD |= (1<<WR_PIN);
  39:setup.c       **** #define wrPin_low		PORTD &= ~(1<<WR_PIN);
  40:setup.c       **** #define rdPin_high	PORTD |= (1<<RD_PIN);
  41:setup.c       **** #define rdPin_low		PORTD &= ~(1<<RD_PIN);
  42:setup.c       **** #define cs_mreqPin_high		PORTD |= (1<<CS_MREQ_PIN);
  43:setup.c       **** #define cs_mreqPin_low		PORTD &= ~(1<<CS_MREQ_PIN);
  44:setup.c       **** #define cs2Pin_high		PORTE |= (1<<CS2_PIN);
  45:setup.c       **** #define cs2Pin_low		PORTE &= ~(1<<CS2_PIN);
  46:setup.c       **** #define audioPin_high	PORTE |= (1<<AUDIO_PIN);
  47:setup.c       **** #define audioPin_low		PORTE &= ~(1<<AUDIO_PIN);
  48:setup.c       **** 
  49:setup.c       **** #define GB_MODE 1
  50:setup.c       **** #define GBA_MODE 2
  51:setup.c       **** 
  52:setup.c       **** // GB/GBC
  53:setup.c       **** #define PORT_ADDR7_0 PORTB
  54:setup.c       **** #define PORT_ADDR15_8 PORTA
  55:setup.c       **** #define PORT_DATA7_0 PORTC
  56:setup.c       **** 
  57:setup.c       **** #define DDR_ADDR7_0 DDRB
  58:setup.c       **** #define DDR_ADDR15_8 DDRA
  59:setup.c       **** #define DDR_DATA7_0 DDRC
  60:setup.c       **** 
  61:setup.c       **** #define PIN_ADDR7_0 PINB
  62:setup.c       **** #define PIN_ADDR15_8 PINA
  63:setup.c       **** #define PIN_DATA7_0 PINC
  64:setup.c       **** 
  65:setup.c       **** #define BANK_WRITE 0
  66:setup.c       **** #define MEMORY_WRITE 1
  67:setup.c       **** 
  68:setup.c       **** // GBA
  69:setup.c       **** #define EEPROM_WRITE 1
  70:setup.c       **** #define EEPROM_READ 0
  71:setup.c       **** 
  72:setup.c       **** #define EEPROM_NONE 0
  73:setup.c       **** #define EEPROM_4KBIT 1
  74:setup.c       **** #define EEPROM_64KBIT 2
  75:setup.c       **** 
  76:setup.c       **** #define AD0 PB0
  77:setup.c       **** #define ad0Pin_high		PORTB |= (1<<AD0);
  78:setup.c       **** #define ad0Pin_low		PORTB &= ~(1<<AD0);
  79:setup.c       **** 
  80:setup.c       **** #define A23 PC7
  81:setup.c       **** #define a23Pin_high		PORTC |= (1<<A23);
  82:setup.c       **** #define a23Pin_low		PORTC &= ~(1<<A23);
  83:setup.c       **** 
  84:setup.c       **** #define GBA_DDR_ROM_ADDR7_0 DDRB
  85:setup.c       **** #define GBA_DDR_ROM_ADDR15_8 DDRA
  86:setup.c       **** #define GBA_DDR_ROM_ADDR23_16 DDRC
  87:setup.c       **** #define GBA_DDR_ROM_DATA7_0 DDRB
  88:setup.c       **** #define GBA_DDR_ROM_DATA15_8 DDRA
  89:setup.c       **** #define GBA_DDR_RAM_DATA7_0 DDRC
  90:setup.c       **** #define GBA_DDR_EEPROM_DATA7_0 DDRB
  91:setup.c       **** 
  92:setup.c       **** #define GBA_PORT_ROM_ADDR7_0 PORTB
  93:setup.c       **** #define GBA_PORT_ROM_ADDR15_8 PORTA
  94:setup.c       **** #define GBA_PORT_ROM_ADDR23_16 PORTC
  95:setup.c       **** #define GBA_PORT_ROM_DATA7_0 PORTB
  96:setup.c       **** #define GBA_PORT_ROM_DATA15_8 PORTA
  97:setup.c       **** #define GBA_PORT_RAM_DATA7_0 PORTC
  98:setup.c       **** #define GBA_PORT_EEPROM_DATA7_0 PORTB
  99:setup.c       **** 
 100:setup.c       **** #define GBA_PIN_ROM_DATA7_0 PINB
 101:setup.c       **** #define GBA_PIN_ROM_DATA15_8 PINA
 102:setup.c       **** #define GBA_PIN_RAM_DATA7_0 PINC
 103:setup.c       **** #define GBA_PIN_EEPROM_DATA7_0 PINB
 104:setup.c       **** 
 105:setup.c       **** // GB/GBC commands
 106:setup.c       **** #define SET_START_ADDRESS 'A'
 107:setup.c       **** #define READ_ROM_RAM 'R'
 108:setup.c       **** #define WRITE_RAM 'W'
 109:setup.c       **** #define SET_BANK 'B'
 110:setup.c       **** #define GB_CART_MODE 'G'
 111:setup.c       **** 
 112:setup.c       **** // GBA commands
 113:setup.c       **** #define GBA_READ_ROM 'r'
 114:setup.c       **** #define GBA_READ_ROM_256BYTE 'j'
 115:setup.c       **** #define GBA_READ_SRAM 'm'
 116:setup.c       **** #define GBA_WRITE_SRAM 'w'
 117:setup.c       **** #define GBA_WRITE_ONE_BYTE_SRAM 'o'
 118:setup.c       **** #define GBA_CART_MODE 'g'
 119:setup.c       **** 
 120:setup.c       **** #define GBA_FLASH_READ_ID 'i'
 121:setup.c       **** #define GBA_FLASH_SET_BANK 'k'
 122:setup.c       **** #define GBA_FLASH_4K_SECTOR_ERASE 's'
 123:setup.c       **** #define GBA_FLASH_WRITE_BYTE 'b'
 124:setup.c       **** #define GBA_FLASH_WRITE_ATMEL 'a'
 125:setup.c       **** 
 126:setup.c       **** #define GBA_SET_EEPROM_SIZE 'S'
 127:setup.c       **** #define GBA_READ_EEPROM 'e'
 128:setup.c       **** #define GBA_WRITE_EEPROM 'p'
 129:setup.c       **** 
 130:setup.c       **** // Flash Cart commands
 131:setup.c       **** #define GB_FLASH_WE_PIN 'P'
 132:setup.c       **** 	#define WE_AS_AUDIO_PIN 'A'
 133:setup.c       **** 	#define WE_AS_WR_PIN 'W'
 134:setup.c       **** 
 135:setup.c       **** #define GB_FLASH_PROGRAM_METHOD 'E'
 136:setup.c       **** 	#define GB_FLASH_PROGRAM_555 0
 137:setup.c       **** 	#define GB_FLASH_PROGRAM_AAA 1
 138:setup.c       **** 	#define GB_FLASH_PROGRAM_555_BIT01_SWAPPED 2
 139:setup.c       **** 	#define GB_FLASH_PROGRAM_AAA_BIT01_SWAPPED 3
 140:setup.c       **** 	#define GB_FLASH_PROGRAM_5555 4
 141:setup.c       **** 
 142:setup.c       **** #define GB_FLASH_WRITE_BYTE 'F'
 143:setup.c       **** #define GB_FLASH_WRITE_64BYTE 'T'
 144:setup.c       **** #define GB_FLASH_WRITE_256BYTE 'X'
 145:setup.c       **** 
 146:setup.c       **** #define GB_FLASH_BANK_1_COMMAND_WRITES 'N'
 147:setup.c       **** 
 148:setup.c       **** #define GBA_FLASH_CART_WRITE_BYTE 'n'
 149:setup.c       **** #define GBA_FLASH_WRITE_64BYTE 'q'
 150:setup.c       **** #define GBA_FLASH_WRITE_256BYTE 't'
 151:setup.c       **** #define GBA_FLASH_WRITE_INTEL_64BYTE 'l'
 152:setup.c       **** 
 153:setup.c       **** // General commands
 154:setup.c       **** #define SEND_ACK '1'
 155:setup.c       **** #define CART_MODE 'C'
 156:setup.c       **** #define SET_INPUT 'I'
 157:setup.c       **** #define SET_OUTPUT 'O'
 158:setup.c       **** #define SET_OUTPUT_LOW 'L'
 159:setup.c       **** #define SET_OUTPUT_HIGH 'H'
 160:setup.c       **** #define READ_INPUT 'D'
 161:setup.c       **** #define RESET_COMMON_LINES 'M'
 162:setup.c       **** #define READ_FIRMWARE_VERSION 'V'
 163:setup.c       **** #define READ_PCB_VERSION 'h'
 164:setup.c       **** 
 165:setup.c       **** #define RESET_AVR '*'
 166:setup.c       **** #define RESET_VALUE 0x7E5E1
 167:setup.c       **** 
 168:setup.c       **** 
 169:setup.c       **** char receivedBuffer[256];
 170:setup.c       **** char receivedChar;
 171:setup.c       **** uint8_t eepromBuffer[8];
 172:setup.c       **** uint8_t flashChipIdBuffer[2];
 173:setup.c       **** 
 174:setup.c       **** char flashWriteWePin;
 175:setup.c       **** uint16_t flashWriteCycle[3][2];
 176:setup.c       **** uint8_t flashBank1CommandWrites = 0;
 177:setup.c       **** uint8_t lastBankAccessed = 0;
 178:setup.c       **** 
 179:setup.c       **** 
 180:setup.c       **** // Receive USART data
 181:setup.c       **** uint8_t USART_Receive(void) {
  15               		.loc 1 181 0
  16               		.cfi_startproc
  17               	/* prologue: function */
  18               	/* frame size = 0 */
  19               	/* stack size = 0 */
  20               	.L__stack_usage = 0
  21               	.L2:
 182:setup.c       **** 	while ( !(UCSRA & (1<<RXC)) ); // Wait for data to be received
  22               		.loc 1 182 0 discriminator 1
  23 0000 5F9B      		sbis 0xb,7
  24 0002 00C0      		rjmp .L2
 183:setup.c       **** 	return UDR; // Get and return received data from buffer
  25               		.loc 1 183 0
  26 0004 8CB1      		in r24,0xc
 184:setup.c       **** }
  27               		.loc 1 184 0
  28 0006 0895      		ret
  29               		.cfi_endproc
  30               	.LFE12:
  32               	.global	USART_Transmit
  34               	USART_Transmit:
  35               	.LFB13:
 185:setup.c       **** 
 186:setup.c       **** // Transmit USART data
 187:setup.c       **** void USART_Transmit(unsigned char data) {
  36               		.loc 1 187 0
  37               		.cfi_startproc
  38               	/* prologue: function */
  39               	/* frame size = 0 */
  40               	/* stack size = 0 */
  41               	.L__stack_usage = 0
  42               	.LVL0:
  43               	.L6:
 188:setup.c       **** 	while ( !( UCSRA & (1<<UDRE)) ); // Wait for empty transmit buffer
  44               		.loc 1 188 0 discriminator 1
  45 0008 5D9B      		sbis 0xb,5
  46 000a 00C0      		rjmp .L6
 189:setup.c       **** 	UDR = data;
  47               		.loc 1 189 0
  48 000c 8CB9      		out 0xc,r24
  49 000e 0895      		ret
  50               		.cfi_endproc
  51               	.LFE13:
  53               	.global	usart_read_bytes
  55               	usart_read_bytes:
  56               	.LFB14:
 190:setup.c       **** }
 191:setup.c       **** 
 192:setup.c       **** // Read 1-256 bytes from the USART 
 193:setup.c       **** void usart_read_bytes(int count) {
  57               		.loc 1 193 0
  58               		.cfi_startproc
  59               	.LVL1:
  60 0010 0F93      		push r16
  61               	.LCFI0:
  62               		.cfi_def_cfa_offset 3
  63               		.cfi_offset 16, -2
  64 0012 1F93      		push r17
  65               	.LCFI1:
  66               		.cfi_def_cfa_offset 4
  67               		.cfi_offset 17, -3
  68 0014 CF93      		push r28
  69               	.LCFI2:
  70               		.cfi_def_cfa_offset 5
  71               		.cfi_offset 28, -4
  72 0016 DF93      		push r29
  73               	.LCFI3:
  74               		.cfi_def_cfa_offset 6
  75               		.cfi_offset 29, -5
  76               	/* prologue: function */
  77               	/* frame size = 0 */
  78               	/* stack size = 4 */
  79               	.L__stack_usage = 4
  80 0018 8C01      		movw r16,r24
  81               	.LVL2:
  82               	.LBB87:
 194:setup.c       **** 	for (int x = 0; x < count; x++) {
  83               		.loc 1 194 0
  84 001a C0E0      		ldi r28,lo8(receivedBuffer)
  85 001c D0E0      		ldi r29,hi8(receivedBuffer)
  86               	.LVL3:
  87               	.L10:
  88               		.loc 1 194 0 is_stmt 0 discriminator 1
  89 001e CE01      		movw r24,r28
  90 0020 8050      		subi r24,lo8(receivedBuffer)
  91 0022 9040      		sbci r25,hi8(receivedBuffer)
  92               	.LVL4:
  93 0024 8017      		cp r24,r16
  94 0026 9107      		cpc r25,r17
  95 0028 04F4      		brge .L12
 195:setup.c       **** 		receivedBuffer[x] = USART_Receive();
  96               		.loc 1 195 0 is_stmt 1 discriminator 3
  97 002a 00D0      		rcall USART_Receive
  98               	.LVL5:
  99 002c 8993      		st Y+,r24
 100               	.LVL6:
 101 002e 00C0      		rjmp .L10
 102               	.LVL7:
 103               	.L12:
 104               	/* epilogue start */
 105               	.LBE87:
 196:setup.c       **** 	}
 197:setup.c       **** }
 106               		.loc 1 197 0
 107 0030 DF91      		pop r29
 108 0032 CF91      		pop r28
 109 0034 1F91      		pop r17
 110 0036 0F91      		pop r16
 111               	.LVL8:
 112 0038 0895      		ret
 113               		.cfi_endproc
 114               	.LFE14:
 116               	.global	usart_read_chars
 118               	usart_read_chars:
 119               	.LFB15:
 198:setup.c       **** 
 199:setup.c       **** // Read the USART until a 0 (string terminator byte) is received
 200:setup.c       **** void usart_read_chars(void) {
 120               		.loc 1 200 0
 121               		.cfi_startproc
 122 003a CF93      		push r28
 123               	.LCFI4:
 124               		.cfi_def_cfa_offset 3
 125               		.cfi_offset 28, -2
 126 003c DF93      		push r29
 127               	.LCFI5:
 128               		.cfi_def_cfa_offset 4
 129               		.cfi_offset 29, -3
 130               	/* prologue: function */
 131               	/* frame size = 0 */
 132               	/* stack size = 2 */
 133               	.L__stack_usage = 2
 134               	.LVL9:
 135 003e C0E0      		ldi r28,lo8(receivedBuffer)
 136 0040 D0E0      		ldi r29,hi8(receivedBuffer)
 137               	.LVL10:
 138               	.L14:
 201:setup.c       **** 	int x = 0;
 202:setup.c       **** 	while (1) {
 203:setup.c       **** 		receivedBuffer[x] = USART_Receive();
 139               		.loc 1 203 0
 140 0042 00D0      		rcall USART_Receive
 141               	.LVL11:
 142 0044 8993      		st Y+,r24
 143               	.LVL12:
 204:setup.c       **** 		if (receivedBuffer[x] == 0) {
 144               		.loc 1 204 0
 145 0046 8111      		cpse r24,__zero_reg__
 146 0048 00C0      		rjmp .L14
 147               	/* epilogue start */
 205:setup.c       **** 			break;
 206:setup.c       **** 		}
 207:setup.c       **** 		x++;
 208:setup.c       **** 	}
 209:setup.c       **** }
 148               		.loc 1 209 0
 149 004a DF91      		pop r29
 150 004c CF91      		pop r28
 151               	.LVL13:
 152 004e 0895      		ret
 153               		.cfi_endproc
 154               	.LFE15:
 156               	.global	rd_wr_csmreq_cs2_reset
 158               	rd_wr_csmreq_cs2_reset:
 159               	.LFB16:
 210:setup.c       **** 
 211:setup.c       **** // Turn RD, WR, CS/MREQ and CS2 to high so they are deselected (reset state)
 212:setup.c       **** void rd_wr_csmreq_cs2_reset(void) {
 160               		.loc 1 212 0
 161               		.cfi_startproc
 162               	/* prologue: function */
 163               	/* frame size = 0 */
 164               	/* stack size = 0 */
 165               	.L__stack_usage = 0
 213:setup.c       **** 	cs2Pin_high; // CS2 off
 166               		.loc 1 213 0
 167 0050 3A9A      		sbi 0x7,2
 214:setup.c       **** 	cs_mreqPin_high; // CS/MREQ off
 168               		.loc 1 214 0
 169 0052 949A      		sbi 0x12,4
 215:setup.c       **** 	rdPin_high; // RD off
 170               		.loc 1 215 0
 171 0054 959A      		sbi 0x12,5
 216:setup.c       **** 	wrPin_high; // WR off
 172               		.loc 1 216 0
 173 0056 969A      		sbi 0x12,6
 174 0058 0895      		ret
 175               		.cfi_endproc
 176               	.LFE16:
 178               	.global	gb_mode
 180               	gb_mode:
 181               	.LFB17:
 217:setup.c       **** }
 218:setup.c       **** 
 219:setup.c       **** 
 220:setup.c       **** 
 221:setup.c       **** // ****** Gameboy / Gameboy Colour functions ******
 222:setup.c       **** 
 223:setup.c       **** // Set Gameboy mode
 224:setup.c       **** void gb_mode(void) {
 182               		.loc 1 224 0
 183               		.cfi_startproc
 184               	/* prologue: function */
 185               	/* frame size = 0 */
 186               	/* stack size = 0 */
 187               	.L__stack_usage = 0
 225:setup.c       **** 	// Set inputs
 226:setup.c       **** 	PORT_DATA7_0 = 0;
 188               		.loc 1 226 0
 189 005a 15BA      		out 0x15,__zero_reg__
 227:setup.c       **** 	DDR_DATA7_0 = 0;
 190               		.loc 1 227 0
 191 005c 14BA      		out 0x14,__zero_reg__
 228:setup.c       **** 	
 229:setup.c       **** 	// Set outputs
 230:setup.c       **** 	PORT_ADDR7_0 = 0;
 192               		.loc 1 230 0
 193 005e 18BA      		out 0x18,__zero_reg__
 231:setup.c       **** 	PORT_ADDR15_8 = 0;
 194               		.loc 1 231 0
 195 0060 1BBA      		out 0x1b,__zero_reg__
 232:setup.c       **** 	DDR_ADDR7_0 = 0xFF;
 196               		.loc 1 232 0
 197 0062 8FEF      		ldi r24,lo8(-1)
 198 0064 87BB      		out 0x17,r24
 233:setup.c       **** 	DDR_ADDR15_8 = 0xFF;
 199               		.loc 1 233 0
 200 0066 8ABB      		out 0x1a,r24
 201 0068 0895      		ret
 202               		.cfi_endproc
 203               	.LFE17:
 205               	.global	set_16bit_address
 207               	set_16bit_address:
 208               	.LFB18:
 234:setup.c       **** }
 235:setup.c       **** 
 236:setup.c       **** // Set the 16 bit address on A15-0
 237:setup.c       **** void set_16bit_address(uint16_t address) {
 209               		.loc 1 237 0
 210               		.cfi_startproc
 211               	.LVL14:
 212               	/* prologue: function */
 213               	/* frame size = 0 */
 214               	/* stack size = 0 */
 215               	.L__stack_usage = 0
 238:setup.c       **** 	PORT_ADDR15_8 = (address >> 8);
 216               		.loc 1 238 0
 217 006a 9BBB      		out 0x1b,r25
 239:setup.c       **** 	PORT_ADDR7_0 = (address & 0xFF);
 218               		.loc 1 239 0
 219 006c 88BB      		out 0x18,r24
 220 006e 0895      		ret
 221               		.cfi_endproc
 222               	.LFE18:
 224               	.global	read_8bit_data
 226               	read_8bit_data:
 227               	.LFB19:
 240:setup.c       **** }
 241:setup.c       **** 
 242:setup.c       **** // Set the address and read a byte from the 8 bit data line
 243:setup.c       **** uint8_t read_8bit_data(uint16_t address) {
 228               		.loc 1 243 0
 229               		.cfi_startproc
 230               	.LVL15:
 231               	/* prologue: function */
 232               	/* frame size = 0 */
 233               	/* stack size = 0 */
 234               	.L__stack_usage = 0
 244:setup.c       **** 	set_16bit_address(address);
 235               		.loc 1 244 0
 236 0070 00D0      		rcall set_16bit_address
 237               	.LVL16:
 245:setup.c       **** 	
 246:setup.c       **** 	cs_mreqPin_low;
 238               		.loc 1 246 0
 239 0072 9498      		cbi 0x12,4
 247:setup.c       **** 	rdPin_low;
 240               		.loc 1 247 0
 241 0074 9598      		cbi 0x12,5
 248:setup.c       **** 	
 249:setup.c       **** 	asm volatile("nop"); // Delay a little (minimum needed is 1 nops, 2 nops for GB camera)
 242               		.loc 1 249 0
 243               	/* #APP */
 244               	 ;  249 "setup.c" 1
 245 0076 0000      		nop
 246               	 ;  0 "" 2
 250:setup.c       **** 	asm volatile("nop");
 247               		.loc 1 250 0
 248               	 ;  250 "setup.c" 1
 249 0078 0000      		nop
 250               	 ;  0 "" 2
 251:setup.c       **** 	uint8_t data = PIN_DATA7_0; // Read data
 251               		.loc 1 251 0
 252               	/* #NOAPP */
 253 007a 83B3      		in r24,0x13
 254               	.LVL17:
 252:setup.c       **** 	
 253:setup.c       **** 	rdPin_high;
 255               		.loc 1 253 0
 256 007c 959A      		sbi 0x12,5
 254:setup.c       **** 	cs_mreqPin_high;
 257               		.loc 1 254 0
 258 007e 949A      		sbi 0x12,4
 255:setup.c       **** 	
 256:setup.c       **** 	return data;
 257:setup.c       **** }
 259               		.loc 1 257 0
 260 0080 0895      		ret
 261               		.cfi_endproc
 262               	.LFE19:
 264               	.global	write_8bit_data
 266               	write_8bit_data:
 267               	.LFB20:
 258:setup.c       **** 
 259:setup.c       **** // Set the address and write a byte to the 8 bit data line and pulse cs/mREQ if writing to RAM
 260:setup.c       **** void write_8bit_data(uint16_t address, uint8_t data, uint8_t type) {
 268               		.loc 1 260 0
 269               		.cfi_startproc
 270               	.LVL18:
 271 0082 CF93      		push r28
 272               	.LCFI6:
 273               		.cfi_def_cfa_offset 3
 274               		.cfi_offset 28, -2
 275 0084 DF93      		push r29
 276               	.LCFI7:
 277               		.cfi_def_cfa_offset 4
 278               		.cfi_offset 29, -3
 279               	/* prologue: function */
 280               	/* frame size = 0 */
 281               	/* stack size = 2 */
 282               	.L__stack_usage = 2
 283 0086 D62F      		mov r29,r22
 284 0088 C42F      		mov r28,r20
 261:setup.c       **** 	set_16bit_address(address);
 285               		.loc 1 261 0
 286 008a 00D0      		rcall set_16bit_address
 287               	.LVL19:
 262:setup.c       **** 	
 263:setup.c       **** 	DDR_DATA7_0 = 0xFF; // Set data pins as outputs
 288               		.loc 1 263 0
 289 008c 8FEF      		ldi r24,lo8(-1)
 290 008e 84BB      		out 0x14,r24
 264:setup.c       **** 	PORT_DATA7_0 = data; // Set data
 291               		.loc 1 264 0
 292 0090 D5BB      		out 0x15,r29
 265:setup.c       **** 	
 266:setup.c       **** 	// Pulse WR and mREQ if the type matches
 267:setup.c       **** 	wrPin_low;
 293               		.loc 1 267 0
 294 0092 9698      		cbi 0x12,6
 268:setup.c       **** 	if (type == MEMORY_WRITE) {
 295               		.loc 1 268 0
 296 0094 C130      		cpi r28,lo8(1)
 297 0096 01F4      		brne .L21
 269:setup.c       **** 		cs_mreqPin_low;
 298               		.loc 1 269 0
 299 0098 9498      		cbi 0x12,4
 300               	.L21:
 270:setup.c       **** 	}
 271:setup.c       **** 	
 272:setup.c       **** 	asm volatile("nop");
 301               		.loc 1 272 0
 302               	/* #APP */
 303               	 ;  272 "setup.c" 1
 304 009a 0000      		nop
 305               	 ;  0 "" 2
 273:setup.c       **** 	
 274:setup.c       **** 	if (type == MEMORY_WRITE) {
 306               		.loc 1 274 0
 307               	/* #NOAPP */
 308 009c C130      		cpi r28,lo8(1)
 309 009e 01F4      		brne .L22
 275:setup.c       **** 		cs_mreqPin_high;
 310               		.loc 1 275 0
 311 00a0 949A      		sbi 0x12,4
 312               	.L22:
 276:setup.c       **** 	}
 277:setup.c       **** 	wrPin_high;
 313               		.loc 1 277 0
 314 00a2 969A      		sbi 0x12,6
 278:setup.c       **** 	
 279:setup.c       **** 	// Clear data outputs and set data pins as inputs
 280:setup.c       **** 	PORT_DATA7_0 = 0;
 315               		.loc 1 280 0
 316 00a4 15BA      		out 0x15,__zero_reg__
 281:setup.c       **** 	DDR_DATA7_0 = 0;
 317               		.loc 1 281 0
 318 00a6 14BA      		out 0x14,__zero_reg__
 319               	/* epilogue start */
 282:setup.c       **** }
 320               		.loc 1 282 0
 321 00a8 DF91      		pop r29
 322               	.LVL20:
 323 00aa CF91      		pop r28
 324               	.LVL21:
 325 00ac 0895      		ret
 326               		.cfi_endproc
 327               	.LFE20:
 329               	.global	gba_mode
 331               	gba_mode:
 332               	.LFB21:
 283:setup.c       **** 
 284:setup.c       **** 
 285:setup.c       **** 
 286:setup.c       **** // ****** Gameboy Advance functions ****** 
 287:setup.c       **** 
 288:setup.c       **** // Set GBA mode
 289:setup.c       **** void gba_mode(void) {
 333               		.loc 1 289 0
 334               		.cfi_startproc
 335               	/* prologue: function */
 336               	/* frame size = 0 */
 337               	/* stack size = 0 */
 338               	.L__stack_usage = 0
 290:setup.c       **** 	// Set outputs for reading ROM addresses as default
 291:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = 0;
 339               		.loc 1 291 0
 340 00ae 18BA      		out 0x18,__zero_reg__
 292:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = 0;
 341               		.loc 1 292 0
 342 00b0 1BBA      		out 0x1b,__zero_reg__
 293:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = 0;
 343               		.loc 1 293 0
 344 00b2 15BA      		out 0x15,__zero_reg__
 294:setup.c       **** 	GBA_DDR_ROM_ADDR7_0 = 0xFF;
 345               		.loc 1 294 0
 346 00b4 8FEF      		ldi r24,lo8(-1)
 347 00b6 87BB      		out 0x17,r24
 295:setup.c       **** 	GBA_DDR_ROM_ADDR15_8 = 0xFF;
 348               		.loc 1 295 0
 349 00b8 8ABB      		out 0x1a,r24
 296:setup.c       **** 	GBA_DDR_ROM_ADDR23_16 = 0xFF;
 350               		.loc 1 296 0
 351 00ba 84BB      		out 0x14,r24
 352 00bc 0895      		ret
 353               		.cfi_endproc
 354               	.LFE21:
 356               	.global	gba_set_24bit_address
 358               	gba_set_24bit_address:
 359               	.LFB22:
 297:setup.c       **** }
 298:setup.c       **** 
 299:setup.c       **** // Set the 24 bit address on A23-0
 300:setup.c       **** void gba_set_24bit_address(uint32_t address) {	
 360               		.loc 1 300 0
 361               		.cfi_startproc
 362               	.LVL22:
 363 00be 0F93      		push r16
 364               	.LCFI8:
 365               		.cfi_def_cfa_offset 3
 366               		.cfi_offset 16, -2
 367 00c0 1F93      		push r17
 368               	.LCFI9:
 369               		.cfi_def_cfa_offset 4
 370               		.cfi_offset 17, -3
 371               	/* prologue: function */
 372               	/* frame size = 0 */
 373               	/* stack size = 2 */
 374               	.L__stack_usage = 2
 301:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = 0; // Set 0-23 address lines low and set as outputs
 375               		.loc 1 301 0
 376 00c2 15BA      		out 0x15,__zero_reg__
 302:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = 0;
 377               		.loc 1 302 0
 378 00c4 1BBA      		out 0x1b,__zero_reg__
 303:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = 0;
 379               		.loc 1 303 0
 380 00c6 18BA      		out 0x18,__zero_reg__
 304:setup.c       **** 	GBA_DDR_ROM_ADDR23_16 = 0xFF;
 381               		.loc 1 304 0
 382 00c8 2FEF      		ldi r18,lo8(-1)
 383 00ca 24BB      		out 0x14,r18
 305:setup.c       **** 	GBA_DDR_ROM_ADDR15_8 = 0xFF;
 384               		.loc 1 305 0
 385 00cc 2ABB      		out 0x1a,r18
 306:setup.c       **** 	GBA_DDR_ROM_ADDR7_0 = 0xFF;
 386               		.loc 1 306 0
 387 00ce 27BB      		out 0x17,r18
 307:setup.c       **** 	
 308:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = (address >> 16);
 388               		.loc 1 308 0
 389 00d0 8C01      		movw r16,r24
 390 00d2 2227      		clr r18
 391 00d4 3327      		clr r19
 392 00d6 05BB      		out 0x15,r16
 309:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = (address >> 8);
 393               		.loc 1 309 0
 394 00d8 072F      		mov r16,r23
 395 00da 182F      		mov r17,r24
 396 00dc 292F      		mov r18,r25
 397 00de 3327      		clr r19
 398 00e0 0BBB      		out 0x1b,r16
 310:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = (address & 0xFF);
 399               		.loc 1 310 0
 400 00e2 68BB      		out 0x18,r22
 401               	/* epilogue start */
 311:setup.c       **** }
 402               		.loc 1 311 0
 403 00e4 1F91      		pop r17
 404 00e6 0F91      		pop r16
 405 00e8 0895      		ret
 406               		.cfi_endproc
 407               	.LFE22:
 409               	.global	gba_read_16bit_data
 411               	gba_read_16bit_data:
 412               	.LFB23:
 312:setup.c       **** 
 313:setup.c       **** 
 314:setup.c       **** 
 315:setup.c       **** // ---------- ROM/SRAM ----------
 316:setup.c       **** 
 317:setup.c       **** // Read a byte from the 16 bit data line non-sequentially
 318:setup.c       **** uint16_t gba_read_16bit_data(uint32_t address) {
 413               		.loc 1 318 0
 414               		.cfi_startproc
 415               	.LVL23:
 416               	/* prologue: function */
 417               	/* frame size = 0 */
 418               	/* stack size = 0 */
 419               	.L__stack_usage = 0
 319:setup.c       **** 	gba_set_24bit_address(address);
 420               		.loc 1 319 0
 421 00ea 00D0      		rcall gba_set_24bit_address
 422               	.LVL24:
 320:setup.c       **** 	
 321:setup.c       **** 	cs_mreqPin_low;
 423               		.loc 1 321 0
 424 00ec 9498      		cbi 0x12,4
 322:setup.c       **** 	
 323:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = 0; // Set A16-A0 address lines low and set as inputs for the data to be re
 425               		.loc 1 323 0
 426 00ee 1BBA      		out 0x1b,__zero_reg__
 324:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = 0;
 427               		.loc 1 324 0
 428 00f0 18BA      		out 0x18,__zero_reg__
 325:setup.c       **** 	GBA_DDR_ROM_ADDR15_8 = 0;
 429               		.loc 1 325 0
 430 00f2 1ABA      		out 0x1a,__zero_reg__
 326:setup.c       **** 	GBA_DDR_ROM_ADDR7_0 = 0;
 431               		.loc 1 326 0
 432 00f4 17BA      		out 0x17,__zero_reg__
 327:setup.c       **** 	
 328:setup.c       **** 	rdPin_low;
 433               		.loc 1 328 0
 434 00f6 9598      		cbi 0x12,5
 329:setup.c       **** 	asm volatile("nop");
 435               		.loc 1 329 0
 436               	/* #APP */
 437               	 ;  329 "setup.c" 1
 438 00f8 0000      		nop
 439               	 ;  0 "" 2
 330:setup.c       **** 	
 331:setup.c       **** 	uint16_t data = (GBA_PIN_ROM_DATA15_8 << 8) | GBA_PIN_ROM_DATA7_0; // Read data
 440               		.loc 1 331 0
 441               	/* #NOAPP */
 442 00fa 29B3      		in r18,0x19
 443 00fc 86B3      		in r24,0x16
 444               	.LVL25:
 332:setup.c       **** 	
 333:setup.c       **** 	rdPin_high;
 445               		.loc 1 333 0
 446 00fe 959A      		sbi 0x12,5
 334:setup.c       **** 	cs_mreqPin_high;
 447               		.loc 1 334 0
 448 0100 949A      		sbi 0x12,4
 335:setup.c       **** 	
 336:setup.c       **** 	return data;
 449               		.loc 1 336 0
 450 0102 90E0      		ldi r25,0
 337:setup.c       **** }
 451               		.loc 1 337 0
 452 0104 922B      		or r25,r18
 453 0106 0895      		ret
 454               		.cfi_endproc
 455               	.LFE23:
 457               	.global	gba_read_ram_8bit_data
 459               	gba_read_ram_8bit_data:
 460               	.LFB24:
 338:setup.c       **** 
 339:setup.c       **** // Set the address and read a byte from the 8 bit data line
 340:setup.c       **** uint8_t gba_read_ram_8bit_data(uint16_t address) {
 461               		.loc 1 340 0
 462               		.cfi_startproc
 463               	.LVL26:
 464               	/* prologue: function */
 465               	/* frame size = 0 */
 466               	/* stack size = 0 */
 467               	.L__stack_usage = 0
 341:setup.c       **** 	set_16bit_address(address);
 468               		.loc 1 341 0
 469 0108 00D0      		rcall set_16bit_address
 470               	.LVL27:
 342:setup.c       **** 	
 343:setup.c       **** 	rdPin_low;
 471               		.loc 1 343 0
 472 010a 9598      		cbi 0x12,5
 344:setup.c       **** 	cs2Pin_low; // CS2 pin low for SRAM/Flash select
 473               		.loc 1 344 0
 474 010c 3A98      		cbi 0x7,2
 345:setup.c       **** 	
 346:setup.c       **** 	asm volatile("nop"); // Delay a little (minimum needed is 2)
 475               		.loc 1 346 0
 476               	/* #APP */
 477               	 ;  346 "setup.c" 1
 478 010e 0000      		nop
 479               	 ;  0 "" 2
 347:setup.c       **** 	asm volatile("nop");
 480               		.loc 1 347 0
 481               	 ;  347 "setup.c" 1
 482 0110 0000      		nop
 483               	 ;  0 "" 2
 348:setup.c       **** 	
 349:setup.c       **** 	uint8_t data = GBA_PIN_RAM_DATA7_0; // Read data
 484               		.loc 1 349 0
 485               	/* #NOAPP */
 486 0112 83B3      		in r24,0x13
 487               	.LVL28:
 350:setup.c       **** 	
 351:setup.c       **** 	cs2Pin_high;
 488               		.loc 1 351 0
 489 0114 3A9A      		sbi 0x7,2
 352:setup.c       **** 	rdPin_high;
 490               		.loc 1 352 0
 491 0116 959A      		sbi 0x12,5
 353:setup.c       **** 	
 354:setup.c       **** 	return data;
 355:setup.c       **** }
 492               		.loc 1 355 0
 493 0118 0895      		ret
 494               		.cfi_endproc
 495               	.LFE24:
 497               	.global	gba_write_ram_8bit_data
 499               	gba_write_ram_8bit_data:
 500               	.LFB25:
 356:setup.c       **** 
 357:setup.c       **** // Set the address and write a byte to the 8 bit data line 
 358:setup.c       **** void gba_write_ram_8bit_data(uint16_t address, uint8_t data) {
 501               		.loc 1 358 0
 502               		.cfi_startproc
 503               	.LVL29:
 504 011a CF93      		push r28
 505               	.LCFI10:
 506               		.cfi_def_cfa_offset 3
 507               		.cfi_offset 28, -2
 508               	/* prologue: function */
 509               	/* frame size = 0 */
 510               	/* stack size = 1 */
 511               	.L__stack_usage = 1
 512 011c C62F      		mov r28,r22
 359:setup.c       **** 	set_16bit_address(address);
 513               		.loc 1 359 0
 514 011e 00D0      		rcall set_16bit_address
 515               	.LVL30:
 360:setup.c       **** 	
 361:setup.c       **** 	GBA_DDR_RAM_DATA7_0 = 0xFF; // Set data pins as outputs
 516               		.loc 1 361 0
 517 0120 8FEF      		ldi r24,lo8(-1)
 518 0122 84BB      		out 0x14,r24
 362:setup.c       **** 	GBA_PORT_RAM_DATA7_0 = data; // Set data
 519               		.loc 1 362 0
 520 0124 C5BB      		out 0x15,r28
 363:setup.c       **** 	
 364:setup.c       **** 	// Pulse WR
 365:setup.c       **** 	wrPin_low;
 521               		.loc 1 365 0
 522 0126 9698      		cbi 0x12,6
 366:setup.c       **** 	cs2Pin_low; // CS2 pin low for SRAM/Flash select
 523               		.loc 1 366 0
 524 0128 3A98      		cbi 0x7,2
 367:setup.c       **** 	
 368:setup.c       **** 	asm volatile("nop");
 525               		.loc 1 368 0
 526               	/* #APP */
 527               	 ;  368 "setup.c" 1
 528 012a 0000      		nop
 529               	 ;  0 "" 2
 369:setup.c       **** 	asm volatile("nop");
 530               		.loc 1 369 0
 531               	 ;  369 "setup.c" 1
 532 012c 0000      		nop
 533               	 ;  0 "" 2
 370:setup.c       **** 	
 371:setup.c       **** 	cs2Pin_high;
 534               		.loc 1 371 0
 535               	/* #NOAPP */
 536 012e 3A9A      		sbi 0x7,2
 372:setup.c       **** 	wrPin_high;
 537               		.loc 1 372 0
 538 0130 969A      		sbi 0x12,6
 373:setup.c       **** 	
 374:setup.c       **** 	// Clear data outputs and set data pins as inputs
 375:setup.c       **** 	GBA_PORT_RAM_DATA7_0 = 0;
 539               		.loc 1 375 0
 540 0132 15BA      		out 0x15,__zero_reg__
 376:setup.c       **** 	GBA_DDR_RAM_DATA7_0 = 0;
 541               		.loc 1 376 0
 542 0134 14BA      		out 0x14,__zero_reg__
 543               	/* epilogue start */
 377:setup.c       **** }
 544               		.loc 1 377 0
 545 0136 CF91      		pop r28
 546               	.LVL31:
 547 0138 0895      		ret
 548               		.cfi_endproc
 549               	.LFE25:
 551               	.global	gba_eeprom_mode
 553               	gba_eeprom_mode:
 554               	.LFB26:
 378:setup.c       **** 
 379:setup.c       **** 
 380:setup.c       **** 
 381:setup.c       **** // ---------- EEPROM ----------
 382:setup.c       **** 
 383:setup.c       **** // Set address/data all high (includes AD0/A23)
 384:setup.c       **** void gba_eeprom_mode (void) {
 555               		.loc 1 384 0
 556               		.cfi_startproc
 557               	/* prologue: function */
 558               	/* frame size = 0 */
 559               	/* stack size = 0 */
 560               	.L__stack_usage = 0
 385:setup.c       **** 	GBA_DDR_ROM_ADDR7_0 = 0xFF;
 561               		.loc 1 385 0
 562 013a 8FEF      		ldi r24,lo8(-1)
 563 013c 87BB      		out 0x17,r24
 386:setup.c       **** 	GBA_DDR_ROM_ADDR15_8 = 0xFF;
 564               		.loc 1 386 0
 565 013e 8ABB      		out 0x1a,r24
 387:setup.c       **** 	GBA_DDR_ROM_ADDR23_16 = 0xFF;
 566               		.loc 1 387 0
 567 0140 84BB      		out 0x14,r24
 388:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = 0x80;
 568               		.loc 1 388 0
 569 0142 90E8      		ldi r25,lo8(-128)
 570 0144 98BB      		out 0x18,r25
 389:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = 0xFF;
 571               		.loc 1 389 0
 572 0146 8BBB      		out 0x1b,r24
 390:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = 0xFF;
 573               		.loc 1 390 0
 574 0148 85BB      		out 0x15,r24
 575 014a 0895      		ret
 576               		.cfi_endproc
 577               	.LFE26:
 579               	.global	gba_eeprom_set_address
 581               	gba_eeprom_set_address:
 582               	.LFB27:
 391:setup.c       **** }
 392:setup.c       **** 
 393:setup.c       **** // Send out EEPROM address serially (WR clock, AD0 data out)
 394:setup.c       **** void gba_eeprom_set_address(uint16_t address, uint8_t eepromSize, uint8_t command) {
 583               		.loc 1 394 0
 584               		.cfi_startproc
 585               	.LVL32:
 586               	/* prologue: function */
 587               	/* frame size = 0 */
 588               	/* stack size = 0 */
 589               	.L__stack_usage = 0
 395:setup.c       **** 	cs_mreqPin_low;
 590               		.loc 1 395 0
 591 014c 9498      		cbi 0x12,4
 592               	.LVL33:
 396:setup.c       **** 	
 397:setup.c       **** 	int8_t x = 0;
 398:setup.c       **** 	if (eepromSize == EEPROM_64KBIT) {
 593               		.loc 1 398 0
 594 014e 6230      		cpi r22,lo8(2)
 595 0150 01F4      		brne .L30
 399:setup.c       **** 		if (command == EEPROM_READ) {
 596               		.loc 1 399 0
 597 0152 4111      		cpse r20,__zero_reg__
 598 0154 00C0      		rjmp .L31
 400:setup.c       **** 			address |= (1<<15) | (1<<14); // Set upper 2 bits high for read request
 599               		.loc 1 400 0
 600 0156 906C      		ori r25,192
 601               	.LVL34:
 602               	.L40:
 401:setup.c       **** 		}
 402:setup.c       **** 		else {
 403:setup.c       **** 			address |= (1<<15); // Set upper 1 bit high for write request
 404:setup.c       **** 		}
 405:setup.c       **** 		x = 15;
 603               		.loc 1 405 0
 604 0158 2FE0      		ldi r18,lo8(15)
 605               	.L33:
 606               	.LVL35:
 406:setup.c       **** 	}
 407:setup.c       **** 	else {
 408:setup.c       **** 		if (command == EEPROM_READ) {
 409:setup.c       **** 			address |= (1<<7) | (1<<6);
 410:setup.c       **** 		}
 411:setup.c       **** 		else {
 412:setup.c       **** 			address |= (1<<7);
 413:setup.c       **** 		}
 414:setup.c       **** 		x = 7;
 415:setup.c       **** 	}
 416:setup.c       **** 	
 417:setup.c       **** 	// Loop through address, 8 or 16 bits depending on EEPROM (includes the 2 bits for request type)
 418:setup.c       **** 	while (x >= 0) {
 419:setup.c       **** 		if (address & (1<<x)) {
 607               		.loc 1 419 0
 608 015a E1E0      		ldi r30,lo8(1)
 609 015c F0E0      		ldi r31,0
 610 015e 00C0      		rjmp .L32
 611               	.LVL36:
 612               	.L31:
 403:setup.c       **** 		}
 613               		.loc 1 403 0
 614 0160 9068      		ori r25,128
 615               	.LVL37:
 616 0162 00C0      		rjmp .L40
 617               	.L30:
 408:setup.c       **** 			address |= (1<<7) | (1<<6);
 618               		.loc 1 408 0
 619 0164 4111      		cpse r20,__zero_reg__
 620 0166 00C0      		rjmp .L34
 409:setup.c       **** 		}
 621               		.loc 1 409 0
 622 0168 806C      		ori r24,192
 623               	.LVL38:
 624 016a 00C0      		rjmp .L39
 625               	.L34:
 412:setup.c       **** 		}
 626               		.loc 1 412 0
 627 016c 8068      		ori r24,128
 628               	.LVL39:
 629               	.L39:
 414:setup.c       **** 	}
 630               		.loc 1 414 0
 631 016e 27E0      		ldi r18,lo8(7)
 632 0170 00C0      		rjmp .L33
 633               	.LVL40:
 634               	.L35:
 420:setup.c       **** 			ad0Pin_high;
 421:setup.c       **** 		}
 422:setup.c       **** 		else {
 423:setup.c       **** 			ad0Pin_low;
 635               		.loc 1 423 0
 636 0172 C098      		cbi 0x18,0
 637               	.L36:
 424:setup.c       **** 		}
 425:setup.c       **** 		
 426:setup.c       **** 		wrPin_low; // CLK
 638               		.loc 1 426 0
 639 0174 9698      		cbi 0x12,6
 427:setup.c       **** 		asm ("nop");
 640               		.loc 1 427 0
 641               	/* #APP */
 642               	 ;  427 "setup.c" 1
 643 0176 0000      		nop
 644               	 ;  0 "" 2
 428:setup.c       **** 		asm ("nop");
 645               		.loc 1 428 0
 646               	 ;  428 "setup.c" 1
 647 0178 0000      		nop
 648               	 ;  0 "" 2
 429:setup.c       **** 		wrPin_high; 
 649               		.loc 1 429 0
 650               	/* #NOAPP */
 651 017a 969A      		sbi 0x12,6
 430:setup.c       **** 		asm ("nop");
 652               		.loc 1 430 0
 653               	/* #APP */
 654               	 ;  430 "setup.c" 1
 655 017c 0000      		nop
 656               	 ;  0 "" 2
 431:setup.c       **** 		asm ("nop");
 657               		.loc 1 431 0
 658               	 ;  431 "setup.c" 1
 659 017e 0000      		nop
 660               	 ;  0 "" 2
 661               	/* #NOAPP */
 662 0180 2150      		subi r18,lo8(-(-1))
 663               	.LVL41:
 418:setup.c       **** 		if (address & (1<<x)) {
 664               		.loc 1 418 0
 665 0182 27FD      		sbrc r18,7
 666 0184 00C0      		rjmp .L41
 667               	.L32:
 419:setup.c       **** 			ad0Pin_high;
 668               		.loc 1 419 0
 669 0186 BF01      		movw r22,r30
 670 0188 022E      		mov r0,r18
 671 018a 00C0      		rjmp 2f
 672               		1:
 673 018c 660F      		lsl r22
 674 018e 771F      		rol r23
 675               		2:
 676 0190 0A94      		dec r0
 677 0192 02F4      		brpl 1b
 678 0194 6823      		and r22,r24
 679 0196 7923      		and r23,r25
 680 0198 672B      		or r22,r23
 681 019a 01F0      		breq .L35
 420:setup.c       **** 		}
 682               		.loc 1 420 0
 683 019c C09A      		sbi 0x18,0
 684 019e 00C0      		rjmp .L36
 685               	.L41:
 432:setup.c       **** 		
 433:setup.c       **** 		x--;
 434:setup.c       **** 	}
 435:setup.c       **** 	
 436:setup.c       **** 	// Only send stop bit (0) and WR/CS high if reading, as writing is done in 1 continuous chunk
 437:setup.c       **** 	if (command == EEPROM_READ) {  
 686               		.loc 1 437 0
 687 01a0 4111      		cpse r20,__zero_reg__
 688 01a2 00C0      		rjmp .L29
 438:setup.c       **** 		ad0Pin_low;
 689               		.loc 1 438 0
 690 01a4 C098      		cbi 0x18,0
 439:setup.c       **** 		asm ("nop");
 691               		.loc 1 439 0
 692               	/* #APP */
 693               	 ;  439 "setup.c" 1
 694 01a6 0000      		nop
 695               	 ;  0 "" 2
 440:setup.c       **** 		wrPin_low;
 696               		.loc 1 440 0
 697               	/* #NOAPP */
 698 01a8 9698      		cbi 0x12,6
 441:setup.c       **** 		asm ("nop");
 699               		.loc 1 441 0
 700               	/* #APP */
 701               	 ;  441 "setup.c" 1
 702 01aa 0000      		nop
 703               	 ;  0 "" 2
 442:setup.c       **** 		asm ("nop");
 704               		.loc 1 442 0
 705               	 ;  442 "setup.c" 1
 706 01ac 0000      		nop
 707               	 ;  0 "" 2
 443:setup.c       **** 		
 444:setup.c       **** 		wrPin_high;
 708               		.loc 1 444 0
 709               	/* #NOAPP */
 710 01ae 969A      		sbi 0x12,6
 445:setup.c       **** 		cs_mreqPin_high;
 711               		.loc 1 445 0
 712 01b0 949A      		sbi 0x12,4
 713               	.L29:
 714 01b2 0895      		ret
 715               		.cfi_endproc
 716               	.LFE27:
 718               	.global	gba_eeprom_read
 720               	gba_eeprom_read:
 721               	.LFB28:
 446:setup.c       **** 	}
 447:setup.c       **** }
 448:setup.c       **** 
 449:setup.c       **** // Read 8 bytes from the EEPROM address, data is valid on rising edge
 450:setup.c       **** void gba_eeprom_read(uint16_t address, uint8_t eepromSize) {
 722               		.loc 1 450 0
 723               		.cfi_startproc
 724               	.LVL42:
 725               	/* prologue: function */
 726               	/* frame size = 0 */
 727               	/* stack size = 0 */
 728               	.L__stack_usage = 0
 451:setup.c       **** 	gba_eeprom_set_address(address, eepromSize, EEPROM_READ);
 729               		.loc 1 451 0
 730 01b4 40E0      		ldi r20,0
 731 01b6 00D0      		rcall gba_eeprom_set_address
 732               	.LVL43:
 452:setup.c       **** 	
 453:setup.c       **** 	// Set AD0 pin as input
 454:setup.c       **** 	GBA_PORT_EEPROM_DATA7_0 &= ~(1<<AD0);
 733               		.loc 1 454 0
 734 01b8 C098      		cbi 0x18,0
 455:setup.c       **** 	GBA_DDR_EEPROM_DATA7_0 &= ~(1<<AD0);
 735               		.loc 1 455 0
 736 01ba B898      		cbi 0x17,0
 456:setup.c       **** 	
 457:setup.c       **** 	cs_mreqPin_low;
 737               		.loc 1 457 0
 738 01bc 9498      		cbi 0x12,4
 739               	.LVL44:
 740 01be 84E0      		ldi r24,lo8(4)
 741               	.LVL45:
 742               	.L43:
 743               	.LBB88:
 458:setup.c       **** 	
 459:setup.c       **** 	// Ignore first 4 bits
 460:setup.c       **** 	for (int8_t x = 0; x < 4; x++) {
 461:setup.c       **** 		rdPin_low; // CLK
 744               		.loc 1 461 0 discriminator 3
 745 01c0 9598      		cbi 0x12,5
 462:setup.c       **** 		asm ("nop");
 746               		.loc 1 462 0 discriminator 3
 747               	/* #APP */
 748               	 ;  462 "setup.c" 1
 749 01c2 0000      		nop
 750               	 ;  0 "" 2
 463:setup.c       **** 		asm ("nop");
 751               		.loc 1 463 0 discriminator 3
 752               	 ;  463 "setup.c" 1
 753 01c4 0000      		nop
 754               	 ;  0 "" 2
 464:setup.c       **** 		rdPin_high; 
 755               		.loc 1 464 0 discriminator 3
 756               	/* #NOAPP */
 757 01c6 959A      		sbi 0x12,5
 465:setup.c       **** 		asm ("nop");
 758               		.loc 1 465 0 discriminator 3
 759               	/* #APP */
 760               	 ;  465 "setup.c" 1
 761 01c8 0000      		nop
 762               	 ;  0 "" 2
 466:setup.c       **** 		asm ("nop");
 763               		.loc 1 466 0 discriminator 3
 764               	 ;  466 "setup.c" 1
 765 01ca 0000      		nop
 766               	 ;  0 "" 2
 767               	.LVL46:
 768               	/* #NOAPP */
 769 01cc 8150      		subi r24,lo8(-(-1))
 770               	.LVL47:
 460:setup.c       **** 		rdPin_low; // CLK
 771               		.loc 1 460 0 discriminator 3
 772 01ce 01F4      		brne .L43
 773 01d0 E0E0      		ldi r30,lo8(eepromBuffer)
 774 01d2 F0E0      		ldi r31,hi8(eepromBuffer)
 775               	.LBE88:
 776               	.LBB89:
 777               	.LBB90:
 778               	.LBB91:
 467:setup.c       **** 	}
 468:setup.c       **** 	
 469:setup.c       **** 	// Read out 64 bits
 470:setup.c       **** 	for (uint8_t c = 0; c < 8; c++) {
 471:setup.c       **** 		uint8_t data = 0;
 472:setup.c       **** 		for (int8_t x = 7; x >= 0; x--) {
 473:setup.c       **** 			rdPin_low; // CLK
 474:setup.c       **** 			asm ("nop");
 475:setup.c       **** 			asm ("nop");
 476:setup.c       **** 			rdPin_high;
 477:setup.c       **** 			
 478:setup.c       **** 			if (GBA_PIN_EEPROM_DATA7_0 & (1<<AD0)) {
 479:setup.c       **** 				data |= (1<<x);
 779               		.loc 1 479 0
 780 01d4 41E0      		ldi r20,lo8(1)
 781 01d6 50E0      		ldi r21,0
 782               	.LVL48:
 783               	.L44:
 784               	.LBE91:
 785               	.LBE90:
 786               	.LBE89:
 457:setup.c       **** 	
 787               		.loc 1 457 0
 788 01d8 87E0      		ldi r24,lo8(7)
 789 01da 90E0      		ldi r25,0
 790 01dc 20E0      		ldi r18,0
 791               	.LVL49:
 792               	.L46:
 793               	.LBB94:
 794               	.LBB93:
 795               	.LBB92:
 473:setup.c       **** 			asm ("nop");
 796               		.loc 1 473 0
 797 01de 9598      		cbi 0x12,5
 474:setup.c       **** 			asm ("nop");
 798               		.loc 1 474 0
 799               	/* #APP */
 800               	 ;  474 "setup.c" 1
 801 01e0 0000      		nop
 802               	 ;  0 "" 2
 475:setup.c       **** 			rdPin_high;
 803               		.loc 1 475 0
 804               	 ;  475 "setup.c" 1
 805 01e2 0000      		nop
 806               	 ;  0 "" 2
 476:setup.c       **** 			
 807               		.loc 1 476 0
 808               	/* #NOAPP */
 809 01e4 959A      		sbi 0x12,5
 478:setup.c       **** 				data |= (1<<x);
 810               		.loc 1 478 0
 811 01e6 B09B      		sbis 0x16,0
 812 01e8 00C0      		rjmp .L45
 813               		.loc 1 479 0
 814 01ea BA01      		movw r22,r20
 815 01ec 082E      		mov r0,r24
 816 01ee 00C0      		rjmp 2f
 817               		1:
 818 01f0 660F      		lsl r22
 819               		2:
 820 01f2 0A94      		dec r0
 821 01f4 02F4      		brpl 1b
 822 01f6 262B      		or r18,r22
 823               	.LVL50:
 824               	.L45:
 825               	.LVL51:
 826 01f8 0197      		sbiw r24,1
 827 01fa 00F4      		brcc .L46
 828               	.LBE92:
 480:setup.c       **** 			}
 481:setup.c       **** 		}
 482:setup.c       **** 		eepromBuffer[c] = data;
 829               		.loc 1 482 0 discriminator 2
 830 01fc 2193      		st Z+,r18
 831               	.LVL52:
 832               	.LBE93:
 470:setup.c       **** 		uint8_t data = 0;
 833               		.loc 1 470 0 discriminator 2
 834 01fe 80E0      		ldi r24,hi8(eepromBuffer+8)
 835 0200 E030      		cpi r30,lo8(eepromBuffer+8)
 836 0202 F807      		cpc r31,r24
 837               	.LVL53:
 838 0204 01F4      		brne .L44
 839               	.LBE94:
 483:setup.c       **** 	}
 484:setup.c       **** 	
 485:setup.c       **** 	cs_mreqPin_high;
 840               		.loc 1 485 0
 841 0206 949A      		sbi 0x12,4
 486:setup.c       **** 	
 487:setup.c       **** 	// Set AD0 pin as output
 488:setup.c       **** 	GBA_PORT_EEPROM_DATA7_0 |= (1<<AD0);
 842               		.loc 1 488 0
 843 0208 C09A      		sbi 0x18,0
 489:setup.c       **** 	GBA_DDR_EEPROM_DATA7_0 |= (1<<AD0);
 844               		.loc 1 489 0
 845 020a B89A      		sbi 0x17,0
 846 020c 0895      		ret
 847               		.cfi_endproc
 848               	.LFE28:
 850               	.global	gba_eeprom_write
 852               	gba_eeprom_write:
 853               	.LFB29:
 490:setup.c       **** }
 491:setup.c       **** 
 492:setup.c       **** // Write 8 bytes to the EEPROM address
 493:setup.c       **** void gba_eeprom_write(uint16_t address, uint8_t eepromSize) {
 854               		.loc 1 493 0
 855               		.cfi_startproc
 856               	.LVL54:
 857               	/* prologue: function */
 858               	/* frame size = 0 */
 859               	/* stack size = 0 */
 860               	.L__stack_usage = 0
 494:setup.c       **** 	gba_eeprom_set_address(address, eepromSize, EEPROM_WRITE);
 861               		.loc 1 494 0
 862 020e 41E0      		ldi r20,lo8(1)
 863 0210 00D0      		rcall gba_eeprom_set_address
 864               	.LVL55:
 865 0212 E0E0      		ldi r30,lo8(eepromBuffer)
 866 0214 F0E0      		ldi r31,hi8(eepromBuffer)
 867 0216 48E0      		ldi r20,lo8(8)
 868               	.LVL56:
 869               	.L54:
 493:setup.c       **** 	gba_eeprom_set_address(address, eepromSize, EEPROM_WRITE);
 870               		.loc 1 493 0
 871 0218 27E0      		ldi r18,lo8(7)
 872 021a 30E0      		ldi r19,0
 873               	.LVL57:
 874               	.L57:
 875               	.LBB95:
 876               	.LBB96:
 495:setup.c       **** 	
 496:setup.c       **** 	// Write 64 bits
 497:setup.c       **** 	for (uint8_t c = 0; c < 8; c++) {
 498:setup.c       **** 		for (int8_t x = 7; x >= 0; x--) {
 499:setup.c       **** 			if (eepromBuffer[c] & (1<<x)) {
 877               		.loc 1 499 0
 878 021c 8081      		ld r24,Z
 879 021e 90E0      		ldi r25,0
 880 0220 022E      		mov r0,r18
 881 0222 00C0      		rjmp 2f
 882               		1:
 883 0224 9595      		asr r25
 884 0226 8795      		ror r24
 885               		2:
 886 0228 0A94      		dec r0
 887 022a 02F4      		brpl 1b
 888 022c 80FF      		sbrs r24,0
 889 022e 00C0      		rjmp .L55
 500:setup.c       **** 				ad0Pin_high;
 890               		.loc 1 500 0
 891 0230 C09A      		sbi 0x18,0
 892 0232 00C0      		rjmp .L56
 893               	.L55:
 501:setup.c       **** 			}
 502:setup.c       **** 			else {
 503:setup.c       **** 				ad0Pin_low;
 894               		.loc 1 503 0
 895 0234 C098      		cbi 0x18,0
 896               	.L56:
 504:setup.c       **** 			}
 505:setup.c       **** 			
 506:setup.c       **** 			wrPin_low; // CLK
 897               		.loc 1 506 0 discriminator 2
 898 0236 9698      		cbi 0x12,6
 507:setup.c       **** 			asm ("nop");
 899               		.loc 1 507 0 discriminator 2
 900               	/* #APP */
 901               	 ;  507 "setup.c" 1
 902 0238 0000      		nop
 903               	 ;  0 "" 2
 508:setup.c       **** 			asm ("nop");
 904               		.loc 1 508 0 discriminator 2
 905               	 ;  508 "setup.c" 1
 906 023a 0000      		nop
 907               	 ;  0 "" 2
 509:setup.c       **** 			wrPin_high; 
 908               		.loc 1 509 0 discriminator 2
 909               	/* #NOAPP */
 910 023c 969A      		sbi 0x12,6
 510:setup.c       **** 			asm ("nop");
 911               		.loc 1 510 0 discriminator 2
 912               	/* #APP */
 913               	 ;  510 "setup.c" 1
 914 023e 0000      		nop
 915               	 ;  0 "" 2
 511:setup.c       **** 			asm ("nop");
 916               		.loc 1 511 0 discriminator 2
 917               	 ;  511 "setup.c" 1
 918 0240 0000      		nop
 919               	 ;  0 "" 2
 920               	.LVL58:
 921               	/* #NOAPP */
 922               	.LVL59:
 923 0242 2150      		subi r18,1
 924 0244 3109      		sbc r19,__zero_reg__
 925 0246 00F4      		brcc .L57
 926 0248 4150      		subi r20,lo8(-(-1))
 927 024a 3196      		adiw r30,1
 928               	.LVL60:
 929               	.LBE96:
 497:setup.c       **** 		for (int8_t x = 7; x >= 0; x--) {
 930               		.loc 1 497 0 discriminator 2
 931 024c 4111      		cpse r20,__zero_reg__
 932 024e 00C0      		rjmp .L54
 933               	.LBE95:
 512:setup.c       **** 		}
 513:setup.c       **** 	}
 514:setup.c       **** 	
 515:setup.c       **** 	// Last bit low
 516:setup.c       **** 	ad0Pin_low;
 934               		.loc 1 516 0
 935 0250 C098      		cbi 0x18,0
 517:setup.c       **** 	wrPin_low; // CLK
 936               		.loc 1 517 0
 937 0252 9698      		cbi 0x12,6
 518:setup.c       **** 	asm ("nop");
 938               		.loc 1 518 0
 939               	/* #APP */
 940               	 ;  518 "setup.c" 1
 941 0254 0000      		nop
 942               	 ;  0 "" 2
 519:setup.c       **** 	asm ("nop");
 943               		.loc 1 519 0
 944               	 ;  519 "setup.c" 1
 945 0256 0000      		nop
 946               	 ;  0 "" 2
 520:setup.c       **** 	wrPin_high; 
 947               		.loc 1 520 0
 948               	/* #NOAPP */
 949 0258 969A      		sbi 0x12,6
 521:setup.c       **** 	asm ("nop");
 950               		.loc 1 521 0
 951               	/* #APP */
 952               	 ;  521 "setup.c" 1
 953 025a 0000      		nop
 954               	 ;  0 "" 2
 522:setup.c       **** 	asm ("nop");
 955               		.loc 1 522 0
 956               	 ;  522 "setup.c" 1
 957 025c 0000      		nop
 958               	 ;  0 "" 2
 523:setup.c       **** 	
 524:setup.c       **** 	cs_mreqPin_high;
 959               		.loc 1 524 0
 960               	/* #NOAPP */
 961 025e 949A      		sbi 0x12,4
 962 0260 0895      		ret
 963               		.cfi_endproc
 964               	.LFE29:
 966               	.global	flash_write_bus_cycle
 968               	flash_write_bus_cycle:
 969               	.LFB30:
 525:setup.c       **** }
 526:setup.c       **** 
 527:setup.c       **** 
 528:setup.c       **** 
 529:setup.c       **** // ---------- FLASH ----------
 530:setup.c       **** 
 531:setup.c       **** // Set the address and data for the write byte cycle to the flash
 532:setup.c       **** void flash_write_bus_cycle(uint16_t address, uint8_t data) {
 970               		.loc 1 532 0
 971               		.cfi_startproc
 972               	.LVL61:
 973 0262 CF93      		push r28
 974               	.LCFI11:
 975               		.cfi_def_cfa_offset 3
 976               		.cfi_offset 28, -2
 977               	/* prologue: function */
 978               	/* frame size = 0 */
 979               	/* stack size = 1 */
 980               	.L__stack_usage = 1
 981 0264 C62F      		mov r28,r22
 533:setup.c       **** 	GBA_DDR_RAM_DATA7_0 = 0xFF; // Set data pins as outputs
 982               		.loc 1 533 0
 983 0266 2FEF      		ldi r18,lo8(-1)
 984 0268 24BB      		out 0x14,r18
 534:setup.c       **** 	set_16bit_address(address);
 985               		.loc 1 534 0
 986 026a 00D0      		rcall set_16bit_address
 987               	.LVL62:
 535:setup.c       **** 	GBA_PORT_RAM_DATA7_0 = data;
 988               		.loc 1 535 0
 989 026c C5BB      		out 0x15,r28
 536:setup.c       **** 	
 537:setup.c       **** 	wrPin_low;
 990               		.loc 1 537 0
 991 026e 9698      		cbi 0x12,6
 538:setup.c       **** 	cs2Pin_low;
 992               		.loc 1 538 0
 993 0270 3A98      		cbi 0x7,2
 539:setup.c       **** 	asm volatile("nop");
 994               		.loc 1 539 0
 995               	/* #APP */
 996               	 ;  539 "setup.c" 1
 997 0272 0000      		nop
 998               	 ;  0 "" 2
 540:setup.c       **** 	wrPin_high;
 999               		.loc 1 540 0
 1000               	/* #NOAPP */
 1001 0274 969A      		sbi 0x12,6
 541:setup.c       **** 	cs2Pin_high;
 1002               		.loc 1 541 0
 1003 0276 3A9A      		sbi 0x7,2
 1004               	/* epilogue start */
 542:setup.c       **** }
 1005               		.loc 1 542 0
 1006 0278 CF91      		pop r28
 1007               	.LVL63:
 1008 027a 0895      		ret
 1009               		.cfi_endproc
 1010               	.LFE30:
 1012               	.global	flash_read_chip_id
 1014               	flash_read_chip_id:
 1015               	.LFB31:
 543:setup.c       **** 
 544:setup.c       **** // Read the flash manufacturer and device ID (Software ID)
 545:setup.c       **** void flash_read_chip_id(void) {
 1016               		.loc 1 545 0
 1017               		.cfi_startproc
 1018 027c CF93      		push r28
 1019               	.LCFI12:
 1020               		.cfi_def_cfa_offset 3
 1021               		.cfi_offset 28, -2
 1022 027e DF93      		push r29
 1023               	.LCFI13:
 1024               		.cfi_def_cfa_offset 4
 1025               		.cfi_offset 29, -3
 1026               	/* prologue: function */
 1027               	/* frame size = 0 */
 1028               	/* stack size = 2 */
 1029               	.L__stack_usage = 2
 546:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xAA);
 1030               		.loc 1 546 0
 1031 0280 6AEA      		ldi r22,lo8(-86)
 1032 0282 85E5      		ldi r24,lo8(85)
 1033 0284 95E5      		ldi r25,lo8(85)
 1034 0286 00D0      		rcall flash_write_bus_cycle
 1035               	.LVL64:
 547:setup.c       **** 	flash_write_bus_cycle(0x2AAA, 0x55);
 1036               		.loc 1 547 0
 1037 0288 65E5      		ldi r22,lo8(85)
 1038 028a 8AEA      		ldi r24,lo8(-86)
 1039 028c 9AE2      		ldi r25,lo8(42)
 1040 028e 00D0      		rcall flash_write_bus_cycle
 1041               	.LVL65:
 548:setup.c       **** 	flash_write_bus_cycle(0x5555, 0x90); // Software ID entry
 1042               		.loc 1 548 0
 1043 0290 60E9      		ldi r22,lo8(-112)
 1044 0292 85E5      		ldi r24,lo8(85)
 1045 0294 95E5      		ldi r25,lo8(85)
 1046 0296 00D0      		rcall flash_write_bus_cycle
 1047               	.LVL66:
 1048               	.LBB97:
 1049               	.LBB98:
 1050               		.file 2 "c:\\winavr-20100110\\avr\\include\\util\\delay.h"
   1:c:\winavr-20100110\avr\include\util\delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:c:\winavr-20100110\avr\include\util\delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:c:\winavr-20100110\avr\include\util\delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:c:\winavr-20100110\avr\include\util\delay.h ****    All rights reserved.
   5:c:\winavr-20100110\avr\include\util\delay.h **** 
   6:c:\winavr-20100110\avr\include\util\delay.h ****    Redistribution and use in source and binary forms, with or without
   7:c:\winavr-20100110\avr\include\util\delay.h ****    modification, are permitted provided that the following conditions are met:
   8:c:\winavr-20100110\avr\include\util\delay.h **** 
   9:c:\winavr-20100110\avr\include\util\delay.h ****    * Redistributions of source code must retain the above copyright
  10:c:\winavr-20100110\avr\include\util\delay.h ****      notice, this list of conditions and the following disclaimer.
  11:c:\winavr-20100110\avr\include\util\delay.h **** 
  12:c:\winavr-20100110\avr\include\util\delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:c:\winavr-20100110\avr\include\util\delay.h ****      notice, this list of conditions and the following disclaimer in
  14:c:\winavr-20100110\avr\include\util\delay.h ****      the documentation and/or other materials provided with the
  15:c:\winavr-20100110\avr\include\util\delay.h ****      distribution.
  16:c:\winavr-20100110\avr\include\util\delay.h **** 
  17:c:\winavr-20100110\avr\include\util\delay.h ****    * Neither the name of the copyright holders nor the names of
  18:c:\winavr-20100110\avr\include\util\delay.h ****      contributors may be used to endorse or promote products derived
  19:c:\winavr-20100110\avr\include\util\delay.h ****      from this software without specific prior written permission.
  20:c:\winavr-20100110\avr\include\util\delay.h **** 
  21:c:\winavr-20100110\avr\include\util\delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:c:\winavr-20100110\avr\include\util\delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:c:\winavr-20100110\avr\include\util\delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:c:\winavr-20100110\avr\include\util\delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:c:\winavr-20100110\avr\include\util\delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:c:\winavr-20100110\avr\include\util\delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:c:\winavr-20100110\avr\include\util\delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:c:\winavr-20100110\avr\include\util\delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:c:\winavr-20100110\avr\include\util\delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:c:\winavr-20100110\avr\include\util\delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:c:\winavr-20100110\avr\include\util\delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:c:\winavr-20100110\avr\include\util\delay.h **** 
  33:c:\winavr-20100110\avr\include\util\delay.h **** /* $Id$ */
  34:c:\winavr-20100110\avr\include\util\delay.h **** 
  35:c:\winavr-20100110\avr\include\util\delay.h **** #ifndef _UTIL_DELAY_H_
  36:c:\winavr-20100110\avr\include\util\delay.h **** #define _UTIL_DELAY_H_ 1
  37:c:\winavr-20100110\avr\include\util\delay.h **** 
  38:c:\winavr-20100110\avr\include\util\delay.h **** #ifndef __DOXYGEN__
  39:c:\winavr-20100110\avr\include\util\delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:c:\winavr-20100110\avr\include\util\delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:c:\winavr-20100110\avr\include\util\delay.h **** #  endif
  42:c:\winavr-20100110\avr\include\util\delay.h **** #endif  /* __DOXYGEN__ */
  43:c:\winavr-20100110\avr\include\util\delay.h **** 
  44:c:\winavr-20100110\avr\include\util\delay.h **** #include <inttypes.h>
  45:c:\winavr-20100110\avr\include\util\delay.h **** #include <util/delay_basic.h>
  46:c:\winavr-20100110\avr\include\util\delay.h **** #include <math.h>
  47:c:\winavr-20100110\avr\include\util\delay.h **** 
  48:c:\winavr-20100110\avr\include\util\delay.h **** /** \file */
  49:c:\winavr-20100110\avr\include\util\delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:c:\winavr-20100110\avr\include\util\delay.h ****     \code
  51:c:\winavr-20100110\avr\include\util\delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:c:\winavr-20100110\avr\include\util\delay.h ****     //#define F_CPU 14.7456E6
  53:c:\winavr-20100110\avr\include\util\delay.h ****     #include <util/delay.h>
  54:c:\winavr-20100110\avr\include\util\delay.h ****     \endcode
  55:c:\winavr-20100110\avr\include\util\delay.h **** 
  56:c:\winavr-20100110\avr\include\util\delay.h ****     \note As an alternative method, it is possible to pass the
  57:c:\winavr-20100110\avr\include\util\delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:c:\winavr-20100110\avr\include\util\delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:c:\winavr-20100110\avr\include\util\delay.h ****     used.
  60:c:\winavr-20100110\avr\include\util\delay.h **** 
  61:c:\winavr-20100110\avr\include\util\delay.h ****     The functions in this header file are wrappers around the basic
  62:c:\winavr-20100110\avr\include\util\delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:c:\winavr-20100110\avr\include\util\delay.h ****     convenience functions where actual time values can be specified
  64:c:\winavr-20100110\avr\include\util\delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:c:\winavr-20100110\avr\include\util\delay.h ****     that compile-time constant expressions will be eliminated by
  66:c:\winavr-20100110\avr\include\util\delay.h ****     compiler optimization so floating-point expressions can be used
  67:c:\winavr-20100110\avr\include\util\delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:c:\winavr-20100110\avr\include\util\delay.h ****     frequency passed by the macro F_CPU.
  69:c:\winavr-20100110\avr\include\util\delay.h **** 
  70:c:\winavr-20100110\avr\include\util\delay.h ****     \note In order for these functions to work as intended, compiler
  71:c:\winavr-20100110\avr\include\util\delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:c:\winavr-20100110\avr\include\util\delay.h ****     <em>must</em> be an expression that is a known constant at
  73:c:\winavr-20100110\avr\include\util\delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:c:\winavr-20100110\avr\include\util\delay.h ****     delay will be much longer (and basically unpredictable), and
  75:c:\winavr-20100110\avr\include\util\delay.h ****     applications that otherwise do not use floating-point calculations
  76:c:\winavr-20100110\avr\include\util\delay.h ****     will experience severe code bloat by the floating-point library
  77:c:\winavr-20100110\avr\include\util\delay.h ****     routines linked into the application.
  78:c:\winavr-20100110\avr\include\util\delay.h **** 
  79:c:\winavr-20100110\avr\include\util\delay.h ****     The functions available allow the specification of microsecond, and
  80:c:\winavr-20100110\avr\include\util\delay.h ****     millisecond delays directly, using the application-supplied macro
  81:c:\winavr-20100110\avr\include\util\delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:c:\winavr-20100110\avr\include\util\delay.h **** 
  83:c:\winavr-20100110\avr\include\util\delay.h **** */
  84:c:\winavr-20100110\avr\include\util\delay.h **** 
  85:c:\winavr-20100110\avr\include\util\delay.h **** #if !defined(__DOXYGEN__)
  86:c:\winavr-20100110\avr\include\util\delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:c:\winavr-20100110\avr\include\util\delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:c:\winavr-20100110\avr\include\util\delay.h **** #endif
  89:c:\winavr-20100110\avr\include\util\delay.h **** 
  90:c:\winavr-20100110\avr\include\util\delay.h **** #ifndef F_CPU
  91:c:\winavr-20100110\avr\include\util\delay.h **** /* prevent compiler error by supplying a default */
  92:c:\winavr-20100110\avr\include\util\delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:c:\winavr-20100110\avr\include\util\delay.h **** /** \ingroup util_delay
  94:c:\winavr-20100110\avr\include\util\delay.h ****     \def F_CPU
  95:c:\winavr-20100110\avr\include\util\delay.h ****     \brief CPU frequency in Hz
  96:c:\winavr-20100110\avr\include\util\delay.h **** 
  97:c:\winavr-20100110\avr\include\util\delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:c:\winavr-20100110\avr\include\util\delay.h ****     the delay macros.  This macro is normally supplied by the
  99:c:\winavr-20100110\avr\include\util\delay.h ****     environment (e.g. from within a project header, or the project's
 100:c:\winavr-20100110\avr\include\util\delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:c:\winavr-20100110\avr\include\util\delay.h ****     fallback if no such user-provided definition could be found.
 102:c:\winavr-20100110\avr\include\util\delay.h **** 
 103:c:\winavr-20100110\avr\include\util\delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:c:\winavr-20100110\avr\include\util\delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:c:\winavr-20100110\avr\include\util\delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:c:\winavr-20100110\avr\include\util\delay.h ****     integer value.
 107:c:\winavr-20100110\avr\include\util\delay.h ****  */
 108:c:\winavr-20100110\avr\include\util\delay.h **** # define F_CPU 1000000UL
 109:c:\winavr-20100110\avr\include\util\delay.h **** #endif
 110:c:\winavr-20100110\avr\include\util\delay.h **** 
 111:c:\winavr-20100110\avr\include\util\delay.h **** #ifndef __OPTIMIZE__
 112:c:\winavr-20100110\avr\include\util\delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:c:\winavr-20100110\avr\include\util\delay.h **** #endif
 114:c:\winavr-20100110\avr\include\util\delay.h **** 
 115:c:\winavr-20100110\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:c:\winavr-20100110\avr\include\util\delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:c:\winavr-20100110\avr\include\util\delay.h ****   __STDC_HOSTED__
 118:c:\winavr-20100110\avr\include\util\delay.h **** #  include <math.h>
 119:c:\winavr-20100110\avr\include\util\delay.h **** #endif
 120:c:\winavr-20100110\avr\include\util\delay.h **** 
 121:c:\winavr-20100110\avr\include\util\delay.h **** /**
 122:c:\winavr-20100110\avr\include\util\delay.h ****    \ingroup util_delay
 123:c:\winavr-20100110\avr\include\util\delay.h **** 
 124:c:\winavr-20100110\avr\include\util\delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:c:\winavr-20100110\avr\include\util\delay.h **** 
 126:c:\winavr-20100110\avr\include\util\delay.h ****    The macro F_CPU is supposed to be defined to a
 127:c:\winavr-20100110\avr\include\util\delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:c:\winavr-20100110\avr\include\util\delay.h **** 
 129:c:\winavr-20100110\avr\include\util\delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:c:\winavr-20100110\avr\include\util\delay.h **** 
 131:c:\winavr-20100110\avr\include\util\delay.h ****    When the user request delay which exceed the maximum possible one,
 132:c:\winavr-20100110\avr\include\util\delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:c:\winavr-20100110\avr\include\util\delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:c:\winavr-20100110\avr\include\util\delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:c:\winavr-20100110\avr\include\util\delay.h ****    user will not be informed about decreased resolution.
 136:c:\winavr-20100110\avr\include\util\delay.h **** 
 137:c:\winavr-20100110\avr\include\util\delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:c:\winavr-20100110\avr\include\util\delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:c:\winavr-20100110\avr\include\util\delay.h ****    values greater than the maximal possible delay, overflows results in
 140:c:\winavr-20100110\avr\include\util\delay.h ****    no delay i.e., 0ms.
 141:c:\winavr-20100110\avr\include\util\delay.h **** 
 142:c:\winavr-20100110\avr\include\util\delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:c:\winavr-20100110\avr\include\util\delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:c:\winavr-20100110\avr\include\util\delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:c:\winavr-20100110\avr\include\util\delay.h ****    microseconds of delay.
 146:c:\winavr-20100110\avr\include\util\delay.h **** 
 147:c:\winavr-20100110\avr\include\util\delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:c:\winavr-20100110\avr\include\util\delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:c:\winavr-20100110\avr\include\util\delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:c:\winavr-20100110\avr\include\util\delay.h ****    respectively.
 151:c:\winavr-20100110\avr\include\util\delay.h **** 
 152:c:\winavr-20100110\avr\include\util\delay.h ****    \note
 153:c:\winavr-20100110\avr\include\util\delay.h **** 
 154:c:\winavr-20100110\avr\include\util\delay.h ****    The implementation of _delay_ms() based on
 155:c:\winavr-20100110\avr\include\util\delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:c:\winavr-20100110\avr\include\util\delay.h ****    implementations.  In order to get functionality backward compatible
 157:c:\winavr-20100110\avr\include\util\delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:c:\winavr-20100110\avr\include\util\delay.h ****    must be defined before including this header file. Also, the
 159:c:\winavr-20100110\avr\include\util\delay.h ****    backward compatible algorithm will be chosen if the code is
 160:c:\winavr-20100110\avr\include\util\delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:c:\winavr-20100110\avr\include\util\delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:c:\winavr-20100110\avr\include\util\delay.h ****    not available to the compiler then.
 163:c:\winavr-20100110\avr\include\util\delay.h **** 
 164:c:\winavr-20100110\avr\include\util\delay.h ****  */
 165:c:\winavr-20100110\avr\include\util\delay.h **** void
 166:c:\winavr-20100110\avr\include\util\delay.h **** _delay_ms(double __ms)
 167:c:\winavr-20100110\avr\include\util\delay.h **** {
 168:c:\winavr-20100110\avr\include\util\delay.h **** 	double __tmp ;
 169:c:\winavr-20100110\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:c:\winavr-20100110\avr\include\util\delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:c:\winavr-20100110\avr\include\util\delay.h ****   __STDC_HOSTED__
 172:c:\winavr-20100110\avr\include\util\delay.h **** 	uint32_t __ticks_dc;
 173:c:\winavr-20100110\avr\include\util\delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 174:c:\winavr-20100110\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 175:c:\winavr-20100110\avr\include\util\delay.h **** 
 176:c:\winavr-20100110\avr\include\util\delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:c:\winavr-20100110\avr\include\util\delay.h **** 
 179:c:\winavr-20100110\avr\include\util\delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:c:\winavr-20100110\avr\include\util\delay.h **** 
 182:c:\winavr-20100110\avr\include\util\delay.h **** 	#else
 183:c:\winavr-20100110\avr\include\util\delay.h **** 		//round up by default
 184:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 185:c:\winavr-20100110\avr\include\util\delay.h **** 	#endif
 186:c:\winavr-20100110\avr\include\util\delay.h **** 
 187:c:\winavr-20100110\avr\include\util\delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 1051               		.loc 2 187 0
 1052 0298 8FE3      		ldi r24,lo8(-25537)
 1053 029a 9CE9      		ldi r25,hi8(-25537)
 1054 029c 0197      	1:	sbiw r24,1
 1055 029e 01F4      		brne 1b
 1056 02a0 00C0      		rjmp .
 1057 02a2 0000      		nop
 1058               	.LVL67:
 1059               	.LBE98:
 1060               	.LBE97:
 549:setup.c       **** 	_delay_ms(20); // Wait a little (for Atmel chip)
 550:setup.c       **** 	
 551:setup.c       **** 	// Set data as inputs
 552:setup.c       **** 	GBA_PORT_RAM_DATA7_0 = 0;
 1061               		.loc 1 552 0
 1062 02a4 15BA      		out 0x15,__zero_reg__
 553:setup.c       **** 	GBA_DDR_RAM_DATA7_0 = 0;
 1063               		.loc 1 553 0
 1064 02a6 14BA      		out 0x14,__zero_reg__
 554:setup.c       **** 	
 555:setup.c       **** 	// Read and transmit the 2 bytes
 556:setup.c       **** 	flashChipIdBuffer[0] = gba_read_ram_8bit_data(0x0000);
 1065               		.loc 1 556 0
 1066 02a8 80E0      		ldi r24,0
 1067 02aa 90E0      		ldi r25,0
 1068 02ac 00D0      		rcall gba_read_ram_8bit_data
 1069               	.LVL68:
 1070 02ae C0E0      		ldi r28,lo8(flashChipIdBuffer)
 1071 02b0 D0E0      		ldi r29,hi8(flashChipIdBuffer)
 1072 02b2 8883      		st Y,r24
 557:setup.c       **** 	flashChipIdBuffer[1] = gba_read_ram_8bit_data(0x0001);
 1073               		.loc 1 557 0
 1074 02b4 81E0      		ldi r24,lo8(1)
 1075 02b6 90E0      		ldi r25,0
 1076 02b8 00D0      		rcall gba_read_ram_8bit_data
 1077               	.LVL69:
 1078 02ba 8983      		std Y+1,r24
 558:setup.c       **** 	
 559:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xAA);
 1079               		.loc 1 559 0
 1080 02bc 6AEA      		ldi r22,lo8(-86)
 1081 02be 85E5      		ldi r24,lo8(85)
 1082 02c0 95E5      		ldi r25,lo8(85)
 1083 02c2 00D0      		rcall flash_write_bus_cycle
 1084               	.LVL70:
 560:setup.c       **** 	flash_write_bus_cycle(0x2AAA, 0x55);
 1085               		.loc 1 560 0
 1086 02c4 65E5      		ldi r22,lo8(85)
 1087 02c6 8AEA      		ldi r24,lo8(-86)
 1088 02c8 9AE2      		ldi r25,lo8(42)
 1089 02ca 00D0      		rcall flash_write_bus_cycle
 1090               	.LVL71:
 561:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xF0); // Software ID exit
 1091               		.loc 1 561 0
 1092 02cc 60EF      		ldi r22,lo8(-16)
 1093 02ce 85E5      		ldi r24,lo8(85)
 1094 02d0 95E5      		ldi r25,lo8(85)
 1095 02d2 00D0      		rcall flash_write_bus_cycle
 1096               	.LVL72:
 1097               	.LBB99:
 1098               	.LBB100:
 1099               		.loc 2 187 0
 1100 02d4 8FE3      		ldi r24,lo8(-25537)
 1101 02d6 9CE9      		ldi r25,hi8(-25537)
 1102 02d8 0197      	1:	sbiw r24,1
 1103 02da 01F4      		brne 1b
 1104 02dc 00C0      		rjmp .
 1105 02de 0000      		nop
 1106               	.LVL73:
 1107               	/* epilogue start */
 1108               	.LBE100:
 1109               	.LBE99:
 562:setup.c       **** 	_delay_ms(20); // Wait a little (for Atmel chip)
 563:setup.c       **** }
 1110               		.loc 1 563 0
 1111 02e0 DF91      		pop r29
 1112 02e2 CF91      		pop r28
 1113 02e4 0895      		ret
 1114               		.cfi_endproc
 1115               	.LFE31:
 1117               	.global	flash_switch_bank
 1119               	flash_switch_bank:
 1120               	.LFB32:
 564:setup.c       **** 
 565:setup.c       **** // Switch banks on the Flash
 566:setup.c       **** void flash_switch_bank(uint8_t bank) {
 1121               		.loc 1 566 0
 1122               		.cfi_startproc
 1123               	.LVL74:
 1124 02e6 CF93      		push r28
 1125               	.LCFI14:
 1126               		.cfi_def_cfa_offset 3
 1127               		.cfi_offset 28, -2
 1128               	/* prologue: function */
 1129               	/* frame size = 0 */
 1130               	/* stack size = 1 */
 1131               	.L__stack_usage = 1
 1132 02e8 C82F      		mov r28,r24
 567:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xAA);
 1133               		.loc 1 567 0
 1134 02ea 6AEA      		ldi r22,lo8(-86)
 1135 02ec 85E5      		ldi r24,lo8(85)
 1136 02ee 95E5      		ldi r25,lo8(85)
 1137               	.LVL75:
 1138 02f0 00D0      		rcall flash_write_bus_cycle
 1139               	.LVL76:
 568:setup.c       **** 	flash_write_bus_cycle(0x2AAA, 0x55);
 1140               		.loc 1 568 0
 1141 02f2 65E5      		ldi r22,lo8(85)
 1142 02f4 8AEA      		ldi r24,lo8(-86)
 1143 02f6 9AE2      		ldi r25,lo8(42)
 1144 02f8 00D0      		rcall flash_write_bus_cycle
 1145               	.LVL77:
 569:setup.c       **** 	
 570:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xB0);
 1146               		.loc 1 570 0
 1147 02fa 60EB      		ldi r22,lo8(-80)
 1148 02fc 85E5      		ldi r24,lo8(85)
 1149 02fe 95E5      		ldi r25,lo8(85)
 1150 0300 00D0      		rcall flash_write_bus_cycle
 1151               	.LVL78:
 571:setup.c       **** 	flash_write_bus_cycle(0x0000, bank);
 1152               		.loc 1 571 0
 1153 0302 6C2F      		mov r22,r28
 1154 0304 80E0      		ldi r24,0
 1155 0306 90E0      		ldi r25,0
 1156               	/* epilogue start */
 572:setup.c       **** }
 1157               		.loc 1 572 0
 1158 0308 CF91      		pop r28
 1159               	.LVL79:
 571:setup.c       **** 	flash_write_bus_cycle(0x0000, bank);
 1160               		.loc 1 571 0
 1161 030a 00C0      		rjmp flash_write_bus_cycle
 1162               	.LVL80:
 1163               		.cfi_endproc
 1164               	.LFE32:
 1166               	.global	flash_erase_4k_sector
 1168               	flash_erase_4k_sector:
 1169               	.LFB33:
 573:setup.c       **** 
 574:setup.c       **** // Erase 4K sector on Flash, expects first sector to start at 0, left shifts by 12 (A15-A12 to sele
 575:setup.c       **** // Takes 25ms after last command to erase sector
 576:setup.c       **** void flash_erase_4k_sector(uint8_t sector) {
 1170               		.loc 1 576 0
 1171               		.cfi_startproc
 1172               	.LVL81:
 1173 030c CF93      		push r28
 1174               	.LCFI15:
 1175               		.cfi_def_cfa_offset 3
 1176               		.cfi_offset 28, -2
 1177               	/* prologue: function */
 1178               	/* frame size = 0 */
 1179               	/* stack size = 1 */
 1180               	.L__stack_usage = 1
 1181 030e C82F      		mov r28,r24
 577:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xAA);
 1182               		.loc 1 577 0
 1183 0310 6AEA      		ldi r22,lo8(-86)
 1184 0312 85E5      		ldi r24,lo8(85)
 1185 0314 95E5      		ldi r25,lo8(85)
 1186               	.LVL82:
 1187 0316 00D0      		rcall flash_write_bus_cycle
 1188               	.LVL83:
 578:setup.c       **** 	flash_write_bus_cycle(0x2AAA, 0x55);
 1189               		.loc 1 578 0
 1190 0318 65E5      		ldi r22,lo8(85)
 1191 031a 8AEA      		ldi r24,lo8(-86)
 1192 031c 9AE2      		ldi r25,lo8(42)
 1193 031e 00D0      		rcall flash_write_bus_cycle
 1194               	.LVL84:
 579:setup.c       **** 	flash_write_bus_cycle(0x5555, 0x80);
 1195               		.loc 1 579 0
 1196 0320 60E8      		ldi r22,lo8(-128)
 1197 0322 85E5      		ldi r24,lo8(85)
 1198 0324 95E5      		ldi r25,lo8(85)
 1199 0326 00D0      		rcall flash_write_bus_cycle
 1200               	.LVL85:
 580:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xAA);
 1201               		.loc 1 580 0
 1202 0328 6AEA      		ldi r22,lo8(-86)
 1203 032a 85E5      		ldi r24,lo8(85)
 1204 032c 95E5      		ldi r25,lo8(85)
 1205 032e 00D0      		rcall flash_write_bus_cycle
 1206               	.LVL86:
 581:setup.c       **** 	flash_write_bus_cycle(0x2AAA, 0x55);
 1207               		.loc 1 581 0
 1208 0330 65E5      		ldi r22,lo8(85)
 1209 0332 8AEA      		ldi r24,lo8(-86)
 1210 0334 9AE2      		ldi r25,lo8(42)
 1211 0336 00D0      		rcall flash_write_bus_cycle
 1212               	.LVL87:
 582:setup.c       **** 	
 583:setup.c       **** 	flash_write_bus_cycle((uint16_t) sector << 12, 0x30);
 1213               		.loc 1 583 0
 1214 0338 60E3      		ldi r22,lo8(48)
 1215 033a 80E0      		ldi r24,0
 1216 033c 9C2F      		mov r25,r28
 1217 033e 9295      		swap r25
 1218 0340 907F      		andi r25,lo8(-16)
 1219 0342 00D0      		rcall flash_write_bus_cycle
 1220               	.LVL88:
 1221               	.LBB101:
 1222               	.LBB102:
 1223               		.loc 2 187 0
 1224 0344 8FE4      		ldi r24,lo8(-15537)
 1225 0346 93EC      		ldi r25,hi8(-15537)
 1226 0348 0197      	1:	sbiw r24,1
 1227 034a 01F4      		brne 1b
 1228 034c 00C0      		rjmp .
 1229 034e 0000      		nop
 1230               	.LVL89:
 1231               	/* epilogue start */
 1232               	.LBE102:
 1233               	.LBE101:
 584:setup.c       **** 	_delay_ms(25); // Wait 25ms for sector erase
 585:setup.c       **** }
 1234               		.loc 1 585 0
 1235 0350 CF91      		pop r28
 1236               	.LVL90:
 1237 0352 0895      		ret
 1238               		.cfi_endproc
 1239               	.LFE33:
 1241               	.global	flash_write_byte
 1243               	flash_write_byte:
 1244               	.LFB34:
 586:setup.c       **** 
 587:setup.c       **** // Write a single byte to the Flash address
 588:setup.c       **** // Takes 20us to program Flash
 589:setup.c       **** void flash_write_byte(uint16_t address, uint8_t data) {
 1245               		.loc 1 589 0
 1246               		.cfi_startproc
 1247               	.LVL91:
 1248 0354 1F93      		push r17
 1249               	.LCFI16:
 1250               		.cfi_def_cfa_offset 3
 1251               		.cfi_offset 17, -2
 1252 0356 CF93      		push r28
 1253               	.LCFI17:
 1254               		.cfi_def_cfa_offset 4
 1255               		.cfi_offset 28, -3
 1256 0358 DF93      		push r29
 1257               	.LCFI18:
 1258               		.cfi_def_cfa_offset 5
 1259               		.cfi_offset 29, -4
 1260               	/* prologue: function */
 1261               	/* frame size = 0 */
 1262               	/* stack size = 3 */
 1263               	.L__stack_usage = 3
 1264 035a EC01      		movw r28,r24
 1265 035c 162F      		mov r17,r22
 590:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xAA);
 1266               		.loc 1 590 0
 1267 035e 6AEA      		ldi r22,lo8(-86)
 1268               	.LVL92:
 1269 0360 85E5      		ldi r24,lo8(85)
 1270 0362 95E5      		ldi r25,lo8(85)
 1271               	.LVL93:
 1272 0364 00D0      		rcall flash_write_bus_cycle
 1273               	.LVL94:
 591:setup.c       **** 	flash_write_bus_cycle(0x2AAA, 0x55);
 1274               		.loc 1 591 0
 1275 0366 65E5      		ldi r22,lo8(85)
 1276 0368 8AEA      		ldi r24,lo8(-86)
 1277 036a 9AE2      		ldi r25,lo8(42)
 1278 036c 00D0      		rcall flash_write_bus_cycle
 1279               	.LVL95:
 592:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xA0);
 1280               		.loc 1 592 0
 1281 036e 60EA      		ldi r22,lo8(-96)
 1282 0370 85E5      		ldi r24,lo8(85)
 1283 0372 95E5      		ldi r25,lo8(85)
 1284 0374 00D0      		rcall flash_write_bus_cycle
 1285               	.LVL96:
 593:setup.c       **** 	
 594:setup.c       **** 	flash_write_bus_cycle(address, data);
 1286               		.loc 1 594 0
 1287 0376 612F      		mov r22,r17
 1288 0378 CE01      		movw r24,r28
 1289 037a 00D0      		rcall flash_write_bus_cycle
 1290               	.LVL97:
 1291               	.LBB103:
 1292               	.LBB104:
 188:c:\winavr-20100110\avr\include\util\delay.h **** 
 189:c:\winavr-20100110\avr\include\util\delay.h **** #else
 190:c:\winavr-20100110\avr\include\util\delay.h **** 	uint16_t __ticks;
 191:c:\winavr-20100110\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 4e3) * __ms;
 192:c:\winavr-20100110\avr\include\util\delay.h **** 	if (__tmp < 1.0)
 193:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks = 1;
 194:c:\winavr-20100110\avr\include\util\delay.h **** 	else if (__tmp > 65535)
 195:c:\winavr-20100110\avr\include\util\delay.h **** 	{
 196:c:\winavr-20100110\avr\include\util\delay.h **** 		//	__ticks = requested delay in 1/10 ms
 197:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 198:c:\winavr-20100110\avr\include\util\delay.h **** 		while(__ticks)
 199:c:\winavr-20100110\avr\include\util\delay.h **** 		{
 200:c:\winavr-20100110\avr\include\util\delay.h **** 			// wait 1/10 ms
 201:c:\winavr-20100110\avr\include\util\delay.h **** 			_delay_loop_2(((F_CPU) / 4e3) / 10);
 202:c:\winavr-20100110\avr\include\util\delay.h **** 			__ticks --;
 203:c:\winavr-20100110\avr\include\util\delay.h **** 		}
 204:c:\winavr-20100110\avr\include\util\delay.h **** 		return;
 205:c:\winavr-20100110\avr\include\util\delay.h **** 	}
 206:c:\winavr-20100110\avr\include\util\delay.h **** 	else
 207:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks = (uint16_t)__tmp;
 208:c:\winavr-20100110\avr\include\util\delay.h **** 	_delay_loop_2(__ticks);
 209:c:\winavr-20100110\avr\include\util\delay.h **** #endif
 210:c:\winavr-20100110\avr\include\util\delay.h **** }
 211:c:\winavr-20100110\avr\include\util\delay.h **** 
 212:c:\winavr-20100110\avr\include\util\delay.h **** /**
 213:c:\winavr-20100110\avr\include\util\delay.h ****    \ingroup util_delay
 214:c:\winavr-20100110\avr\include\util\delay.h **** 
 215:c:\winavr-20100110\avr\include\util\delay.h ****    Perform a delay of \c __us microseconds, using _delay_loop_1().
 216:c:\winavr-20100110\avr\include\util\delay.h **** 
 217:c:\winavr-20100110\avr\include\util\delay.h ****    The macro F_CPU is supposed to be defined to a
 218:c:\winavr-20100110\avr\include\util\delay.h ****    constant defining the CPU clock frequency (in Hertz).
 219:c:\winavr-20100110\avr\include\util\delay.h **** 
 220:c:\winavr-20100110\avr\include\util\delay.h ****    The maximal possible delay is 768 us / F_CPU in MHz.
 221:c:\winavr-20100110\avr\include\util\delay.h **** 
 222:c:\winavr-20100110\avr\include\util\delay.h ****    If the user requests a delay greater than the maximal possible one,
 223:c:\winavr-20100110\avr\include\util\delay.h ****    _delay_us() will automatically call _delay_ms() instead.  The user
 224:c:\winavr-20100110\avr\include\util\delay.h ****    will not be informed about this case.
 225:c:\winavr-20100110\avr\include\util\delay.h **** 
 226:c:\winavr-20100110\avr\include\util\delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 227:c:\winavr-20100110\avr\include\util\delay.h ****    support, maximal possible delay is 4294967.295 us/ F_CPU in MHz. For
 228:c:\winavr-20100110\avr\include\util\delay.h ****    values greater than the maximal possible delay, overflow results in
 229:c:\winavr-20100110\avr\include\util\delay.h ****    no delay i.e., 0us.
 230:c:\winavr-20100110\avr\include\util\delay.h **** 
 231:c:\winavr-20100110\avr\include\util\delay.h ****    Conversion of \c __us into clock cycles may not always result in
 232:c:\winavr-20100110\avr\include\util\delay.h ****    integer.  By default, the clock cycles rounded up to next
 233:c:\winavr-20100110\avr\include\util\delay.h ****    integer. This ensures that the user gets at least \c __us
 234:c:\winavr-20100110\avr\include\util\delay.h ****    microseconds of delay.
 235:c:\winavr-20100110\avr\include\util\delay.h **** 
 236:c:\winavr-20100110\avr\include\util\delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 237:c:\winavr-20100110\avr\include\util\delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 238:c:\winavr-20100110\avr\include\util\delay.h ****    algorithm can be made to round down, or round to closest integer,
 239:c:\winavr-20100110\avr\include\util\delay.h ****    respectively.
 240:c:\winavr-20100110\avr\include\util\delay.h **** 
 241:c:\winavr-20100110\avr\include\util\delay.h ****    \note
 242:c:\winavr-20100110\avr\include\util\delay.h **** 
 243:c:\winavr-20100110\avr\include\util\delay.h ****    The implementation of _delay_ms() based on
 244:c:\winavr-20100110\avr\include\util\delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 245:c:\winavr-20100110\avr\include\util\delay.h ****    implementations.  In order to get functionality backward compatible
 246:c:\winavr-20100110\avr\include\util\delay.h ****    with previous versions, the macro \c __DELAY_BACKWARD_COMPATIBLE__
 247:c:\winavr-20100110\avr\include\util\delay.h ****    must be defined before including this header file. Also, the
 248:c:\winavr-20100110\avr\include\util\delay.h ****    backward compatible algorithm will be chosen if the code is
 249:c:\winavr-20100110\avr\include\util\delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 250:c:\winavr-20100110\avr\include\util\delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 251:c:\winavr-20100110\avr\include\util\delay.h ****    not available to the compiler then.
 252:c:\winavr-20100110\avr\include\util\delay.h **** 
 253:c:\winavr-20100110\avr\include\util\delay.h ****  */
 254:c:\winavr-20100110\avr\include\util\delay.h **** void
 255:c:\winavr-20100110\avr\include\util\delay.h **** _delay_us(double __us)
 256:c:\winavr-20100110\avr\include\util\delay.h **** {
 257:c:\winavr-20100110\avr\include\util\delay.h **** 	double __tmp ;
 258:c:\winavr-20100110\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 259:c:\winavr-20100110\avr\include\util\delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 260:c:\winavr-20100110\avr\include\util\delay.h ****   __STDC_HOSTED__
 261:c:\winavr-20100110\avr\include\util\delay.h **** 	uint32_t __ticks_dc;
 262:c:\winavr-20100110\avr\include\util\delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 263:c:\winavr-20100110\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 264:c:\winavr-20100110\avr\include\util\delay.h **** 
 265:c:\winavr-20100110\avr\include\util\delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 266:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 267:c:\winavr-20100110\avr\include\util\delay.h **** 
 268:c:\winavr-20100110\avr\include\util\delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 269:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 270:c:\winavr-20100110\avr\include\util\delay.h **** 
 271:c:\winavr-20100110\avr\include\util\delay.h **** 	#else
 272:c:\winavr-20100110\avr\include\util\delay.h **** 		//round up by default
 273:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 274:c:\winavr-20100110\avr\include\util\delay.h **** 	#endif
 275:c:\winavr-20100110\avr\include\util\delay.h **** 
 276:c:\winavr-20100110\avr\include\util\delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 1293               		.loc 2 276 0
 1294 037c 85E3      		ldi r24,lo8(53)
 1295 037e 8A95      	1:	dec r24
 1296 0380 01F4      		brne 1b
 1297 0382 0000      		nop
 1298               	.LVL98:
 1299               	/* epilogue start */
 1300               	.LBE104:
 1301               	.LBE103:
 595:setup.c       **** 	_delay_us(20); // Wait byte program time
 596:setup.c       **** }
 1302               		.loc 1 596 0
 1303 0384 DF91      		pop r29
 1304 0386 CF91      		pop r28
 1305               	.LVL99:
 1306 0388 1F91      		pop r17
 1307               	.LVL100:
 1308 038a 0895      		ret
 1309               		.cfi_endproc
 1310               	.LFE34:
 1312               	.global	flash_write_sector
 1314               	flash_write_sector:
 1315               	.LFB35:
 597:setup.c       **** 
 598:setup.c       **** // Write a sector (128 bytes) to the Atmel flash
 599:setup.c       **** // Takes 20ms for write cycle
 600:setup.c       **** void flash_write_sector(uint16_t sector) {
 1316               		.loc 1 600 0
 1317               		.cfi_startproc
 1318               	.LVL101:
 1319 038c EF92      		push r14
 1320               	.LCFI19:
 1321               		.cfi_def_cfa_offset 3
 1322               		.cfi_offset 14, -2
 1323 038e FF92      		push r15
 1324               	.LCFI20:
 1325               		.cfi_def_cfa_offset 4
 1326               		.cfi_offset 15, -3
 1327 0390 0F93      		push r16
 1328               	.LCFI21:
 1329               		.cfi_def_cfa_offset 5
 1330               		.cfi_offset 16, -4
 1331 0392 1F93      		push r17
 1332               	.LCFI22:
 1333               		.cfi_def_cfa_offset 6
 1334               		.cfi_offset 17, -5
 1335 0394 CF93      		push r28
 1336               	.LCFI23:
 1337               		.cfi_def_cfa_offset 7
 1338               		.cfi_offset 28, -6
 1339 0396 DF93      		push r29
 1340               	.LCFI24:
 1341               		.cfi_def_cfa_offset 8
 1342               		.cfi_offset 29, -7
 1343               	/* prologue: function */
 1344               	/* frame size = 0 */
 1345               	/* stack size = 6 */
 1346               	.L__stack_usage = 6
 1347 0398 8C01      		movw r16,r24
 601:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xAA);
 1348               		.loc 1 601 0
 1349 039a 6AEA      		ldi r22,lo8(-86)
 1350 039c 85E5      		ldi r24,lo8(85)
 1351 039e 95E5      		ldi r25,lo8(85)
 1352               	.LVL102:
 1353 03a0 00D0      		rcall flash_write_bus_cycle
 1354               	.LVL103:
 602:setup.c       **** 	flash_write_bus_cycle(0x2AAA, 0x55);
 1355               		.loc 1 602 0
 1356 03a2 65E5      		ldi r22,lo8(85)
 1357 03a4 8AEA      		ldi r24,lo8(-86)
 1358 03a6 9AE2      		ldi r25,lo8(42)
 1359 03a8 00D0      		rcall flash_write_bus_cycle
 1360               	.LVL104:
 603:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xA0);
 1361               		.loc 1 603 0
 1362 03aa 60EA      		ldi r22,lo8(-96)
 1363 03ac 85E5      		ldi r24,lo8(85)
 1364 03ae 95E5      		ldi r25,lo8(85)
 1365 03b0 00D0      		rcall flash_write_bus_cycle
 1366               	.LVL105:
 1367               	.LBB105:
 604:setup.c       **** 	
 605:setup.c       **** 	// Write the bytes (A0-A6 byte address, A7-A15 sector address)
 606:setup.c       **** 	for (uint8_t x = 0; x < 128; x++) {
 607:setup.c       **** 		flash_write_bus_cycle((uint16_t) (sector << 7) | (uint16_t) x, receivedBuffer[x]);
 1368               		.loc 1 607 0
 1369 03b2 1695      		lsr r17
 1370 03b4 102F      		mov r17,r16
 1371 03b6 0027      		clr r16
 1372 03b8 1795      		ror r17
 1373 03ba 0795      		ror r16
 1374               	.LVL106:
 1375 03bc 90E0      		ldi r25,lo8(receivedBuffer)
 1376 03be E92E      		mov r14,r25
 1377 03c0 90E0      		ldi r25,hi8(receivedBuffer)
 1378 03c2 F92E      		mov r15,r25
 1379 03c4 C0E0      		ldi r28,0
 1380 03c6 D0E0      		ldi r29,0
 1381               	.LVL107:
 1382               	.L66:
 1383               		.loc 1 607 0 is_stmt 0 discriminator 3
 1384 03c8 F701      		movw r30,r14
 1385 03ca 6191      		ld r22,Z+
 1386 03cc 7F01      		movw r14,r30
 1387 03ce CE01      		movw r24,r28
 1388 03d0 802B      		or r24,r16
 1389 03d2 912B      		or r25,r17
 1390 03d4 00D0      		rcall flash_write_bus_cycle
 1391               	.LVL108:
 1392 03d6 2196      		adiw r28,1
 1393               	.LVL109:
 606:setup.c       **** 		flash_write_bus_cycle((uint16_t) (sector << 7) | (uint16_t) x, receivedBuffer[x]);
 1394               		.loc 1 606 0 is_stmt 1 discriminator 3
 1395 03d8 C038      		cpi r28,-128
 1396 03da D105      		cpc r29,__zero_reg__
 1397 03dc 01F4      		brne .L66
 1398               	.LVL110:
 1399               	.LBE105:
 1400               	.LBB106:
 1401               	.LBB107:
 187:c:\winavr-20100110\avr\include\util\delay.h **** 
 1402               		.loc 2 187 0
 1403 03de 8FE3      		ldi r24,lo8(-25537)
 1404 03e0 9CE9      		ldi r25,hi8(-25537)
 1405 03e2 0197      	1:	sbiw r24,1
 1406 03e4 01F4      		brne 1b
 1407 03e6 00C0      		rjmp .
 1408 03e8 0000      		nop
 1409               	.LVL111:
 1410               	/* epilogue start */
 1411               	.LBE107:
 1412               	.LBE106:
 608:setup.c       **** 	}
 609:setup.c       **** 	_delay_ms(20); // Wait sector program time
 610:setup.c       **** }
 1413               		.loc 1 610 0
 1414 03ea DF91      		pop r29
 1415 03ec CF91      		pop r28
 1416               	.LVL112:
 1417 03ee 1F91      		pop r17
 1418 03f0 0F91      		pop r16
 1419 03f2 FF90      		pop r15
 1420 03f4 EF90      		pop r14
 1421 03f6 0895      		ret
 1422               		.cfi_endproc
 1423               	.LFE35:
 1425               	.global	gb_flash_read_byte
 1427               	gb_flash_read_byte:
 1428               	.LFB36:
 611:setup.c       **** 
 612:setup.c       **** 
 613:setup.c       **** 
 614:setup.c       **** // ---------- GB FLASH CARTS ----------
 615:setup.c       **** 
 616:setup.c       **** // Read a byte from the flash (No CS pin pulse)
 617:setup.c       **** uint8_t gb_flash_read_byte(uint16_t address) {
 1429               		.loc 1 617 0
 1430               		.cfi_startproc
 1431               	.LVL113:
 1432               	/* prologue: function */
 1433               	/* frame size = 0 */
 1434               	/* stack size = 0 */
 1435               	.L__stack_usage = 0
 618:setup.c       **** 	PORT_DATA7_0 = 0;
 1436               		.loc 1 618 0
 1437 03f8 15BA      		out 0x15,__zero_reg__
 619:setup.c       **** 	DDR_DATA7_0 = 0;
 1438               		.loc 1 619 0
 1439 03fa 14BA      		out 0x14,__zero_reg__
 620:setup.c       **** 	
 621:setup.c       **** 	set_16bit_address(address);
 1440               		.loc 1 621 0
 1441 03fc 00D0      		rcall set_16bit_address
 1442               	.LVL114:
 622:setup.c       **** 	
 623:setup.c       **** 	rdPin_low;
 1443               		.loc 1 623 0
 1444 03fe 9598      		cbi 0x12,5
 624:setup.c       **** 	asm volatile("nop"); // Delay a little
 1445               		.loc 1 624 0
 1446               	/* #APP */
 1447               	 ;  624 "setup.c" 1
 1448 0400 0000      		nop
 1449               	 ;  0 "" 2
 625:setup.c       **** 	asm volatile("nop");
 1450               		.loc 1 625 0
 1451               	 ;  625 "setup.c" 1
 1452 0402 0000      		nop
 1453               	 ;  0 "" 2
 626:setup.c       **** 	uint8_t data = PIN_DATA7_0; // Read data
 1454               		.loc 1 626 0
 1455               	/* #NOAPP */
 1456 0404 83B3      		in r24,0x13
 1457               	.LVL115:
 627:setup.c       **** 	rdPin_high;
 1458               		.loc 1 627 0
 1459 0406 959A      		sbi 0x12,5
 628:setup.c       **** 	
 629:setup.c       **** 	return data;
 630:setup.c       **** }
 1460               		.loc 1 630 0
 1461 0408 0895      		ret
 1462               		.cfi_endproc
 1463               	.LFE36:
 1465               	.global	gb_flash_write_bus_cycle
 1467               	gb_flash_write_bus_cycle:
 1468               	.LFB37:
 631:setup.c       **** 
 632:setup.c       **** // Set the address and data for the write byte cycle to the flash
 633:setup.c       **** void gb_flash_write_bus_cycle(uint16_t address, uint8_t data) {
 1469               		.loc 1 633 0
 1470               		.cfi_startproc
 1471               	.LVL116:
 1472 040a CF93      		push r28
 1473               	.LCFI25:
 1474               		.cfi_def_cfa_offset 3
 1475               		.cfi_offset 28, -2
 1476               	/* prologue: function */
 1477               	/* frame size = 0 */
 1478               	/* stack size = 1 */
 1479               	.L__stack_usage = 1
 1480 040c C62F      		mov r28,r22
 634:setup.c       **** 	DDR_DATA7_0 = 0xFF; // Set data pins as outputs
 1481               		.loc 1 634 0
 1482 040e 2FEF      		ldi r18,lo8(-1)
 1483 0410 24BB      		out 0x14,r18
 635:setup.c       **** 	set_16bit_address(address);
 1484               		.loc 1 635 0
 1485 0412 00D0      		rcall set_16bit_address
 1486               	.LVL117:
 636:setup.c       **** 	PORT_DATA7_0 = data;
 1487               		.loc 1 636 0
 1488 0414 C5BB      		out 0x15,r28
 637:setup.c       **** 	
 638:setup.c       **** 	if (flashWriteWePin == WE_AS_AUDIO_PIN) { // Audio pin
 1489               		.loc 1 638 0
 1490 0416 8091 0000 		lds r24,flashWriteWePin
 1491 041a 8134      		cpi r24,lo8(65)
 1492 041c 01F4      		brne .L70
 1493               	.LVL118:
 1494               	.LBB110:
 1495               	.LBB111:
 639:setup.c       **** 		audioPin_low; // WE low
 1496               		.loc 1 639 0
 1497 041e 3998      		cbi 0x7,1
 640:setup.c       **** 		asm volatile("nop");
 1498               		.loc 1 640 0
 1499               	/* #APP */
 1500               	 ;  640 "setup.c" 1
 1501 0420 0000      		nop
 1502               	 ;  0 "" 2
 641:setup.c       **** 		asm volatile("nop");
 1503               		.loc 1 641 0
 1504               	 ;  641 "setup.c" 1
 1505 0422 0000      		nop
 1506               	 ;  0 "" 2
 642:setup.c       **** 		asm volatile("nop");
 1507               		.loc 1 642 0
 1508               	 ;  642 "setup.c" 1
 1509 0424 0000      		nop
 1510               	 ;  0 "" 2
 643:setup.c       **** 		audioPin_high; // WE high
 1511               		.loc 1 643 0
 1512               	/* #NOAPP */
 1513 0426 399A      		sbi 0x7,1
 1514 0428 00C0      		rjmp .L69
 1515               	.LVL119:
 1516               	.L70:
 1517               	.LBE111:
 1518               	.LBE110:
 644:setup.c       **** 	}
 645:setup.c       **** 	else { // WR pin
 646:setup.c       **** 		wrPin_low; // WE low
 1519               		.loc 1 646 0
 1520 042a 9698      		cbi 0x12,6
 647:setup.c       **** 		asm volatile("nop");
 1521               		.loc 1 647 0
 1522               	/* #APP */
 1523               	 ;  647 "setup.c" 1
 1524 042c 0000      		nop
 1525               	 ;  0 "" 2
 648:setup.c       **** 		asm volatile("nop");
 1526               		.loc 1 648 0
 1527               	 ;  648 "setup.c" 1
 1528 042e 0000      		nop
 1529               	 ;  0 "" 2
 649:setup.c       **** 		asm volatile("nop");
 1530               		.loc 1 649 0
 1531               	 ;  649 "setup.c" 1
 1532 0430 0000      		nop
 1533               	 ;  0 "" 2
 650:setup.c       **** 		wrPin_high; // WE high
 1534               		.loc 1 650 0
 1535               	/* #NOAPP */
 1536 0432 969A      		sbi 0x12,6
 1537               	.L69:
 1538               	/* epilogue start */
 651:setup.c       **** 	}
 652:setup.c       **** }
 1539               		.loc 1 652 0
 1540 0434 CF91      		pop r28
 1541               	.LVL120:
 1542 0436 0895      		ret
 1543               		.cfi_endproc
 1544               	.LFE37:
 1546               	.global	gb_flash_write_byte
 1548               	gb_flash_write_byte:
 1549               	.LFB38:
 653:setup.c       **** 
 654:setup.c       **** // Write a single byte to the Flash address. Takes 10-50us to program each byte.
 655:setup.c       **** void gb_flash_write_byte(uint16_t address, uint8_t data) {
 1550               		.loc 1 655 0
 1551               		.cfi_startproc
 1552               	.LVL121:
 1553 0438 1F93      		push r17
 1554               	.LCFI26:
 1555               		.cfi_def_cfa_offset 3
 1556               		.cfi_offset 17, -2
 1557 043a CF93      		push r28
 1558               	.LCFI27:
 1559               		.cfi_def_cfa_offset 4
 1560               		.cfi_offset 28, -3
 1561 043c DF93      		push r29
 1562               	.LCFI28:
 1563               		.cfi_def_cfa_offset 5
 1564               		.cfi_offset 29, -4
 1565               	/* prologue: function */
 1566               	/* frame size = 0 */
 1567               	/* stack size = 3 */
 1568               	.L__stack_usage = 3
 1569 043e EC01      		movw r28,r24
 1570 0440 162F      		mov r17,r22
 656:setup.c       **** 	gb_flash_write_bus_cycle(flashWriteCycle[0][0], flashWriteCycle[0][1]);
 1571               		.loc 1 656 0
 1572 0442 6091 0000 		lds r22,flashWriteCycle+2
 1573               	.LVL122:
 1574 0446 8091 0000 		lds r24,flashWriteCycle
 1575 044a 9091 0000 		lds r25,flashWriteCycle+1
 1576               	.LVL123:
 1577 044e 00D0      		rcall gb_flash_write_bus_cycle
 1578               	.LVL124:
 657:setup.c       **** 	gb_flash_write_bus_cycle(flashWriteCycle[1][0], flashWriteCycle[1][1]);
 1579               		.loc 1 657 0
 1580 0450 6091 0000 		lds r22,flashWriteCycle+6
 1581 0454 8091 0000 		lds r24,flashWriteCycle+4
 1582 0458 9091 0000 		lds r25,flashWriteCycle+4+1
 1583 045c 00D0      		rcall gb_flash_write_bus_cycle
 1584               	.LVL125:
 658:setup.c       **** 	gb_flash_write_bus_cycle(flashWriteCycle[2][0], flashWriteCycle[2][1]);
 1585               		.loc 1 658 0
 1586 045e 6091 0000 		lds r22,flashWriteCycle+10
 1587 0462 8091 0000 		lds r24,flashWriteCycle+8
 1588 0466 9091 0000 		lds r25,flashWriteCycle+8+1
 1589 046a 00D0      		rcall gb_flash_write_bus_cycle
 1590               	.LVL126:
 659:setup.c       **** 	gb_flash_write_bus_cycle(address, data);
 1591               		.loc 1 659 0
 1592 046c 612F      		mov r22,r17
 1593 046e CE01      		movw r24,r28
 1594 0470 00D0      		rcall gb_flash_write_bus_cycle
 1595               	.LVL127:
 1596               	.LBB112:
 1597               	.LBB113:
 1598               		.loc 2 276 0
 1599 0472 8AE1      		ldi r24,lo8(26)
 1600 0474 8A95      	1:	dec r24
 1601 0476 01F4      		brne 1b
 1602 0478 00C0      		rjmp .
 1603               	.LVL128:
 1604               	.LBE113:
 1605               	.LBE112:
 660:setup.c       **** 	_delay_us(10); // Wait byte program time
 661:setup.c       **** 	
 662:setup.c       **** 	// Set data pins inputs
 663:setup.c       **** 	PORT_DATA7_0 = 0;
 1606               		.loc 1 663 0
 1607 047a 15BA      		out 0x15,__zero_reg__
 664:setup.c       **** 	DDR_DATA7_0 = 0;
 1608               		.loc 1 664 0
 1609 047c 14BA      		out 0x14,__zero_reg__
 665:setup.c       **** 	
 666:setup.c       **** 	// Verify data
 667:setup.c       **** 	uint8_t dataVerify = gb_flash_read_byte(address);
 1610               		.loc 1 667 0
 1611 047e CE01      		movw r24,r28
 1612 0480 00D0      		rcall gb_flash_read_byte
 1613               	.LVL129:
 1614               	.L73:
 668:setup.c       **** 	while (data != dataVerify) {
 1615               		.loc 1 668 0
 1616 0482 8117      		cp r24,r17
 1617 0484 01F0      		breq .L75
 669:setup.c       **** 		dataVerify = gb_flash_read_byte(address);
 1618               		.loc 1 669 0
 1619 0486 CE01      		movw r24,r28
 1620               	.LVL130:
 1621 0488 00D0      		rcall gb_flash_read_byte
 1622               	.LVL131:
 1623               	.LBB114:
 1624               	.LBB115:
 1625               		.loc 2 276 0
 1626 048a 9DE0      		ldi r25,lo8(13)
 1627 048c 9A95      	1:	dec r25
 1628 048e 01F4      		brne 1b
 1629 0490 0000      		nop
 1630 0492 00C0      		rjmp .L73
 1631               	.LVL132:
 1632               	.L75:
 1633               	/* epilogue start */
 1634               	.LBE115:
 1635               	.LBE114:
 670:setup.c       **** 		_delay_us(5);
 671:setup.c       **** 	}
 672:setup.c       **** }
 1636               		.loc 1 672 0
 1637 0494 DF91      		pop r29
 1638 0496 CF91      		pop r28
 1639               	.LVL133:
 1640 0498 1F91      		pop r17
 1641               	.LVL134:
 1642 049a 0895      		ret
 1643               		.cfi_endproc
 1644               	.LFE38:
 1646               	.global	gb_flash_write_byte_bank1_commands
 1648               	gb_flash_write_byte_bank1_commands:
 1649               	.LFB39:
 673:setup.c       **** 
 674:setup.c       **** // Write a single byte to the Flash address. Takes 10-50us to program each byte. 
 675:setup.c       **** // Switch to bank 1 to issue flash commands, then switch back to the bank we were at before
 676:setup.c       **** void gb_flash_write_byte_bank1_commands(uint16_t address, uint8_t data) {
 1650               		.loc 1 676 0
 1651               		.cfi_startproc
 1652               	.LVL135:
 1653 049c FF92      		push r15
 1654               	.LCFI29:
 1655               		.cfi_def_cfa_offset 3
 1656               		.cfi_offset 15, -2
 1657 049e 0F93      		push r16
 1658               	.LCFI30:
 1659               		.cfi_def_cfa_offset 4
 1660               		.cfi_offset 16, -3
 1661 04a0 1F93      		push r17
 1662               	.LCFI31:
 1663               		.cfi_def_cfa_offset 5
 1664               		.cfi_offset 17, -4
 1665 04a2 CF93      		push r28
 1666               	.LCFI32:
 1667               		.cfi_def_cfa_offset 6
 1668               		.cfi_offset 28, -5
 1669 04a4 DF93      		push r29
 1670               	.LCFI33:
 1671               		.cfi_def_cfa_offset 7
 1672               		.cfi_offset 29, -6
 1673               	/* prologue: function */
 1674               	/* frame size = 0 */
 1675               	/* stack size = 5 */
 1676               	.L__stack_usage = 5
 1677 04a6 EC01      		movw r28,r24
 1678 04a8 162F      		mov r17,r22
 677:setup.c       **** 	// Set bank 1
 678:setup.c       **** 	DDR_DATA7_0 = 0xFF;
 1679               		.loc 1 678 0
 1680 04aa FF24      		clr r15
 1681 04ac FA94      		dec r15
 1682 04ae F4BA      		out 0x14,r15
 1683               	.LVL136:
 1684               	.LBB116:
 1685               	.LBB117:
 238:setup.c       **** 	PORT_ADDR7_0 = (address & 0xFF);
 1686               		.loc 1 238 0
 1687 04b0 01E2      		ldi r16,lo8(33)
 1688 04b2 0BBB      		out 0x1b,r16
 239:setup.c       **** }
 1689               		.loc 1 239 0
 1690 04b4 18BA      		out 0x18,__zero_reg__
 1691               	.LVL137:
 1692               	.LBE117:
 1693               	.LBE116:
 679:setup.c       **** 	set_16bit_address(0x2100);
 680:setup.c       **** 	PORT_DATA7_0 = 1;
 1694               		.loc 1 680 0
 1695 04b6 81E0      		ldi r24,lo8(1)
 1696               	.LVL138:
 1697 04b8 85BB      		out 0x15,r24
 681:setup.c       **** 	wrPin_low; // Pulse WR
 1698               		.loc 1 681 0
 1699 04ba 9698      		cbi 0x12,6
 682:setup.c       **** 	asm volatile("nop");
 1700               		.loc 1 682 0
 1701               	/* #APP */
 1702               	 ;  682 "setup.c" 1
 1703 04bc 0000      		nop
 1704               	 ;  0 "" 2
 683:setup.c       **** 	wrPin_high;
 1705               		.loc 1 683 0
 1706               	/* #NOAPP */
 1707 04be 969A      		sbi 0x12,6
 684:setup.c       **** 	
 685:setup.c       **** 	gb_flash_write_bus_cycle(flashWriteCycle[0][0], flashWriteCycle[0][1]);
 1708               		.loc 1 685 0
 1709 04c0 6091 0000 		lds r22,flashWriteCycle+2
 1710               	.LVL139:
 1711 04c4 8091 0000 		lds r24,flashWriteCycle
 1712 04c8 9091 0000 		lds r25,flashWriteCycle+1
 1713 04cc 00D0      		rcall gb_flash_write_bus_cycle
 1714               	.LVL140:
 686:setup.c       **** 	gb_flash_write_bus_cycle(flashWriteCycle[1][0], flashWriteCycle[1][1]);
 1715               		.loc 1 686 0
 1716 04ce 6091 0000 		lds r22,flashWriteCycle+6
 1717 04d2 8091 0000 		lds r24,flashWriteCycle+4
 1718 04d6 9091 0000 		lds r25,flashWriteCycle+4+1
 1719 04da 00D0      		rcall gb_flash_write_bus_cycle
 1720               	.LVL141:
 687:setup.c       **** 	gb_flash_write_bus_cycle(flashWriteCycle[2][0], flashWriteCycle[2][1]);
 1721               		.loc 1 687 0
 1722 04dc 6091 0000 		lds r22,flashWriteCycle+10
 1723 04e0 8091 0000 		lds r24,flashWriteCycle+8
 1724 04e4 9091 0000 		lds r25,flashWriteCycle+8+1
 1725 04e8 00D0      		rcall gb_flash_write_bus_cycle
 1726               	.LVL142:
 688:setup.c       **** 	
 689:setup.c       **** 	
 690:setup.c       **** 	// Set bank back
 691:setup.c       **** 	DDR_DATA7_0 = 0xFF;
 1727               		.loc 1 691 0
 1728 04ea F4BA      		out 0x14,r15
 1729               	.LVL143:
 1730               	.LBB118:
 1731               	.LBB119:
 238:setup.c       **** 	PORT_ADDR7_0 = (address & 0xFF);
 1732               		.loc 1 238 0
 1733 04ec 0BBB      		out 0x1b,r16
 239:setup.c       **** }
 1734               		.loc 1 239 0
 1735 04ee 18BA      		out 0x18,__zero_reg__
 1736               	.LVL144:
 1737               	.LBE119:
 1738               	.LBE118:
 692:setup.c       **** 	set_16bit_address(0x2100);
 693:setup.c       **** 	PORT_DATA7_0 = lastBankAccessed;
 1739               		.loc 1 693 0
 1740 04f0 8091 0000 		lds r24,lastBankAccessed
 1741 04f4 85BB      		out 0x15,r24
 694:setup.c       **** 	wrPin_low; // Pulse WR
 1742               		.loc 1 694 0
 1743 04f6 9698      		cbi 0x12,6
 695:setup.c       **** 	asm volatile("nop");
 1744               		.loc 1 695 0
 1745               	/* #APP */
 1746               	 ;  695 "setup.c" 1
 1747 04f8 0000      		nop
 1748               	 ;  0 "" 2
 696:setup.c       **** 	wrPin_high;
 1749               		.loc 1 696 0
 1750               	/* #NOAPP */
 1751 04fa 969A      		sbi 0x12,6
 697:setup.c       **** 	
 698:setup.c       **** 	gb_flash_write_bus_cycle(address, data);
 1752               		.loc 1 698 0
 1753 04fc 612F      		mov r22,r17
 1754 04fe CE01      		movw r24,r28
 1755 0500 00D0      		rcall gb_flash_write_bus_cycle
 1756               	.LVL145:
 1757               	.LBB120:
 1758               	.LBB121:
 1759               		.loc 2 276 0
 1760 0502 8AE1      		ldi r24,lo8(26)
 1761 0504 8A95      	1:	dec r24
 1762 0506 01F4      		brne 1b
 1763 0508 00C0      		rjmp .
 1764               	.LVL146:
 1765               	.LBE121:
 1766               	.LBE120:
 699:setup.c       **** 	_delay_us(10); // Wait byte program time
 700:setup.c       **** 	
 701:setup.c       **** 	// Set data pins inputs
 702:setup.c       **** 	PORT_DATA7_0 = 0;
 1767               		.loc 1 702 0
 1768 050a 15BA      		out 0x15,__zero_reg__
 703:setup.c       **** 	DDR_DATA7_0 = 0;
 1769               		.loc 1 703 0
 1770 050c 14BA      		out 0x14,__zero_reg__
 704:setup.c       **** 	
 705:setup.c       **** 	// Verify data
 706:setup.c       **** 	uint8_t dataVerify = gb_flash_read_byte(address);
 1771               		.loc 1 706 0
 1772 050e CE01      		movw r24,r28
 1773 0510 00D0      		rcall gb_flash_read_byte
 1774               	.LVL147:
 1775               	.L77:
 707:setup.c       **** 	while (data != dataVerify) {
 1776               		.loc 1 707 0
 1777 0512 8117      		cp r24,r17
 1778 0514 01F0      		breq .L79
 708:setup.c       **** 		dataVerify = gb_flash_read_byte(address);
 1779               		.loc 1 708 0
 1780 0516 CE01      		movw r24,r28
 1781               	.LVL148:
 1782 0518 00D0      		rcall gb_flash_read_byte
 1783               	.LVL149:
 1784               	.LBB122:
 1785               	.LBB123:
 1786               		.loc 2 276 0
 1787 051a 9DE0      		ldi r25,lo8(13)
 1788 051c 9A95      	1:	dec r25
 1789 051e 01F4      		brne 1b
 1790 0520 0000      		nop
 1791 0522 00C0      		rjmp .L77
 1792               	.LVL150:
 1793               	.L79:
 1794               	/* epilogue start */
 1795               	.LBE123:
 1796               	.LBE122:
 709:setup.c       **** 		_delay_us(5);
 710:setup.c       **** 	}
 711:setup.c       **** }
 1797               		.loc 1 711 0
 1798 0524 DF91      		pop r29
 1799 0526 CF91      		pop r28
 1800               	.LVL151:
 1801 0528 1F91      		pop r17
 1802               	.LVL152:
 1803 052a 0F91      		pop r16
 1804 052c FF90      		pop r15
 1805 052e 0895      		ret
 1806               		.cfi_endproc
 1807               	.LFE39:
 1809               	.global	gba_flash_write_bus_cycle
 1811               	gba_flash_write_bus_cycle:
 1812               	.LFB40:
 712:setup.c       **** 
 713:setup.c       **** 
 714:setup.c       **** 
 715:setup.c       **** // ---------- GBA FLASH CARTS ----------
 716:setup.c       **** 
 717:setup.c       **** // Set the 24 bit address and 16 bit data for the write byte cycle to the flash (pulse WR pin)
 718:setup.c       **** void gba_flash_write_bus_cycle(uint32_t address, uint16_t data) {
 1813               		.loc 1 718 0
 1814               		.cfi_startproc
 1815               	.LVL153:
 1816 0530 0F93      		push r16
 1817               	.LCFI34:
 1818               		.cfi_def_cfa_offset 3
 1819               		.cfi_offset 16, -2
 1820 0532 1F93      		push r17
 1821               	.LCFI35:
 1822               		.cfi_def_cfa_offset 4
 1823               		.cfi_offset 17, -3
 1824               	/* prologue: function */
 1825               	/* frame size = 0 */
 1826               	/* stack size = 2 */
 1827               	.L__stack_usage = 2
 719:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = (address >> 16);
 1828               		.loc 1 719 0
 1829 0534 8C01      		movw r16,r24
 1830 0536 2227      		clr r18
 1831 0538 3327      		clr r19
 1832 053a 05BB      		out 0x15,r16
 720:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = (address >> 8);
 1833               		.loc 1 720 0
 1834 053c 072F      		mov r16,r23
 1835 053e 182F      		mov r17,r24
 1836 0540 292F      		mov r18,r25
 1837 0542 3327      		clr r19
 1838 0544 0BBB      		out 0x1b,r16
 721:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = (address & 0xFF);
 1839               		.loc 1 721 0
 1840 0546 68BB      		out 0x18,r22
 722:setup.c       **** 	
 723:setup.c       **** 	cs_mreqPin_low;
 1841               		.loc 1 723 0
 1842 0548 9498      		cbi 0x12,4
 724:setup.c       **** 	
 725:setup.c       **** 	GBA_PORT_ROM_DATA15_8 = data >> 8; // Set data
 1843               		.loc 1 725 0
 1844 054a 5BBB      		out 0x1b,r21
 726:setup.c       **** 	GBA_PORT_ROM_DATA7_0 = data & 0xFF;
 1845               		.loc 1 726 0
 1846 054c 48BB      		out 0x18,r20
 727:setup.c       **** 	
 728:setup.c       **** 	wrPin_low;
 1847               		.loc 1 728 0
 1848 054e 9698      		cbi 0x12,6
 729:setup.c       **** 	asm volatile("nop");
 1849               		.loc 1 729 0
 1850               	/* #APP */
 1851               	 ;  729 "setup.c" 1
 1852 0550 0000      		nop
 1853               	 ;  0 "" 2
 730:setup.c       **** 	asm volatile("nop");
 1854               		.loc 1 730 0
 1855               	 ;  730 "setup.c" 1
 1856 0552 0000      		nop
 1857               	 ;  0 "" 2
 731:setup.c       **** 	asm volatile("nop");
 1858               		.loc 1 731 0
 1859               	 ;  731 "setup.c" 1
 1860 0554 0000      		nop
 1861               	 ;  0 "" 2
 732:setup.c       **** 	wrPin_high;
 1862               		.loc 1 732 0
 1863               	/* #NOAPP */
 1864 0556 969A      		sbi 0x12,6
 733:setup.c       **** 	cs_mreqPin_high;
 1865               		.loc 1 733 0
 1866 0558 949A      		sbi 0x12,4
 1867               	/* epilogue start */
 734:setup.c       **** }
 1868               		.loc 1 734 0
 1869 055a 1F91      		pop r17
 1870 055c 0F91      		pop r16
 1871 055e 0895      		ret
 1872               		.cfi_endproc
 1873               	.LFE40:
 1875               	.global	gba_flash_write_cycle_start
 1877               	gba_flash_write_cycle_start:
 1878               	.LFB41:
 735:setup.c       **** 
 736:setup.c       **** // Send the first 3 write cycles to the flash
 737:setup.c       **** void gba_flash_write_cycle_start(void) {
 1879               		.loc 1 737 0
 1880               		.cfi_startproc
 1881               	/* prologue: function */
 1882               	/* frame size = 0 */
 1883               	/* stack size = 0 */
 1884               	.L__stack_usage = 0
 738:setup.c       **** 	// Set outputs
 739:setup.c       **** 	GBA_DDR_ROM_ADDR23_16 = 0xFF;
 1885               		.loc 1 739 0
 1886 0560 8FEF      		ldi r24,lo8(-1)
 1887 0562 84BB      		out 0x14,r24
 740:setup.c       **** 	GBA_DDR_ROM_ADDR15_8 = 0xFF;
 1888               		.loc 1 740 0
 1889 0564 8ABB      		out 0x1a,r24
 741:setup.c       **** 	GBA_DDR_ROM_ADDR7_0 = 0xFF;
 1890               		.loc 1 741 0
 1891 0566 87BB      		out 0x17,r24
 742:setup.c       **** 	
 743:setup.c       **** 	// 0x555, 0xA9
 744:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = 0;
 1892               		.loc 1 744 0
 1893 0568 15BA      		out 0x15,__zero_reg__
 745:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = 0x05;
 1894               		.loc 1 745 0
 1895 056a 95E0      		ldi r25,lo8(5)
 1896 056c 9BBB      		out 0x1b,r25
 746:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = 0x55;
 1897               		.loc 1 746 0
 1898 056e 85E5      		ldi r24,lo8(85)
 1899 0570 88BB      		out 0x18,r24
 747:setup.c       **** 	cs_mreqPin_low;
 1900               		.loc 1 747 0
 1901 0572 9498      		cbi 0x12,4
 748:setup.c       **** 	GBA_PORT_ROM_DATA15_8 = 0; // Set data
 1902               		.loc 1 748 0
 1903 0574 1BBA      		out 0x1b,__zero_reg__
 749:setup.c       **** 	GBA_PORT_ROM_DATA7_0 = 0xA9;
 1904               		.loc 1 749 0
 1905 0576 29EA      		ldi r18,lo8(-87)
 1906 0578 28BB      		out 0x18,r18
 750:setup.c       **** 	wrPin_low;
 1907               		.loc 1 750 0
 1908 057a 9698      		cbi 0x12,6
 751:setup.c       **** 	asm volatile("nop");
 1909               		.loc 1 751 0
 1910               	/* #APP */
 1911               	 ;  751 "setup.c" 1
 1912 057c 0000      		nop
 1913               	 ;  0 "" 2
 752:setup.c       **** 	asm volatile("nop");
 1914               		.loc 1 752 0
 1915               	 ;  752 "setup.c" 1
 1916 057e 0000      		nop
 1917               	 ;  0 "" 2
 753:setup.c       **** 	asm volatile("nop");
 1918               		.loc 1 753 0
 1919               	 ;  753 "setup.c" 1
 1920 0580 0000      		nop
 1921               	 ;  0 "" 2
 754:setup.c       **** 	wrPin_high;
 1922               		.loc 1 754 0
 1923               	/* #NOAPP */
 1924 0582 969A      		sbi 0x12,6
 755:setup.c       **** 	cs_mreqPin_high;
 1925               		.loc 1 755 0
 1926 0584 949A      		sbi 0x12,4
 756:setup.c       **** 	
 757:setup.c       **** 	// 0x2AA, 0x56
 758:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = 0;
 1927               		.loc 1 758 0
 1928 0586 15BA      		out 0x15,__zero_reg__
 759:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = 0x02;
 1929               		.loc 1 759 0
 1930 0588 22E0      		ldi r18,lo8(2)
 1931 058a 2BBB      		out 0x1b,r18
 760:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = 0xAA;
 1932               		.loc 1 760 0
 1933 058c 2AEA      		ldi r18,lo8(-86)
 1934 058e 28BB      		out 0x18,r18
 761:setup.c       **** 	cs_mreqPin_low;
 1935               		.loc 1 761 0
 1936 0590 9498      		cbi 0x12,4
 762:setup.c       **** 	GBA_PORT_ROM_DATA15_8 = 0; // Set data
 1937               		.loc 1 762 0
 1938 0592 1BBA      		out 0x1b,__zero_reg__
 763:setup.c       **** 	GBA_PORT_ROM_DATA7_0 = 0x56;
 1939               		.loc 1 763 0
 1940 0594 26E5      		ldi r18,lo8(86)
 1941 0596 28BB      		out 0x18,r18
 764:setup.c       **** 	wrPin_low;
 1942               		.loc 1 764 0
 1943 0598 9698      		cbi 0x12,6
 765:setup.c       **** 	asm volatile("nop");
 1944               		.loc 1 765 0
 1945               	/* #APP */
 1946               	 ;  765 "setup.c" 1
 1947 059a 0000      		nop
 1948               	 ;  0 "" 2
 766:setup.c       **** 	asm volatile("nop");
 1949               		.loc 1 766 0
 1950               	 ;  766 "setup.c" 1
 1951 059c 0000      		nop
 1952               	 ;  0 "" 2
 767:setup.c       **** 	asm volatile("nop");
 1953               		.loc 1 767 0
 1954               	 ;  767 "setup.c" 1
 1955 059e 0000      		nop
 1956               	 ;  0 "" 2
 768:setup.c       **** 	wrPin_high;
 1957               		.loc 1 768 0
 1958               	/* #NOAPP */
 1959 05a0 969A      		sbi 0x12,6
 769:setup.c       **** 	cs_mreqPin_high;
 1960               		.loc 1 769 0
 1961 05a2 949A      		sbi 0x12,4
 770:setup.c       **** 	
 771:setup.c       **** 	// 0x555, 0xA0;
 772:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = 0;
 1962               		.loc 1 772 0
 1963 05a4 15BA      		out 0x15,__zero_reg__
 773:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = 0x05;
 1964               		.loc 1 773 0
 1965 05a6 9BBB      		out 0x1b,r25
 774:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = 0x55;
 1966               		.loc 1 774 0
 1967 05a8 88BB      		out 0x18,r24
 775:setup.c       **** 	cs_mreqPin_low;
 1968               		.loc 1 775 0
 1969 05aa 9498      		cbi 0x12,4
 776:setup.c       **** 	GBA_PORT_ROM_DATA15_8 = 0; // Set data
 1970               		.loc 1 776 0
 1971 05ac 1BBA      		out 0x1b,__zero_reg__
 777:setup.c       **** 	GBA_PORT_ROM_DATA7_0 = 0xA0;
 1972               		.loc 1 777 0
 1973 05ae 80EA      		ldi r24,lo8(-96)
 1974 05b0 88BB      		out 0x18,r24
 778:setup.c       **** 	wrPin_low;
 1975               		.loc 1 778 0
 1976 05b2 9698      		cbi 0x12,6
 779:setup.c       **** 	asm volatile("nop");
 1977               		.loc 1 779 0
 1978               	/* #APP */
 1979               	 ;  779 "setup.c" 1
 1980 05b4 0000      		nop
 1981               	 ;  0 "" 2
 780:setup.c       **** 	asm volatile("nop");
 1982               		.loc 1 780 0
 1983               	 ;  780 "setup.c" 1
 1984 05b6 0000      		nop
 1985               	 ;  0 "" 2
 781:setup.c       **** 	asm volatile("nop");
 1986               		.loc 1 781 0
 1987               	 ;  781 "setup.c" 1
 1988 05b8 0000      		nop
 1989               	 ;  0 "" 2
 782:setup.c       **** 	wrPin_high;
 1990               		.loc 1 782 0
 1991               	/* #NOAPP */
 1992 05ba 969A      		sbi 0x12,6
 783:setup.c       **** 	cs_mreqPin_high;
 1993               		.loc 1 783 0
 1994 05bc 949A      		sbi 0x12,4
 1995 05be 0895      		ret
 1996               		.cfi_endproc
 1997               	.LFE41:
 1999               	.global	gba_flash_write_byte_swapped
 2001               	gba_flash_write_byte_swapped:
 2002               	.LFB42:
 784:setup.c       **** }	
 785:setup.c       **** 
 786:setup.c       **** 
 787:setup.c       **** // Write 2 bytes to the Flash address. Time to wait depends on Flash, we will query it to verify th
 788:setup.c       **** // Address is divided by 2 as we are in GBA mode. 
 789:setup.c       **** // Data byte's bit 0 & 1 are swapped for chip commands as D0 & D1 lines are swapped
 790:setup.c       **** void gba_flash_write_byte_swapped(uint32_t address, uint16_t data) {
 2003               		.loc 1 790 0
 2004               		.cfi_startproc
 2005               	.LVL154:
 2006 05c0 CF92      		push r12
 2007               	.LCFI36:
 2008               		.cfi_def_cfa_offset 3
 2009               		.cfi_offset 12, -2
 2010 05c2 DF92      		push r13
 2011               	.LCFI37:
 2012               		.cfi_def_cfa_offset 4
 2013               		.cfi_offset 13, -3
 2014 05c4 EF92      		push r14
 2015               	.LCFI38:
 2016               		.cfi_def_cfa_offset 5
 2017               		.cfi_offset 14, -4
 2018 05c6 FF92      		push r15
 2019               	.LCFI39:
 2020               		.cfi_def_cfa_offset 6
 2021               		.cfi_offset 15, -5
 2022 05c8 CF93      		push r28
 2023               	.LCFI40:
 2024               		.cfi_def_cfa_offset 7
 2025               		.cfi_offset 28, -6
 2026 05ca DF93      		push r29
 2027               	.LCFI41:
 2028               		.cfi_def_cfa_offset 8
 2029               		.cfi_offset 29, -7
 2030               	/* prologue: function */
 2031               	/* frame size = 0 */
 2032               	/* stack size = 6 */
 2033               	.L__stack_usage = 6
 2034 05cc 6B01      		movw r12,r22
 2035 05ce 7C01      		movw r14,r24
 2036 05d0 EA01      		movw r28,r20
 791:setup.c       **** 	gba_flash_write_cycle_start();
 2037               		.loc 1 791 0
 2038 05d2 00D0      		rcall gba_flash_write_cycle_start
 2039               	.LVL155:
 792:setup.c       **** 	gba_flash_write_bus_cycle(address, data);
 2040               		.loc 1 792 0
 2041 05d4 AE01      		movw r20,r28
 2042 05d6 C701      		movw r24,r14
 2043 05d8 B601      		movw r22,r12
 2044 05da 00D0      		rcall gba_flash_write_bus_cycle
 2045               	.LVL156:
 2046               	.LBB124:
 2047               	.LBB125:
 2048               		.loc 2 276 0
 2049 05dc 25E0      		ldi r18,lo8(5)
 2050 05de 2A95      	1:	dec r18
 2051 05e0 01F4      		brne 1b
 2052 05e2 0000      		nop
 2053               	.LVL157:
 2054               	.LBE125:
 2055               	.LBE124:
 793:setup.c       **** 	_delay_us(2); // Wait byte program time
 794:setup.c       **** 	
 795:setup.c       **** 	// Verify data
 796:setup.c       **** 	uint16_t dataVerify = gba_read_16bit_data(address);
 2056               		.loc 1 796 0
 2057 05e4 C701      		movw r24,r14
 2058 05e6 B601      		movw r22,r12
 2059 05e8 00D0      		rcall gba_read_16bit_data
 2060               	.LVL158:
 2061               	.L83:
 797:setup.c       **** 	while (data != dataVerify) {
 2062               		.loc 1 797 0
 2063 05ea 8C17      		cp r24,r28
 2064 05ec 9D07      		cpc r25,r29
 2065 05ee 01F0      		breq .L85
 798:setup.c       **** 		dataVerify = gba_read_16bit_data(address);
 2066               		.loc 1 798 0
 2067 05f0 C701      		movw r24,r14
 2068 05f2 B601      		movw r22,r12
 2069 05f4 00D0      		rcall gba_read_16bit_data
 2070               	.LVL159:
 2071               	.LBB126:
 2072               	.LBB127:
 2073               		.loc 2 276 0
 2074 05f6 25E0      		ldi r18,lo8(5)
 2075 05f8 2A95      	1:	dec r18
 2076 05fa 01F4      		brne 1b
 2077 05fc 0000      		nop
 2078 05fe 00C0      		rjmp .L83
 2079               	.LVL160:
 2080               	.L85:
 2081               	/* epilogue start */
 2082               	.LBE127:
 2083               	.LBE126:
 799:setup.c       **** 		_delay_us(2);
 800:setup.c       **** 	}
 801:setup.c       **** }
 2084               		.loc 1 801 0
 2085 0600 DF91      		pop r29
 2086 0602 CF91      		pop r28
 2087               	.LVL161:
 2088 0604 FF90      		pop r15
 2089 0606 EF90      		pop r14
 2090 0608 DF90      		pop r13
 2091 060a CF90      		pop r12
 2092               	.LVL162:
 2093 060c 0895      		ret
 2094               		.cfi_endproc
 2095               	.LFE42:
 2097               	.global	setup
 2099               	setup:
 2100               	.LFB43:
 802:setup.c       **** 
 803:setup.c       **** 
 804:setup.c       **** // Setup
 805:setup.c       **** void setup(void) {
 2101               		.loc 1 805 0
 2102               		.cfi_startproc
 2103               	/* prologue: function */
 2104               	/* frame size = 0 */
 2105               	/* stack size = 0 */
 2106               	.L__stack_usage = 0
 806:setup.c       **** 	// Turn off watchdog
 807:setup.c       **** 	MCUCSR &= ~(1<<WDRF);
 2107               		.loc 1 807 0
 2108 060e 84B7      		in r24,0x34
 2109 0610 877F      		andi r24,lo8(-9)
 2110 0612 84BF      		out 0x34,r24
 808:setup.c       **** 	WDTCR = (1<<WDCE) | (1<<WDE);
 2111               		.loc 1 808 0
 2112 0614 88E1      		ldi r24,lo8(24)
 2113 0616 81BD      		out 0x21,r24
 809:setup.c       **** 	WDTCR = 0;
 2114               		.loc 1 809 0
 2115 0618 11BC      		out 0x21,__zero_reg__
 810:setup.c       **** 	
 811:setup.c       **** 	// Reset common lines
 812:setup.c       **** 	rd_wr_csmreq_cs2_reset();
 2116               		.loc 1 812 0
 2117 061a 00D0      		rcall rd_wr_csmreq_cs2_reset
 2118               	.LVL163:
 813:setup.c       **** 	
 814:setup.c       **** 	// Set outputs
 815:setup.c       **** 	DDRD |= (1<<ACTIVITY_LED) | (1<<WR_PIN) | (1<<RD_PIN) | (1<<CS_MREQ_PIN) | (1<<LED_5V);
 2119               		.loc 1 815 0
 2120 061c 81B3      		in r24,0x11
 2121 061e 886F      		ori r24,lo8(-8)
 2122 0620 81BB      		out 0x11,r24
 816:setup.c       **** 	DDRE |= (1<<CS2_PIN) | (1<<LED_3V);
 2123               		.loc 1 816 0
 2124 0622 86B1      		in r24,0x6
 2125 0624 8560      		ori r24,lo8(5)
 2126 0626 86B9      		out 0x6,r24
 817:setup.c       **** 	
 818:setup.c       **** 	// Set all pins as inputs
 819:setup.c       **** 	PORT_DATA7_0 = 0;
 2127               		.loc 1 819 0
 2128 0628 15BA      		out 0x15,__zero_reg__
 820:setup.c       **** 	DDR_DATA7_0 = 0;
 2129               		.loc 1 820 0
 2130 062a 14BA      		out 0x14,__zero_reg__
 821:setup.c       **** 	PORT_ADDR7_0 = 0;
 2131               		.loc 1 821 0
 2132 062c 18BA      		out 0x18,__zero_reg__
 822:setup.c       **** 	DDR_ADDR7_0 = 0;
 2133               		.loc 1 822 0
 2134 062e 17BA      		out 0x17,__zero_reg__
 823:setup.c       **** 	PORT_ADDR15_8 = 0;
 2135               		.loc 1 823 0
 2136 0630 1BBA      		out 0x1b,__zero_reg__
 824:setup.c       **** 	DDR_ADDR15_8 = 0;
 2137               		.loc 1 824 0
 2138 0632 1ABA      		out 0x1a,__zero_reg__
 825:setup.c       **** 	
 826:setup.c       **** 	// Light up 3.3V or 5V
 827:setup.c       **** 	if (PIND & (1<<SWITCH_DETECT)) {
 2139               		.loc 1 827 0
 2140 0634 829B      		sbis 0x10,2
 2141 0636 00C0      		rjmp .L87
 828:setup.c       **** 		PORTD |= (1<<LED_5V);
 2142               		.loc 1 828 0
 2143 0638 979A      		sbi 0x12,7
 829:setup.c       **** 		PORTE &= ~(1<<LED_3V);
 2144               		.loc 1 829 0
 2145 063a 3898      		cbi 0x7,0
 830:setup.c       **** 		
 831:setup.c       **** 		// Set Reset low for 50ms to reset the cart (also for CPLD carts to initialise properly)
 832:setup.c       **** 		cs2Pin_low;
 2146               		.loc 1 832 0
 2147 063c 3A98      		cbi 0x7,2
 2148               	.LVL164:
 2149               	.LBB128:
 2150               	.LBB129:
 187:c:\winavr-20100110\avr\include\util\delay.h **** 
 2151               		.loc 2 187 0
 2152 063e 2FE7      		ldi r18,lo8(79999)
 2153 0640 88E3      		ldi r24,hi8(79999)
 2154 0642 91E0      		ldi r25,hlo8(79999)
 2155 0644 2150      	1:	subi r18,1
 2156 0646 8040      		sbci r24,0
 2157 0648 9040      		sbci r25,0
 2158 064a 01F4      		brne 1b
 2159 064c 00C0      		rjmp .
 2160 064e 0000      		nop
 2161               	.LVL165:
 2162               	.LBE129:
 2163               	.LBE128:
 833:setup.c       **** 		_delay_ms(50);
 834:setup.c       **** 		cs2Pin_high;
 2164               		.loc 1 834 0
 2165 0650 3A9A      		sbi 0x7,2
 2166 0652 00C0      		rjmp .L88
 2167               	.L87:
 835:setup.c       **** 	}
 836:setup.c       **** 	else {
 837:setup.c       **** 		PORTE |= (1<<LED_3V);
 2168               		.loc 1 837 0
 2169 0654 389A      		sbi 0x7,0
 838:setup.c       **** 		PORTD &= ~(1<<LED_5V);
 2170               		.loc 1 838 0
 2171 0656 9798      		cbi 0x12,7
 2172               	.L88:
 839:setup.c       **** 	}
 840:setup.c       **** 	
 841:setup.c       **** 	// Light LED
 842:setup.c       **** 	PORTD |= (1<<ACTIVITY_LED);
 2173               		.loc 1 842 0
 2174 0658 939A      		sbi 0x12,3
 2175               	.LVL166:
 2176               	.LBB130:
 2177               	.LBB131:
 187:c:\winavr-20100110\avr\include\util\delay.h **** 
 2178               		.loc 2 187 0
 2179 065a 2FEF      		ldi r18,lo8(799999)
 2180 065c 84E3      		ldi r24,hi8(799999)
 2181 065e 9CE0      		ldi r25,hlo8(799999)
 2182 0660 2150      	1:	subi r18,1
 2183 0662 8040      		sbci r24,0
 2184 0664 9040      		sbci r25,0
 2185 0666 01F4      		brne 1b
 2186 0668 00C0      		rjmp .
 2187 066a 0000      		nop
 2188               	.LVL167:
 2189               	.LBE131:
 2190               	.LBE130:
 843:setup.c       **** 	_delay_ms(500);
 844:setup.c       **** 	PORTD &= ~(1<<ACTIVITY_LED);
 2191               		.loc 1 844 0
 2192 066c 9398      		cbi 0x12,3
 845:setup.c       **** 	
 846:setup.c       **** 	// Setup USART
 847:setup.c       **** 	UBRRL = 0; // 1Mbps Baud rate
 2193               		.loc 1 847 0
 2194 066e 19B8      		out 0x9,__zero_reg__
 848:setup.c       **** 	sbi(UCSRA, U2X); // Double rate
 2195               		.loc 1 848 0
 2196 0670 599A      		sbi 0xb,1
 849:setup.c       **** 	sbi(UCSRB, TXEN); // Transmitter enable
 2197               		.loc 1 849 0
 2198 0672 539A      		sbi 0xa,3
 850:setup.c       **** 	sbi(UCSRB, RXEN); // Receiver enable
 2199               		.loc 1 850 0
 2200 0674 549A      		sbi 0xa,4
 851:setup.c       **** 	
 852:setup.c       **** 	// Turn on interrupts
 853:setup.c       **** 	sei();
 2201               		.loc 1 853 0
 2202               	/* #APP */
 2203               	 ;  853 "setup.c" 1
 2204 0676 7894      		sei
 2205               	 ;  0 "" 2
 2206               	/* #NOAPP */
 2207 0678 0895      		ret
 2208               		.cfi_endproc
 2209               	.LFE43:
 2211               		.section	.text.startup,"ax",@progbits
 2212               	.global	main
 2214               	main:
 2215               	.LFB44:
 2216               		.file 3 "main.c"
   1:main.c        **** /*
   2:main.c        ****  GBxCart RW
   3:main.c        ****  PCB version: 1.1 or 1.2
   4:main.c        ****  Firmware version: R11
   5:main.c        ****  Author: Alex from insideGadgets (www.insidegadgets.com)
   6:main.c        ****  Created: 7/11/2016
   7:main.c        ****  Last Modified: 14/09/2018
   8:main.c        ****  
   9:main.c        ****  GBxCart RW allows you to dump your Gameboy/Gameboy Colour/Gameboy Advance games ROM, save the RAM,
  10:main.c        ****  write to certain Gameboy/Gameboy Advance flash carts.
  11:main.c        ****  
  12:main.c        ****  The ATmega8515L talks to the cartridge and interfaces with the CH340G serial to USB converter with
  13:main.c        ****  
  14:main.c        ****  
  15:main.c        ****  Set fuse bits: External 8MHz crystal, divide clock by 8 is off, boot loader is on (512 bytes), BOD
  16:main.c        ****  avrdude -p atmega8515 -c usbasp -U lfuse:w:0xaf:m -U hfuse:w:0xda:m
  17:main.c        ****  
  18:main.c        ****  Program the TinySafeBoot boot loader (modified ASM code, watchdog reset will act as a hardware res
  19:main.c        ****  avrdude -p atmega8515 -c usbasp -U flash:w:GBxCart_RW_v1.1_Rx\tsb\tsb_m8515_d0d1_resetwdt.hex
  20:main.c        ****  
  21:main.c        ****  Program GBxCart RW through TinySafeBoot
  22:main.c        ****  tsb com16:57600 fw GBxCart_RW_v1.1_Rx\main.hex
  23:main.c        ****  
  24:main.c        ****  Set TinySafeBoot delay time to 25 (T 25), gives ~0.5s in bootloader
  25:main.c        ****  tsb com16:9600 T 25
  26:main.c        ****  
  27:main.c        ****  
  28:main.c        ****  Programming shortcuts (if added in Programmers Notepad):
  29:main.c        ****  Alt + W - Program fuse
  30:main.c        ****  Alt + B - Burn bootloader
  31:main.c        ****  
  32:main.c        ****  Plug in USB then
  33:main.c        ****  Alt + T - Program
  34:main.c        ****  Alt + N - Program delay settings
  35:main.c        ****  
  36:main.c        ****  
  37:main.c        ****  */
  38:main.c        **** 
  39:main.c        **** // ATmega8515L Pin Map
  40:main.c        **** //
  41:main.c        **** // VCC (5)			GND (6)			XTAL (7 ,8)		Activity LED PD3 (9)				Switch sense PD2 (8)
  42:main.c        **** // SCK PB7 (3)		MOSI PB5 (1)	MISO PB6 (2)	RST (4)		RXD PD0 (5)			TXD PD1 (7)
  43:main.c        **** // 
  44:main.c        **** // Gameboy / Gameboy Colour
  45:main.c        **** // A0-A7 PB0-7 (40-44, 1-3) 		A8-A15 PA0-7 (37-30)			D0-D7 PC0-7 (18-25)		Audio PE1 (27)
  46:main.c        **** // 
  47:main.c        **** // Gameboy Advance
  48:main.c        **** // AD0-AD7 PB0-7 (40-44, 1-3) 	AD8-AD15 PA0-7 (37-30)		A16-23 / D0-D7 PC0-7 (19-26)
  49:main.c        **** // *WR PD6 (13)						*RD PD5 (14)					*MREQ/CS PD4 (15)			CS2/RST PE2 (16)
  50:main.c        **** 
  51:main.c        **** #define F_CPU 8000000 // 8 MHz
  52:main.c        **** #define PCB_VERSION 2
  53:main.c        **** #define FIRMWARE_VERSION 11
  54:main.c        **** 
  55:main.c        **** #include <avr/io.h>
  56:main.c        **** #include <avr/wdt.h>
  57:main.c        **** #include <avr/eeprom.h>
  58:main.c        **** #include <avr/interrupt.h>
  59:main.c        **** #include <avr/sleep.h>
  60:main.c        **** #include <util/delay.h>
  61:main.c        **** #include <stdlib.h>
  62:main.c        **** #include <string.h>
  63:main.c        **** #include "setup.c" // See defines, variables, constants, functions here
  64:main.c        **** 
  65:main.c        **** 
  66:main.c        **** int main(void) {
 2217               		.loc 3 66 0
 2218               		.cfi_startproc
 2219 0000 CF93      		push r28
 2220               	.LCFI42:
 2221               		.cfi_def_cfa_offset 3
 2222               		.cfi_offset 28, -2
 2223 0002 DF93      		push r29
 2224               	.LCFI43:
 2225               		.cfi_def_cfa_offset 4
 2226               		.cfi_offset 29, -3
 2227 0004 00D0      		rcall .
 2228 0006 00D0      		rcall .
 2229               	.LCFI44:
 2230               		.cfi_def_cfa_offset 8
 2231 0008 CDB7      		in r28,__SP_L__
 2232 000a DEB7      		in r29,__SP_H__
 2233               	.LCFI45:
 2234               		.cfi_def_cfa_register 28
 2235               	/* prologue: function */
 2236               	/* frame size = 4 */
 2237               	/* stack size = 6 */
 2238               	.L__stack_usage = 6
  67:main.c        **** 	setup();
 2239               		.loc 3 67 0
 2240 000c 00D0      		rcall setup
 2241               	.LVL168:
  68:main.c        **** 	
  69:main.c        **** 	uint32_t address = 0;
  70:main.c        **** 	uint8_t eepromSize = EEPROM_4KBIT;
  71:main.c        **** 	uint8_t cartMode = GB_MODE;
  72:main.c        **** 	uint8_t resetCommonLines = 1;
 2242               		.loc 3 72 0
 2243 000e 21E0      		ldi r18,lo8(1)
 2244 0010 2983      		std Y+1,r18
  70:main.c        **** 	uint8_t cartMode = GB_MODE;
 2245               		.loc 3 70 0
 2246 0012 01E0      		ldi r16,lo8(1)
  69:main.c        **** 	uint8_t eepromSize = EEPROM_4KBIT;
 2247               		.loc 3 69 0
 2248 0014 C12C      		mov r12,__zero_reg__
 2249 0016 D12C      		mov r13,__zero_reg__
 2250 0018 7601      		movw r14,r12
 2251               	.LBB132:
  73:main.c        **** 	
  74:main.c        **** 	while(1) {
  75:main.c        **** 		if (resetCommonLines == 1) {
  76:main.c        **** 			rd_wr_csmreq_cs2_reset();
  77:main.c        **** 		}
  78:main.c        **** 		receivedChar = USART_Receive(); // Wait for 1 byte of data
  79:main.c        **** 		
  80:main.c        **** 		// Read the pin to find out which mode we are in, if it reads high, we are powered by 5V
  81:main.c        **** 		if (PIND & (1<<SWITCH_DETECT)) {
  82:main.c        **** 			cartMode = GB_MODE;
  83:main.c        **** 			PORTD |= (1<<LED_5V);
  84:main.c        **** 			PORTE &= ~(1<<LED_3V);
  85:main.c        **** 		}
  86:main.c        **** 		else {
  87:main.c        **** 			cartMode = GBA_MODE;
  88:main.c        **** 			PORTE |= (1<<LED_3V);
  89:main.c        **** 			PORTD &= ~(1<<LED_5V);
  90:main.c        **** 		}
  91:main.c        **** 		
  92:main.c        **** 		// Return the cart mode in use
  93:main.c        **** 		if (receivedChar == CART_MODE) {
  94:main.c        **** 			USART_Transmit(cartMode);
  95:main.c        **** 		}
  96:main.c        **** 		
  97:main.c        **** 		// Change to GB mode or GBA mode if requested
  98:main.c        **** 		else if (receivedChar == GB_CART_MODE) {
  99:main.c        **** 			gb_mode();
 100:main.c        **** 		}
 101:main.c        **** 		else if (receivedChar == GBA_CART_MODE) {
 102:main.c        **** 			gba_mode();
 103:main.c        **** 		}
 104:main.c        **** 		
 105:main.c        **** 		// Set address
 106:main.c        **** 		else if (receivedChar == SET_START_ADDRESS) {
 107:main.c        **** 			usart_read_chars(); // Read start address
 108:main.c        **** 			address = strtol(receivedBuffer, NULL, 16); // Convert address string in hex to dec
 109:main.c        **** 		}
 110:main.c        **** 		
 111:main.c        **** 		
 112:main.c        **** 		// ****** Gameboy / Gameboy Colour ******
 113:main.c        **** 		
 114:main.c        **** 		// Read 64 bytes of ROM/RAM from address (and increment) until anything but 1 is received
 115:main.c        **** 		else if (receivedChar == READ_ROM_RAM) {
 116:main.c        **** 			gb_mode();
 117:main.c        **** 			receivedChar = '1';
 118:main.c        **** 			while (receivedChar == '1') {
 119:main.c        **** 				PORTD |= (1<<ACTIVITY_LED);
 120:main.c        **** 				for (uint8_t x = 0; x < 64; x++) {
 121:main.c        **** 					USART_Transmit(read_8bit_data(address));
 122:main.c        **** 					address++;
 123:main.c        **** 				}
 124:main.c        **** 				
 125:main.c        **** 				PORTD &= ~(1<<ACTIVITY_LED);
 126:main.c        **** 				receivedChar = USART_Receive();
 127:main.c        **** 			}
 128:main.c        **** 		}
 129:main.c        **** 		
 130:main.c        **** 		// Write 64 bytes to RAM on address (and increment)
 131:main.c        **** 		else if (receivedChar == WRITE_RAM) {
 132:main.c        **** 			gb_mode();
 133:main.c        **** 			
 134:main.c        **** 			// Read 64 bytes first as CH340G sends them all at once
 135:main.c        **** 			usart_read_bytes(64);
 136:main.c        **** 			
 137:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 138:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 139:main.c        **** 				write_8bit_data(address, receivedBuffer[x], MEMORY_WRITE);
 140:main.c        **** 				address++;
 141:main.c        **** 			}
 142:main.c        **** 			
 143:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 144:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 145:main.c        **** 		}
 146:main.c        **** 		
 147:main.c        **** 		// Set bank address and write a byte
 148:main.c        **** 		else if (receivedChar == SET_BANK) {
 149:main.c        **** 			gb_mode();
 150:main.c        **** 			
 151:main.c        **** 			usart_read_chars(); // Read start address
 152:main.c        **** 			uint16_t bankaddress = strtol(receivedBuffer, NULL, 16); // Convert address string in hex to dec
 153:main.c        **** 			
 154:main.c        **** 			receivedChar = USART_Receive(); // Wait for bank number
 155:main.c        **** 			if (receivedChar == 'B') {
 156:main.c        **** 				usart_read_chars(); // Read data
 157:main.c        **** 				uint8_t data = atoi(receivedBuffer); // Convert data string to dec
 158:main.c        **** 				lastBankAccessed = data; // Store the last bank accessed (used for flash carts that need it)
 159:main.c        **** 				
 160:main.c        **** 				write_8bit_data(bankaddress, data, BANK_WRITE);
 161:main.c        **** 			}
 162:main.c        **** 		}
 163:main.c        **** 		
 164:main.c        **** 		
 165:main.c        **** 		// ****** Gameboy Advance ******
 166:main.c        **** 		
 167:main.c        **** 		// ---------- ROM ----------
 168:main.c        **** 		// Read one 16bit byte from ROM using address (and increment) until anything but 1 is received
 169:main.c        **** 		else if (receivedChar == GBA_READ_ROM || receivedChar == GBA_READ_ROM_256BYTE) {
 170:main.c        **** 			gba_mode();
 171:main.c        **** 			
 172:main.c        **** 			uint8_t readEnd = 32;
 173:main.c        **** 			if (receivedChar == GBA_READ_ROM_256BYTE) {
 174:main.c        **** 				readEnd = 128;
 175:main.c        **** 			}
 176:main.c        **** 			
 177:main.c        **** 			receivedChar = '1';
 2252               		.loc 3 177 0
 2253 001a 11E3      		ldi r17,lo8(49)
 2254 001c E0E0      		ldi r30,lo8(eepromBuffer+8)
 2255 001e 6E2E      		mov r6,r30
 2256 0020 E0E0      		ldi r30,hi8(eepromBuffer+8)
 2257 0022 7E2E      		mov r7,r30
 2258               	.LVL169:
 2259               	.L90:
 2260               	.LBE132:
  75:main.c        **** 			rd_wr_csmreq_cs2_reset();
 2261               		.loc 3 75 0
 2262 0024 8981      		ldd r24,Y+1
 2263 0026 8130      		cpi r24,lo8(1)
 2264 0028 01F4      		brne .L91
 2265               	.LVL170:
 2266               	.L214:
  76:main.c        **** 		}
 2267               		.loc 3 76 0
 2268 002a 00D0      		rcall rd_wr_csmreq_cs2_reset
 2269               	.LVL171:
 2270               	.L91:
  78:main.c        **** 		
 2271               		.loc 3 78 0
 2272 002c 00D0      		rcall USART_Receive
 2273               	.LVL172:
 2274 002e 8093 0000 		sts receivedChar,r24
  81:main.c        **** 			cartMode = GB_MODE;
 2275               		.loc 3 81 0
 2276 0032 829B      		sbis 0x10,2
 2277 0034 00C0      		rjmp .L92
 2278               	.LVL173:
  83:main.c        **** 			PORTE &= ~(1<<LED_3V);
 2279               		.loc 3 83 0
 2280 0036 979A      		sbi 0x12,7
  84:main.c        **** 		}
 2281               		.loc 3 84 0
 2282 0038 3898      		cbi 0x7,0
  82:main.c        **** 			PORTD |= (1<<LED_5V);
 2283               		.loc 3 82 0
 2284 003a 81E0      		ldi r24,lo8(1)
 2285 003c 00C0      		rjmp .L93
 2286               	.LVL174:
 2287               	.L92:
  88:main.c        **** 			PORTD &= ~(1<<LED_5V);
 2288               		.loc 3 88 0
 2289 003e 389A      		sbi 0x7,0
  89:main.c        **** 		}
 2290               		.loc 3 89 0
 2291 0040 9798      		cbi 0x12,7
  87:main.c        **** 			PORTE |= (1<<LED_3V);
 2292               		.loc 3 87 0
 2293 0042 82E0      		ldi r24,lo8(2)
 2294               	.LVL175:
 2295               	.L93:
  93:main.c        **** 			USART_Transmit(cartMode);
 2296               		.loc 3 93 0
 2297 0044 9091 0000 		lds r25,receivedChar
 2298 0048 9334      		cpi r25,lo8(67)
 2299 004a 01F4      		brne .+2
 2300 004c 00C0      		rjmp .L215
  98:main.c        **** 			gb_mode();
 2301               		.loc 3 98 0
 2302 004e 9734      		cpi r25,lo8(71)
 2303 0050 01F4      		brne .L96
  99:main.c        **** 		}
 2304               		.loc 3 99 0
 2305 0052 00D0      		rcall gb_mode
 2306               	.LVL176:
 2307 0054 00C0      		rjmp .L90
 2308               	.LVL177:
 2309               	.L96:
 101:main.c        **** 			gba_mode();
 2310               		.loc 3 101 0
 2311 0056 9736      		cpi r25,lo8(103)
 2312 0058 01F4      		brne .+2
 2313 005a 00C0      		rjmp .L217
 106:main.c        **** 			usart_read_chars(); // Read start address
 2314               		.loc 3 106 0
 2315 005c 9134      		cpi r25,lo8(65)
 2316 005e 01F4      		brne .L98
 107:main.c        **** 			address = strtol(receivedBuffer, NULL, 16); // Convert address string in hex to dec
 2317               		.loc 3 107 0
 2318 0060 00D0      		rcall usart_read_chars
 2319               	.LVL178:
 108:main.c        **** 		}
 2320               		.loc 3 108 0
 2321 0062 40E1      		ldi r20,lo8(16)
 2322 0064 50E0      		ldi r21,0
 2323 0066 60E0      		ldi r22,0
 2324 0068 70E0      		ldi r23,0
 2325 006a 80E0      		ldi r24,lo8(receivedBuffer)
 2326 006c 90E0      		ldi r25,hi8(receivedBuffer)
 2327 006e 00D0      		rcall strtol
 2328               	.LVL179:
 2329 0070 6B01      		movw r12,r22
 2330 0072 7C01      		movw r14,r24
 2331               	.LVL180:
 2332 0074 00C0      		rjmp .L90
 2333               	.LVL181:
 2334               	.L98:
 115:main.c        **** 			gb_mode();
 2335               		.loc 3 115 0
 2336 0076 9235      		cpi r25,lo8(82)
 2337 0078 01F4      		brne .L99
 116:main.c        **** 			receivedChar = '1';
 2338               		.loc 3 116 0
 2339 007a 00D0      		rcall gb_mode
 2340               	.LVL182:
 117:main.c        **** 			while (receivedChar == '1') {
 2341               		.loc 3 117 0
 2342 007c 1093 0000 		sts receivedChar,r17
 2343               	.LVL183:
 2344               	.L100:
 118:main.c        **** 				PORTD |= (1<<ACTIVITY_LED);
 2345               		.loc 3 118 0
 2346 0080 8091 0000 		lds r24,receivedChar
 2347 0084 8133      		cpi r24,lo8(49)
 2348 0086 01F4      		brne .L90
 119:main.c        **** 				for (uint8_t x = 0; x < 64; x++) {
 2349               		.loc 3 119 0
 2350 0088 939A      		sbi 0x12,3
 2351               	.LVL184:
 2352 008a 1C82      		std Y+4,__zero_reg__
 2353 008c 1B82      		std Y+3,__zero_reg__
 2354               	.LVL185:
 2355               	.L101:
 2356               	.LBB135:
 121:main.c        **** 					address++;
 2357               		.loc 3 121 0 discriminator 3
 2358 008e 8B81      		ldd r24,Y+3
 2359 0090 9C81      		ldd r25,Y+4
 2360 0092 8C0D      		add r24,r12
 2361 0094 9D1D      		adc r25,r13
 2362 0096 00D0      		rcall read_8bit_data
 2363               	.LVL186:
 2364 0098 00D0      		rcall USART_Transmit
 2365               	.LVL187:
 2366 009a EB81      		ldd r30,Y+3
 2367 009c FC81      		ldd r31,Y+4
 2368 009e 3196      		adiw r30,1
 2369 00a0 FC83      		std Y+4,r31
 2370 00a2 EB83      		std Y+3,r30
 2371               	.LVL188:
 120:main.c        **** 					USART_Transmit(read_8bit_data(address));
 2372               		.loc 3 120 0 discriminator 3
 2373 00a4 E034      		cpi r30,64
 2374 00a6 F105      		cpc r31,__zero_reg__
 2375 00a8 01F4      		brne .L101
 2376 00aa F0E4      		ldi r31,64
 2377 00ac CF0E      		add r12,r31
 2378 00ae D11C      		adc r13,__zero_reg__
 2379 00b0 E11C      		adc r14,__zero_reg__
 2380 00b2 F11C      		adc r15,__zero_reg__
 2381               	.LBE135:
 125:main.c        **** 				receivedChar = USART_Receive();
 2382               		.loc 3 125 0
 2383 00b4 9398      		cbi 0x12,3
 126:main.c        **** 			}
 2384               		.loc 3 126 0
 2385 00b6 00D0      		rcall USART_Receive
 2386               	.LVL189:
 2387 00b8 8093 0000 		sts receivedChar,r24
 2388 00bc 00C0      		rjmp .L100
 2389               	.LVL190:
 2390               	.L99:
 131:main.c        **** 			gb_mode();
 2391               		.loc 3 131 0
 2392 00be 9735      		cpi r25,lo8(87)
 2393 00c0 01F4      		brne .L103
 132:main.c        **** 			
 2394               		.loc 3 132 0
 2395 00c2 00D0      		rcall gb_mode
 2396               	.LVL191:
 135:main.c        **** 			
 2397               		.loc 3 135 0
 2398 00c4 80E4      		ldi r24,lo8(64)
 2399 00c6 90E0      		ldi r25,0
 2400 00c8 00D0      		rcall usart_read_bytes
 2401               	.LVL192:
 137:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 2402               		.loc 3 137 0
 2403 00ca 939A      		sbi 0x12,3
 2404               	.LVL193:
 2405 00cc 70E0      		ldi r23,lo8(receivedBuffer)
 2406 00ce A72E      		mov r10,r23
 2407 00d0 70E0      		ldi r23,hi8(receivedBuffer)
 2408 00d2 B72E      		mov r11,r23
 2409 00d4 1C82      		std Y+4,__zero_reg__
 2410 00d6 1B82      		std Y+3,__zero_reg__
 2411               	.LVL194:
 2412               	.L104:
 2413               	.LBB136:
 139:main.c        **** 				address++;
 2414               		.loc 3 139 0 discriminator 3
 2415 00d8 F501      		movw r30,r10
 2416 00da 6191      		ld r22,Z+
 2417 00dc 5F01      		movw r10,r30
 2418 00de 8B81      		ldd r24,Y+3
 2419 00e0 9C81      		ldd r25,Y+4
 2420 00e2 8C0D      		add r24,r12
 2421 00e4 9D1D      		adc r25,r13
 2422 00e6 41E0      		ldi r20,lo8(1)
 2423 00e8 00D0      		rcall write_8bit_data
 2424               	.LVL195:
 2425 00ea 2B81      		ldd r18,Y+3
 2426 00ec 3C81      		ldd r19,Y+4
 2427 00ee 2F5F      		subi r18,-1
 2428 00f0 3F4F      		sbci r19,-1
 2429 00f2 3C83      		std Y+4,r19
 2430 00f4 2B83      		std Y+3,r18
 2431               	.LVL196:
 138:main.c        **** 				write_8bit_data(address, receivedBuffer[x], MEMORY_WRITE);
 2432               		.loc 3 138 0 discriminator 3
 2433 00f6 2034      		cpi r18,64
 2434 00f8 3105      		cpc r19,__zero_reg__
 2435 00fa 01F4      		brne .L104
 2436 00fc 30E4      		ldi r19,64
 2437 00fe C30E      		add r12,r19
 2438 0100 D11C      		adc r13,__zero_reg__
 2439 0102 E11C      		adc r14,__zero_reg__
 2440 0104 F11C      		adc r15,__zero_reg__
 2441 0106 00C0      		rjmp .L234
 2442               	.LVL197:
 2443               	.L103:
 2444               	.LBE136:
 148:main.c        **** 			gb_mode();
 2445               		.loc 3 148 0
 2446 0108 9234      		cpi r25,lo8(66)
 2447 010a 01F4      		brne .L105
 2448               	.LBB137:
 149:main.c        **** 			
 2449               		.loc 3 149 0
 2450 010c 00D0      		rcall gb_mode
 2451               	.LVL198:
 151:main.c        **** 			uint16_t bankaddress = strtol(receivedBuffer, NULL, 16); // Convert address string in hex to dec
 2452               		.loc 3 151 0
 2453 010e 00D0      		rcall usart_read_chars
 2454               	.LVL199:
 152:main.c        **** 			
 2455               		.loc 3 152 0
 2456 0110 40E1      		ldi r20,lo8(16)
 2457 0112 50E0      		ldi r21,0
 2458 0114 60E0      		ldi r22,0
 2459 0116 70E0      		ldi r23,0
 2460 0118 80E0      		ldi r24,lo8(receivedBuffer)
 2461 011a 90E0      		ldi r25,hi8(receivedBuffer)
 2462 011c 00D0      		rcall strtol
 2463               	.LVL200:
 2464 011e 4B01      		movw r8,r22
 2465 0120 5C01      		movw r10,r24
 2466               	.LVL201:
 154:main.c        **** 			if (receivedChar == 'B') {
 2467               		.loc 3 154 0
 2468 0122 00D0      		rcall USART_Receive
 2469               	.LVL202:
 2470 0124 8093 0000 		sts receivedChar,r24
 155:main.c        **** 				usart_read_chars(); // Read data
 2471               		.loc 3 155 0
 2472 0128 8234      		cpi r24,lo8(66)
 2473 012a 01F0      		breq .+2
 2474 012c 00C0      		rjmp .L90
 2475               	.LBB138:
 156:main.c        **** 				uint8_t data = atoi(receivedBuffer); // Convert data string to dec
 2476               		.loc 3 156 0
 2477 012e 00D0      		rcall usart_read_chars
 2478               	.LVL203:
 157:main.c        **** 				lastBankAccessed = data; // Store the last bank accessed (used for flash carts that need it)
 2479               		.loc 3 157 0
 2480 0130 80E0      		ldi r24,lo8(receivedBuffer)
 2481 0132 90E0      		ldi r25,hi8(receivedBuffer)
 2482 0134 00D0      		rcall atoi
 2483               	.LVL204:
 158:main.c        **** 				
 2484               		.loc 3 158 0
 2485 0136 8093 0000 		sts lastBankAccessed,r24
 160:main.c        **** 			}
 2486               		.loc 3 160 0
 2487 013a 40E0      		ldi r20,0
 2488 013c 682F      		mov r22,r24
 2489 013e C401      		movw r24,r8
 2490               	.LVL205:
 2491 0140 00D0      		rcall write_8bit_data
 2492               	.LVL206:
 2493 0142 00C0      		rjmp .L90
 2494               	.LVL207:
 2495               	.L105:
 2496               	.LBE138:
 2497               	.LBE137:
 169:main.c        **** 			gba_mode();
 2498               		.loc 3 169 0
 2499 0144 9237      		cpi r25,lo8(114)
 2500 0146 01F0      		breq .L106
 169:main.c        **** 			gba_mode();
 2501               		.loc 3 169 0 is_stmt 0 discriminator 1
 2502 0148 9A36      		cpi r25,lo8(106)
 2503 014a 01F4      		brne .L107
 2504               	.L106:
 2505               	.LBB139:
 170:main.c        **** 			
 2506               		.loc 3 170 0 is_stmt 1
 2507 014c 00D0      		rcall gba_mode
 2508               	.LVL208:
 173:main.c        **** 				readEnd = 128;
 2509               		.loc 3 173 0
 2510 014e 8091 0000 		lds r24,receivedChar
 2511 0152 8A36      		cpi r24,lo8(106)
 2512 0154 01F4      		brne .L189
 174:main.c        **** 			}
 2513               		.loc 3 174 0
 2514 0156 80E8      		ldi r24,lo8(-128)
 2515 0158 8A83      		std Y+2,r24
 2516 015a 00C0      		rjmp .L108
 2517               	.L189:
 172:main.c        **** 			if (receivedChar == GBA_READ_ROM_256BYTE) {
 2518               		.loc 3 172 0
 2519 015c 90E2      		ldi r25,lo8(32)
 2520 015e 9A83      		std Y+2,r25
 2521               	.L108:
 2522               	.LVL209:
 2523               		.loc 3 177 0
 2524 0160 1093 0000 		sts receivedChar,r17
 2525 0164 8A80      		ldd r8,Y+2
 2526 0166 8A94      		dec r8
 2527 0168 912C      		mov r9,__zero_reg__
 2528 016a A12C      		mov r10,__zero_reg__
 2529 016c B12C      		mov r11,__zero_reg__
 2530 016e EFEF      		ldi r30,-1
 2531 0170 8E1A      		sub r8,r30
 2532 0172 9E0A      		sbc r9,r30
 2533 0174 AE0A      		sbc r10,r30
 2534 0176 BE0A      		sbc r11,r30
 2535               	.LVL210:
 2536               	.L109:
 178:main.c        **** 			while (receivedChar == '1') {
 2537               		.loc 3 178 0
 2538 0178 8091 0000 		lds r24,receivedChar
 2539 017c 8133      		cpi r24,lo8(49)
 2540 017e 01F0      		breq .+2
 2541 0180 00C0      		rjmp .L90
 179:main.c        **** 				PORTD |= (1<<ACTIVITY_LED);
 2542               		.loc 3 179 0
 2543 0182 939A      		sbi 0x12,3
 2544               	.LVL211:
 2545 0184 1601      		movw r2,r12
 2546 0186 2701      		movw r4,r14
 2547               	.LVL212:
 2548               	.L110:
 2549               	.LBB133:
 2550               	.LBB134:
 180:main.c        **** 				
 181:main.c        **** 				for (uint8_t x = 0; x < readEnd; x++) {
 182:main.c        **** 					uint16_t dataRead = gba_read_16bit_data(address);
 2551               		.loc 3 182 0 discriminator 3
 2552 0188 C201      		movw r24,r4
 2553 018a B101      		movw r22,r2
 2554 018c 00D0      		rcall gba_read_16bit_data
 2555               	.LVL213:
 2556 018e 9B83      		std Y+3,r25
 2557               	.LVL214:
 183:main.c        **** 					
 184:main.c        **** 					// Low byte & High byte
 185:main.c        **** 					USART_Transmit(dataRead & 0xFF);
 2558               		.loc 3 185 0 discriminator 3
 2559 0190 00D0      		rcall USART_Transmit
 2560               	.LVL215:
 186:main.c        **** 					USART_Transmit(dataRead >> 8);
 2561               		.loc 3 186 0 discriminator 3
 2562 0192 8B81      		ldd r24,Y+3
 2563 0194 00D0      		rcall USART_Transmit
 2564               	.LVL216:
 187:main.c        **** 					
 188:main.c        **** 					address++;
 2565               		.loc 3 188 0 discriminator 3
 2566 0196 FFEF      		ldi r31,-1
 2567 0198 2F1A      		sub r2,r31
 2568 019a 3F0A      		sbc r3,r31
 2569 019c 4F0A      		sbc r4,r31
 2570 019e 5F0A      		sbc r5,r31
 2571               	.LVL217:
 2572               	.LBE134:
 181:main.c        **** 					uint16_t dataRead = gba_read_16bit_data(address);
 2573               		.loc 3 181 0 discriminator 3
 2574 01a0 822D      		mov r24,r2
 2575 01a2 8C19      		sub r24,r12
 2576 01a4 2A81      		ldd r18,Y+2
 2577 01a6 8217      		cp r24,r18
 2578 01a8 00F0      		brlo .L110
 2579 01aa C80C      		add r12,r8
 2580 01ac D91C      		adc r13,r9
 2581 01ae EA1C      		adc r14,r10
 2582 01b0 FB1C      		adc r15,r11
 2583               	.LVL218:
 2584               	.LBE133:
 189:main.c        **** 				}
 190:main.c        **** 				
 191:main.c        **** 				PORTD &= ~(1<<ACTIVITY_LED);
 2585               		.loc 3 191 0
 2586 01b2 9398      		cbi 0x12,3
 192:main.c        **** 				receivedChar = USART_Receive();
 2587               		.loc 3 192 0
 2588 01b4 00D0      		rcall USART_Receive
 2589               	.LVL219:
 2590 01b6 8093 0000 		sts receivedChar,r24
 2591 01ba 00C0      		rjmp .L109
 2592               	.LVL220:
 2593               	.L107:
 2594               	.LBE139:
 193:main.c        **** 			}
 194:main.c        **** 		}
 195:main.c        **** 		
 196:main.c        **** 		// ---------- SRAM ----------
 197:main.c        **** 		// Read RAM from address (and increment) until anything but 1 is received
 198:main.c        **** 		else if (receivedChar == GBA_READ_SRAM) {
 2595               		.loc 3 198 0
 2596 01bc 9D36      		cpi r25,lo8(109)
 2597 01be 01F4      		brne .L112
 199:main.c        **** 			gb_mode(); // Set GB mode as it uses 16 bit address with 8 bit data
 2598               		.loc 3 199 0
 2599 01c0 00D0      		rcall gb_mode
 2600               	.LVL221:
 200:main.c        **** 			
 201:main.c        **** 			receivedChar = '1';
 2601               		.loc 3 201 0
 2602 01c2 1093 0000 		sts receivedChar,r17
 2603               	.LVL222:
 2604               	.L113:
 202:main.c        **** 			while (receivedChar == '1') {
 2605               		.loc 3 202 0
 2606 01c6 8091 0000 		lds r24,receivedChar
 2607 01ca 8133      		cpi r24,lo8(49)
 2608 01cc 01F0      		breq .+2
 2609 01ce 00C0      		rjmp .L217
 203:main.c        **** 				PORTD |= (1<<ACTIVITY_LED);
 2610               		.loc 3 203 0
 2611 01d0 939A      		sbi 0x12,3
 2612               	.LVL223:
 2613 01d2 1C82      		std Y+4,__zero_reg__
 2614 01d4 1B82      		std Y+3,__zero_reg__
 2615               	.LVL224:
 2616               	.L114:
 2617               	.LBB140:
 204:main.c        **** 				for (uint8_t x = 0; x < 64; x++) {
 205:main.c        **** 					USART_Transmit(gba_read_ram_8bit_data(address));
 2618               		.loc 3 205 0 discriminator 3
 2619 01d6 8B81      		ldd r24,Y+3
 2620 01d8 9C81      		ldd r25,Y+4
 2621 01da 8C0D      		add r24,r12
 2622 01dc 9D1D      		adc r25,r13
 2623 01de 00D0      		rcall gba_read_ram_8bit_data
 2624               	.LVL225:
 2625 01e0 00D0      		rcall USART_Transmit
 2626               	.LVL226:
 2627 01e2 8B81      		ldd r24,Y+3
 2628 01e4 9C81      		ldd r25,Y+4
 2629 01e6 0196      		adiw r24,1
 2630 01e8 9C83      		std Y+4,r25
 2631 01ea 8B83      		std Y+3,r24
 2632               	.LVL227:
 204:main.c        **** 				for (uint8_t x = 0; x < 64; x++) {
 2633               		.loc 3 204 0 discriminator 3
 2634 01ec 8034      		cpi r24,64
 2635 01ee 9105      		cpc r25,__zero_reg__
 2636 01f0 01F4      		brne .L114
 2637 01f2 90E4      		ldi r25,64
 2638 01f4 C90E      		add r12,r25
 2639 01f6 D11C      		adc r13,__zero_reg__
 2640 01f8 E11C      		adc r14,__zero_reg__
 2641 01fa F11C      		adc r15,__zero_reg__
 2642               	.LBE140:
 206:main.c        **** 					address++;
 207:main.c        **** 				}
 208:main.c        **** 				
 209:main.c        **** 				PORTD &= ~(1<<ACTIVITY_LED);
 2643               		.loc 3 209 0
 2644 01fc 9398      		cbi 0x12,3
 210:main.c        **** 				receivedChar = USART_Receive();
 2645               		.loc 3 210 0
 2646 01fe 00D0      		rcall USART_Receive
 2647               	.LVL228:
 2648 0200 8093 0000 		sts receivedChar,r24
 2649 0204 00C0      		rjmp .L113
 2650               	.LVL229:
 2651               	.L112:
 211:main.c        **** 			}
 212:main.c        **** 			
 213:main.c        **** 			gba_mode(); // Set back
 214:main.c        **** 		}
 215:main.c        **** 		
 216:main.c        **** 		// Write to RAM on address (and increment) with 64 bytes of data
 217:main.c        **** 		else if (receivedChar == GBA_WRITE_SRAM) {
 2652               		.loc 3 217 0
 2653 0206 9737      		cpi r25,lo8(119)
 2654 0208 01F4      		brne .L116
 218:main.c        **** 			gb_mode();
 2655               		.loc 3 218 0
 2656 020a 00D0      		rcall gb_mode
 2657               	.LVL230:
 219:main.c        **** 			
 220:main.c        **** 			usart_read_bytes(64);
 2658               		.loc 3 220 0
 2659 020c 80E4      		ldi r24,lo8(64)
 2660 020e 90E0      		ldi r25,0
 2661 0210 00D0      		rcall usart_read_bytes
 2662               	.LVL231:
 221:main.c        **** 			
 222:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 2663               		.loc 3 222 0
 2664 0212 939A      		sbi 0x12,3
 2665               	.LVL232:
 2666 0214 60E0      		ldi r22,lo8(receivedBuffer)
 2667 0216 A62E      		mov r10,r22
 2668 0218 60E0      		ldi r22,hi8(receivedBuffer)
 2669 021a B62E      		mov r11,r22
 2670 021c 1C82      		std Y+4,__zero_reg__
 2671 021e 1B82      		std Y+3,__zero_reg__
 2672               	.LVL233:
 2673               	.L117:
 2674               	.LBB141:
 223:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 224:main.c        **** 				gba_write_ram_8bit_data(address, receivedBuffer[x]);
 2675               		.loc 3 224 0 discriminator 3
 2676 0220 F501      		movw r30,r10
 2677 0222 6191      		ld r22,Z+
 2678 0224 5F01      		movw r10,r30
 2679 0226 8B81      		ldd r24,Y+3
 2680 0228 9C81      		ldd r25,Y+4
 2681 022a 8C0D      		add r24,r12
 2682 022c 9D1D      		adc r25,r13
 2683 022e 00D0      		rcall gba_write_ram_8bit_data
 2684               	.LVL234:
 2685 0230 2B81      		ldd r18,Y+3
 2686 0232 3C81      		ldd r19,Y+4
 2687 0234 2F5F      		subi r18,-1
 2688 0236 3F4F      		sbci r19,-1
 2689 0238 3C83      		std Y+4,r19
 2690 023a 2B83      		std Y+3,r18
 2691               	.LVL235:
 223:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 2692               		.loc 3 223 0 discriminator 3
 2693 023c 2034      		cpi r18,64
 2694 023e 3105      		cpc r19,__zero_reg__
 2695 0240 01F4      		brne .L117
 2696               	.L220:
 2697 0242 30E4      		ldi r19,64
 2698 0244 C30E      		add r12,r19
 2699 0246 D11C      		adc r13,__zero_reg__
 2700 0248 E11C      		adc r14,__zero_reg__
 2701 024a F11C      		adc r15,__zero_reg__
 2702               	.L219:
 2703               	.LBE141:
 225:main.c        **** 				address++;
 226:main.c        **** 			}
 227:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 2704               		.loc 3 227 0
 2705 024c 81E3      		ldi r24,lo8(49)
 2706 024e 00D0      		rcall USART_Transmit
 2707               	.LVL236:
 228:main.c        **** 			
 229:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 2708               		.loc 3 229 0
 2709 0250 9398      		cbi 0x12,3
 2710               	.L217:
 230:main.c        **** 			gba_mode(); // Set back
 2711               		.loc 3 230 0
 2712 0252 00D0      		rcall gba_mode
 2713               	.LVL237:
 2714 0254 00C0      		rjmp .L90
 2715               	.LVL238:
 2716               	.L116:
 231:main.c        **** 		}
 232:main.c        **** 		
 233:main.c        **** 		// Write 1 byte to SRAM address
 234:main.c        **** 		else if (receivedChar == GBA_WRITE_ONE_BYTE_SRAM) {
 2717               		.loc 3 234 0
 2718 0256 9F36      		cpi r25,lo8(111)
 2719 0258 01F4      		brne .L118
 2720               	.LBB142:
 235:main.c        **** 			gb_mode();
 2721               		.loc 3 235 0
 2722 025a 00D0      		rcall gb_mode
 2723               	.LVL239:
 236:main.c        **** 			
 237:main.c        **** 			uint8_t data = USART_Receive();
 2724               		.loc 3 237 0
 2725 025c 00D0      		rcall USART_Receive
 2726               	.LVL240:
 238:main.c        **** 			gba_write_ram_8bit_data(address, data);
 2727               		.loc 3 238 0
 2728 025e 682F      		mov r22,r24
 2729 0260 C601      		movw r24,r12
 2730               	.LVL241:
 2731 0262 00D0      		rcall gba_write_ram_8bit_data
 2732               	.LVL242:
 2733 0264 00C0      		rjmp .L222
 2734               	.LVL243:
 2735               	.L118:
 2736               	.LBE142:
 239:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 240:main.c        **** 			
 241:main.c        **** 			gba_mode(); // Set back
 242:main.c        **** 		}
 243:main.c        **** 		
 244:main.c        **** 		
 245:main.c        **** 		// ---------- FLASH ----------
 246:main.c        **** 		// Read the Flash Manufacturer and Device ID
 247:main.c        **** 		else if (receivedChar == GBA_FLASH_READ_ID) {
 2737               		.loc 3 247 0
 2738 0266 9936      		cpi r25,lo8(105)
 2739 0268 01F4      		brne .L119
 248:main.c        **** 			gb_mode();
 2740               		.loc 3 248 0
 2741 026a 00D0      		rcall gb_mode
 2742               	.LVL244:
 249:main.c        **** 			
 250:main.c        **** 			flash_read_chip_id();
 2743               		.loc 3 250 0
 2744 026c 00D0      		rcall flash_read_chip_id
 2745               	.LVL245:
 251:main.c        **** 			USART_Transmit(flashChipIdBuffer[0]);
 2746               		.loc 3 251 0
 2747 026e 8091 0000 		lds r24,flashChipIdBuffer
 2748 0272 00D0      		rcall USART_Transmit
 2749               	.LVL246:
 252:main.c        **** 			USART_Transmit(flashChipIdBuffer[1]);
 2750               		.loc 3 252 0
 2751 0274 8091 0000 		lds r24,flashChipIdBuffer+1
 2752               	.L221:
 2753 0278 00D0      		rcall USART_Transmit
 2754               	.LVL247:
 2755 027a 00C0      		rjmp .L217
 2756               	.LVL248:
 2757               	.L119:
 253:main.c        **** 			
 254:main.c        **** 			gba_mode(); // Set back
 255:main.c        **** 		}
 256:main.c        **** 		
 257:main.c        **** 		// Change bank
 258:main.c        **** 		else if (receivedChar == GBA_FLASH_SET_BANK) {
 2758               		.loc 3 258 0
 2759 027c 9B36      		cpi r25,lo8(107)
 2760 027e 01F4      		brne .L120
 2761               	.LBB143:
 259:main.c        **** 			usart_read_chars(); // Read data
 2762               		.loc 3 259 0
 2763 0280 00D0      		rcall usart_read_chars
 2764               	.LVL249:
 260:main.c        **** 			uint8_t bank = atoi(receivedBuffer); // Convert data string to dec
 2765               		.loc 3 260 0
 2766 0282 80E0      		ldi r24,lo8(receivedBuffer)
 2767 0284 90E0      		ldi r25,hi8(receivedBuffer)
 2768 0286 00D0      		rcall atoi
 2769               	.LVL250:
 2770 0288 8A83      		std Y+2,r24
 2771               	.LVL251:
 261:main.c        **** 			
 262:main.c        **** 			gb_mode();
 2772               		.loc 3 262 0
 2773 028a 00D0      		rcall gb_mode
 2774               	.LVL252:
 263:main.c        **** 			flash_switch_bank(bank);
 2775               		.loc 3 263 0
 2776 028c 8A81      		ldd r24,Y+2
 2777 028e 00D0      		rcall flash_switch_bank
 2778               	.LVL253:
 2779 0290 00C0      		rjmp .L217
 2780               	.LVL254:
 2781               	.L120:
 2782               	.LBE143:
 264:main.c        **** 			
 265:main.c        **** 			gba_mode(); // Set back
 266:main.c        **** 		}
 267:main.c        **** 		
 268:main.c        **** 		// Erase 4K sector on Flash (sector 0 to 15 for 512Kbit)
 269:main.c        **** 		else if (receivedChar == GBA_FLASH_4K_SECTOR_ERASE) {
 2783               		.loc 3 269 0
 2784 0292 9337      		cpi r25,lo8(115)
 2785 0294 01F4      		brne .L121
 2786               	.LBB144:
 270:main.c        **** 			gb_mode();
 2787               		.loc 3 270 0
 2788 0296 00D0      		rcall gb_mode
 2789               	.LVL255:
 271:main.c        **** 			
 272:main.c        **** 			usart_read_chars(); // Read sector
 2790               		.loc 3 272 0
 2791 0298 00D0      		rcall usart_read_chars
 2792               	.LVL256:
 273:main.c        **** 			uint8_t sectorAddress = strtol(receivedBuffer, NULL, 16); // Convert address string in hex to de
 2793               		.loc 3 273 0
 2794 029a 40E1      		ldi r20,lo8(16)
 2795 029c 50E0      		ldi r21,0
 2796 029e 60E0      		ldi r22,0
 2797 02a0 70E0      		ldi r23,0
 2798 02a2 80E0      		ldi r24,lo8(receivedBuffer)
 2799 02a4 90E0      		ldi r25,hi8(receivedBuffer)
 2800 02a6 00D0      		rcall strtol
 2801               	.LVL257:
 2802 02a8 862F      		mov r24,r22
 2803               	.LVL258:
 274:main.c        **** 			
 275:main.c        **** 			flash_erase_4k_sector(sectorAddress);
 2804               		.loc 3 275 0
 2805 02aa 00D0      		rcall flash_erase_4k_sector
 2806               	.LVL259:
 2807               	.L222:
 276:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 2808               		.loc 3 276 0
 2809 02ac 81E3      		ldi r24,lo8(49)
 2810 02ae 00C0      		rjmp .L221
 2811               	.LVL260:
 2812               	.L121:
 2813               	.LBE144:
 277:main.c        **** 			
 278:main.c        **** 			gba_mode(); // Set back
 279:main.c        **** 		}
 280:main.c        **** 		
 281:main.c        **** 		// Write 64 bytes to Flash address one byte write at a time (and increment)
 282:main.c        **** 		else if (receivedChar == GBA_FLASH_WRITE_BYTE) {
 2814               		.loc 3 282 0
 2815 02b0 9236      		cpi r25,lo8(98)
 2816 02b2 01F4      		brne .L122
 283:main.c        **** 			gb_mode();
 2817               		.loc 3 283 0
 2818 02b4 00D0      		rcall gb_mode
 2819               	.LVL261:
 284:main.c        **** 			
 285:main.c        **** 			usart_read_bytes(64);
 2820               		.loc 3 285 0
 2821 02b6 80E4      		ldi r24,lo8(64)
 2822 02b8 90E0      		ldi r25,0
 2823 02ba 00D0      		rcall usart_read_bytes
 2824               	.LVL262:
 286:main.c        **** 			
 287:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 2825               		.loc 3 287 0
 2826 02bc 939A      		sbi 0x12,3
 2827               	.LVL263:
 2828 02be 50E0      		ldi r21,lo8(receivedBuffer)
 2829 02c0 A52E      		mov r10,r21
 2830 02c2 50E0      		ldi r21,hi8(receivedBuffer)
 2831 02c4 B52E      		mov r11,r21
 2832 02c6 1C82      		std Y+4,__zero_reg__
 2833 02c8 1B82      		std Y+3,__zero_reg__
 2834               	.LVL264:
 2835               	.L123:
 2836               	.LBB145:
 288:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 289:main.c        **** 				flash_write_byte(address, receivedBuffer[x]);
 2837               		.loc 3 289 0 discriminator 3
 2838 02ca F501      		movw r30,r10
 2839 02cc 6191      		ld r22,Z+
 2840 02ce 5F01      		movw r10,r30
 2841 02d0 8B81      		ldd r24,Y+3
 2842 02d2 9C81      		ldd r25,Y+4
 2843 02d4 8C0D      		add r24,r12
 2844 02d6 9D1D      		adc r25,r13
 2845 02d8 00D0      		rcall flash_write_byte
 2846               	.LVL265:
 2847 02da 2B81      		ldd r18,Y+3
 2848 02dc 3C81      		ldd r19,Y+4
 2849 02de 2F5F      		subi r18,-1
 2850 02e0 3F4F      		sbci r19,-1
 2851 02e2 3C83      		std Y+4,r19
 2852 02e4 2B83      		std Y+3,r18
 2853               	.LVL266:
 288:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 2854               		.loc 3 288 0 discriminator 3
 2855 02e6 2034      		cpi r18,64
 2856 02e8 3105      		cpc r19,__zero_reg__
 2857 02ea 01F4      		brne .L123
 2858 02ec 00C0      		rjmp .L220
 2859               	.LVL267:
 2860               	.L122:
 2861               	.LBE145:
 290:main.c        **** 				address++;
 291:main.c        **** 			}
 292:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 293:main.c        **** 			
 294:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 295:main.c        **** 			gba_mode(); // Set back
 296:main.c        **** 		}
 297:main.c        **** 		
 298:main.c        **** 		// Write 128 bytes to flash sector for Atmel flash (and increment)
 299:main.c        **** 		else if (receivedChar == GBA_FLASH_WRITE_ATMEL) {
 2862               		.loc 3 299 0
 2863 02ee 9136      		cpi r25,lo8(97)
 2864 02f0 01F4      		brne .L124
 300:main.c        **** 			gb_mode();
 2865               		.loc 3 300 0
 2866 02f2 00D0      		rcall gb_mode
 2867               	.LVL268:
 301:main.c        **** 			
 302:main.c        **** 			usart_read_bytes(128);
 2868               		.loc 3 302 0
 2869 02f4 80E8      		ldi r24,lo8(-128)
 2870 02f6 90E0      		ldi r25,0
 2871 02f8 00D0      		rcall usart_read_bytes
 2872               	.LVL269:
 303:main.c        **** 			
 304:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 2873               		.loc 3 304 0
 2874 02fa 939A      		sbi 0x12,3
 305:main.c        **** 			flash_write_sector(address); // Address used as sector number
 2875               		.loc 3 305 0
 2876 02fc C601      		movw r24,r12
 2877 02fe 00D0      		rcall flash_write_sector
 2878               	.LVL270:
 306:main.c        **** 			address++;
 2879               		.loc 3 306 0
 2880 0300 8FEF      		ldi r24,-1
 2881 0302 C81A      		sub r12,r24
 2882 0304 D80A      		sbc r13,r24
 2883 0306 E80A      		sbc r14,r24
 2884 0308 F80A      		sbc r15,r24
 2885               	.LVL271:
 2886 030a 00C0      		rjmp .L219
 2887               	.LVL272:
 2888               	.L124:
 307:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 308:main.c        **** 			
 309:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 310:main.c        **** 			gba_mode(); // Set back
 311:main.c        **** 		}
 312:main.c        **** 		
 313:main.c        **** 		
 314:main.c        **** 		// ---------- EEPROM ----------
 315:main.c        **** 		// Set EEPROM size
 316:main.c        **** 		else if (receivedChar == GBA_SET_EEPROM_SIZE) {
 2889               		.loc 3 316 0
 2890 030c 9335      		cpi r25,lo8(83)
 2891 030e 01F4      		brne .L125
 317:main.c        **** 			usart_read_chars(); // Read size
 2892               		.loc 3 317 0
 2893 0310 00D0      		rcall usart_read_chars
 2894               	.LVL273:
 318:main.c        **** 			eepromSize = strtol(receivedBuffer, NULL, 16); // Convert size to dec
 2895               		.loc 3 318 0
 2896 0312 40E1      		ldi r20,lo8(16)
 2897 0314 50E0      		ldi r21,0
 2898 0316 60E0      		ldi r22,0
 2899 0318 70E0      		ldi r23,0
 2900 031a 80E0      		ldi r24,lo8(receivedBuffer)
 2901 031c 90E0      		ldi r25,hi8(receivedBuffer)
 2902 031e 00D0      		rcall strtol
 2903               	.LVL274:
 2904 0320 062F      		mov r16,r22
 2905               	.LVL275:
 2906 0322 00C0      		rjmp .L90
 2907               	.LVL276:
 2908               	.L125:
 319:main.c        **** 		}
 320:main.c        **** 		
 321:main.c        **** 		// Read the EEPROM on address (and increment) until anything but 1 is received
 322:main.c        **** 		else if (receivedChar == GBA_READ_EEPROM) {
 2909               		.loc 3 322 0
 2910 0324 9536      		cpi r25,lo8(101)
 2911 0326 01F4      		brne .L126
 323:main.c        **** 			gba_eeprom_mode();
 2912               		.loc 3 323 0
 2913 0328 00D0      		rcall gba_eeprom_mode
 2914               	.LVL277:
 324:main.c        **** 			
 325:main.c        **** 			receivedChar = '1';
 2915               		.loc 3 325 0
 2916 032a 1093 0000 		sts receivedChar,r17
 2917               	.L127:
 326:main.c        **** 			while (receivedChar == '1') {
 2918               		.loc 3 326 0
 2919 032e 8091 0000 		lds r24,receivedChar
 2920 0332 8133      		cpi r24,lo8(49)
 2921 0334 01F0      		breq .+2
 2922 0336 00C0      		rjmp .L217
 327:main.c        **** 				PORTD |= (1<<ACTIVITY_LED);
 2923               		.loc 3 327 0
 2924 0338 939A      		sbi 0x12,3
 328:main.c        **** 				gba_eeprom_read(address, eepromSize);
 2925               		.loc 3 328 0
 2926 033a 602F      		mov r22,r16
 2927 033c C601      		movw r24,r12
 2928 033e 00D0      		rcall gba_eeprom_read
 2929               	.LVL278:
 2930 0340 E0E0      		ldi r30,lo8(eepromBuffer)
 2931 0342 F0E0      		ldi r31,hi8(eepromBuffer)
 2932 0344 FC83      		std Y+4,r31
 2933 0346 EB83      		std Y+3,r30
 2934               	.LVL279:
 2935               	.L128:
 2936               	.LBB146:
 329:main.c        **** 				
 330:main.c        **** 				// Send back the 8 bytes of data
 331:main.c        **** 				for (uint8_t c = 0; c < 8; c++) {
 332:main.c        **** 					USART_Transmit(eepromBuffer[c]);
 2937               		.loc 3 332 0 discriminator 3
 2938 0348 EB81      		ldd r30,Y+3
 2939 034a FC81      		ldd r31,Y+4
 2940 034c 8191      		ld r24,Z+
 2941 034e FC83      		std Y+4,r31
 2942 0350 EB83      		std Y+3,r30
 2943               	.LVL280:
 2944 0352 00D0      		rcall USART_Transmit
 2945               	.LVL281:
 331:main.c        **** 					USART_Transmit(eepromBuffer[c]);
 2946               		.loc 3 331 0 discriminator 3
 2947 0354 2B81      		ldd r18,Y+3
 2948 0356 3C81      		ldd r19,Y+4
 2949 0358 6216      		cp r6,r18
 2950 035a 7306      		cpc r7,r19
 2951 035c 01F4      		brne .L128
 2952               	.LBE146:
 333:main.c        **** 				}
 334:main.c        **** 				address++; // Increment to next 8 bytes
 2953               		.loc 3 334 0
 2954 035e 3FEF      		ldi r19,-1
 2955 0360 C31A      		sub r12,r19
 2956 0362 D30A      		sbc r13,r19
 2957 0364 E30A      		sbc r14,r19
 2958 0366 F30A      		sbc r15,r19
 2959               	.LVL282:
 335:main.c        **** 				
 336:main.c        **** 				PORTD &= ~(1<<ACTIVITY_LED);
 2960               		.loc 3 336 0
 2961 0368 9398      		cbi 0x12,3
 337:main.c        **** 				receivedChar = USART_Receive();
 2962               		.loc 3 337 0
 2963 036a 00D0      		rcall USART_Receive
 2964               	.LVL283:
 2965 036c 8093 0000 		sts receivedChar,r24
 2966 0370 00C0      		rjmp .L127
 2967               	.LVL284:
 2968               	.L126:
 338:main.c        **** 			}
 339:main.c        **** 			
 340:main.c        **** 			gba_mode(); // Set back
 341:main.c        **** 		}
 342:main.c        **** 		
 343:main.c        **** 		// Write 8 bytes to the EEPROM address (and increment)
 344:main.c        **** 		else if (receivedChar == GBA_WRITE_EEPROM) {
 2969               		.loc 3 344 0
 2970 0372 9037      		cpi r25,lo8(112)
 2971 0374 01F4      		brne .L130
 345:main.c        **** 			gba_eeprom_mode();
 2972               		.loc 3 345 0
 2973 0376 00D0      		rcall gba_eeprom_mode
 2974               	.LVL285:
 2975 0378 80E0      		ldi r24,lo8(eepromBuffer)
 2976 037a 90E0      		ldi r25,hi8(eepromBuffer)
 2977 037c 9C83      		std Y+4,r25
 2978 037e 8B83      		std Y+3,r24
 2979               	.LVL286:
 2980               	.L131:
 2981               	.LBB147:
 346:main.c        **** 			
 347:main.c        **** 			// Read 8 bytes from USART and place in buffer
 348:main.c        **** 			for (uint8_t x = 0; x < 8; x++) {
 349:main.c        **** 				eepromBuffer[x] = USART_Receive();
 2982               		.loc 3 349 0 discriminator 3
 2983 0380 00D0      		rcall USART_Receive
 2984               	.LVL287:
 2985 0382 EB81      		ldd r30,Y+3
 2986 0384 FC81      		ldd r31,Y+4
 2987 0386 8193      		st Z+,r24
 2988 0388 FC83      		std Y+4,r31
 2989 038a EB83      		std Y+3,r30
 2990               	.LVL288:
 348:main.c        **** 				eepromBuffer[x] = USART_Receive();
 2991               		.loc 3 348 0 discriminator 3
 2992 038c 6E16      		cp r6,r30
 2993 038e 7F06      		cpc r7,r31
 2994 0390 01F4      		brne .L131
 2995               	.LBE147:
 350:main.c        **** 			}
 351:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 2996               		.loc 3 351 0
 2997 0392 939A      		sbi 0x12,3
 352:main.c        **** 			
 353:main.c        **** 			gba_eeprom_write(address, eepromSize);
 2998               		.loc 3 353 0
 2999 0394 602F      		mov r22,r16
 3000 0396 C601      		movw r24,r12
 3001 0398 00D0      		rcall gba_eeprom_write
 3002               	.LVL289:
 354:main.c        **** 			address++;
 3003               		.loc 3 354 0
 3004 039a FFEF      		ldi r31,-1
 3005 039c CF1A      		sub r12,r31
 3006 039e DF0A      		sbc r13,r31
 3007 03a0 EF0A      		sbc r14,r31
 3008 03a2 FF0A      		sbc r15,r31
 3009               	.LVL290:
 3010               	.LBB148:
 3011               	.LBB149:
 187:c:\winavr-20100110\avr\include\util\delay.h **** 
 3012               		.loc 2 187 0
 3013 03a4 8FE7      		ldi r24,lo8(15999)
 3014 03a6 9EE3      		ldi r25,hi8(15999)
 3015 03a8 0197      	1:	sbiw r24,1
 3016 03aa 01F4      		brne 1b
 3017 03ac 00C0      		rjmp .
 3018 03ae 0000      		nop
 3019               	.LVL291:
 3020 03b0 00C0      		rjmp .L219
 3021               	.LVL292:
 3022               	.L130:
 3023               	.LBE149:
 3024               	.LBE148:
 355:main.c        **** 			
 356:main.c        **** 			_delay_ms(8); // Wait for EEPROM to write data (8ms)
 357:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 358:main.c        **** 			
 359:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 360:main.c        **** 			gba_mode(); // Set back
 361:main.c        **** 		}
 362:main.c        **** 		
 363:main.c        **** 		
 364:main.c        **** 		// ---------- GB FLASH CARTS ----------
 365:main.c        **** 		// Select which pin need to pulse as WE (Audio or WR)
 366:main.c        **** 		else if (receivedChar == GB_FLASH_WE_PIN) {
 3025               		.loc 3 366 0
 3026 03b2 9035      		cpi r25,lo8(80)
 3027 03b4 01F4      		brne .L132
 367:main.c        **** 			flashWriteWePin = USART_Receive();
 3028               		.loc 3 367 0
 3029 03b6 00D0      		rcall USART_Receive
 3030               	.LVL293:
 3031 03b8 8093 0000 		sts flashWriteWePin,r24
 368:main.c        **** 			
 369:main.c        **** 			if (flashWriteWePin == WE_AS_AUDIO_PIN) {
 3032               		.loc 3 369 0
 3033 03bc 8134      		cpi r24,lo8(65)
 3034 03be 01F0      		breq .+2
 3035 03c0 00C0      		rjmp .L90
 370:main.c        **** 				DDRE |= (1<<AUDIO_PIN);
 3036               		.loc 3 370 0
 3037 03c2 319A      		sbi 0x6,1
 371:main.c        **** 				audioPin_high;
 3038               		.loc 3 371 0
 3039 03c4 399A      		sbi 0x7,1
 3040 03c6 00C0      		rjmp .L90
 3041               	.LVL294:
 3042               	.L132:
 372:main.c        **** 			}
 373:main.c        **** 		}
 374:main.c        **** 		
 375:main.c        **** 		// Some flash carts may require changing the bank back to 1 in order to accept flash chip command
 376:main.c        **** 		else if (receivedChar == GB_FLASH_BANK_1_COMMAND_WRITES) {
 3043               		.loc 3 376 0
 3044 03c8 9E34      		cpi r25,lo8(78)
 3045 03ca 01F4      		brne .L133
 377:main.c        **** 			flashBank1CommandWrites = 1;
 3046               		.loc 3 377 0
 3047 03cc 91E0      		ldi r25,lo8(1)
 3048 03ce 9093 0000 		sts flashBank1CommandWrites,r25
 3049 03d2 00C0      		rjmp .L90
 3050               	.L133:
 378:main.c        **** 		}
 379:main.c        **** 		
 380:main.c        **** 		// Load the program method to use
 381:main.c        **** 		else if (receivedChar == GB_FLASH_PROGRAM_METHOD) {
 3051               		.loc 3 381 0
 3052 03d4 9534      		cpi r25,lo8(69)
 3053 03d6 01F4      		brne .L134
 3054 03d8 E0E0      		ldi r30,lo8(flashWriteCycle)
 3055 03da F0E0      		ldi r31,hi8(flashWriteCycle)
 3056 03dc FC83      		std Y+4,r31
 3057 03de EB83      		std Y+3,r30
 3058               	.LVL295:
 3059               	.L135:
 3060               	.LBB150:
 382:main.c        **** 			for (uint8_t x = 0; x < 3; x++) {
 383:main.c        **** 				usart_read_chars(); // Address
 3061               		.loc 3 383 0 discriminator 3
 3062 03e0 00D0      		rcall usart_read_chars
 3063               	.LVL296:
 384:main.c        **** 				flashWriteCycle[x][0] = strtol(receivedBuffer, NULL, 16);
 3064               		.loc 3 384 0 discriminator 3
 3065 03e2 40E1      		ldi r20,lo8(16)
 3066 03e4 50E0      		ldi r21,0
 3067 03e6 60E0      		ldi r22,0
 3068 03e8 70E0      		ldi r23,0
 3069 03ea 80E0      		ldi r24,lo8(receivedBuffer)
 3070 03ec 90E0      		ldi r25,hi8(receivedBuffer)
 3071 03ee 00D0      		rcall strtol
 3072               	.LVL297:
 3073 03f0 EB81      		ldd r30,Y+3
 3074 03f2 FC81      		ldd r31,Y+4
 3075 03f4 7183      		std Z+1,r23
 3076 03f6 6083      		st Z,r22
 385:main.c        **** 				USART_Transmit(SEND_ACK);
 3077               		.loc 3 385 0 discriminator 3
 3078 03f8 81E3      		ldi r24,lo8(49)
 3079 03fa 00D0      		rcall USART_Transmit
 3080               	.LVL298:
 386:main.c        **** 				
 387:main.c        **** 				usart_read_chars(); // Data
 3081               		.loc 3 387 0 discriminator 3
 3082 03fc 00D0      		rcall usart_read_chars
 3083               	.LVL299:
 388:main.c        **** 				flashWriteCycle[x][1] = strtol(receivedBuffer, NULL, 16);
 3084               		.loc 3 388 0 discriminator 3
 3085 03fe 40E1      		ldi r20,lo8(16)
 3086 0400 50E0      		ldi r21,0
 3087 0402 60E0      		ldi r22,0
 3088 0404 70E0      		ldi r23,0
 3089 0406 80E0      		ldi r24,lo8(receivedBuffer)
 3090 0408 90E0      		ldi r25,hi8(receivedBuffer)
 3091 040a 00D0      		rcall strtol
 3092               	.LVL300:
 3093 040c EB81      		ldd r30,Y+3
 3094 040e FC81      		ldd r31,Y+4
 3095 0410 7383      		std Z+3,r23
 3096 0412 6283      		std Z+2,r22
 389:main.c        **** 				USART_Transmit(SEND_ACK);
 3097               		.loc 3 389 0 discriminator 3
 3098 0414 81E3      		ldi r24,lo8(49)
 3099 0416 00D0      		rcall USART_Transmit
 3100               	.LVL301:
 3101 0418 2B81      		ldd r18,Y+3
 3102 041a 3C81      		ldd r19,Y+4
 3103 041c 2C5F      		subi r18,-4
 3104 041e 3F4F      		sbci r19,-1
 3105 0420 3C83      		std Y+4,r19
 3106 0422 2B83      		std Y+3,r18
 382:main.c        **** 				usart_read_chars(); // Address
 3107               		.loc 3 382 0 discriminator 3
 3108 0424 80E0      		ldi r24,lo8(flashWriteCycle+12)
 3109 0426 90E0      		ldi r25,hi8(flashWriteCycle+12)
 3110 0428 8217      		cp r24,r18
 3111 042a 9307      		cpc r25,r19
 3112 042c 01F4      		brne .L135
 3113 042e 00C0      		rjmp .L90
 3114               	.LVL302:
 3115               	.L134:
 3116               	.LBE150:
 390:main.c        **** 			}
 391:main.c        **** 		}
 392:main.c        **** 		
 393:main.c        **** 		// Write address and one byte to Flash, pulse a pin
 394:main.c        **** 		else if (receivedChar == GB_FLASH_WRITE_BYTE) {
 3117               		.loc 3 394 0
 3118 0430 9634      		cpi r25,lo8(70)
 3119 0432 01F4      		brne .L136
 3120               	.LBB151:
 395:main.c        **** 			usart_read_chars(); // Read address
 3121               		.loc 3 395 0
 3122 0434 00D0      		rcall usart_read_chars
 3123               	.LVL303:
 396:main.c        **** 			uint16_t flashAddress = strtol(receivedBuffer, NULL, 16);
 3124               		.loc 3 396 0
 3125 0436 40E1      		ldi r20,lo8(16)
 3126 0438 50E0      		ldi r21,0
 3127 043a 60E0      		ldi r22,0
 3128 043c 70E0      		ldi r23,0
 3129 043e 80E0      		ldi r24,lo8(receivedBuffer)
 3130 0440 90E0      		ldi r25,hi8(receivedBuffer)
 3131 0442 00D0      		rcall strtol
 3132               	.LVL304:
 3133 0444 4B01      		movw r8,r22
 3134 0446 5C01      		movw r10,r24
 3135               	.LVL305:
 397:main.c        **** 			
 398:main.c        **** 			usart_read_chars(); // Read data byte
 3136               		.loc 3 398 0
 3137 0448 00D0      		rcall usart_read_chars
 3138               	.LVL306:
 399:main.c        **** 			uint8_t flashByte = strtol(receivedBuffer, NULL, 16);
 3139               		.loc 3 399 0
 3140 044a 40E1      		ldi r20,lo8(16)
 3141 044c 50E0      		ldi r21,0
 3142 044e 60E0      		ldi r22,0
 3143 0450 70E0      		ldi r23,0
 3144 0452 80E0      		ldi r24,lo8(receivedBuffer)
 3145 0454 90E0      		ldi r25,hi8(receivedBuffer)
 3146 0456 00D0      		rcall strtol
 3147               	.LVL307:
 400:main.c        **** 			
 401:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 3148               		.loc 3 401 0
 3149 0458 939A      		sbi 0x12,3
 402:main.c        **** 			gb_flash_write_bus_cycle(flashAddress, flashByte);
 3150               		.loc 3 402 0
 3151 045a C401      		movw r24,r8
 3152 045c 00D0      		rcall gb_flash_write_bus_cycle
 3153               	.LVL308:
 3154 045e 00C0      		rjmp .L234
 3155               	.LVL309:
 3156               	.L136:
 3157               	.LBE151:
 403:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 404:main.c        **** 			
 405:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 406:main.c        **** 		}
 407:main.c        **** 		
 408:main.c        **** 		// Write 64 bytes to Flash address one byte write at a time (and increment), pulse a pin
 409:main.c        **** 		else if (receivedChar == GB_FLASH_WRITE_64BYTE) {
 3158               		.loc 3 409 0
 3159 0460 9435      		cpi r25,lo8(84)
 3160 0462 01F4      		brne .L137
 410:main.c        **** 			usart_read_bytes(64);
 3161               		.loc 3 410 0
 3162 0464 80E4      		ldi r24,lo8(64)
 3163 0466 90E0      		ldi r25,0
 3164               	.LVL310:
 3165 0468 00D0      		rcall usart_read_bytes
 3166               	.LVL311:
 411:main.c        **** 			
 412:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 3167               		.loc 3 412 0
 3168 046a 939A      		sbi 0x12,3
 3169               	.LVL312:
 3170 046c E0E0      		ldi r30,lo8(receivedBuffer)
 3171 046e F0E0      		ldi r31,hi8(receivedBuffer)
 3172 0470 FC83      		std Y+4,r31
 3173 0472 EB83      		std Y+3,r30
 3174 0474 40E4      		ldi r20,lo8(64)
 3175 0476 942E      		mov r9,r20
 3176 0478 9601      		movw r18,r12
 3177 047a 2050      		subi r18,lo8(receivedBuffer)
 3178 047c 3040      		sbci r19,hi8(receivedBuffer)
 3179 047e 5901      		movw r10,r18
 3180               	.LVL313:
 3181               	.L140:
 3182               	.LBB152:
 413:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 414:main.c        **** 				if (flashBank1CommandWrites == 0) {
 3183               		.loc 3 414 0
 3184 0480 8091 0000 		lds r24,flashBank1CommandWrites
 415:main.c        **** 					gb_flash_write_byte(address, receivedBuffer[x]);
 3185               		.loc 3 415 0
 3186 0484 EB81      		ldd r30,Y+3
 3187 0486 FC81      		ldd r31,Y+4
 3188 0488 6081      		ld r22,Z
 414:main.c        **** 					gb_flash_write_byte(address, receivedBuffer[x]);
 3189               		.loc 3 414 0
 3190 048a 8111      		cpse r24,__zero_reg__
 3191 048c 00C0      		rjmp .L138
 3192               		.loc 3 415 0
 3193 048e CF01      		movw r24,r30
 3194 0490 8A0D      		add r24,r10
 3195 0492 9B1D      		adc r25,r11
 3196 0494 00D0      		rcall gb_flash_write_byte
 3197               	.LVL314:
 3198 0496 00C0      		rjmp .L139
 3199               	.L138:
 416:main.c        **** 				}
 417:main.c        **** 				else { // Some flash carts need to change to bank 1 to issue flash commands
 418:main.c        **** 					gb_flash_write_byte_bank1_commands(address, receivedBuffer[x]);
 3200               		.loc 3 418 0
 3201 0498 CF01      		movw r24,r30
 3202 049a 8A0D      		add r24,r10
 3203 049c 9B1D      		adc r25,r11
 3204 049e 00D0      		rcall gb_flash_write_byte_bank1_commands
 3205               	.LVL315:
 3206               	.L139:
 3207 04a0 9A94      		dec r9
 3208 04a2 2B81      		ldd r18,Y+3
 3209 04a4 3C81      		ldd r19,Y+4
 3210 04a6 2F5F      		subi r18,-1
 3211 04a8 3F4F      		sbci r19,-1
 3212 04aa 3C83      		std Y+4,r19
 3213 04ac 2B83      		std Y+3,r18
 3214               	.LVL316:
 413:main.c        **** 				if (flashBank1CommandWrites == 0) {
 3215               		.loc 3 413 0 discriminator 2
 3216 04ae 9110      		cpse r9,__zero_reg__
 3217 04b0 00C0      		rjmp .L140
 3218 04b2 30E4      		ldi r19,64
 3219 04b4 C30E      		add r12,r19
 3220 04b6 D11C      		adc r13,__zero_reg__
 3221 04b8 E11C      		adc r14,__zero_reg__
 3222 04ba F11C      		adc r15,__zero_reg__
 3223 04bc 00C0      		rjmp .L223
 3224               	.LVL317:
 3225               	.L137:
 3226               	.LBE152:
 419:main.c        **** 				}
 420:main.c        **** 				address++;
 421:main.c        **** 			}
 422:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 423:main.c        **** 			
 424:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 425:main.c        **** 		}
 426:main.c        **** 		
 427:main.c        **** 		
 428:main.c        **** 		// Buffered programming, write 256 bytes to Flash address
 429:main.c        **** 		else if (receivedChar == GB_FLASH_WRITE_256BYTE) {
 3227               		.loc 3 429 0
 3228 04be 9835      		cpi r25,lo8(88)
 3229 04c0 01F0      		breq .+2
 3230 04c2 00C0      		rjmp .L141
 3231               	.LBB153:
 430:main.c        **** 			usart_read_bytes(256);
 3232               		.loc 3 430 0
 3233 04c4 80E0      		ldi r24,0
 3234 04c6 91E0      		ldi r25,lo8(1)
 3235               	.LVL318:
 3236 04c8 00D0      		rcall usart_read_bytes
 3237               	.LVL319:
 431:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 3238               		.loc 3 431 0
 3239 04ca 939A      		sbi 0x12,3
 432:main.c        **** 			
 433:main.c        **** 			// Setup buffered write
 434:main.c        **** 			gb_flash_write_bus_cycle(0xAAA, 0xA9);
 3240               		.loc 3 434 0
 3241 04cc 69EA      		ldi r22,lo8(-87)
 3242 04ce 8AEA      		ldi r24,lo8(-86)
 3243 04d0 9AE0      		ldi r25,lo8(10)
 3244 04d2 00D0      		rcall gb_flash_write_bus_cycle
 3245               	.LVL320:
 435:main.c        **** 			gb_flash_write_bus_cycle(0x555, 0x56);
 3246               		.loc 3 435 0
 3247 04d4 66E5      		ldi r22,lo8(86)
 3248 04d6 85E5      		ldi r24,lo8(85)
 3249 04d8 95E0      		ldi r25,lo8(5)
 3250 04da 00D0      		rcall gb_flash_write_bus_cycle
 3251               	.LVL321:
 436:main.c        **** 			gb_flash_write_bus_cycle(address, 0x26);
 3252               		.loc 3 436 0
 3253 04dc 5601      		movw r10,r12
 3254 04de 66E2      		ldi r22,lo8(38)
 3255 04e0 C601      		movw r24,r12
 3256 04e2 00D0      		rcall gb_flash_write_bus_cycle
 3257               	.LVL322:
 437:main.c        **** 			gb_flash_write_bus_cycle(address, 0xFF); // Length
 3258               		.loc 3 437 0
 3259 04e4 6FEF      		ldi r22,lo8(-1)
 3260 04e6 C601      		movw r24,r12
 3261 04e8 00D0      		rcall gb_flash_write_bus_cycle
 3262               	.LVL323:
 3263               	.LBB154:
 3264               	.LBB155:
 3265               		.loc 2 276 0
 3266 04ea 85E8      		ldi r24,lo8(-123)
 3267 04ec 8A95      	1:	dec r24
 3268 04ee 01F4      		brne 1b
 3269 04f0 0000      		nop
 3270               	.LVL324:
 3271 04f2 E0E0      		ldi r30,lo8(receivedBuffer)
 3272 04f4 F0E0      		ldi r31,hi8(receivedBuffer)
 3273 04f6 FC83      		std Y+4,r31
 3274 04f8 EB83      		std Y+3,r30
 3275               	.LBE155:
 3276               	.LBE154:
 3277               	.LBB156:
 438:main.c        **** 			_delay_us(50);
 439:main.c        **** 			
 440:main.c        **** 			// Write data
 441:main.c        **** 			for (int x = 0; x < 256; x++) {
 3278               		.loc 3 441 0
 3279 04fa 812C      		mov r8,__zero_reg__
 3280 04fc 912C      		mov r9,__zero_reg__
 3281               	.LVL325:
 3282               	.L142:
 442:main.c        **** 				gb_flash_write_bus_cycle(address, receivedBuffer[x]);
 3283               		.loc 3 442 0 discriminator 3
 3284 04fe EB81      		ldd r30,Y+3
 3285 0500 FC81      		ldd r31,Y+4
 3286 0502 6191      		ld r22,Z+
 3287 0504 FC83      		std Y+4,r31
 3288 0506 EB83      		std Y+3,r30
 3289 0508 C401      		movw r24,r8
 3290 050a 8A0D      		add r24,r10
 3291 050c 9B1D      		adc r25,r11
 3292 050e 00D0      		rcall gb_flash_write_bus_cycle
 3293               	.LVL326:
 441:main.c        **** 				gb_flash_write_bus_cycle(address, receivedBuffer[x]);
 3294               		.loc 3 441 0 discriminator 3
 3295 0510 FFEF      		ldi r31,-1
 3296 0512 8F1A      		sub r8,r31
 3297 0514 9F0A      		sbc r9,r31
 3298               	.LVL327:
 3299 0516 8114      		cp r8,__zero_reg__
 3300 0518 21E0      		ldi r18,1
 3301 051a 9206      		cpc r9,r18
 3302 051c 01F4      		brne .L142
 3303 051e 3FEF      		ldi r19,-1
 3304 0520 D31A      		sub r13,r19
 3305 0522 E30A      		sbc r14,r19
 3306 0524 F30A      		sbc r15,r19
 3307               	.LBE156:
 443:main.c        **** 				address++;
 444:main.c        **** 			}
 445:main.c        **** 			
 446:main.c        **** 			// Write buffer to flash
 447:main.c        **** 			gb_flash_write_bus_cycle(address-256, 0x2A);
 3308               		.loc 3 447 0
 3309 0526 C601      		movw r24,r12
 3310 0528 9A95      		dec r25
 3311 052a 6AE2      		ldi r22,lo8(42)
 3312 052c 00D0      		rcall gb_flash_write_bus_cycle
 3313               	.LVL328:
 448:main.c        **** 			
 449:main.c        **** 			// Verify last byte written
 450:main.c        **** 			uint8_t dataVerify = gb_flash_read_byte(address-1);
 3314               		.loc 3 450 0
 3315 052e C601      		movw r24,r12
 3316 0530 0197      		sbiw r24,1
 3317 0532 9C83      		std Y+4,r25
 3318 0534 8B83      		std Y+3,r24
 3319 0536 00D0      		rcall gb_flash_read_byte
 3320               	.LVL329:
 3321               	.L143:
 451:main.c        **** 			while (dataVerify != receivedBuffer[255]) {
 3322               		.loc 3 451 0
 3323 0538 9091 0000 		lds r25,receivedBuffer+255
 3324 053c 8917      		cp r24,r25
 3325 053e 01F4      		brne .+2
 3326 0540 00C0      		rjmp .L223
 452:main.c        **** 				dataVerify = gb_flash_read_byte(address-1);
 3327               		.loc 3 452 0
 3328 0542 8B81      		ldd r24,Y+3
 3329 0544 9C81      		ldd r25,Y+4
 3330               	.LVL330:
 3331 0546 00D0      		rcall gb_flash_read_byte
 3332               	.LVL331:
 3333               	.LBB157:
 3334               	.LBB158:
 3335               		.loc 2 276 0
 3336 0548 9DE0      		ldi r25,lo8(13)
 3337 054a 9A95      	1:	dec r25
 3338 054c 01F4      		brne 1b
 3339 054e 0000      		nop
 3340 0550 00C0      		rjmp .L143
 3341               	.LVL332:
 3342               	.L141:
 3343               	.LBE158:
 3344               	.LBE157:
 3345               	.LBE153:
 453:main.c        **** 				_delay_us(5);
 454:main.c        **** 			}
 455:main.c        **** 			
 456:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 457:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 458:main.c        **** 		}
 459:main.c        **** 		
 460:main.c        **** 		
 461:main.c        **** 		// ---------- GBA FLASH CARTS ----------
 462:main.c        **** 		// Write 24 bit address, 16 bit data and pulse a pin
 463:main.c        **** 		else if (receivedChar == GBA_FLASH_CART_WRITE_BYTE) {
 3346               		.loc 3 463 0
 3347 0552 9E36      		cpi r25,lo8(110)
 3348 0554 01F4      		brne .L145
 3349               	.LBB159:
 464:main.c        **** 			usart_read_chars(); // Read address
 3350               		.loc 3 464 0
 3351 0556 00D0      		rcall usart_read_chars
 3352               	.LVL333:
 465:main.c        **** 			uint32_t flashAddress = strtol(receivedBuffer, NULL, 16); // Convert address string in hex to de
 3353               		.loc 3 465 0
 3354 0558 40E1      		ldi r20,lo8(16)
 3355 055a 50E0      		ldi r21,0
 3356 055c 60E0      		ldi r22,0
 3357 055e 70E0      		ldi r23,0
 3358 0560 80E0      		ldi r24,lo8(receivedBuffer)
 3359 0562 90E0      		ldi r25,hi8(receivedBuffer)
 3360 0564 00D0      		rcall strtol
 3361               	.LVL334:
 3362 0566 4B01      		movw r8,r22
 3363 0568 5C01      		movw r10,r24
 3364               	.LVL335:
 466:main.c        **** 			
 467:main.c        **** 			receivedChar = USART_Receive(); // Wait for byte
 3365               		.loc 3 467 0
 3366 056a 00D0      		rcall USART_Receive
 3367               	.LVL336:
 3368 056c 8093 0000 		sts receivedChar,r24
 468:main.c        **** 			if (receivedChar == GBA_FLASH_CART_WRITE_BYTE) {
 3369               		.loc 3 468 0
 3370 0570 8E36      		cpi r24,lo8(110)
 3371 0572 01F0      		breq .+2
 3372 0574 00C0      		rjmp .L90
 3373               	.LBB160:
 469:main.c        **** 				usart_read_chars(); // Read data
 3374               		.loc 3 469 0
 3375 0576 00D0      		rcall usart_read_chars
 3376               	.LVL337:
 470:main.c        **** 				uint16_t flashByte = strtol(receivedBuffer, NULL, 16); // Convert data byte in hex to dec
 3377               		.loc 3 470 0
 3378 0578 40E1      		ldi r20,lo8(16)
 3379 057a 50E0      		ldi r21,0
 3380 057c 60E0      		ldi r22,0
 3381 057e 70E0      		ldi r23,0
 3382 0580 80E0      		ldi r24,lo8(receivedBuffer)
 3383 0582 90E0      		ldi r25,hi8(receivedBuffer)
 3384 0584 00D0      		rcall strtol
 3385               	.LVL338:
 471:main.c        **** 				
 472:main.c        **** 				PORTD |= (1<<ACTIVITY_LED);
 3386               		.loc 3 472 0
 3387 0586 939A      		sbi 0x12,3
 473:main.c        **** 				GBA_DDR_ROM_ADDR23_16 = 0xFF;
 3388               		.loc 3 473 0
 3389 0588 2FEF      		ldi r18,lo8(-1)
 3390 058a 24BB      		out 0x14,r18
 474:main.c        **** 				GBA_DDR_ROM_ADDR15_8 = 0xFF;
 3391               		.loc 3 474 0
 3392 058c 2ABB      		out 0x1a,r18
 475:main.c        **** 				GBA_DDR_ROM_ADDR7_0 = 0xFF;
 3393               		.loc 3 475 0
 3394 058e 27BB      		out 0x17,r18
 476:main.c        **** 				gba_flash_write_bus_cycle(flashAddress, flashByte);
 3395               		.loc 3 476 0
 3396 0590 AB01      		movw r20,r22
 3397 0592 C501      		movw r24,r10
 3398 0594 B401      		movw r22,r8
 3399               	.LVL339:
 3400 0596 00D0      		rcall gba_flash_write_bus_cycle
 3401               	.LVL340:
 3402               	.L234:
 477:main.c        **** 				PORTD &= ~(1<<ACTIVITY_LED);
 3403               		.loc 3 477 0
 3404 0598 9398      		cbi 0x12,3
 478:main.c        **** 				
 479:main.c        **** 				USART_Transmit(SEND_ACK); // Send back acknowledgement
 3405               		.loc 3 479 0
 3406 059a 81E3      		ldi r24,lo8(49)
 3407 059c 00C0      		rjmp .L215
 3408               	.LVL341:
 3409               	.L145:
 3410               	.LBE160:
 3411               	.LBE159:
 480:main.c        **** 			}
 481:main.c        **** 		}
 482:main.c        **** 		
 483:main.c        **** 		// Write 64 or 256 bytes to Flash address, combine 2 bytes and write one at a time (and increment
 484:main.c        **** 		else if (receivedChar == GBA_FLASH_WRITE_64BYTE || receivedChar == GBA_FLASH_WRITE_256BYTE) {
 3412               		.loc 3 484 0
 3413 059e 9137      		cpi r25,lo8(113)
 3414 05a0 01F0      		breq .L146
 3415               		.loc 3 484 0 is_stmt 0 discriminator 1
 3416 05a2 9437      		cpi r25,lo8(116)
 3417 05a4 01F0      		breq .+2
 3418 05a6 00C0      		rjmp .L147
 3419               	.L146:
 3420               	.LBB161:
 485:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 3421               		.loc 3 485 0 is_stmt 1
 3422 05a8 939A      		sbi 0x12,3
 3423               	.LVL342:
 486:main.c        **** 			
 487:main.c        **** 			int readLength = 64;
 488:main.c        **** 			if (receivedChar == GBA_FLASH_WRITE_256BYTE) {
 3424               		.loc 3 488 0
 3425 05aa 8091 0000 		lds r24,receivedChar
 3426               	.LVL343:
 3427 05ae 8437      		cpi r24,lo8(116)
 3428 05b0 01F4      		brne .L190
 489:main.c        **** 				readLength = 256;
 3429               		.loc 3 489 0
 3430 05b2 E0E0      		ldi r30,0
 3431 05b4 F1E0      		ldi r31,lo8(1)
 3432 05b6 FC83      		std Y+4,r31
 3433 05b8 EB83      		std Y+3,r30
 3434 05ba 00C0      		rjmp .L148
 3435               	.L190:
 487:main.c        **** 			if (receivedChar == GBA_FLASH_WRITE_256BYTE) {
 3436               		.loc 3 487 0
 3437 05bc 20E4      		ldi r18,lo8(64)
 3438 05be 30E0      		ldi r19,0
 3439 05c0 3C83      		std Y+4,r19
 3440 05c2 2B83      		std Y+3,r18
 3441               	.L148:
 3442               	.LVL344:
 490:main.c        **** 			}
 491:main.c        **** 			usart_read_bytes(readLength);
 3443               		.loc 3 491 0
 3444 05c4 8B81      		ldd r24,Y+3
 3445 05c6 9C81      		ldd r25,Y+4
 3446 05c8 00D0      		rcall usart_read_bytes
 3447               	.LVL345:
 3448 05ca 30E0      		ldi r19,lo8(receivedBuffer)
 3449 05cc A32E      		mov r10,r19
 3450 05ce 30E0      		ldi r19,hi8(receivedBuffer)
 3451 05d0 B32E      		mov r11,r19
 3452 05d2 1601      		movw r2,r12
 3453 05d4 2701      		movw r4,r14
 3454               	.LVL346:
 3455               	.L149:
 3456               	.LBB162:
 3457               	.LBB163:
 492:main.c        **** 			
 493:main.c        **** 			for (int x = 0; x < readLength; x += 2) {
 494:main.c        **** 				uint16_t combinedBytes = (uint16_t) receivedBuffer[x+1] << 8 | (uint16_t) receivedBuffer[x];
 495:main.c        **** 				gba_flash_write_byte_swapped(address, combinedBytes);
 3458               		.loc 3 495 0 discriminator 3
 3459 05d6 F501      		movw r30,r10
 3460 05d8 4181      		ldd r20,Z+1
 3461 05da 50E0      		ldi r21,0
 3462 05dc 542F      		mov r21,r20
 3463 05de 4427      		clr r20
 3464 05e0 8081      		ld r24,Z
 3465 05e2 482B      		or r20,r24
 3466 05e4 C201      		movw r24,r4
 3467 05e6 B101      		movw r22,r2
 3468 05e8 00D0      		rcall gba_flash_write_byte_swapped
 3469               	.LVL347:
 496:main.c        **** 				address++;
 3470               		.loc 3 496 0 discriminator 3
 3471 05ea FFEF      		ldi r31,-1
 3472 05ec 2F1A      		sub r2,r31
 3473 05ee 3F0A      		sbc r3,r31
 3474 05f0 4F0A      		sbc r4,r31
 3475 05f2 5F0A      		sbc r5,r31
 3476               	.LVL348:
 3477 05f4 22E0      		ldi r18,2
 3478 05f6 A20E      		add r10,r18
 3479 05f8 B11C      		adc r11,__zero_reg__
 3480               	.LVL349:
 3481               	.LBE163:
 493:main.c        **** 				uint16_t combinedBytes = (uint16_t) receivedBuffer[x+1] << 8 | (uint16_t) receivedBuffer[x];
 3482               		.loc 3 493 0 discriminator 3
 3483 05fa C501      		movw r24,r10
 3484 05fc 8050      		subi r24,lo8(receivedBuffer)
 3485 05fe 9040      		sbci r25,hi8(receivedBuffer)
 3486 0600 EB81      		ldd r30,Y+3
 3487 0602 FC81      		ldd r31,Y+4
 3488 0604 8E17      		cp r24,r30
 3489 0606 9F07      		cpc r25,r31
 3490 0608 04F0      		brlt .L149
 3491 060a FFEF      		ldi r31,-1
 3492 060c CF1A      		sub r12,r31
 3493 060e DF0A      		sbc r13,r31
 3494 0610 EF0A      		sbc r14,r31
 3495 0612 FF0A      		sbc r15,r31
 3496 0614 2B81      		ldd r18,Y+3
 3497 0616 3C81      		ldd r19,Y+4
 3498 0618 2150      		subi r18,1
 3499 061a 3109      		sbc r19,__zero_reg__
 3500 061c 3695      		lsr r19
 3501 061e 2795      		ror r18
 3502 0620 C20E      		add r12,r18
 3503 0622 D31E      		adc r13,r19
 3504 0624 E11C      		adc r14,__zero_reg__
 3505 0626 F11C      		adc r15,__zero_reg__
 3506 0628 00C0      		rjmp .L223
 3507               	.LVL350:
 3508               	.L147:
 3509               	.LBE162:
 3510               	.LBE161:
 497:main.c        **** 			}
 498:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 499:main.c        **** 			
 500:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 501:main.c        **** 		}
 502:main.c        **** 		
 503:main.c        **** 		// Intel flash command based chips
 504:main.c        **** 		// Write 64 bytes to Flash address, combine 2 bytes and write one at a time (and increment addres
 505:main.c        **** 		else if (receivedChar == GBA_FLASH_WRITE_INTEL_64BYTE) {
 3511               		.loc 3 505 0
 3512 062a 9C36      		cpi r25,lo8(108)
 3513 062c 01F0      		breq .+2
 3514 062e 00C0      		rjmp .L150
 3515               	.LBB164:
 506:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 3516               		.loc 3 506 0
 3517 0630 939A      		sbi 0x12,3
 507:main.c        **** 			usart_read_bytes(64);
 3518               		.loc 3 507 0
 3519 0632 80E4      		ldi r24,lo8(64)
 3520 0634 90E0      		ldi r25,0
 3521               	.LVL351:
 3522 0636 00D0      		rcall usart_read_bytes
 3523               	.LVL352:
 508:main.c        **** 			
 509:main.c        **** 			// Set address lines as outputs
 510:main.c        **** 			GBA_DDR_ROM_ADDR23_16 = 0xFF;
 3524               		.loc 3 510 0
 3525 0638 8FEF      		ldi r24,lo8(-1)
 3526 063a 84BB      		out 0x14,r24
 511:main.c        **** 			GBA_DDR_ROM_ADDR15_8 = 0xFF;
 3527               		.loc 3 511 0
 3528 063c 8ABB      		out 0x1a,r24
 512:main.c        **** 			GBA_DDR_ROM_ADDR7_0 = 0xFF;
 3529               		.loc 3 512 0
 3530 063e 87BB      		out 0x17,r24
 513:main.c        **** 			
 514:main.c        **** 			// Unlock
 515:main.c        **** 			gba_flash_write_bus_cycle(address, 0x60);
 3531               		.loc 3 515 0
 3532 0640 40E6      		ldi r20,lo8(96)
 3533 0642 50E0      		ldi r21,0
 3534 0644 C701      		movw r24,r14
 3535 0646 B601      		movw r22,r12
 3536 0648 00D0      		rcall gba_flash_write_bus_cycle
 3537               	.LVL353:
 516:main.c        **** 			gba_flash_write_bus_cycle(address, 0xD0);
 3538               		.loc 3 516 0
 3539 064a 40ED      		ldi r20,lo8(-48)
 3540 064c 50E0      		ldi r21,0
 3541 064e C701      		movw r24,r14
 3542 0650 B601      		movw r22,r12
 3543 0652 00D0      		rcall gba_flash_write_bus_cycle
 3544               	.LVL354:
 517:main.c        **** 			
 518:main.c        **** 			// Buffered write command
 519:main.c        **** 			gba_flash_write_bus_cycle(address, 0xE8);
 3545               		.loc 3 519 0
 3546 0654 48EE      		ldi r20,lo8(-24)
 3547 0656 50E0      		ldi r21,0
 3548 0658 C701      		movw r24,r14
 3549 065a B601      		movw r22,r12
 3550 065c 00D0      		rcall gba_flash_write_bus_cycle
 3551               	.LVL355:
 3552               	.LBB165:
 3553               	.LBB166:
 3554               		.loc 2 276 0
 3555 065e 35E8      		ldi r19,lo8(-123)
 3556 0660 3A95      	1:	dec r19
 3557 0662 01F4      		brne 1b
 3558 0664 0000      		nop
 3559               	.LVL356:
 3560               	.LBE166:
 3561               	.LBE165:
 520:main.c        **** 			_delay_us(50);
 521:main.c        **** 			
 522:main.c        **** 			// Wait for first 2 bytes to be 0x80, 0x00
 523:main.c        **** 			uint16_t dataVerify = gba_read_16bit_data(address);
 3562               		.loc 3 523 0
 3563 0666 C701      		movw r24,r14
 3564 0668 B601      		movw r22,r12
 3565 066a 00D0      		rcall gba_read_16bit_data
 3566               	.LVL357:
 3567               	.L151:
 524:main.c        **** 			while (dataVerify != 0x0080) {
 3568               		.loc 3 524 0
 3569 066c 8038      		cpi r24,-128
 3570 066e 9105      		cpc r25,__zero_reg__
 3571 0670 01F0      		breq .L235
 525:main.c        **** 				dataVerify = gba_read_16bit_data(address);
 3572               		.loc 3 525 0
 3573 0672 C701      		movw r24,r14
 3574 0674 B601      		movw r22,r12
 3575 0676 00D0      		rcall gba_read_16bit_data
 3576               	.LVL358:
 3577               	.LBB167:
 3578               	.LBB168:
 3579               		.loc 2 276 0
 3580 0678 E5E8      		ldi r30,lo8(-123)
 3581 067a EA95      	1:	dec r30
 3582 067c 01F4      		brne 1b
 3583 067e 0000      		nop
 3584 0680 00C0      		rjmp .L151
 3585               	.LVL359:
 3586               	.L235:
 3587               	.LBE168:
 3588               	.LBE167:
 526:main.c        **** 				_delay_us(50);
 527:main.c        **** 			}
 528:main.c        **** 			
 529:main.c        **** 			
 530:main.c        **** 			// Set address lines as outputs
 531:main.c        **** 			GBA_DDR_ROM_ADDR23_16 = 0xFF;
 3589               		.loc 3 531 0
 3590 0682 8FEF      		ldi r24,lo8(-1)
 3591               	.LVL360:
 3592 0684 84BB      		out 0x14,r24
 532:main.c        **** 			GBA_DDR_ROM_ADDR15_8 = 0xFF;
 3593               		.loc 3 532 0
 3594 0686 8ABB      		out 0x1a,r24
 533:main.c        **** 			GBA_DDR_ROM_ADDR7_0 = 0xFF;
 3595               		.loc 3 533 0
 3596 0688 87BB      		out 0x17,r24
 534:main.c        **** 			
 535:main.c        **** 			// Set length
 536:main.c        **** 			gba_flash_write_bus_cycle(address, 0x1F);
 3597               		.loc 3 536 0
 3598 068a 4FE1      		ldi r20,lo8(31)
 3599 068c 50E0      		ldi r21,0
 3600 068e C701      		movw r24,r14
 3601 0690 B601      		movw r22,r12
 3602 0692 00D0      		rcall gba_flash_write_bus_cycle
 3603               	.LVL361:
 3604 0694 20E0      		ldi r18,lo8(receivedBuffer)
 3605 0696 30E0      		ldi r19,hi8(receivedBuffer)
 3606 0698 3C83      		std Y+4,r19
 3607 069a 2B83      		std Y+3,r18
 3608 069c 4601      		movw r8,r12
 3609 069e 5701      		movw r10,r14
 3610               	.LVL362:
 3611               	.L153:
 3612               	.LBB169:
 3613               	.LBB170:
 537:main.c        **** 			
 538:main.c        **** 			// Write data
 539:main.c        **** 			for (int x = 0; x < 64; x += 2) {
 540:main.c        **** 				uint16_t combinedBytes = (uint16_t) receivedBuffer[x+1] << 8 | (uint16_t) receivedBuffer[x];
 541:main.c        **** 				gba_flash_write_bus_cycle(address, combinedBytes);
 3614               		.loc 3 541 0 discriminator 3
 3615 06a0 EB81      		ldd r30,Y+3
 3616 06a2 FC81      		ldd r31,Y+4
 3617 06a4 4181      		ldd r20,Z+1
 3618 06a6 50E0      		ldi r21,0
 3619 06a8 542F      		mov r21,r20
 3620 06aa 4427      		clr r20
 3621 06ac 8081      		ld r24,Z
 3622 06ae 482B      		or r20,r24
 3623 06b0 C501      		movw r24,r10
 3624 06b2 B401      		movw r22,r8
 3625 06b4 00D0      		rcall gba_flash_write_bus_cycle
 3626               	.LVL363:
 542:main.c        **** 				address++;
 3627               		.loc 3 542 0 discriminator 3
 3628 06b6 FFEF      		ldi r31,-1
 3629 06b8 8F1A      		sub r8,r31
 3630 06ba 9F0A      		sbc r9,r31
 3631 06bc AF0A      		sbc r10,r31
 3632 06be BF0A      		sbc r11,r31
 3633               	.LVL364:
 3634 06c0 2B81      		ldd r18,Y+3
 3635 06c2 3C81      		ldd r19,Y+4
 3636 06c4 2E5F      		subi r18,-2
 3637 06c6 3F4F      		sbci r19,-1
 3638 06c8 3C83      		std Y+4,r19
 3639 06ca 2B83      		std Y+3,r18
 3640               	.LVL365:
 3641               	.LBE170:
 539:main.c        **** 				uint16_t combinedBytes = (uint16_t) receivedBuffer[x+1] << 8 | (uint16_t) receivedBuffer[x];
 3642               		.loc 3 539 0 discriminator 3
 3643 06cc 80E0      		ldi r24,lo8(receivedBuffer+64)
 3644 06ce 90E0      		ldi r25,hi8(receivedBuffer+64)
 3645 06d0 8217      		cp r24,r18
 3646 06d2 9307      		cpc r25,r19
 3647 06d4 01F4      		brne .L153
 3648 06d6 90E2      		ldi r25,32
 3649 06d8 C90E      		add r12,r25
 3650 06da D11C      		adc r13,__zero_reg__
 3651 06dc E11C      		adc r14,__zero_reg__
 3652 06de F11C      		adc r15,__zero_reg__
 3653               	.LBE169:
 543:main.c        **** 			}
 544:main.c        **** 			
 545:main.c        **** 			// Write buffer to flash
 546:main.c        **** 			gba_flash_write_bus_cycle(address, 0xD0);
 3654               		.loc 3 546 0
 3655 06e0 40ED      		ldi r20,lo8(-48)
 3656 06e2 50E0      		ldi r21,0
 3657 06e4 C701      		movw r24,r14
 3658 06e6 B601      		movw r22,r12
 3659 06e8 00D0      		rcall gba_flash_write_bus_cycle
 3660               	.LVL366:
 3661               	.LBB171:
 3662               	.LBB172:
 3663               		.loc 2 276 0
 3664 06ea EFE6      		ldi r30,lo8(879)
 3665 06ec F3E0      		ldi r31,hi8(879)
 3666 06ee 3197      	1:	sbiw r30,1
 3667 06f0 01F4      		brne 1b
 3668 06f2 00C0      		rjmp .
 3669 06f4 0000      		nop
 3670               	.LVL367:
 3671               	.LBE172:
 3672               	.LBE171:
 547:main.c        **** 			_delay_us(440);
 548:main.c        **** 			
 549:main.c        **** 			// Wait for first 2 bytes to be 0x80, 0x00
 550:main.c        **** 			dataVerify = gba_read_16bit_data(address);
 3673               		.loc 3 550 0
 3674 06f6 C701      		movw r24,r14
 3675 06f8 B601      		movw r22,r12
 3676 06fa 00D0      		rcall gba_read_16bit_data
 3677               	.LVL368:
 3678               	.L154:
 551:main.c        **** 			while (dataVerify != 0x0080) {
 3679               		.loc 3 551 0
 3680 06fc 8038      		cpi r24,-128
 3681 06fe 9105      		cpc r25,__zero_reg__
 3682 0700 01F0      		breq .L236
 552:main.c        **** 				dataVerify = gba_read_16bit_data(address);
 3683               		.loc 3 552 0
 3684 0702 C701      		movw r24,r14
 3685 0704 B601      		movw r22,r12
 3686 0706 00D0      		rcall gba_read_16bit_data
 3687               	.LVL369:
 3688               	.LBB173:
 3689               	.LBB174:
 3690               		.loc 2 276 0
 3691 0708 F5E8      		ldi r31,lo8(-123)
 3692 070a FA95      	1:	dec r31
 3693 070c 01F4      		brne 1b
 3694 070e 0000      		nop
 3695 0710 00C0      		rjmp .L154
 3696               	.LVL370:
 3697               	.L236:
 3698               	.LBE174:
 3699               	.LBE173:
 553:main.c        **** 				_delay_us(50);
 554:main.c        **** 			}
 555:main.c        **** 			
 556:main.c        **** 			
 557:main.c        **** 			// Set address lines as outputs
 558:main.c        **** 			GBA_DDR_ROM_ADDR23_16 = 0xFF;
 3700               		.loc 3 558 0
 3701 0712 8FEF      		ldi r24,lo8(-1)
 3702               	.LVL371:
 3703 0714 84BB      		out 0x14,r24
 3704               	.LVL372:
 559:main.c        **** 			GBA_DDR_ROM_ADDR15_8 = 0xFF;
 3705               		.loc 3 559 0
 3706 0716 8ABB      		out 0x1a,r24
 560:main.c        **** 			GBA_DDR_ROM_ADDR7_0 = 0xFF;
 3707               		.loc 3 560 0
 3708 0718 87BB      		out 0x17,r24
 561:main.c        **** 			
 562:main.c        **** 			// Back to reading mode
 563:main.c        **** 			gba_flash_write_bus_cycle(address, 0xFF);
 3709               		.loc 3 563 0
 3710 071a 4FEF      		ldi r20,lo8(-1)
 3711 071c 50E0      		ldi r21,0
 3712 071e C701      		movw r24,r14
 3713 0720 B601      		movw r22,r12
 3714 0722 00D0      		rcall gba_flash_write_bus_cycle
 3715               	.LVL373:
 3716               	.L223:
 564:main.c        **** 			
 565:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 3717               		.loc 3 565 0
 3718 0724 81E3      		ldi r24,lo8(49)
 3719 0726 00C0      		rjmp .L218
 3720               	.LVL374:
 3721               	.L150:
 3722               	.LBE164:
 566:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 567:main.c        **** 		}
 568:main.c        **** 		
 569:main.c        **** 		
 570:main.c        **** 		// ---------- General commands ----------
 571:main.c        **** 		// Set any pin as input/output
 572:main.c        **** 		// Reads the DDR/PORT (e.g. DDRB/PORTB is 'B') and the hex value that represents pins to set to a
 573:main.c        **** 		else if (receivedChar == SET_INPUT || receivedChar == SET_OUTPUT) {
 3723               		.loc 3 573 0
 3724 0728 9934      		cpi r25,lo8(73)
 3725 072a 01F0      		breq .L156
 3726               		.loc 3 573 0 is_stmt 0 discriminator 1
 3727 072c 9F34      		cpi r25,lo8(79)
 3728 072e 01F0      		breq .+2
 3729 0730 00C0      		rjmp .L157
 3730               	.L156:
 3731               	.LBB175:
 574:main.c        **** 			char portChar = USART_Receive();
 3732               		.loc 3 574 0 is_stmt 1
 3733 0732 00D0      		rcall USART_Receive
 3734               	.LVL375:
 3735 0734 8A83      		std Y+2,r24
 3736               	.LVL376:
 575:main.c        **** 			usart_read_chars();
 3737               		.loc 3 575 0
 3738 0736 00D0      		rcall usart_read_chars
 3739               	.LVL377:
 576:main.c        **** 			uint8_t setValue = strtol(receivedBuffer, NULL, 16);
 3740               		.loc 3 576 0
 3741 0738 40E1      		ldi r20,lo8(16)
 3742 073a 50E0      		ldi r21,0
 3743 073c 60E0      		ldi r22,0
 3744 073e 70E0      		ldi r23,0
 3745 0740 80E0      		ldi r24,lo8(receivedBuffer)
 3746 0742 90E0      		ldi r25,hi8(receivedBuffer)
 3747 0744 00D0      		rcall strtol
 3748               	.LVL378:
 577:main.c        **** 			
 578:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 3749               		.loc 3 578 0
 3750 0746 939A      		sbi 0x12,3
 579:main.c        **** 			if (receivedChar == SET_INPUT) {
 3751               		.loc 3 579 0
 3752 0748 8091 0000 		lds r24,receivedChar
 3753 074c 8934      		cpi r24,lo8(73)
 3754 074e 01F4      		brne .L158
 580:main.c        **** 				if (portChar == 'A') {
 3755               		.loc 3 580 0
 3756 0750 2A81      		ldd r18,Y+2
 3757 0752 2134      		cpi r18,lo8(65)
 3758 0754 01F4      		brne .L159
 581:main.c        **** 					DDRA &= ~(setValue);
 3759               		.loc 3 581 0
 3760 0756 8AB3      		in r24,0x1a
 3761 0758 6095      		com r22
 3762               	.LVL379:
 3763 075a 6823      		and r22,r24
 3764               	.LVL380:
 3765 075c 00C0      		rjmp .L225
 3766               	.LVL381:
 3767               	.L159:
 582:main.c        **** 				}
 583:main.c        **** 				else if (portChar == 'B') {
 3768               		.loc 3 583 0
 3769 075e 3A81      		ldd r19,Y+2
 3770 0760 3234      		cpi r19,lo8(66)
 3771 0762 01F4      		brne .L161
 584:main.c        **** 					DDRB &= ~(setValue);
 3772               		.loc 3 584 0
 3773 0764 87B3      		in r24,0x17
 3774 0766 6095      		com r22
 3775               	.LVL382:
 3776 0768 6823      		and r22,r24
 3777               	.LVL383:
 3778 076a 00C0      		rjmp .L226
 3779               	.LVL384:
 3780               	.L161:
 585:main.c        **** 				}
 586:main.c        **** 				else if (portChar == 'C') {
 3781               		.loc 3 586 0
 3782 076c 8A81      		ldd r24,Y+2
 3783 076e 8334      		cpi r24,lo8(67)
 3784 0770 01F4      		brne .L162
 587:main.c        **** 					DDRC &= ~(setValue);
 3785               		.loc 3 587 0
 3786 0772 84B3      		in r24,0x14
 3787 0774 6095      		com r22
 3788               	.LVL385:
 3789 0776 6823      		and r22,r24
 3790               	.LVL386:
 3791 0778 00C0      		rjmp .L231
 3792               	.LVL387:
 3793               	.L162:
 588:main.c        **** 				}
 589:main.c        **** 				else if (portChar == 'D') {
 3794               		.loc 3 589 0
 3795 077a 9A81      		ldd r25,Y+2
 3796 077c 9434      		cpi r25,lo8(68)
 3797 077e 01F4      		brne .L163
 590:main.c        **** 					DDRD &= ~(setValue);
 3798               		.loc 3 590 0
 3799 0780 81B3      		in r24,0x11
 3800 0782 6095      		com r22
 3801               	.LVL388:
 3802 0784 6823      		and r22,r24
 3803               	.LVL389:
 3804 0786 00C0      		rjmp .L232
 3805               	.LVL390:
 3806               	.L163:
 591:main.c        **** 				}
 592:main.c        **** 				else if (portChar == 'E') {
 3807               		.loc 3 592 0
 3808 0788 EA81      		ldd r30,Y+2
 3809 078a E534      		cpi r30,lo8(69)
 3810 078c 01F0      		breq .+2
 3811 078e 00C0      		rjmp .L182
 593:main.c        **** 					DDRE &= ~(setValue);
 3812               		.loc 3 593 0
 3813 0790 86B1      		in r24,0x6
 3814 0792 6095      		com r22
 3815               	.LVL391:
 3816 0794 6823      		and r22,r24
 3817               	.LVL392:
 3818 0796 00C0      		rjmp .L233
 3819               	.LVL393:
 3820               	.L158:
 594:main.c        **** 				}
 595:main.c        **** 			}
 596:main.c        **** 			else if (receivedChar == SET_OUTPUT) {
 3821               		.loc 3 596 0
 3822 0798 8F34      		cpi r24,lo8(79)
 3823 079a 01F0      		breq .+2
 3824 079c 00C0      		rjmp .L182
 597:main.c        **** 				if (portChar == 'A') {
 3825               		.loc 3 597 0
 3826 079e FA81      		ldd r31,Y+2
 3827 07a0 F134      		cpi r31,lo8(65)
 3828 07a2 01F4      		brne .L164
 598:main.c        **** 					DDRA |= (setValue);
 3829               		.loc 3 598 0
 3830 07a4 8AB3      		in r24,0x1a
 3831 07a6 682B      		or r22,r24
 3832               	.LVL394:
 3833               	.L225:
 3834 07a8 6ABB      		out 0x1a,r22
 3835               	.LVL395:
 3836 07aa 00C0      		rjmp .L182
 3837               	.LVL396:
 3838               	.L164:
 599:main.c        **** 				}
 600:main.c        **** 				else if (portChar == 'B') {
 3839               		.loc 3 600 0
 3840 07ac 2A81      		ldd r18,Y+2
 3841 07ae 2234      		cpi r18,lo8(66)
 3842 07b0 01F4      		brne .L165
 601:main.c        **** 					DDRB |= (setValue);
 3843               		.loc 3 601 0
 3844 07b2 87B3      		in r24,0x17
 3845 07b4 682B      		or r22,r24
 3846               	.LVL397:
 3847               	.L226:
 3848 07b6 67BB      		out 0x17,r22
 3849               	.LVL398:
 3850 07b8 00C0      		rjmp .L182
 3851               	.LVL399:
 3852               	.L165:
 602:main.c        **** 				}
 603:main.c        **** 				else if (portChar == 'C') {
 3853               		.loc 3 603 0
 3854 07ba 3A81      		ldd r19,Y+2
 3855 07bc 3334      		cpi r19,lo8(67)
 3856 07be 01F4      		brne .L166
 604:main.c        **** 					DDRC |= (setValue);
 3857               		.loc 3 604 0
 3858 07c0 84B3      		in r24,0x14
 3859 07c2 682B      		or r22,r24
 3860               	.LVL400:
 3861               	.L231:
 3862 07c4 64BB      		out 0x14,r22
 3863               	.LVL401:
 3864 07c6 00C0      		rjmp .L182
 3865               	.LVL402:
 3866               	.L166:
 605:main.c        **** 				}
 606:main.c        **** 				else if (portChar == 'D') {
 3867               		.loc 3 606 0
 3868 07c8 8A81      		ldd r24,Y+2
 3869 07ca 8434      		cpi r24,lo8(68)
 3870 07cc 01F4      		brne .L167
 607:main.c        **** 					DDRD |= (setValue);
 3871               		.loc 3 607 0
 3872 07ce 81B3      		in r24,0x11
 3873 07d0 682B      		or r22,r24
 3874               	.LVL403:
 3875               	.L232:
 3876 07d2 61BB      		out 0x11,r22
 3877               	.LVL404:
 3878 07d4 00C0      		rjmp .L182
 3879               	.LVL405:
 3880               	.L167:
 608:main.c        **** 				}
 609:main.c        **** 				else if (portChar == 'E') {
 3881               		.loc 3 609 0
 3882 07d6 9A81      		ldd r25,Y+2
 3883 07d8 9534      		cpi r25,lo8(69)
 3884 07da 01F0      		breq .+2
 3885 07dc 00C0      		rjmp .L182
 610:main.c        **** 					DDRE |= (setValue);
 3886               		.loc 3 610 0
 3887 07de 86B1      		in r24,0x6
 3888 07e0 682B      		or r22,r24
 3889               	.LVL406:
 3890               	.L233:
 3891 07e2 66B9      		out 0x6,r22
 3892               	.LVL407:
 3893 07e4 00C0      		rjmp .L182
 3894               	.LVL408:
 3895               	.L157:
 3896               	.LBE175:
 611:main.c        **** 				}
 612:main.c        **** 			}
 613:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 614:main.c        **** 		}
 615:main.c        **** 		
 616:main.c        **** 		// Set pin output as low
 617:main.c        **** 		else if (receivedChar == SET_OUTPUT_LOW) {
 3897               		.loc 3 617 0
 3898 07e6 9C34      		cpi r25,lo8(76)
 3899 07e8 01F4      		brne .L168
 3900               	.LBB176:
 618:main.c        **** 			char portChar = USART_Receive();			
 3901               		.loc 3 618 0
 3902 07ea 00D0      		rcall USART_Receive
 3903               	.LVL409:
 3904 07ec 8A83      		std Y+2,r24
 3905               	.LVL410:
 619:main.c        **** 			usart_read_chars();
 3906               		.loc 3 619 0
 3907 07ee 00D0      		rcall usart_read_chars
 3908               	.LVL411:
 620:main.c        **** 			uint8_t setValue = strtol(receivedBuffer, NULL, 16);
 3909               		.loc 3 620 0
 3910 07f0 40E1      		ldi r20,lo8(16)
 3911 07f2 50E0      		ldi r21,0
 3912 07f4 60E0      		ldi r22,0
 3913 07f6 70E0      		ldi r23,0
 3914 07f8 80E0      		ldi r24,lo8(receivedBuffer)
 3915 07fa 90E0      		ldi r25,hi8(receivedBuffer)
 3916 07fc 00D0      		rcall strtol
 3917               	.LVL412:
 621:main.c        **** 			
 622:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 3918               		.loc 3 622 0
 3919 07fe 939A      		sbi 0x12,3
 623:main.c        **** 			if (portChar == 'A') {
 3920               		.loc 3 623 0
 3921 0800 EA81      		ldd r30,Y+2
 3922 0802 E134      		cpi r30,lo8(65)
 3923 0804 01F4      		brne .L169
 624:main.c        **** 				PORTA &= ~(setValue);
 3924               		.loc 3 624 0
 3925 0806 8BB3      		in r24,0x1b
 3926 0808 6095      		com r22
 3927               	.LVL413:
 3928 080a 6823      		and r22,r24
 3929               	.LVL414:
 3930 080c 00C0      		rjmp .L230
 3931               	.LVL415:
 3932               	.L169:
 625:main.c        **** 			}
 626:main.c        **** 			else if (portChar == 'B') {
 3933               		.loc 3 626 0
 3934 080e FA81      		ldd r31,Y+2
 3935 0810 F234      		cpi r31,lo8(66)
 3936 0812 01F4      		brne .L171
 627:main.c        **** 				PORTB &= ~(setValue);
 3937               		.loc 3 627 0
 3938 0814 88B3      		in r24,0x18
 3939 0816 6095      		com r22
 3940               	.LVL416:
 3941 0818 6823      		and r22,r24
 3942               	.LVL417:
 3943 081a 00C0      		rjmp .L229
 3944               	.LVL418:
 3945               	.L171:
 628:main.c        **** 			}
 629:main.c        **** 			else if (portChar == 'C') {
 3946               		.loc 3 629 0
 3947 081c 2A81      		ldd r18,Y+2
 3948 081e 2334      		cpi r18,lo8(67)
 3949 0820 01F4      		brne .L172
 630:main.c        **** 				PORTC &= ~(setValue);
 3950               		.loc 3 630 0
 3951 0822 85B3      		in r24,0x15
 3952 0824 6095      		com r22
 3953               	.LVL419:
 3954 0826 6823      		and r22,r24
 3955               	.LVL420:
 3956 0828 00C0      		rjmp .L228
 3957               	.LVL421:
 3958               	.L172:
 631:main.c        **** 			}
 632:main.c        **** 			else if (portChar == 'D') {
 3959               		.loc 3 632 0
 3960 082a 3A81      		ldd r19,Y+2
 3961 082c 3434      		cpi r19,lo8(68)
 3962 082e 01F4      		brne .L173
 633:main.c        **** 				PORTD &= ~(setValue);
 3963               		.loc 3 633 0
 3964 0830 82B3      		in r24,0x12
 3965 0832 6095      		com r22
 3966               	.LVL422:
 3967 0834 6823      		and r22,r24
 3968               	.LVL423:
 3969 0836 00C0      		rjmp .L227
 3970               	.LVL424:
 3971               	.L173:
 634:main.c        **** 			}
 635:main.c        **** 			else if (portChar == 'E') {
 3972               		.loc 3 635 0
 3973 0838 8A81      		ldd r24,Y+2
 3974 083a 8534      		cpi r24,lo8(69)
 3975 083c 01F0      		breq .+2
 3976 083e 00C0      		rjmp .L182
 636:main.c        **** 				PORTE &= ~(setValue);
 3977               		.loc 3 636 0
 3978 0840 87B1      		in r24,0x7
 3979 0842 6095      		com r22
 3980               	.LVL425:
 3981 0844 6823      		and r22,r24
 3982               	.LVL426:
 3983 0846 00C0      		rjmp .L224
 3984               	.LVL427:
 3985               	.L168:
 3986               	.LBE176:
 637:main.c        **** 			}
 638:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 639:main.c        **** 		}
 640:main.c        **** 		
 641:main.c        **** 		// Set pin output as high
 642:main.c        **** 		else if (receivedChar == SET_OUTPUT_HIGH) {
 3987               		.loc 3 642 0
 3988 0848 9834      		cpi r25,lo8(72)
 3989 084a 01F4      		brne .L174
 3990               	.LBB177:
 643:main.c        **** 			char portChar = USART_Receive();			
 3991               		.loc 3 643 0
 3992 084c 00D0      		rcall USART_Receive
 3993               	.LVL428:
 3994 084e 8A83      		std Y+2,r24
 3995               	.LVL429:
 644:main.c        **** 			usart_read_chars();
 3996               		.loc 3 644 0
 3997 0850 00D0      		rcall usart_read_chars
 3998               	.LVL430:
 645:main.c        **** 			uint8_t setValue = strtol(receivedBuffer, NULL, 16);
 3999               		.loc 3 645 0
 4000 0852 40E1      		ldi r20,lo8(16)
 4001 0854 50E0      		ldi r21,0
 4002 0856 60E0      		ldi r22,0
 4003 0858 70E0      		ldi r23,0
 4004 085a 80E0      		ldi r24,lo8(receivedBuffer)
 4005 085c 90E0      		ldi r25,hi8(receivedBuffer)
 4006 085e 00D0      		rcall strtol
 4007               	.LVL431:
 646:main.c        **** 			
 647:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 4008               		.loc 3 647 0
 4009 0860 939A      		sbi 0x12,3
 648:main.c        **** 			if (portChar == 'A') {
 4010               		.loc 3 648 0
 4011 0862 9A81      		ldd r25,Y+2
 4012 0864 9134      		cpi r25,lo8(65)
 4013 0866 01F4      		brne .L175
 649:main.c        **** 				PORTA |= (setValue);
 4014               		.loc 3 649 0
 4015 0868 8BB3      		in r24,0x1b
 4016 086a 682B      		or r22,r24
 4017               	.LVL432:
 4018               	.L230:
 4019 086c 6BBB      		out 0x1b,r22
 4020 086e 00C0      		rjmp .L182
 4021               	.LVL433:
 4022               	.L175:
 650:main.c        **** 			}
 651:main.c        **** 			else if (portChar == 'B') {
 4023               		.loc 3 651 0
 4024 0870 EA81      		ldd r30,Y+2
 4025 0872 E234      		cpi r30,lo8(66)
 4026 0874 01F4      		brne .L177
 652:main.c        **** 				PORTB |= (setValue);
 4027               		.loc 3 652 0
 4028 0876 88B3      		in r24,0x18
 4029 0878 682B      		or r22,r24
 4030               	.LVL434:
 4031               	.L229:
 4032 087a 68BB      		out 0x18,r22
 4033 087c 00C0      		rjmp .L182
 4034               	.LVL435:
 4035               	.L177:
 653:main.c        **** 			}
 654:main.c        **** 			else if (portChar == 'C') {
 4036               		.loc 3 654 0
 4037 087e FA81      		ldd r31,Y+2
 4038 0880 F334      		cpi r31,lo8(67)
 4039 0882 01F4      		brne .L178
 655:main.c        **** 				PORTC |= (setValue);
 4040               		.loc 3 655 0
 4041 0884 85B3      		in r24,0x15
 4042 0886 682B      		or r22,r24
 4043               	.LVL436:
 4044               	.L228:
 4045 0888 65BB      		out 0x15,r22
 4046 088a 00C0      		rjmp .L182
 4047               	.LVL437:
 4048               	.L178:
 656:main.c        **** 			}
 657:main.c        **** 			else if (portChar == 'D') {
 4049               		.loc 3 657 0
 4050 088c 2A81      		ldd r18,Y+2
 4051 088e 2434      		cpi r18,lo8(68)
 4052 0890 01F4      		brne .L179
 658:main.c        **** 				PORTD |= (setValue);
 4053               		.loc 3 658 0
 4054 0892 82B3      		in r24,0x12
 4055 0894 682B      		or r22,r24
 4056               	.LVL438:
 4057               	.L227:
 4058 0896 62BB      		out 0x12,r22
 4059 0898 00C0      		rjmp .L182
 4060               	.LVL439:
 4061               	.L179:
 659:main.c        **** 			}
 660:main.c        **** 			else if (portChar == 'E') {
 4062               		.loc 3 660 0
 4063 089a 3A81      		ldd r19,Y+2
 4064 089c 3534      		cpi r19,lo8(69)
 4065 089e 01F4      		brne .L182
 661:main.c        **** 				PORTE |= (setValue);
 4066               		.loc 3 661 0
 4067 08a0 87B1      		in r24,0x7
 4068 08a2 682B      		or r22,r24
 4069               	.LVL440:
 4070               	.L224:
 4071 08a4 67B9      		out 0x7,r22
 4072 08a6 00C0      		rjmp .L182
 4073               	.LVL441:
 4074               	.L174:
 4075               	.LBE177:
 662:main.c        **** 			}
 663:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 664:main.c        **** 		}
 665:main.c        **** 		
 666:main.c        **** 		// Read all pins of a PORT and return the value
 667:main.c        **** 		else if (receivedChar == READ_INPUT) {
 4076               		.loc 3 667 0
 4077 08a8 9434      		cpi r25,lo8(68)
 4078 08aa 01F4      		brne .L180
 4079               	.LBB178:
 668:main.c        **** 			char portChar = USART_Receive();			
 4080               		.loc 3 668 0
 4081 08ac 00D0      		rcall USART_Receive
 4082               	.LVL442:
 669:main.c        **** 			
 670:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 4083               		.loc 3 670 0
 4084 08ae 939A      		sbi 0x12,3
 671:main.c        **** 			if (portChar == 'A') {
 4085               		.loc 3 671 0
 4086 08b0 8134      		cpi r24,lo8(65)
 4087 08b2 01F4      		brne .L181
 672:main.c        **** 				USART_Transmit(PINA);
 4088               		.loc 3 672 0
 4089 08b4 89B3      		in r24,0x19
 4090               	.LVL443:
 4091 08b6 00C0      		rjmp .L218
 4092               	.LVL444:
 4093               	.L181:
 673:main.c        **** 			}
 674:main.c        **** 			else if (portChar == 'B') {
 4094               		.loc 3 674 0
 4095 08b8 8234      		cpi r24,lo8(66)
 4096 08ba 01F4      		brne .L183
 675:main.c        **** 				USART_Transmit(PINB);
 4097               		.loc 3 675 0
 4098 08bc 86B3      		in r24,0x16
 4099               	.LVL445:
 4100 08be 00C0      		rjmp .L218
 4101               	.LVL446:
 4102               	.L183:
 676:main.c        **** 			}
 677:main.c        **** 			else if (portChar == 'C') {
 4103               		.loc 3 677 0
 4104 08c0 8334      		cpi r24,lo8(67)
 4105 08c2 01F4      		brne .L184
 678:main.c        **** 				USART_Transmit(PINC);
 4106               		.loc 3 678 0
 4107 08c4 83B3      		in r24,0x13
 4108               	.LVL447:
 4109 08c6 00C0      		rjmp .L218
 4110               	.LVL448:
 4111               	.L184:
 679:main.c        **** 			}
 680:main.c        **** 			else if (portChar == 'D') {
 4112               		.loc 3 680 0
 4113 08c8 8434      		cpi r24,lo8(68)
 4114 08ca 01F4      		brne .L185
 681:main.c        **** 				USART_Transmit(PIND);
 4115               		.loc 3 681 0
 4116 08cc 80B3      		in r24,0x10
 4117               	.LVL449:
 4118 08ce 00C0      		rjmp .L218
 4119               	.LVL450:
 4120               	.L185:
 682:main.c        **** 			}
 683:main.c        **** 			else if (portChar == 'E') {
 4121               		.loc 3 683 0
 4122 08d0 8534      		cpi r24,lo8(69)
 4123 08d2 01F4      		brne .L182
 684:main.c        **** 				USART_Transmit(PINE);
 4124               		.loc 3 684 0
 4125 08d4 85B1      		in r24,0x5
 4126               	.LVL451:
 4127               	.L218:
 4128 08d6 00D0      		rcall USART_Transmit
 4129               	.LVL452:
 4130               	.L182:
 685:main.c        **** 			}
 686:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 4131               		.loc 3 686 0
 4132 08d8 9398      		cbi 0x12,3
 4133               	.LBE178:
 4134 08da 00C0      		rjmp .L90
 4135               	.LVL453:
 4136               	.L180:
 687:main.c        **** 		}
 688:main.c        **** 		
 689:main.c        **** 		// Set the reset common lines variable on or off, useful if you are controlling all the pins dire
 690:main.c        **** 		else if (receivedChar == RESET_COMMON_LINES) {
 4137               		.loc 3 690 0
 4138 08dc 9D34      		cpi r25,lo8(77)
 4139 08de 01F4      		brne .L186
 4140               	.LBB179:
 691:main.c        **** 			char commonChar = USART_Receive();
 4141               		.loc 3 691 0
 4142 08e0 00D0      		rcall USART_Receive
 4143               	.LVL454:
 692:main.c        **** 			if (commonChar == '1') {
 4144               		.loc 3 692 0
 4145 08e2 8133      		cpi r24,lo8(49)
 4146 08e4 01F4      		brne .L237
 693:main.c        **** 				resetCommonLines = 1;
 4147               		.loc 3 693 0
 4148 08e6 31E0      		ldi r19,lo8(1)
 4149 08e8 3983      		std Y+1,r19
 4150 08ea 00C0      		rjmp .L214
 4151               	.L237:
 694:main.c        **** 			}
 695:main.c        **** 			else if (commonChar == '0') {
 4152               		.loc 3 695 0
 4153 08ec 8033      		cpi r24,lo8(48)
 4154 08ee 01F0      		breq .+2
 4155 08f0 00C0      		rjmp .L90
 696:main.c        **** 				resetCommonLines = 0;
 4156               		.loc 3 696 0
 4157 08f2 1982      		std Y+1,__zero_reg__
 4158 08f4 00C0      		rjmp .L91
 4159               	.LVL455:
 4160               	.L186:
 4161               	.LBE179:
 697:main.c        **** 			}
 698:main.c        **** 		}
 699:main.c        **** 		
 700:main.c        **** 		// Send back the PCB version number
 701:main.c        **** 		else if (receivedChar == READ_PCB_VERSION) {
 4162               		.loc 3 701 0
 4163 08f6 9836      		cpi r25,lo8(104)
 4164 08f8 01F4      		brne .L187
 702:main.c        **** 			USART_Transmit(PCB_VERSION);
 4165               		.loc 3 702 0
 4166 08fa 82E0      		ldi r24,lo8(2)
 4167               	.LVL456:
 4168 08fc 00C0      		rjmp .L215
 4169               	.LVL457:
 4170               	.L187:
 703:main.c        **** 		}
 704:main.c        **** 		
 705:main.c        **** 		// Send back the firmware version number
 706:main.c        **** 		else if (receivedChar == READ_FIRMWARE_VERSION) {
 4171               		.loc 3 706 0
 4172 08fe 9635      		cpi r25,lo8(86)
 4173 0900 01F4      		brne .L188
 707:main.c        **** 			USART_Transmit(FIRMWARE_VERSION);
 4174               		.loc 3 707 0
 4175 0902 8BE0      		ldi r24,lo8(11)
 4176               	.LVL458:
 4177               	.L215:
 4178 0904 00D0      		rcall USART_Transmit
 4179               	.LVL459:
 4180 0906 00C0      		rjmp .L90
 4181               	.LVL460:
 4182               	.L188:
 708:main.c        **** 		}
 709:main.c        **** 		
 710:main.c        **** 		// Reset the AVR if it matches the number
 711:main.c        **** 		else if (receivedChar == RESET_AVR) {
 4183               		.loc 3 711 0
 4184 0908 9A32      		cpi r25,lo8(42)
 4185 090a 01F0      		breq .+2
 4186 090c 00C0      		rjmp .L90
 4187               	.LBB180:
 712:main.c        **** 			usart_read_chars();
 4188               		.loc 3 712 0
 4189 090e 00D0      		rcall usart_read_chars
 4190               	.LVL461:
 713:main.c        **** 			uint32_t resetValue = strtol(receivedBuffer, NULL, 16);
 4191               		.loc 3 713 0
 4192 0910 40E1      		ldi r20,lo8(16)
 4193 0912 50E0      		ldi r21,0
 4194 0914 60E0      		ldi r22,0
 4195 0916 70E0      		ldi r23,0
 4196 0918 80E0      		ldi r24,lo8(receivedBuffer)
 4197 091a 90E0      		ldi r25,hi8(receivedBuffer)
 4198 091c 00D0      		rcall strtol
 4199               	.LVL462:
 714:main.c        **** 			if (resetValue == RESET_VALUE) {
 4200               		.loc 3 714 0
 4201 091e 613E      		cpi r22,-31
 4202 0920 754E      		sbci r23,-27
 4203 0922 8740      		sbci r24,7
 4204 0924 9105      		cpc r25,__zero_reg__
 4205 0926 01F0      		breq .+2
 4206 0928 00C0      		rjmp .L90
 715:main.c        **** 				// Clear watchdog flag
 716:main.c        **** 				MCUCSR &= ~(1<<WDRF);
 4207               		.loc 3 716 0
 4208 092a 84B7      		in r24,0x34
 4209 092c 877F      		andi r24,lo8(-9)
 4210 092e 84BF      		out 0x34,r24
 717:main.c        **** 				
 718:main.c        **** 				// Start timed sequence
 719:main.c        **** 				WDTCR = (1<<WDCE) | (1<<WDE);
 4211               		.loc 3 719 0
 4212 0930 F8E1      		ldi r31,lo8(24)
 4213 0932 F1BD      		out 0x21,r31
 720:main.c        **** 				
 721:main.c        **** 				// Reset in 250 ms
 722:main.c        **** 				WDTCR = (1<<WDP2) | (1<<WDE);
 4214               		.loc 3 722 0
 4215 0934 2CE0      		ldi r18,lo8(12)
 4216 0936 21BD      		out 0x21,r18
 4217               	.LVL463:
 4218               	.LBB181:
 4219               	.LBB182:
 4220               		.file 4 "c:\\winavr-20100110\\avr\\include\\util\\delay_basic.h"
   1:c:\winavr-20100110\avr\include\util\delay_basic.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:c:\winavr-20100110\avr\include\util\delay_basic.h ****    Copyright (c) 2007 Joerg Wunsch
   3:c:\winavr-20100110\avr\include\util\delay_basic.h ****    All rights reserved.
   4:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
   5:c:\winavr-20100110\avr\include\util\delay_basic.h ****    Redistribution and use in source and binary forms, with or without
   6:c:\winavr-20100110\avr\include\util\delay_basic.h ****    modification, are permitted provided that the following conditions are met:
   7:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
   8:c:\winavr-20100110\avr\include\util\delay_basic.h ****    * Redistributions of source code must retain the above copyright
   9:c:\winavr-20100110\avr\include\util\delay_basic.h ****      notice, this list of conditions and the following disclaimer.
  10:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  11:c:\winavr-20100110\avr\include\util\delay_basic.h ****    * Redistributions in binary form must reproduce the above copyright
  12:c:\winavr-20100110\avr\include\util\delay_basic.h ****      notice, this list of conditions and the following disclaimer in
  13:c:\winavr-20100110\avr\include\util\delay_basic.h ****      the documentation and/or other materials provided with the
  14:c:\winavr-20100110\avr\include\util\delay_basic.h ****      distribution.
  15:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  16:c:\winavr-20100110\avr\include\util\delay_basic.h ****    * Neither the name of the copyright holders nor the names of
  17:c:\winavr-20100110\avr\include\util\delay_basic.h ****      contributors may be used to endorse or promote products derived
  18:c:\winavr-20100110\avr\include\util\delay_basic.h ****      from this software without specific prior written permission.
  19:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  20:c:\winavr-20100110\avr\include\util\delay_basic.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  21:c:\winavr-20100110\avr\include\util\delay_basic.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  22:c:\winavr-20100110\avr\include\util\delay_basic.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  23:c:\winavr-20100110\avr\include\util\delay_basic.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  24:c:\winavr-20100110\avr\include\util\delay_basic.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  25:c:\winavr-20100110\avr\include\util\delay_basic.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  26:c:\winavr-20100110\avr\include\util\delay_basic.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  27:c:\winavr-20100110\avr\include\util\delay_basic.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  28:c:\winavr-20100110\avr\include\util\delay_basic.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  29:c:\winavr-20100110\avr\include\util\delay_basic.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  30:c:\winavr-20100110\avr\include\util\delay_basic.h ****   POSSIBILITY OF SUCH DAMAGE. */
  31:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  32:c:\winavr-20100110\avr\include\util\delay_basic.h **** /* $Id$ */
  33:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  34:c:\winavr-20100110\avr\include\util\delay_basic.h **** #ifndef _UTIL_DELAY_BASIC_H_
  35:c:\winavr-20100110\avr\include\util\delay_basic.h **** #define _UTIL_DELAY_BASIC_H_ 1
  36:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  37:c:\winavr-20100110\avr\include\util\delay_basic.h **** #include <inttypes.h>
  38:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  39:c:\winavr-20100110\avr\include\util\delay_basic.h **** #if !defined(__DOXYGEN__)
  40:c:\winavr-20100110\avr\include\util\delay_basic.h **** static __inline__ void _delay_loop_1(uint8_t __count) __attribute__((__always_inline__));
  41:c:\winavr-20100110\avr\include\util\delay_basic.h **** static __inline__ void _delay_loop_2(uint16_t __count) __attribute__((__always_inline__));
  42:c:\winavr-20100110\avr\include\util\delay_basic.h **** #endif
  43:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  44:c:\winavr-20100110\avr\include\util\delay_basic.h **** /** \file */
  45:c:\winavr-20100110\avr\include\util\delay_basic.h **** /** \defgroup util_delay_basic <util/delay_basic.h>: Basic busy-wait delay loops
  46:c:\winavr-20100110\avr\include\util\delay_basic.h ****     \code
  47:c:\winavr-20100110\avr\include\util\delay_basic.h ****     #include <util/delay_basic.h>
  48:c:\winavr-20100110\avr\include\util\delay_basic.h ****     \endcode
  49:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  50:c:\winavr-20100110\avr\include\util\delay_basic.h ****     The functions in this header file implement simple delay loops
  51:c:\winavr-20100110\avr\include\util\delay_basic.h ****     that perform a busy-waiting.  They are typically used to
  52:c:\winavr-20100110\avr\include\util\delay_basic.h ****     facilitate short delays in the program execution.  They are
  53:c:\winavr-20100110\avr\include\util\delay_basic.h ****     implemented as count-down loops with a well-known CPU cycle
  54:c:\winavr-20100110\avr\include\util\delay_basic.h ****     count per loop iteration.  As such, no other processing can
  55:c:\winavr-20100110\avr\include\util\delay_basic.h ****     occur simultaneously.  It should be kept in mind that the
  56:c:\winavr-20100110\avr\include\util\delay_basic.h ****     functions described here do not disable interrupts.
  57:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  58:c:\winavr-20100110\avr\include\util\delay_basic.h ****     In general, for long delays, the use of hardware timers is
  59:c:\winavr-20100110\avr\include\util\delay_basic.h ****     much preferrable, as they free the CPU, and allow for
  60:c:\winavr-20100110\avr\include\util\delay_basic.h ****     concurrent processing of other events while the timer is
  61:c:\winavr-20100110\avr\include\util\delay_basic.h ****     running.  However, in particular for very short delays, the
  62:c:\winavr-20100110\avr\include\util\delay_basic.h ****     overhead of setting up a hardware timer is too much compared
  63:c:\winavr-20100110\avr\include\util\delay_basic.h ****     to the overall delay time.
  64:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  65:c:\winavr-20100110\avr\include\util\delay_basic.h ****     Two inline functions are provided for the actual delay algorithms.
  66:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  67:c:\winavr-20100110\avr\include\util\delay_basic.h **** */
  68:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  69:c:\winavr-20100110\avr\include\util\delay_basic.h **** /** \ingroup util_delay_basic
  70:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  71:c:\winavr-20100110\avr\include\util\delay_basic.h ****     Delay loop using an 8-bit counter \c __count, so up to 256
  72:c:\winavr-20100110\avr\include\util\delay_basic.h ****     iterations are possible.  (The value 256 would have to be passed
  73:c:\winavr-20100110\avr\include\util\delay_basic.h ****     as 0.)  The loop executes three CPU cycles per iteration, not
  74:c:\winavr-20100110\avr\include\util\delay_basic.h ****     including the overhead the compiler needs to setup the counter
  75:c:\winavr-20100110\avr\include\util\delay_basic.h ****     register.
  76:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  77:c:\winavr-20100110\avr\include\util\delay_basic.h ****     Thus, at a CPU speed of 1 MHz, delays of up to 768 microseconds
  78:c:\winavr-20100110\avr\include\util\delay_basic.h ****     can be achieved.
  79:c:\winavr-20100110\avr\include\util\delay_basic.h **** */
  80:c:\winavr-20100110\avr\include\util\delay_basic.h **** void
  81:c:\winavr-20100110\avr\include\util\delay_basic.h **** _delay_loop_1(uint8_t __count)
  82:c:\winavr-20100110\avr\include\util\delay_basic.h **** {
  83:c:\winavr-20100110\avr\include\util\delay_basic.h **** 	__asm__ volatile (
  84:c:\winavr-20100110\avr\include\util\delay_basic.h **** 		"1: dec %0" "\n\t"
  85:c:\winavr-20100110\avr\include\util\delay_basic.h **** 		"brne 1b"
  86:c:\winavr-20100110\avr\include\util\delay_basic.h **** 		: "=r" (__count)
  87:c:\winavr-20100110\avr\include\util\delay_basic.h **** 		: "0" (__count)
  88:c:\winavr-20100110\avr\include\util\delay_basic.h **** 	);
  89:c:\winavr-20100110\avr\include\util\delay_basic.h **** }
  90:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  91:c:\winavr-20100110\avr\include\util\delay_basic.h **** /** \ingroup util_delay_basic
  92:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  93:c:\winavr-20100110\avr\include\util\delay_basic.h ****     Delay loop using a 16-bit counter \c __count, so up to 65536
  94:c:\winavr-20100110\avr\include\util\delay_basic.h ****     iterations are possible.  (The value 65536 would have to be
  95:c:\winavr-20100110\avr\include\util\delay_basic.h ****     passed as 0.)  The loop executes four CPU cycles per iteration,
  96:c:\winavr-20100110\avr\include\util\delay_basic.h ****     not including the overhead the compiler requires to setup the
  97:c:\winavr-20100110\avr\include\util\delay_basic.h ****     counter register pair.
  98:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  99:c:\winavr-20100110\avr\include\util\delay_basic.h ****     Thus, at a CPU speed of 1 MHz, delays of up to about 262.1
 100:c:\winavr-20100110\avr\include\util\delay_basic.h ****     milliseconds can be achieved.
 101:c:\winavr-20100110\avr\include\util\delay_basic.h ****  */
 102:c:\winavr-20100110\avr\include\util\delay_basic.h **** void
 103:c:\winavr-20100110\avr\include\util\delay_basic.h **** _delay_loop_2(uint16_t __count)
 104:c:\winavr-20100110\avr\include\util\delay_basic.h **** {
 105:c:\winavr-20100110\avr\include\util\delay_basic.h **** 	__asm__ volatile (
 4221               		.loc 4 105 0
 4222 0938 8FEF      		ldi r24,lo8(-1)
 4223 093a 9FEF      		ldi r25,lo8(-1)
 4224               	/* #APP */
 4225               	 ;  105 "c:\winavr-20100110\avr\include\util\delay_basic.h" 1
 4226 093c 0197      		1: sbiw r24,1
 4227 093e 01F4      		brne 1b
 4228               	 ;  0 "" 2
 4229               	.LVL464:
 4230               	/* #NOAPP */
 4231 0940 00C0      		rjmp .L90
 4232               	.LBE182:
 4233               	.LBE181:
 4234               	.LBE180:
 4235               		.cfi_endproc
 4236               	.LFE44:
 4238               	.global	lastBankAccessed
 4239               		.section .bss
 4242               	lastBankAccessed:
 4243 0000 00        		.zero	1
 4244               	.global	flashBank1CommandWrites
 4247               	flashBank1CommandWrites:
 4248 0001 00        		.zero	1
 4249               		.comm	flashWriteCycle,12,1
 4250               		.comm	flashWriteWePin,1,1
 4251               		.comm	flashChipIdBuffer,2,1
 4252               		.comm	eepromBuffer,8,1
 4253               		.comm	receivedChar,1,1
 4254               		.comm	receivedBuffer,256,1
 4255               		.text
 4256               	.Letext0:
 4257               		.file 5 "c:\\winavr-20100110\\avr\\include\\stdint.h"
 4258               		.file 6 "c:\\winavr-20100110\\avr\\include\\stdlib.h"
DEFINED SYMBOLS
                            *ABS*:00000000 main.c
C:\Users\Alex\AppData\Local\Temp\ccQQsnKd.s:2      *ABS*:0000003e __SP_H__
C:\Users\Alex\AppData\Local\Temp\ccQQsnKd.s:3      *ABS*:0000003d __SP_L__
C:\Users\Alex\AppData\Local\Temp\ccQQsnKd.s:4      *ABS*:0000003f __SREG__
C:\Users\Alex\AppData\Local\Temp\ccQQsnKd.s:5      *ABS*:00000000 __tmp_reg__
C:\Users\Alex\AppData\Local\Temp\ccQQsnKd.s:6      *ABS*:00000001 __zero_reg__
C:\Users\Alex\AppData\Local\Temp\ccQQsnKd.s:12     .text:00000000 USART_Receive
C:\Users\Alex\AppData\Local\Temp\ccQQsnKd.s:34     .text:00000008 USART_Transmit
C:\Users\Alex\AppData\Local\Temp\ccQQsnKd.s:55     .text:00000010 usart_read_bytes
                            *COM*:00000100 receivedBuffer
C:\Users\Alex\AppData\Local\Temp\ccQQsnKd.s:118    .text:0000003a usart_read_chars
C:\Users\Alex\AppData\Local\Temp\ccQQsnKd.s:158    .text:00000050 rd_wr_csmreq_cs2_reset
C:\Users\Alex\AppData\Local\Temp\ccQQsnKd.s:180    .text:0000005a gb_mode
C:\Users\Alex\AppData\Local\Temp\ccQQsnKd.s:207    .text:0000006a set_16bit_address
C:\Users\Alex\AppData\Local\Temp\ccQQsnKd.s:226    .text:00000070 read_8bit_data
C:\Users\Alex\AppData\Local\Temp\ccQQsnKd.s:266    .text:00000082 write_8bit_data
C:\Users\Alex\AppData\Local\Temp\ccQQsnKd.s:331    .text:000000ae gba_mode
C:\Users\Alex\AppData\Local\Temp\ccQQsnKd.s:358    .text:000000be gba_set_24bit_address
C:\Users\Alex\AppData\Local\Temp\ccQQsnKd.s:411    .text:000000ea gba_read_16bit_data
C:\Users\Alex\AppData\Local\Temp\ccQQsnKd.s:459    .text:00000108 gba_read_ram_8bit_data
C:\Users\Alex\AppData\Local\Temp\ccQQsnKd.s:499    .text:0000011a gba_write_ram_8bit_data
C:\Users\Alex\AppData\Local\Temp\ccQQsnKd.s:553    .text:0000013a gba_eeprom_mode
C:\Users\Alex\AppData\Local\Temp\ccQQsnKd.s:581    .text:0000014c gba_eeprom_set_address
C:\Users\Alex\AppData\Local\Temp\ccQQsnKd.s:720    .text:000001b4 gba_eeprom_read
                            *COM*:00000008 eepromBuffer
C:\Users\Alex\AppData\Local\Temp\ccQQsnKd.s:852    .text:0000020e gba_eeprom_write
C:\Users\Alex\AppData\Local\Temp\ccQQsnKd.s:968    .text:00000262 flash_write_bus_cycle
C:\Users\Alex\AppData\Local\Temp\ccQQsnKd.s:1014   .text:0000027c flash_read_chip_id
                            *COM*:00000002 flashChipIdBuffer
C:\Users\Alex\AppData\Local\Temp\ccQQsnKd.s:1119   .text:000002e6 flash_switch_bank
C:\Users\Alex\AppData\Local\Temp\ccQQsnKd.s:1168   .text:0000030c flash_erase_4k_sector
C:\Users\Alex\AppData\Local\Temp\ccQQsnKd.s:1243   .text:00000354 flash_write_byte
C:\Users\Alex\AppData\Local\Temp\ccQQsnKd.s:1314   .text:0000038c flash_write_sector
C:\Users\Alex\AppData\Local\Temp\ccQQsnKd.s:1427   .text:000003f8 gb_flash_read_byte
C:\Users\Alex\AppData\Local\Temp\ccQQsnKd.s:1467   .text:0000040a gb_flash_write_bus_cycle
                            *COM*:00000001 flashWriteWePin
C:\Users\Alex\AppData\Local\Temp\ccQQsnKd.s:1548   .text:00000438 gb_flash_write_byte
                            *COM*:0000000c flashWriteCycle
C:\Users\Alex\AppData\Local\Temp\ccQQsnKd.s:1648   .text:0000049c gb_flash_write_byte_bank1_commands
C:\Users\Alex\AppData\Local\Temp\ccQQsnKd.s:4242   .bss:00000000 lastBankAccessed
C:\Users\Alex\AppData\Local\Temp\ccQQsnKd.s:1811   .text:00000530 gba_flash_write_bus_cycle
C:\Users\Alex\AppData\Local\Temp\ccQQsnKd.s:1877   .text:00000560 gba_flash_write_cycle_start
C:\Users\Alex\AppData\Local\Temp\ccQQsnKd.s:2001   .text:000005c0 gba_flash_write_byte_swapped
C:\Users\Alex\AppData\Local\Temp\ccQQsnKd.s:2099   .text:0000060e setup
C:\Users\Alex\AppData\Local\Temp\ccQQsnKd.s:2214   .text.startup:00000000 main
                            *COM*:00000001 receivedChar
C:\Users\Alex\AppData\Local\Temp\ccQQsnKd.s:4247   .bss:00000001 flashBank1CommandWrites

UNDEFINED SYMBOLS
strtol
atoi
__do_clear_bss
