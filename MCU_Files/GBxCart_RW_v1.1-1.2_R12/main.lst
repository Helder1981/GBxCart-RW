   1               		.file	"main.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               	.global	USART_Receive
  12               	USART_Receive:
  13               	.LFB12:
  14               		.file 1 "setup.c"
   1:setup.c       **** /*
   2:setup.c       ****  GBxCart RW
   3:setup.c       ****  PCB version: 1.1 or 1.2
   4:setup.c       ****  Firmware version: R12
   5:setup.c       ****  Author: Alex from insideGadgets (www.insidegadgets.com)
   6:setup.c       ****  Created: 7/11/2016
   7:setup.c       ****  Last Modified: 4/12/2018
   8:setup.c       ****  
   9:setup.c       ****  */
  10:setup.c       ****  
  11:setup.c       **** #ifndef cbi
  12:setup.c       **** #define cbi(sfr, bit) (_SFR_BYTE(sfr) &= ~_BV(bit))
  13:setup.c       **** #endif
  14:setup.c       **** #ifndef sbi
  15:setup.c       **** #define sbi(sfr, bit) (_SFR_BYTE(sfr) |= _BV(bit))
  16:setup.c       **** #endif
  17:setup.c       **** 
  18:setup.c       **** #ifndef NULL
  19:setup.c       **** #define NULL ((void *)0)
  20:setup.c       **** #endif
  21:setup.c       **** 
  22:setup.c       **** #define LOW 0
  23:setup.c       **** #define HIGH 1
  24:setup.c       **** #define false 0
  25:setup.c       **** #define true 1
  26:setup.c       **** 
  27:setup.c       **** #define SWITCH_DETECT PD2
  28:setup.c       **** #define ACTIVITY_LED PD3
  29:setup.c       **** #define LED_5V PD7
  30:setup.c       **** #define LED_3V PE0
  31:setup.c       **** 
  32:setup.c       **** #define WR_PIN PD6
  33:setup.c       **** #define RD_PIN PD5
  34:setup.c       **** #define CS_MREQ_PIN PD4
  35:setup.c       **** #define CS2_PIN PE2
  36:setup.c       **** #define AUDIO_PIN PE1
  37:setup.c       **** 
  38:setup.c       **** #define wrPin_high	PORTD |= (1<<WR_PIN);
  39:setup.c       **** #define wrPin_low		PORTD &= ~(1<<WR_PIN);
  40:setup.c       **** #define rdPin_high	PORTD |= (1<<RD_PIN);
  41:setup.c       **** #define rdPin_low		PORTD &= ~(1<<RD_PIN);
  42:setup.c       **** #define cs_mreqPin_high		PORTD |= (1<<CS_MREQ_PIN);
  43:setup.c       **** #define cs_mreqPin_low		PORTD &= ~(1<<CS_MREQ_PIN);
  44:setup.c       **** #define cs2Pin_high		PORTE |= (1<<CS2_PIN);
  45:setup.c       **** #define cs2Pin_low		PORTE &= ~(1<<CS2_PIN);
  46:setup.c       **** #define audioPin_high	PORTE |= (1<<AUDIO_PIN);
  47:setup.c       **** #define audioPin_low		PORTE &= ~(1<<AUDIO_PIN);
  48:setup.c       **** 
  49:setup.c       **** #define GB_MODE 1
  50:setup.c       **** #define GBA_MODE 2
  51:setup.c       **** 
  52:setup.c       **** // GB/GBC
  53:setup.c       **** #define PORT_ADDR7_0 PORTB
  54:setup.c       **** #define PORT_ADDR15_8 PORTA
  55:setup.c       **** #define PORT_DATA7_0 PORTC
  56:setup.c       **** 
  57:setup.c       **** #define DDR_ADDR7_0 DDRB
  58:setup.c       **** #define DDR_ADDR15_8 DDRA
  59:setup.c       **** #define DDR_DATA7_0 DDRC
  60:setup.c       **** 
  61:setup.c       **** #define PIN_ADDR7_0 PINB
  62:setup.c       **** #define PIN_ADDR15_8 PINA
  63:setup.c       **** #define PIN_DATA7_0 PINC
  64:setup.c       **** 
  65:setup.c       **** #define BANK_WRITE 0
  66:setup.c       **** #define MEMORY_WRITE 1
  67:setup.c       **** 
  68:setup.c       **** // GBA
  69:setup.c       **** #define EEPROM_WRITE 1
  70:setup.c       **** #define EEPROM_READ 0
  71:setup.c       **** 
  72:setup.c       **** #define EEPROM_NONE 0
  73:setup.c       **** #define EEPROM_4KBIT 1
  74:setup.c       **** #define EEPROM_64KBIT 2
  75:setup.c       **** 
  76:setup.c       **** #define AD0 PB0
  77:setup.c       **** #define ad0Pin_high		PORTB |= (1<<AD0);
  78:setup.c       **** #define ad0Pin_low		PORTB &= ~(1<<AD0);
  79:setup.c       **** 
  80:setup.c       **** #define A23 PC7
  81:setup.c       **** #define a23Pin_high		PORTC |= (1<<A23);
  82:setup.c       **** #define a23Pin_low		PORTC &= ~(1<<A23);
  83:setup.c       **** 
  84:setup.c       **** #define GBA_DDR_ROM_ADDR7_0 DDRB
  85:setup.c       **** #define GBA_DDR_ROM_ADDR15_8 DDRA
  86:setup.c       **** #define GBA_DDR_ROM_ADDR23_16 DDRC
  87:setup.c       **** #define GBA_DDR_ROM_DATA7_0 DDRB
  88:setup.c       **** #define GBA_DDR_ROM_DATA15_8 DDRA
  89:setup.c       **** #define GBA_DDR_RAM_DATA7_0 DDRC
  90:setup.c       **** #define GBA_DDR_EEPROM_DATA7_0 DDRB
  91:setup.c       **** 
  92:setup.c       **** #define GBA_PORT_ROM_ADDR7_0 PORTB
  93:setup.c       **** #define GBA_PORT_ROM_ADDR15_8 PORTA
  94:setup.c       **** #define GBA_PORT_ROM_ADDR23_16 PORTC
  95:setup.c       **** #define GBA_PORT_ROM_DATA7_0 PORTB
  96:setup.c       **** #define GBA_PORT_ROM_DATA15_8 PORTA
  97:setup.c       **** #define GBA_PORT_RAM_DATA7_0 PORTC
  98:setup.c       **** #define GBA_PORT_EEPROM_DATA7_0 PORTB
  99:setup.c       **** 
 100:setup.c       **** #define GBA_PIN_ROM_DATA7_0 PINB
 101:setup.c       **** #define GBA_PIN_ROM_DATA15_8 PINA
 102:setup.c       **** #define GBA_PIN_RAM_DATA7_0 PINC
 103:setup.c       **** #define GBA_PIN_EEPROM_DATA7_0 PINB
 104:setup.c       **** 
 105:setup.c       **** // GB/GBC commands
 106:setup.c       **** #define SET_START_ADDRESS 'A'
 107:setup.c       **** #define READ_ROM_RAM 'R'
 108:setup.c       **** #define WRITE_RAM 'W'
 109:setup.c       **** #define SET_BANK 'B'
 110:setup.c       **** #define GB_CART_MODE 'G'
 111:setup.c       **** 
 112:setup.c       **** // GBA commands
 113:setup.c       **** #define GBA_READ_ROM 'r'
 114:setup.c       **** #define GBA_READ_ROM_256BYTE 'j'
 115:setup.c       **** #define GBA_READ_SRAM 'm'
 116:setup.c       **** #define GBA_WRITE_SRAM 'w'
 117:setup.c       **** #define GBA_WRITE_ONE_BYTE_SRAM 'o'
 118:setup.c       **** #define GBA_CART_MODE 'g'
 119:setup.c       **** 
 120:setup.c       **** #define GBA_FLASH_READ_ID 'i'
 121:setup.c       **** #define GBA_FLASH_SET_BANK 'k'
 122:setup.c       **** #define GBA_FLASH_4K_SECTOR_ERASE 's'
 123:setup.c       **** #define GBA_FLASH_WRITE_BYTE 'b'
 124:setup.c       **** #define GBA_FLASH_WRITE_ATMEL 'a'
 125:setup.c       **** 
 126:setup.c       **** #define GBA_SET_EEPROM_SIZE 'S'
 127:setup.c       **** #define GBA_READ_EEPROM 'e'
 128:setup.c       **** #define GBA_WRITE_EEPROM 'p'
 129:setup.c       **** 
 130:setup.c       **** // Flash Cart commands
 131:setup.c       **** #define GB_FLASH_WE_PIN 'P'
 132:setup.c       **** 	#define WE_AS_AUDIO_PIN 'A'
 133:setup.c       **** 	#define WE_AS_WR_PIN 'W'
 134:setup.c       **** 
 135:setup.c       **** #define GB_FLASH_PROGRAM_METHOD 'E'
 136:setup.c       **** 	#define GB_FLASH_PROGRAM_555 0
 137:setup.c       **** 	#define GB_FLASH_PROGRAM_AAA 1
 138:setup.c       **** 	#define GB_FLASH_PROGRAM_555_BIT01_SWAPPED 2
 139:setup.c       **** 	#define GB_FLASH_PROGRAM_AAA_BIT01_SWAPPED 3
 140:setup.c       **** 	#define GB_FLASH_PROGRAM_5555 4
 141:setup.c       **** 
 142:setup.c       **** #define GB_FLASH_WRITE_BYTE 'F'
 143:setup.c       **** #define GB_FLASH_WRITE_BUFFERED_32BYTE 'Y'
 144:setup.c       **** #define GB_FLASH_WRITE_64BYTE 'T'
 145:setup.c       **** #define GB_FLASH_WRITE_256BYTE 'X'
 146:setup.c       **** 
 147:setup.c       **** #define GB_FLASH_BANK_1_COMMAND_WRITES 'N'
 148:setup.c       **** 
 149:setup.c       **** #define GBA_FLASH_CART_WRITE_BYTE 'n'
 150:setup.c       **** #define GBA_FLASH_WRITE_64BYTE_SWAPPED_D0D1 'q'
 151:setup.c       **** #define GBA_FLASH_WRITE_256BYTE_SWAPPED_D0D1 't'
 152:setup.c       **** #define GBA_FLASH_WRITE_256BYTE 'f'
 153:setup.c       **** #define GBA_FLASH_WRITE_INTEL_64BYTE 'l'
 154:setup.c       **** 
 155:setup.c       **** #define D0D1_NOT_SWAPPED 0
 156:setup.c       **** #define D0D1_SWAPPED 1
 157:setup.c       **** 
 158:setup.c       **** // General commands
 159:setup.c       **** #define SEND_ACK '1'
 160:setup.c       **** #define CART_MODE 'C'
 161:setup.c       **** #define SET_INPUT 'I'
 162:setup.c       **** #define SET_OUTPUT 'O'
 163:setup.c       **** #define SET_OUTPUT_LOW 'L'
 164:setup.c       **** #define SET_OUTPUT_HIGH 'H'
 165:setup.c       **** #define READ_INPUT 'D'
 166:setup.c       **** #define RESET_COMMON_LINES 'M'
 167:setup.c       **** #define READ_FIRMWARE_VERSION 'V'
 168:setup.c       **** #define READ_PCB_VERSION 'h'
 169:setup.c       **** 
 170:setup.c       **** #define RESET_AVR '*'
 171:setup.c       **** #define RESET_VALUE 0x7E5E1
 172:setup.c       **** 
 173:setup.c       **** 
 174:setup.c       **** char receivedBuffer[256];
 175:setup.c       **** char receivedChar;
 176:setup.c       **** uint8_t eepromBuffer[8];
 177:setup.c       **** uint8_t flashChipIdBuffer[2];
 178:setup.c       **** 
 179:setup.c       **** char flashWriteWePin;
 180:setup.c       **** uint16_t flashWriteCycle[3][2];
 181:setup.c       **** uint8_t flashBank1CommandWrites = 0;
 182:setup.c       **** uint8_t lastBankAccessed = 0;
 183:setup.c       **** 
 184:setup.c       **** 
 185:setup.c       **** // Receive USART data
 186:setup.c       **** uint8_t USART_Receive(void) {
  15               		.loc 1 186 0
  16               		.cfi_startproc
  17               	/* prologue: function */
  18               	/* frame size = 0 */
  19               	/* stack size = 0 */
  20               	.L__stack_usage = 0
  21               	.L2:
 187:setup.c       **** 	while ( !(UCSRA & (1<<RXC)) ); // Wait for data to be received
  22               		.loc 1 187 0 discriminator 1
  23 0000 5F9B      		sbis 0xb,7
  24 0002 00C0      		rjmp .L2
 188:setup.c       **** 	return UDR; // Get and return received data from buffer
  25               		.loc 1 188 0
  26 0004 8CB1      		in r24,0xc
 189:setup.c       **** }
  27               		.loc 1 189 0
  28 0006 0895      		ret
  29               		.cfi_endproc
  30               	.LFE12:
  32               	.global	USART_Transmit
  34               	USART_Transmit:
  35               	.LFB13:
 190:setup.c       **** 
 191:setup.c       **** // Transmit USART data
 192:setup.c       **** void USART_Transmit(unsigned char data) {
  36               		.loc 1 192 0
  37               		.cfi_startproc
  38               	/* prologue: function */
  39               	/* frame size = 0 */
  40               	/* stack size = 0 */
  41               	.L__stack_usage = 0
  42               	.LVL0:
  43               	.L6:
 193:setup.c       **** 	while ( !( UCSRA & (1<<UDRE)) ); // Wait for empty transmit buffer
  44               		.loc 1 193 0 discriminator 1
  45 0008 5D9B      		sbis 0xb,5
  46 000a 00C0      		rjmp .L6
 194:setup.c       **** 	UDR = data;
  47               		.loc 1 194 0
  48 000c 8CB9      		out 0xc,r24
  49 000e 0895      		ret
  50               		.cfi_endproc
  51               	.LFE13:
  53               	.global	usart_read_bytes
  55               	usart_read_bytes:
  56               	.LFB14:
 195:setup.c       **** }
 196:setup.c       **** 
 197:setup.c       **** // Read 1-256 bytes from the USART 
 198:setup.c       **** void usart_read_bytes(int count) {
  57               		.loc 1 198 0
  58               		.cfi_startproc
  59               	.LVL1:
  60 0010 0F93      		push r16
  61               	.LCFI0:
  62               		.cfi_def_cfa_offset 3
  63               		.cfi_offset 16, -2
  64 0012 1F93      		push r17
  65               	.LCFI1:
  66               		.cfi_def_cfa_offset 4
  67               		.cfi_offset 17, -3
  68 0014 CF93      		push r28
  69               	.LCFI2:
  70               		.cfi_def_cfa_offset 5
  71               		.cfi_offset 28, -4
  72 0016 DF93      		push r29
  73               	.LCFI3:
  74               		.cfi_def_cfa_offset 6
  75               		.cfi_offset 29, -5
  76               	/* prologue: function */
  77               	/* frame size = 0 */
  78               	/* stack size = 4 */
  79               	.L__stack_usage = 4
  80 0018 8C01      		movw r16,r24
  81               	.LVL2:
  82               	.LBB100:
 199:setup.c       **** 	for (int x = 0; x < count; x++) {
  83               		.loc 1 199 0
  84 001a C0E0      		ldi r28,lo8(receivedBuffer)
  85 001c D0E0      		ldi r29,hi8(receivedBuffer)
  86               	.LVL3:
  87               	.L10:
  88               		.loc 1 199 0 is_stmt 0 discriminator 1
  89 001e CE01      		movw r24,r28
  90 0020 8050      		subi r24,lo8(receivedBuffer)
  91 0022 9040      		sbci r25,hi8(receivedBuffer)
  92               	.LVL4:
  93 0024 8017      		cp r24,r16
  94 0026 9107      		cpc r25,r17
  95 0028 04F4      		brge .L12
 200:setup.c       **** 		receivedBuffer[x] = USART_Receive();
  96               		.loc 1 200 0 is_stmt 1 discriminator 3
  97 002a 00D0      		rcall USART_Receive
  98               	.LVL5:
  99 002c 8993      		st Y+,r24
 100               	.LVL6:
 101 002e 00C0      		rjmp .L10
 102               	.LVL7:
 103               	.L12:
 104               	/* epilogue start */
 105               	.LBE100:
 201:setup.c       **** 	}
 202:setup.c       **** }
 106               		.loc 1 202 0
 107 0030 DF91      		pop r29
 108 0032 CF91      		pop r28
 109 0034 1F91      		pop r17
 110 0036 0F91      		pop r16
 111               	.LVL8:
 112 0038 0895      		ret
 113               		.cfi_endproc
 114               	.LFE14:
 116               	.global	usart_read_chars
 118               	usart_read_chars:
 119               	.LFB15:
 203:setup.c       **** 
 204:setup.c       **** // Read the USART until a 0 (string terminator byte) is received
 205:setup.c       **** void usart_read_chars(void) {
 120               		.loc 1 205 0
 121               		.cfi_startproc
 122 003a CF93      		push r28
 123               	.LCFI4:
 124               		.cfi_def_cfa_offset 3
 125               		.cfi_offset 28, -2
 126 003c DF93      		push r29
 127               	.LCFI5:
 128               		.cfi_def_cfa_offset 4
 129               		.cfi_offset 29, -3
 130               	/* prologue: function */
 131               	/* frame size = 0 */
 132               	/* stack size = 2 */
 133               	.L__stack_usage = 2
 134               	.LVL9:
 135 003e C0E0      		ldi r28,lo8(receivedBuffer)
 136 0040 D0E0      		ldi r29,hi8(receivedBuffer)
 137               	.LVL10:
 138               	.L14:
 206:setup.c       **** 	int x = 0;
 207:setup.c       **** 	while (1) {
 208:setup.c       **** 		receivedBuffer[x] = USART_Receive();
 139               		.loc 1 208 0
 140 0042 00D0      		rcall USART_Receive
 141               	.LVL11:
 142 0044 8993      		st Y+,r24
 143               	.LVL12:
 209:setup.c       **** 		if (receivedBuffer[x] == 0) {
 144               		.loc 1 209 0
 145 0046 8111      		cpse r24,__zero_reg__
 146 0048 00C0      		rjmp .L14
 147               	/* epilogue start */
 210:setup.c       **** 			break;
 211:setup.c       **** 		}
 212:setup.c       **** 		x++;
 213:setup.c       **** 	}
 214:setup.c       **** }
 148               		.loc 1 214 0
 149 004a DF91      		pop r29
 150 004c CF91      		pop r28
 151               	.LVL13:
 152 004e 0895      		ret
 153               		.cfi_endproc
 154               	.LFE15:
 156               	.global	rd_wr_csmreq_cs2_reset
 158               	rd_wr_csmreq_cs2_reset:
 159               	.LFB16:
 215:setup.c       **** 
 216:setup.c       **** // Turn RD, WR, CS/MREQ and CS2 to high so they are deselected (reset state)
 217:setup.c       **** void rd_wr_csmreq_cs2_reset(void) {
 160               		.loc 1 217 0
 161               		.cfi_startproc
 162               	/* prologue: function */
 163               	/* frame size = 0 */
 164               	/* stack size = 0 */
 165               	.L__stack_usage = 0
 218:setup.c       **** 	cs2Pin_high; // CS2 off
 166               		.loc 1 218 0
 167 0050 3A9A      		sbi 0x7,2
 219:setup.c       **** 	cs_mreqPin_high; // CS/MREQ off
 168               		.loc 1 219 0
 169 0052 949A      		sbi 0x12,4
 220:setup.c       **** 	rdPin_high; // RD off
 170               		.loc 1 220 0
 171 0054 959A      		sbi 0x12,5
 221:setup.c       **** 	wrPin_high; // WR off
 172               		.loc 1 221 0
 173 0056 969A      		sbi 0x12,6
 174 0058 0895      		ret
 175               		.cfi_endproc
 176               	.LFE16:
 178               	.global	gb_mode
 180               	gb_mode:
 181               	.LFB17:
 222:setup.c       **** }
 223:setup.c       **** 
 224:setup.c       **** 
 225:setup.c       **** 
 226:setup.c       **** // ****** Gameboy / Gameboy Colour functions ******
 227:setup.c       **** 
 228:setup.c       **** // Set Gameboy mode
 229:setup.c       **** void gb_mode(void) {
 182               		.loc 1 229 0
 183               		.cfi_startproc
 184               	/* prologue: function */
 185               	/* frame size = 0 */
 186               	/* stack size = 0 */
 187               	.L__stack_usage = 0
 230:setup.c       **** 	// Set inputs
 231:setup.c       **** 	PORT_DATA7_0 = 0;
 188               		.loc 1 231 0
 189 005a 15BA      		out 0x15,__zero_reg__
 232:setup.c       **** 	DDR_DATA7_0 = 0;
 190               		.loc 1 232 0
 191 005c 14BA      		out 0x14,__zero_reg__
 233:setup.c       **** 	
 234:setup.c       **** 	// Set outputs
 235:setup.c       **** 	PORT_ADDR7_0 = 0;
 192               		.loc 1 235 0
 193 005e 18BA      		out 0x18,__zero_reg__
 236:setup.c       **** 	PORT_ADDR15_8 = 0;
 194               		.loc 1 236 0
 195 0060 1BBA      		out 0x1b,__zero_reg__
 237:setup.c       **** 	DDR_ADDR7_0 = 0xFF;
 196               		.loc 1 237 0
 197 0062 8FEF      		ldi r24,lo8(-1)
 198 0064 87BB      		out 0x17,r24
 238:setup.c       **** 	DDR_ADDR15_8 = 0xFF;
 199               		.loc 1 238 0
 200 0066 8ABB      		out 0x1a,r24
 201 0068 0895      		ret
 202               		.cfi_endproc
 203               	.LFE17:
 205               	.global	set_16bit_address
 207               	set_16bit_address:
 208               	.LFB18:
 239:setup.c       **** }
 240:setup.c       **** 
 241:setup.c       **** // Set the 16 bit address on A15-0
 242:setup.c       **** void set_16bit_address(uint16_t address) {
 209               		.loc 1 242 0
 210               		.cfi_startproc
 211               	.LVL14:
 212               	/* prologue: function */
 213               	/* frame size = 0 */
 214               	/* stack size = 0 */
 215               	.L__stack_usage = 0
 243:setup.c       **** 	PORT_ADDR15_8 = (address >> 8);
 216               		.loc 1 243 0
 217 006a 9BBB      		out 0x1b,r25
 244:setup.c       **** 	PORT_ADDR7_0 = (address & 0xFF);
 218               		.loc 1 244 0
 219 006c 88BB      		out 0x18,r24
 220 006e 0895      		ret
 221               		.cfi_endproc
 222               	.LFE18:
 224               	.global	read_8bit_data
 226               	read_8bit_data:
 227               	.LFB19:
 245:setup.c       **** }
 246:setup.c       **** 
 247:setup.c       **** // Set the address and read a byte from the 8 bit data line
 248:setup.c       **** uint8_t read_8bit_data(uint16_t address) {
 228               		.loc 1 248 0
 229               		.cfi_startproc
 230               	.LVL15:
 231               	/* prologue: function */
 232               	/* frame size = 0 */
 233               	/* stack size = 0 */
 234               	.L__stack_usage = 0
 249:setup.c       **** 	set_16bit_address(address);
 235               		.loc 1 249 0
 236 0070 00D0      		rcall set_16bit_address
 237               	.LVL16:
 250:setup.c       **** 	
 251:setup.c       **** 	cs_mreqPin_low;
 238               		.loc 1 251 0
 239 0072 9498      		cbi 0x12,4
 252:setup.c       **** 	rdPin_low;
 240               		.loc 1 252 0
 241 0074 9598      		cbi 0x12,5
 253:setup.c       **** 	
 254:setup.c       **** 	asm volatile("nop"); // Delay a little (minimum needed is 1 nops, 2 nops for GB camera)
 242               		.loc 1 254 0
 243               	/* #APP */
 244               	 ;  254 "setup.c" 1
 245 0076 0000      		nop
 246               	 ;  0 "" 2
 255:setup.c       **** 	asm volatile("nop");
 247               		.loc 1 255 0
 248               	 ;  255 "setup.c" 1
 249 0078 0000      		nop
 250               	 ;  0 "" 2
 256:setup.c       **** 	uint8_t data = PIN_DATA7_0; // Read data
 251               		.loc 1 256 0
 252               	/* #NOAPP */
 253 007a 83B3      		in r24,0x13
 254               	.LVL17:
 257:setup.c       **** 	
 258:setup.c       **** 	rdPin_high;
 255               		.loc 1 258 0
 256 007c 959A      		sbi 0x12,5
 259:setup.c       **** 	cs_mreqPin_high;
 257               		.loc 1 259 0
 258 007e 949A      		sbi 0x12,4
 260:setup.c       **** 	
 261:setup.c       **** 	return data;
 262:setup.c       **** }
 259               		.loc 1 262 0
 260 0080 0895      		ret
 261               		.cfi_endproc
 262               	.LFE19:
 264               	.global	write_8bit_data
 266               	write_8bit_data:
 267               	.LFB20:
 263:setup.c       **** 
 264:setup.c       **** // Set the address and write a byte to the 8 bit data line and pulse cs/mREQ if writing to RAM
 265:setup.c       **** void write_8bit_data(uint16_t address, uint8_t data, uint8_t type) {
 268               		.loc 1 265 0
 269               		.cfi_startproc
 270               	.LVL18:
 271 0082 CF93      		push r28
 272               	.LCFI6:
 273               		.cfi_def_cfa_offset 3
 274               		.cfi_offset 28, -2
 275 0084 DF93      		push r29
 276               	.LCFI7:
 277               		.cfi_def_cfa_offset 4
 278               		.cfi_offset 29, -3
 279               	/* prologue: function */
 280               	/* frame size = 0 */
 281               	/* stack size = 2 */
 282               	.L__stack_usage = 2
 283 0086 D62F      		mov r29,r22
 284 0088 C42F      		mov r28,r20
 266:setup.c       **** 	set_16bit_address(address);
 285               		.loc 1 266 0
 286 008a 00D0      		rcall set_16bit_address
 287               	.LVL19:
 267:setup.c       **** 	
 268:setup.c       **** 	DDR_DATA7_0 = 0xFF; // Set data pins as outputs
 288               		.loc 1 268 0
 289 008c 8FEF      		ldi r24,lo8(-1)
 290 008e 84BB      		out 0x14,r24
 269:setup.c       **** 	PORT_DATA7_0 = data; // Set data
 291               		.loc 1 269 0
 292 0090 D5BB      		out 0x15,r29
 270:setup.c       **** 	
 271:setup.c       **** 	// Pulse WR and mREQ if the type matches
 272:setup.c       **** 	wrPin_low;
 293               		.loc 1 272 0
 294 0092 9698      		cbi 0x12,6
 273:setup.c       **** 	if (type == MEMORY_WRITE) {
 295               		.loc 1 273 0
 296 0094 C130      		cpi r28,lo8(1)
 297 0096 01F4      		brne .L21
 274:setup.c       **** 		cs_mreqPin_low;
 298               		.loc 1 274 0
 299 0098 9498      		cbi 0x12,4
 300               	.L21:
 275:setup.c       **** 	}
 276:setup.c       **** 	
 277:setup.c       **** 	asm volatile("nop");
 301               		.loc 1 277 0
 302               	/* #APP */
 303               	 ;  277 "setup.c" 1
 304 009a 0000      		nop
 305               	 ;  0 "" 2
 278:setup.c       **** 	
 279:setup.c       **** 	if (type == MEMORY_WRITE) {
 306               		.loc 1 279 0
 307               	/* #NOAPP */
 308 009c C130      		cpi r28,lo8(1)
 309 009e 01F4      		brne .L22
 280:setup.c       **** 		cs_mreqPin_high;
 310               		.loc 1 280 0
 311 00a0 949A      		sbi 0x12,4
 312               	.L22:
 281:setup.c       **** 	}
 282:setup.c       **** 	wrPin_high;
 313               		.loc 1 282 0
 314 00a2 969A      		sbi 0x12,6
 283:setup.c       **** 	
 284:setup.c       **** 	// Clear data outputs and set data pins as inputs
 285:setup.c       **** 	PORT_DATA7_0 = 0;
 315               		.loc 1 285 0
 316 00a4 15BA      		out 0x15,__zero_reg__
 286:setup.c       **** 	DDR_DATA7_0 = 0;
 317               		.loc 1 286 0
 318 00a6 14BA      		out 0x14,__zero_reg__
 319               	/* epilogue start */
 287:setup.c       **** }
 320               		.loc 1 287 0
 321 00a8 DF91      		pop r29
 322               	.LVL20:
 323 00aa CF91      		pop r28
 324               	.LVL21:
 325 00ac 0895      		ret
 326               		.cfi_endproc
 327               	.LFE20:
 329               	.global	gba_mode
 331               	gba_mode:
 332               	.LFB21:
 288:setup.c       **** 
 289:setup.c       **** 
 290:setup.c       **** 
 291:setup.c       **** // ****** Gameboy Advance functions ****** 
 292:setup.c       **** 
 293:setup.c       **** // Set GBA mode
 294:setup.c       **** void gba_mode(void) {
 333               		.loc 1 294 0
 334               		.cfi_startproc
 335               	/* prologue: function */
 336               	/* frame size = 0 */
 337               	/* stack size = 0 */
 338               	.L__stack_usage = 0
 295:setup.c       **** 	// Set outputs for reading ROM addresses as default
 296:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = 0;
 339               		.loc 1 296 0
 340 00ae 18BA      		out 0x18,__zero_reg__
 297:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = 0;
 341               		.loc 1 297 0
 342 00b0 1BBA      		out 0x1b,__zero_reg__
 298:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = 0;
 343               		.loc 1 298 0
 344 00b2 15BA      		out 0x15,__zero_reg__
 299:setup.c       **** 	GBA_DDR_ROM_ADDR7_0 = 0xFF;
 345               		.loc 1 299 0
 346 00b4 8FEF      		ldi r24,lo8(-1)
 347 00b6 87BB      		out 0x17,r24
 300:setup.c       **** 	GBA_DDR_ROM_ADDR15_8 = 0xFF;
 348               		.loc 1 300 0
 349 00b8 8ABB      		out 0x1a,r24
 301:setup.c       **** 	GBA_DDR_ROM_ADDR23_16 = 0xFF;
 350               		.loc 1 301 0
 351 00ba 84BB      		out 0x14,r24
 352 00bc 0895      		ret
 353               		.cfi_endproc
 354               	.LFE21:
 356               	.global	gba_set_24bit_address
 358               	gba_set_24bit_address:
 359               	.LFB22:
 302:setup.c       **** }
 303:setup.c       **** 
 304:setup.c       **** // Set the 24 bit address on A23-0
 305:setup.c       **** void gba_set_24bit_address(uint32_t address) {	
 360               		.loc 1 305 0
 361               		.cfi_startproc
 362               	.LVL22:
 363 00be 0F93      		push r16
 364               	.LCFI8:
 365               		.cfi_def_cfa_offset 3
 366               		.cfi_offset 16, -2
 367 00c0 1F93      		push r17
 368               	.LCFI9:
 369               		.cfi_def_cfa_offset 4
 370               		.cfi_offset 17, -3
 371               	/* prologue: function */
 372               	/* frame size = 0 */
 373               	/* stack size = 2 */
 374               	.L__stack_usage = 2
 306:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = 0; // Set 0-23 address lines low and set as outputs
 375               		.loc 1 306 0
 376 00c2 15BA      		out 0x15,__zero_reg__
 307:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = 0;
 377               		.loc 1 307 0
 378 00c4 1BBA      		out 0x1b,__zero_reg__
 308:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = 0;
 379               		.loc 1 308 0
 380 00c6 18BA      		out 0x18,__zero_reg__
 309:setup.c       **** 	GBA_DDR_ROM_ADDR23_16 = 0xFF;
 381               		.loc 1 309 0
 382 00c8 2FEF      		ldi r18,lo8(-1)
 383 00ca 24BB      		out 0x14,r18
 310:setup.c       **** 	GBA_DDR_ROM_ADDR15_8 = 0xFF;
 384               		.loc 1 310 0
 385 00cc 2ABB      		out 0x1a,r18
 311:setup.c       **** 	GBA_DDR_ROM_ADDR7_0 = 0xFF;
 386               		.loc 1 311 0
 387 00ce 27BB      		out 0x17,r18
 312:setup.c       **** 	
 313:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = (address >> 16);
 388               		.loc 1 313 0
 389 00d0 8C01      		movw r16,r24
 390 00d2 2227      		clr r18
 391 00d4 3327      		clr r19
 392 00d6 05BB      		out 0x15,r16
 314:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = (address >> 8);
 393               		.loc 1 314 0
 394 00d8 072F      		mov r16,r23
 395 00da 182F      		mov r17,r24
 396 00dc 292F      		mov r18,r25
 397 00de 3327      		clr r19
 398 00e0 0BBB      		out 0x1b,r16
 315:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = (address & 0xFF);
 399               		.loc 1 315 0
 400 00e2 68BB      		out 0x18,r22
 401               	/* epilogue start */
 316:setup.c       **** }
 402               		.loc 1 316 0
 403 00e4 1F91      		pop r17
 404 00e6 0F91      		pop r16
 405 00e8 0895      		ret
 406               		.cfi_endproc
 407               	.LFE22:
 409               	.global	gba_read_16bit_data
 411               	gba_read_16bit_data:
 412               	.LFB23:
 317:setup.c       **** 
 318:setup.c       **** 
 319:setup.c       **** 
 320:setup.c       **** // ---------- ROM/SRAM ----------
 321:setup.c       **** 
 322:setup.c       **** // Read a byte from the 16 bit data line non-sequentially
 323:setup.c       **** uint16_t gba_read_16bit_data(uint32_t address) {
 413               		.loc 1 323 0
 414               		.cfi_startproc
 415               	.LVL23:
 416               	/* prologue: function */
 417               	/* frame size = 0 */
 418               	/* stack size = 0 */
 419               	.L__stack_usage = 0
 324:setup.c       **** 	gba_set_24bit_address(address);
 420               		.loc 1 324 0
 421 00ea 00D0      		rcall gba_set_24bit_address
 422               	.LVL24:
 325:setup.c       **** 	
 326:setup.c       **** 	cs_mreqPin_low;
 423               		.loc 1 326 0
 424 00ec 9498      		cbi 0x12,4
 327:setup.c       **** 	
 328:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = 0; // Set A16-A0 address lines low and set as inputs for the data to be re
 425               		.loc 1 328 0
 426 00ee 1BBA      		out 0x1b,__zero_reg__
 329:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = 0;
 427               		.loc 1 329 0
 428 00f0 18BA      		out 0x18,__zero_reg__
 330:setup.c       **** 	GBA_DDR_ROM_ADDR15_8 = 0;
 429               		.loc 1 330 0
 430 00f2 1ABA      		out 0x1a,__zero_reg__
 331:setup.c       **** 	GBA_DDR_ROM_ADDR7_0 = 0;
 431               		.loc 1 331 0
 432 00f4 17BA      		out 0x17,__zero_reg__
 332:setup.c       **** 	
 333:setup.c       **** 	rdPin_low;
 433               		.loc 1 333 0
 434 00f6 9598      		cbi 0x12,5
 334:setup.c       **** 	asm volatile("nop");
 435               		.loc 1 334 0
 436               	/* #APP */
 437               	 ;  334 "setup.c" 1
 438 00f8 0000      		nop
 439               	 ;  0 "" 2
 335:setup.c       **** 	
 336:setup.c       **** 	uint16_t data = (GBA_PIN_ROM_DATA15_8 << 8) | GBA_PIN_ROM_DATA7_0; // Read data
 440               		.loc 1 336 0
 441               	/* #NOAPP */
 442 00fa 29B3      		in r18,0x19
 443 00fc 86B3      		in r24,0x16
 444               	.LVL25:
 337:setup.c       **** 	
 338:setup.c       **** 	rdPin_high;
 445               		.loc 1 338 0
 446 00fe 959A      		sbi 0x12,5
 339:setup.c       **** 	cs_mreqPin_high;
 447               		.loc 1 339 0
 448 0100 949A      		sbi 0x12,4
 340:setup.c       **** 	
 341:setup.c       **** 	return data;
 449               		.loc 1 341 0
 450 0102 90E0      		ldi r25,0
 342:setup.c       **** }
 451               		.loc 1 342 0
 452 0104 922B      		or r25,r18
 453 0106 0895      		ret
 454               		.cfi_endproc
 455               	.LFE23:
 457               	.global	gba_read_ram_8bit_data
 459               	gba_read_ram_8bit_data:
 460               	.LFB24:
 343:setup.c       **** 
 344:setup.c       **** // Set the address and read a byte from the 8 bit data line
 345:setup.c       **** uint8_t gba_read_ram_8bit_data(uint16_t address) {
 461               		.loc 1 345 0
 462               		.cfi_startproc
 463               	.LVL26:
 464               	/* prologue: function */
 465               	/* frame size = 0 */
 466               	/* stack size = 0 */
 467               	.L__stack_usage = 0
 346:setup.c       **** 	set_16bit_address(address);
 468               		.loc 1 346 0
 469 0108 00D0      		rcall set_16bit_address
 470               	.LVL27:
 347:setup.c       **** 	
 348:setup.c       **** 	rdPin_low;
 471               		.loc 1 348 0
 472 010a 9598      		cbi 0x12,5
 349:setup.c       **** 	cs2Pin_low; // CS2 pin low for SRAM/Flash select
 473               		.loc 1 349 0
 474 010c 3A98      		cbi 0x7,2
 350:setup.c       **** 	
 351:setup.c       **** 	asm volatile("nop"); // Delay a little (minimum needed is 2)
 475               		.loc 1 351 0
 476               	/* #APP */
 477               	 ;  351 "setup.c" 1
 478 010e 0000      		nop
 479               	 ;  0 "" 2
 352:setup.c       **** 	asm volatile("nop");
 480               		.loc 1 352 0
 481               	 ;  352 "setup.c" 1
 482 0110 0000      		nop
 483               	 ;  0 "" 2
 353:setup.c       **** 	
 354:setup.c       **** 	uint8_t data = GBA_PIN_RAM_DATA7_0; // Read data
 484               		.loc 1 354 0
 485               	/* #NOAPP */
 486 0112 83B3      		in r24,0x13
 487               	.LVL28:
 355:setup.c       **** 	
 356:setup.c       **** 	cs2Pin_high;
 488               		.loc 1 356 0
 489 0114 3A9A      		sbi 0x7,2
 357:setup.c       **** 	rdPin_high;
 490               		.loc 1 357 0
 491 0116 959A      		sbi 0x12,5
 358:setup.c       **** 	
 359:setup.c       **** 	return data;
 360:setup.c       **** }
 492               		.loc 1 360 0
 493 0118 0895      		ret
 494               		.cfi_endproc
 495               	.LFE24:
 497               	.global	gba_write_ram_8bit_data
 499               	gba_write_ram_8bit_data:
 500               	.LFB25:
 361:setup.c       **** 
 362:setup.c       **** // Set the address and write a byte to the 8 bit data line 
 363:setup.c       **** void gba_write_ram_8bit_data(uint16_t address, uint8_t data) {
 501               		.loc 1 363 0
 502               		.cfi_startproc
 503               	.LVL29:
 504 011a CF93      		push r28
 505               	.LCFI10:
 506               		.cfi_def_cfa_offset 3
 507               		.cfi_offset 28, -2
 508               	/* prologue: function */
 509               	/* frame size = 0 */
 510               	/* stack size = 1 */
 511               	.L__stack_usage = 1
 512 011c C62F      		mov r28,r22
 364:setup.c       **** 	set_16bit_address(address);
 513               		.loc 1 364 0
 514 011e 00D0      		rcall set_16bit_address
 515               	.LVL30:
 365:setup.c       **** 	
 366:setup.c       **** 	GBA_DDR_RAM_DATA7_0 = 0xFF; // Set data pins as outputs
 516               		.loc 1 366 0
 517 0120 8FEF      		ldi r24,lo8(-1)
 518 0122 84BB      		out 0x14,r24
 367:setup.c       **** 	GBA_PORT_RAM_DATA7_0 = data; // Set data
 519               		.loc 1 367 0
 520 0124 C5BB      		out 0x15,r28
 368:setup.c       **** 	
 369:setup.c       **** 	// Pulse WR
 370:setup.c       **** 	wrPin_low;
 521               		.loc 1 370 0
 522 0126 9698      		cbi 0x12,6
 371:setup.c       **** 	cs2Pin_low; // CS2 pin low for SRAM/Flash select
 523               		.loc 1 371 0
 524 0128 3A98      		cbi 0x7,2
 372:setup.c       **** 	
 373:setup.c       **** 	asm volatile("nop");
 525               		.loc 1 373 0
 526               	/* #APP */
 527               	 ;  373 "setup.c" 1
 528 012a 0000      		nop
 529               	 ;  0 "" 2
 374:setup.c       **** 	asm volatile("nop");
 530               		.loc 1 374 0
 531               	 ;  374 "setup.c" 1
 532 012c 0000      		nop
 533               	 ;  0 "" 2
 375:setup.c       **** 	
 376:setup.c       **** 	cs2Pin_high;
 534               		.loc 1 376 0
 535               	/* #NOAPP */
 536 012e 3A9A      		sbi 0x7,2
 377:setup.c       **** 	wrPin_high;
 537               		.loc 1 377 0
 538 0130 969A      		sbi 0x12,6
 378:setup.c       **** 	
 379:setup.c       **** 	// Clear data outputs and set data pins as inputs
 380:setup.c       **** 	GBA_PORT_RAM_DATA7_0 = 0;
 539               		.loc 1 380 0
 540 0132 15BA      		out 0x15,__zero_reg__
 381:setup.c       **** 	GBA_DDR_RAM_DATA7_0 = 0;
 541               		.loc 1 381 0
 542 0134 14BA      		out 0x14,__zero_reg__
 543               	/* epilogue start */
 382:setup.c       **** }
 544               		.loc 1 382 0
 545 0136 CF91      		pop r28
 546               	.LVL31:
 547 0138 0895      		ret
 548               		.cfi_endproc
 549               	.LFE25:
 551               	.global	gba_eeprom_mode
 553               	gba_eeprom_mode:
 554               	.LFB26:
 383:setup.c       **** 
 384:setup.c       **** 
 385:setup.c       **** 
 386:setup.c       **** // ---------- EEPROM ----------
 387:setup.c       **** 
 388:setup.c       **** // Set address/data all high (includes AD0/A23)
 389:setup.c       **** void gba_eeprom_mode (void) {
 555               		.loc 1 389 0
 556               		.cfi_startproc
 557               	/* prologue: function */
 558               	/* frame size = 0 */
 559               	/* stack size = 0 */
 560               	.L__stack_usage = 0
 390:setup.c       **** 	GBA_DDR_ROM_ADDR7_0 = 0xFF;
 561               		.loc 1 390 0
 562 013a 8FEF      		ldi r24,lo8(-1)
 563 013c 87BB      		out 0x17,r24
 391:setup.c       **** 	GBA_DDR_ROM_ADDR15_8 = 0xFF;
 564               		.loc 1 391 0
 565 013e 8ABB      		out 0x1a,r24
 392:setup.c       **** 	GBA_DDR_ROM_ADDR23_16 = 0xFF;
 566               		.loc 1 392 0
 567 0140 84BB      		out 0x14,r24
 393:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = 0x80;
 568               		.loc 1 393 0
 569 0142 90E8      		ldi r25,lo8(-128)
 570 0144 98BB      		out 0x18,r25
 394:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = 0xFF;
 571               		.loc 1 394 0
 572 0146 8BBB      		out 0x1b,r24
 395:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = 0xFF;
 573               		.loc 1 395 0
 574 0148 85BB      		out 0x15,r24
 575 014a 0895      		ret
 576               		.cfi_endproc
 577               	.LFE26:
 579               	.global	gba_eeprom_set_address
 581               	gba_eeprom_set_address:
 582               	.LFB27:
 396:setup.c       **** }
 397:setup.c       **** 
 398:setup.c       **** // Send out EEPROM address serially (WR clock, AD0 data out)
 399:setup.c       **** void gba_eeprom_set_address(uint16_t address, uint8_t eepromSize, uint8_t command) {
 583               		.loc 1 399 0
 584               		.cfi_startproc
 585               	.LVL32:
 586               	/* prologue: function */
 587               	/* frame size = 0 */
 588               	/* stack size = 0 */
 589               	.L__stack_usage = 0
 400:setup.c       **** 	cs_mreqPin_low;
 590               		.loc 1 400 0
 591 014c 9498      		cbi 0x12,4
 592               	.LVL33:
 401:setup.c       **** 	
 402:setup.c       **** 	int8_t x = 0;
 403:setup.c       **** 	if (eepromSize == EEPROM_64KBIT) {
 593               		.loc 1 403 0
 594 014e 6230      		cpi r22,lo8(2)
 595 0150 01F4      		brne .L30
 404:setup.c       **** 		if (command == EEPROM_READ) {
 596               		.loc 1 404 0
 597 0152 4111      		cpse r20,__zero_reg__
 598 0154 00C0      		rjmp .L31
 405:setup.c       **** 			address |= (1<<15) | (1<<14); // Set upper 2 bits high for read request
 599               		.loc 1 405 0
 600 0156 906C      		ori r25,192
 601               	.LVL34:
 602               	.L40:
 406:setup.c       **** 		}
 407:setup.c       **** 		else {
 408:setup.c       **** 			address |= (1<<15); // Set upper 1 bit high for write request
 409:setup.c       **** 		}
 410:setup.c       **** 		x = 15;
 603               		.loc 1 410 0
 604 0158 2FE0      		ldi r18,lo8(15)
 605               	.L33:
 606               	.LVL35:
 411:setup.c       **** 	}
 412:setup.c       **** 	else {
 413:setup.c       **** 		if (command == EEPROM_READ) {
 414:setup.c       **** 			address |= (1<<7) | (1<<6);
 415:setup.c       **** 		}
 416:setup.c       **** 		else {
 417:setup.c       **** 			address |= (1<<7);
 418:setup.c       **** 		}
 419:setup.c       **** 		x = 7;
 420:setup.c       **** 	}
 421:setup.c       **** 	
 422:setup.c       **** 	// Loop through address, 8 or 16 bits depending on EEPROM (includes the 2 bits for request type)
 423:setup.c       **** 	while (x >= 0) {
 424:setup.c       **** 		if (address & (1<<x)) {
 607               		.loc 1 424 0
 608 015a E1E0      		ldi r30,lo8(1)
 609 015c F0E0      		ldi r31,0
 610 015e 00C0      		rjmp .L32
 611               	.LVL36:
 612               	.L31:
 408:setup.c       **** 		}
 613               		.loc 1 408 0
 614 0160 9068      		ori r25,128
 615               	.LVL37:
 616 0162 00C0      		rjmp .L40
 617               	.L30:
 413:setup.c       **** 			address |= (1<<7) | (1<<6);
 618               		.loc 1 413 0
 619 0164 4111      		cpse r20,__zero_reg__
 620 0166 00C0      		rjmp .L34
 414:setup.c       **** 		}
 621               		.loc 1 414 0
 622 0168 806C      		ori r24,192
 623               	.LVL38:
 624 016a 00C0      		rjmp .L39
 625               	.L34:
 417:setup.c       **** 		}
 626               		.loc 1 417 0
 627 016c 8068      		ori r24,128
 628               	.LVL39:
 629               	.L39:
 419:setup.c       **** 	}
 630               		.loc 1 419 0
 631 016e 27E0      		ldi r18,lo8(7)
 632 0170 00C0      		rjmp .L33
 633               	.LVL40:
 634               	.L35:
 425:setup.c       **** 			ad0Pin_high;
 426:setup.c       **** 		}
 427:setup.c       **** 		else {
 428:setup.c       **** 			ad0Pin_low;
 635               		.loc 1 428 0
 636 0172 C098      		cbi 0x18,0
 637               	.L36:
 429:setup.c       **** 		}
 430:setup.c       **** 		
 431:setup.c       **** 		wrPin_low; // CLK
 638               		.loc 1 431 0
 639 0174 9698      		cbi 0x12,6
 432:setup.c       **** 		asm ("nop");
 640               		.loc 1 432 0
 641               	/* #APP */
 642               	 ;  432 "setup.c" 1
 643 0176 0000      		nop
 644               	 ;  0 "" 2
 433:setup.c       **** 		asm ("nop");
 645               		.loc 1 433 0
 646               	 ;  433 "setup.c" 1
 647 0178 0000      		nop
 648               	 ;  0 "" 2
 434:setup.c       **** 		wrPin_high; 
 649               		.loc 1 434 0
 650               	/* #NOAPP */
 651 017a 969A      		sbi 0x12,6
 435:setup.c       **** 		asm ("nop");
 652               		.loc 1 435 0
 653               	/* #APP */
 654               	 ;  435 "setup.c" 1
 655 017c 0000      		nop
 656               	 ;  0 "" 2
 436:setup.c       **** 		asm ("nop");
 657               		.loc 1 436 0
 658               	 ;  436 "setup.c" 1
 659 017e 0000      		nop
 660               	 ;  0 "" 2
 661               	/* #NOAPP */
 662 0180 2150      		subi r18,lo8(-(-1))
 663               	.LVL41:
 423:setup.c       **** 		if (address & (1<<x)) {
 664               		.loc 1 423 0
 665 0182 27FD      		sbrc r18,7
 666 0184 00C0      		rjmp .L41
 667               	.L32:
 424:setup.c       **** 			ad0Pin_high;
 668               		.loc 1 424 0
 669 0186 BF01      		movw r22,r30
 670 0188 022E      		mov r0,r18
 671 018a 00C0      		rjmp 2f
 672               		1:
 673 018c 660F      		lsl r22
 674 018e 771F      		rol r23
 675               		2:
 676 0190 0A94      		dec r0
 677 0192 02F4      		brpl 1b
 678 0194 6823      		and r22,r24
 679 0196 7923      		and r23,r25
 680 0198 672B      		or r22,r23
 681 019a 01F0      		breq .L35
 425:setup.c       **** 		}
 682               		.loc 1 425 0
 683 019c C09A      		sbi 0x18,0
 684 019e 00C0      		rjmp .L36
 685               	.L41:
 437:setup.c       **** 		
 438:setup.c       **** 		x--;
 439:setup.c       **** 	}
 440:setup.c       **** 	
 441:setup.c       **** 	// Only send stop bit (0) and WR/CS high if reading, as writing is done in 1 continuous chunk
 442:setup.c       **** 	if (command == EEPROM_READ) {  
 686               		.loc 1 442 0
 687 01a0 4111      		cpse r20,__zero_reg__
 688 01a2 00C0      		rjmp .L29
 443:setup.c       **** 		ad0Pin_low;
 689               		.loc 1 443 0
 690 01a4 C098      		cbi 0x18,0
 444:setup.c       **** 		asm ("nop");
 691               		.loc 1 444 0
 692               	/* #APP */
 693               	 ;  444 "setup.c" 1
 694 01a6 0000      		nop
 695               	 ;  0 "" 2
 445:setup.c       **** 		wrPin_low;
 696               		.loc 1 445 0
 697               	/* #NOAPP */
 698 01a8 9698      		cbi 0x12,6
 446:setup.c       **** 		asm ("nop");
 699               		.loc 1 446 0
 700               	/* #APP */
 701               	 ;  446 "setup.c" 1
 702 01aa 0000      		nop
 703               	 ;  0 "" 2
 447:setup.c       **** 		asm ("nop");
 704               		.loc 1 447 0
 705               	 ;  447 "setup.c" 1
 706 01ac 0000      		nop
 707               	 ;  0 "" 2
 448:setup.c       **** 		
 449:setup.c       **** 		wrPin_high;
 708               		.loc 1 449 0
 709               	/* #NOAPP */
 710 01ae 969A      		sbi 0x12,6
 450:setup.c       **** 		cs_mreqPin_high;
 711               		.loc 1 450 0
 712 01b0 949A      		sbi 0x12,4
 713               	.L29:
 714 01b2 0895      		ret
 715               		.cfi_endproc
 716               	.LFE27:
 718               	.global	gba_eeprom_read
 720               	gba_eeprom_read:
 721               	.LFB28:
 451:setup.c       **** 	}
 452:setup.c       **** }
 453:setup.c       **** 
 454:setup.c       **** // Read 8 bytes from the EEPROM address, data is valid on rising edge
 455:setup.c       **** void gba_eeprom_read(uint16_t address, uint8_t eepromSize) {
 722               		.loc 1 455 0
 723               		.cfi_startproc
 724               	.LVL42:
 725               	/* prologue: function */
 726               	/* frame size = 0 */
 727               	/* stack size = 0 */
 728               	.L__stack_usage = 0
 456:setup.c       **** 	gba_eeprom_set_address(address, eepromSize, EEPROM_READ);
 729               		.loc 1 456 0
 730 01b4 40E0      		ldi r20,0
 731 01b6 00D0      		rcall gba_eeprom_set_address
 732               	.LVL43:
 457:setup.c       **** 	
 458:setup.c       **** 	// Set AD0 pin as input
 459:setup.c       **** 	GBA_PORT_EEPROM_DATA7_0 &= ~(1<<AD0);
 733               		.loc 1 459 0
 734 01b8 C098      		cbi 0x18,0
 460:setup.c       **** 	GBA_DDR_EEPROM_DATA7_0 &= ~(1<<AD0);
 735               		.loc 1 460 0
 736 01ba B898      		cbi 0x17,0
 461:setup.c       **** 	
 462:setup.c       **** 	cs_mreqPin_low;
 737               		.loc 1 462 0
 738 01bc 9498      		cbi 0x12,4
 739               	.LVL44:
 740 01be 84E0      		ldi r24,lo8(4)
 741               	.LVL45:
 742               	.L43:
 743               	.LBB101:
 463:setup.c       **** 	
 464:setup.c       **** 	// Ignore first 4 bits
 465:setup.c       **** 	for (int8_t x = 0; x < 4; x++) {
 466:setup.c       **** 		rdPin_low; // CLK
 744               		.loc 1 466 0 discriminator 3
 745 01c0 9598      		cbi 0x12,5
 467:setup.c       **** 		asm ("nop");
 746               		.loc 1 467 0 discriminator 3
 747               	/* #APP */
 748               	 ;  467 "setup.c" 1
 749 01c2 0000      		nop
 750               	 ;  0 "" 2
 468:setup.c       **** 		asm ("nop");
 751               		.loc 1 468 0 discriminator 3
 752               	 ;  468 "setup.c" 1
 753 01c4 0000      		nop
 754               	 ;  0 "" 2
 469:setup.c       **** 		rdPin_high; 
 755               		.loc 1 469 0 discriminator 3
 756               	/* #NOAPP */
 757 01c6 959A      		sbi 0x12,5
 470:setup.c       **** 		asm ("nop");
 758               		.loc 1 470 0 discriminator 3
 759               	/* #APP */
 760               	 ;  470 "setup.c" 1
 761 01c8 0000      		nop
 762               	 ;  0 "" 2
 471:setup.c       **** 		asm ("nop");
 763               		.loc 1 471 0 discriminator 3
 764               	 ;  471 "setup.c" 1
 765 01ca 0000      		nop
 766               	 ;  0 "" 2
 767               	.LVL46:
 768               	/* #NOAPP */
 769 01cc 8150      		subi r24,lo8(-(-1))
 770               	.LVL47:
 465:setup.c       **** 		rdPin_low; // CLK
 771               		.loc 1 465 0 discriminator 3
 772 01ce 01F4      		brne .L43
 773 01d0 E0E0      		ldi r30,lo8(eepromBuffer)
 774 01d2 F0E0      		ldi r31,hi8(eepromBuffer)
 775               	.LBE101:
 776               	.LBB102:
 777               	.LBB103:
 778               	.LBB104:
 472:setup.c       **** 	}
 473:setup.c       **** 	
 474:setup.c       **** 	// Read out 64 bits
 475:setup.c       **** 	for (uint8_t c = 0; c < 8; c++) {
 476:setup.c       **** 		uint8_t data = 0;
 477:setup.c       **** 		for (int8_t x = 7; x >= 0; x--) {
 478:setup.c       **** 			rdPin_low; // CLK
 479:setup.c       **** 			asm ("nop");
 480:setup.c       **** 			asm ("nop");
 481:setup.c       **** 			rdPin_high;
 482:setup.c       **** 			
 483:setup.c       **** 			if (GBA_PIN_EEPROM_DATA7_0 & (1<<AD0)) {
 484:setup.c       **** 				data |= (1<<x);
 779               		.loc 1 484 0
 780 01d4 41E0      		ldi r20,lo8(1)
 781 01d6 50E0      		ldi r21,0
 782               	.LVL48:
 783               	.L44:
 784               	.LBE104:
 785               	.LBE103:
 786               	.LBE102:
 462:setup.c       **** 	
 787               		.loc 1 462 0
 788 01d8 87E0      		ldi r24,lo8(7)
 789 01da 90E0      		ldi r25,0
 790 01dc 20E0      		ldi r18,0
 791               	.LVL49:
 792               	.L46:
 793               	.LBB107:
 794               	.LBB106:
 795               	.LBB105:
 478:setup.c       **** 			asm ("nop");
 796               		.loc 1 478 0
 797 01de 9598      		cbi 0x12,5
 479:setup.c       **** 			asm ("nop");
 798               		.loc 1 479 0
 799               	/* #APP */
 800               	 ;  479 "setup.c" 1
 801 01e0 0000      		nop
 802               	 ;  0 "" 2
 480:setup.c       **** 			rdPin_high;
 803               		.loc 1 480 0
 804               	 ;  480 "setup.c" 1
 805 01e2 0000      		nop
 806               	 ;  0 "" 2
 481:setup.c       **** 			
 807               		.loc 1 481 0
 808               	/* #NOAPP */
 809 01e4 959A      		sbi 0x12,5
 483:setup.c       **** 				data |= (1<<x);
 810               		.loc 1 483 0
 811 01e6 B09B      		sbis 0x16,0
 812 01e8 00C0      		rjmp .L45
 813               		.loc 1 484 0
 814 01ea BA01      		movw r22,r20
 815 01ec 082E      		mov r0,r24
 816 01ee 00C0      		rjmp 2f
 817               		1:
 818 01f0 660F      		lsl r22
 819               		2:
 820 01f2 0A94      		dec r0
 821 01f4 02F4      		brpl 1b
 822 01f6 262B      		or r18,r22
 823               	.LVL50:
 824               	.L45:
 825               	.LVL51:
 826 01f8 0197      		sbiw r24,1
 827 01fa 00F4      		brcc .L46
 828               	.LBE105:
 485:setup.c       **** 			}
 486:setup.c       **** 		}
 487:setup.c       **** 		eepromBuffer[c] = data;
 829               		.loc 1 487 0 discriminator 2
 830 01fc 2193      		st Z+,r18
 831               	.LVL52:
 832               	.LBE106:
 475:setup.c       **** 		uint8_t data = 0;
 833               		.loc 1 475 0 discriminator 2
 834 01fe 80E0      		ldi r24,hi8(eepromBuffer+8)
 835 0200 E030      		cpi r30,lo8(eepromBuffer+8)
 836 0202 F807      		cpc r31,r24
 837               	.LVL53:
 838 0204 01F4      		brne .L44
 839               	.LBE107:
 488:setup.c       **** 	}
 489:setup.c       **** 	
 490:setup.c       **** 	cs_mreqPin_high;
 840               		.loc 1 490 0
 841 0206 949A      		sbi 0x12,4
 491:setup.c       **** 	
 492:setup.c       **** 	// Set AD0 pin as output
 493:setup.c       **** 	GBA_PORT_EEPROM_DATA7_0 |= (1<<AD0);
 842               		.loc 1 493 0
 843 0208 C09A      		sbi 0x18,0
 494:setup.c       **** 	GBA_DDR_EEPROM_DATA7_0 |= (1<<AD0);
 844               		.loc 1 494 0
 845 020a B89A      		sbi 0x17,0
 846 020c 0895      		ret
 847               		.cfi_endproc
 848               	.LFE28:
 850               	.global	gba_eeprom_write
 852               	gba_eeprom_write:
 853               	.LFB29:
 495:setup.c       **** }
 496:setup.c       **** 
 497:setup.c       **** // Write 8 bytes to the EEPROM address
 498:setup.c       **** void gba_eeprom_write(uint16_t address, uint8_t eepromSize) {
 854               		.loc 1 498 0
 855               		.cfi_startproc
 856               	.LVL54:
 857               	/* prologue: function */
 858               	/* frame size = 0 */
 859               	/* stack size = 0 */
 860               	.L__stack_usage = 0
 499:setup.c       **** 	gba_eeprom_set_address(address, eepromSize, EEPROM_WRITE);
 861               		.loc 1 499 0
 862 020e 41E0      		ldi r20,lo8(1)
 863 0210 00D0      		rcall gba_eeprom_set_address
 864               	.LVL55:
 865 0212 E0E0      		ldi r30,lo8(eepromBuffer)
 866 0214 F0E0      		ldi r31,hi8(eepromBuffer)
 867 0216 48E0      		ldi r20,lo8(8)
 868               	.LVL56:
 869               	.L54:
 498:setup.c       **** 	gba_eeprom_set_address(address, eepromSize, EEPROM_WRITE);
 870               		.loc 1 498 0
 871 0218 27E0      		ldi r18,lo8(7)
 872 021a 30E0      		ldi r19,0
 873               	.LVL57:
 874               	.L57:
 875               	.LBB108:
 876               	.LBB109:
 500:setup.c       **** 	
 501:setup.c       **** 	// Write 64 bits
 502:setup.c       **** 	for (uint8_t c = 0; c < 8; c++) {
 503:setup.c       **** 		for (int8_t x = 7; x >= 0; x--) {
 504:setup.c       **** 			if (eepromBuffer[c] & (1<<x)) {
 877               		.loc 1 504 0
 878 021c 8081      		ld r24,Z
 879 021e 90E0      		ldi r25,0
 880 0220 022E      		mov r0,r18
 881 0222 00C0      		rjmp 2f
 882               		1:
 883 0224 9595      		asr r25
 884 0226 8795      		ror r24
 885               		2:
 886 0228 0A94      		dec r0
 887 022a 02F4      		brpl 1b
 888 022c 80FF      		sbrs r24,0
 889 022e 00C0      		rjmp .L55
 505:setup.c       **** 				ad0Pin_high;
 890               		.loc 1 505 0
 891 0230 C09A      		sbi 0x18,0
 892 0232 00C0      		rjmp .L56
 893               	.L55:
 506:setup.c       **** 			}
 507:setup.c       **** 			else {
 508:setup.c       **** 				ad0Pin_low;
 894               		.loc 1 508 0
 895 0234 C098      		cbi 0x18,0
 896               	.L56:
 509:setup.c       **** 			}
 510:setup.c       **** 			
 511:setup.c       **** 			wrPin_low; // CLK
 897               		.loc 1 511 0 discriminator 2
 898 0236 9698      		cbi 0x12,6
 512:setup.c       **** 			asm ("nop");
 899               		.loc 1 512 0 discriminator 2
 900               	/* #APP */
 901               	 ;  512 "setup.c" 1
 902 0238 0000      		nop
 903               	 ;  0 "" 2
 513:setup.c       **** 			asm ("nop");
 904               		.loc 1 513 0 discriminator 2
 905               	 ;  513 "setup.c" 1
 906 023a 0000      		nop
 907               	 ;  0 "" 2
 514:setup.c       **** 			wrPin_high; 
 908               		.loc 1 514 0 discriminator 2
 909               	/* #NOAPP */
 910 023c 969A      		sbi 0x12,6
 515:setup.c       **** 			asm ("nop");
 911               		.loc 1 515 0 discriminator 2
 912               	/* #APP */
 913               	 ;  515 "setup.c" 1
 914 023e 0000      		nop
 915               	 ;  0 "" 2
 516:setup.c       **** 			asm ("nop");
 916               		.loc 1 516 0 discriminator 2
 917               	 ;  516 "setup.c" 1
 918 0240 0000      		nop
 919               	 ;  0 "" 2
 920               	.LVL58:
 921               	/* #NOAPP */
 922               	.LVL59:
 923 0242 2150      		subi r18,1
 924 0244 3109      		sbc r19,__zero_reg__
 925 0246 00F4      		brcc .L57
 926 0248 4150      		subi r20,lo8(-(-1))
 927 024a 3196      		adiw r30,1
 928               	.LVL60:
 929               	.LBE109:
 502:setup.c       **** 		for (int8_t x = 7; x >= 0; x--) {
 930               		.loc 1 502 0 discriminator 2
 931 024c 4111      		cpse r20,__zero_reg__
 932 024e 00C0      		rjmp .L54
 933               	.LBE108:
 517:setup.c       **** 		}
 518:setup.c       **** 	}
 519:setup.c       **** 	
 520:setup.c       **** 	// Last bit low
 521:setup.c       **** 	ad0Pin_low;
 934               		.loc 1 521 0
 935 0250 C098      		cbi 0x18,0
 522:setup.c       **** 	wrPin_low; // CLK
 936               		.loc 1 522 0
 937 0252 9698      		cbi 0x12,6
 523:setup.c       **** 	asm ("nop");
 938               		.loc 1 523 0
 939               	/* #APP */
 940               	 ;  523 "setup.c" 1
 941 0254 0000      		nop
 942               	 ;  0 "" 2
 524:setup.c       **** 	asm ("nop");
 943               		.loc 1 524 0
 944               	 ;  524 "setup.c" 1
 945 0256 0000      		nop
 946               	 ;  0 "" 2
 525:setup.c       **** 	wrPin_high; 
 947               		.loc 1 525 0
 948               	/* #NOAPP */
 949 0258 969A      		sbi 0x12,6
 526:setup.c       **** 	asm ("nop");
 950               		.loc 1 526 0
 951               	/* #APP */
 952               	 ;  526 "setup.c" 1
 953 025a 0000      		nop
 954               	 ;  0 "" 2
 527:setup.c       **** 	asm ("nop");
 955               		.loc 1 527 0
 956               	 ;  527 "setup.c" 1
 957 025c 0000      		nop
 958               	 ;  0 "" 2
 528:setup.c       **** 	
 529:setup.c       **** 	cs_mreqPin_high;
 959               		.loc 1 529 0
 960               	/* #NOAPP */
 961 025e 949A      		sbi 0x12,4
 962 0260 0895      		ret
 963               		.cfi_endproc
 964               	.LFE29:
 966               	.global	flash_write_bus_cycle
 968               	flash_write_bus_cycle:
 969               	.LFB30:
 530:setup.c       **** }
 531:setup.c       **** 
 532:setup.c       **** 
 533:setup.c       **** 
 534:setup.c       **** // ---------- FLASH ----------
 535:setup.c       **** 
 536:setup.c       **** // Set the address and data for the write byte cycle to the flash
 537:setup.c       **** void flash_write_bus_cycle(uint16_t address, uint8_t data) {
 970               		.loc 1 537 0
 971               		.cfi_startproc
 972               	.LVL61:
 973 0262 CF93      		push r28
 974               	.LCFI11:
 975               		.cfi_def_cfa_offset 3
 976               		.cfi_offset 28, -2
 977               	/* prologue: function */
 978               	/* frame size = 0 */
 979               	/* stack size = 1 */
 980               	.L__stack_usage = 1
 981 0264 C62F      		mov r28,r22
 538:setup.c       **** 	GBA_DDR_RAM_DATA7_0 = 0xFF; // Set data pins as outputs
 982               		.loc 1 538 0
 983 0266 2FEF      		ldi r18,lo8(-1)
 984 0268 24BB      		out 0x14,r18
 539:setup.c       **** 	set_16bit_address(address);
 985               		.loc 1 539 0
 986 026a 00D0      		rcall set_16bit_address
 987               	.LVL62:
 540:setup.c       **** 	GBA_PORT_RAM_DATA7_0 = data;
 988               		.loc 1 540 0
 989 026c C5BB      		out 0x15,r28
 541:setup.c       **** 	
 542:setup.c       **** 	wrPin_low;
 990               		.loc 1 542 0
 991 026e 9698      		cbi 0x12,6
 543:setup.c       **** 	cs2Pin_low;
 992               		.loc 1 543 0
 993 0270 3A98      		cbi 0x7,2
 544:setup.c       **** 	asm volatile("nop");
 994               		.loc 1 544 0
 995               	/* #APP */
 996               	 ;  544 "setup.c" 1
 997 0272 0000      		nop
 998               	 ;  0 "" 2
 545:setup.c       **** 	wrPin_high;
 999               		.loc 1 545 0
 1000               	/* #NOAPP */
 1001 0274 969A      		sbi 0x12,6
 546:setup.c       **** 	cs2Pin_high;
 1002               		.loc 1 546 0
 1003 0276 3A9A      		sbi 0x7,2
 1004               	/* epilogue start */
 547:setup.c       **** }
 1005               		.loc 1 547 0
 1006 0278 CF91      		pop r28
 1007               	.LVL63:
 1008 027a 0895      		ret
 1009               		.cfi_endproc
 1010               	.LFE30:
 1012               	.global	flash_read_chip_id
 1014               	flash_read_chip_id:
 1015               	.LFB31:
 548:setup.c       **** 
 549:setup.c       **** // Read the flash manufacturer and device ID (Software ID)
 550:setup.c       **** void flash_read_chip_id(void) {
 1016               		.loc 1 550 0
 1017               		.cfi_startproc
 1018 027c CF93      		push r28
 1019               	.LCFI12:
 1020               		.cfi_def_cfa_offset 3
 1021               		.cfi_offset 28, -2
 1022 027e DF93      		push r29
 1023               	.LCFI13:
 1024               		.cfi_def_cfa_offset 4
 1025               		.cfi_offset 29, -3
 1026               	/* prologue: function */
 1027               	/* frame size = 0 */
 1028               	/* stack size = 2 */
 1029               	.L__stack_usage = 2
 551:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xAA);
 1030               		.loc 1 551 0
 1031 0280 6AEA      		ldi r22,lo8(-86)
 1032 0282 85E5      		ldi r24,lo8(85)
 1033 0284 95E5      		ldi r25,lo8(85)
 1034 0286 00D0      		rcall flash_write_bus_cycle
 1035               	.LVL64:
 552:setup.c       **** 	flash_write_bus_cycle(0x2AAA, 0x55);
 1036               		.loc 1 552 0
 1037 0288 65E5      		ldi r22,lo8(85)
 1038 028a 8AEA      		ldi r24,lo8(-86)
 1039 028c 9AE2      		ldi r25,lo8(42)
 1040 028e 00D0      		rcall flash_write_bus_cycle
 1041               	.LVL65:
 553:setup.c       **** 	flash_write_bus_cycle(0x5555, 0x90); // Software ID entry
 1042               		.loc 1 553 0
 1043 0290 60E9      		ldi r22,lo8(-112)
 1044 0292 85E5      		ldi r24,lo8(85)
 1045 0294 95E5      		ldi r25,lo8(85)
 1046 0296 00D0      		rcall flash_write_bus_cycle
 1047               	.LVL66:
 1048               	.LBB110:
 1049               	.LBB111:
 1050               		.file 2 "c:\\winavr-20100110\\avr\\include\\util\\delay.h"
   1:c:\winavr-20100110\avr\include\util\delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:c:\winavr-20100110\avr\include\util\delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:c:\winavr-20100110\avr\include\util\delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:c:\winavr-20100110\avr\include\util\delay.h ****    All rights reserved.
   5:c:\winavr-20100110\avr\include\util\delay.h **** 
   6:c:\winavr-20100110\avr\include\util\delay.h ****    Redistribution and use in source and binary forms, with or without
   7:c:\winavr-20100110\avr\include\util\delay.h ****    modification, are permitted provided that the following conditions are met:
   8:c:\winavr-20100110\avr\include\util\delay.h **** 
   9:c:\winavr-20100110\avr\include\util\delay.h ****    * Redistributions of source code must retain the above copyright
  10:c:\winavr-20100110\avr\include\util\delay.h ****      notice, this list of conditions and the following disclaimer.
  11:c:\winavr-20100110\avr\include\util\delay.h **** 
  12:c:\winavr-20100110\avr\include\util\delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:c:\winavr-20100110\avr\include\util\delay.h ****      notice, this list of conditions and the following disclaimer in
  14:c:\winavr-20100110\avr\include\util\delay.h ****      the documentation and/or other materials provided with the
  15:c:\winavr-20100110\avr\include\util\delay.h ****      distribution.
  16:c:\winavr-20100110\avr\include\util\delay.h **** 
  17:c:\winavr-20100110\avr\include\util\delay.h ****    * Neither the name of the copyright holders nor the names of
  18:c:\winavr-20100110\avr\include\util\delay.h ****      contributors may be used to endorse or promote products derived
  19:c:\winavr-20100110\avr\include\util\delay.h ****      from this software without specific prior written permission.
  20:c:\winavr-20100110\avr\include\util\delay.h **** 
  21:c:\winavr-20100110\avr\include\util\delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:c:\winavr-20100110\avr\include\util\delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:c:\winavr-20100110\avr\include\util\delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:c:\winavr-20100110\avr\include\util\delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:c:\winavr-20100110\avr\include\util\delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:c:\winavr-20100110\avr\include\util\delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:c:\winavr-20100110\avr\include\util\delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:c:\winavr-20100110\avr\include\util\delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:c:\winavr-20100110\avr\include\util\delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:c:\winavr-20100110\avr\include\util\delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:c:\winavr-20100110\avr\include\util\delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:c:\winavr-20100110\avr\include\util\delay.h **** 
  33:c:\winavr-20100110\avr\include\util\delay.h **** /* $Id$ */
  34:c:\winavr-20100110\avr\include\util\delay.h **** 
  35:c:\winavr-20100110\avr\include\util\delay.h **** #ifndef _UTIL_DELAY_H_
  36:c:\winavr-20100110\avr\include\util\delay.h **** #define _UTIL_DELAY_H_ 1
  37:c:\winavr-20100110\avr\include\util\delay.h **** 
  38:c:\winavr-20100110\avr\include\util\delay.h **** #ifndef __DOXYGEN__
  39:c:\winavr-20100110\avr\include\util\delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:c:\winavr-20100110\avr\include\util\delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:c:\winavr-20100110\avr\include\util\delay.h **** #  endif
  42:c:\winavr-20100110\avr\include\util\delay.h **** #endif  /* __DOXYGEN__ */
  43:c:\winavr-20100110\avr\include\util\delay.h **** 
  44:c:\winavr-20100110\avr\include\util\delay.h **** #include <inttypes.h>
  45:c:\winavr-20100110\avr\include\util\delay.h **** #include <util/delay_basic.h>
  46:c:\winavr-20100110\avr\include\util\delay.h **** #include <math.h>
  47:c:\winavr-20100110\avr\include\util\delay.h **** 
  48:c:\winavr-20100110\avr\include\util\delay.h **** /** \file */
  49:c:\winavr-20100110\avr\include\util\delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:c:\winavr-20100110\avr\include\util\delay.h ****     \code
  51:c:\winavr-20100110\avr\include\util\delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:c:\winavr-20100110\avr\include\util\delay.h ****     //#define F_CPU 14.7456E6
  53:c:\winavr-20100110\avr\include\util\delay.h ****     #include <util/delay.h>
  54:c:\winavr-20100110\avr\include\util\delay.h ****     \endcode
  55:c:\winavr-20100110\avr\include\util\delay.h **** 
  56:c:\winavr-20100110\avr\include\util\delay.h ****     \note As an alternative method, it is possible to pass the
  57:c:\winavr-20100110\avr\include\util\delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:c:\winavr-20100110\avr\include\util\delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:c:\winavr-20100110\avr\include\util\delay.h ****     used.
  60:c:\winavr-20100110\avr\include\util\delay.h **** 
  61:c:\winavr-20100110\avr\include\util\delay.h ****     The functions in this header file are wrappers around the basic
  62:c:\winavr-20100110\avr\include\util\delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:c:\winavr-20100110\avr\include\util\delay.h ****     convenience functions where actual time values can be specified
  64:c:\winavr-20100110\avr\include\util\delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:c:\winavr-20100110\avr\include\util\delay.h ****     that compile-time constant expressions will be eliminated by
  66:c:\winavr-20100110\avr\include\util\delay.h ****     compiler optimization so floating-point expressions can be used
  67:c:\winavr-20100110\avr\include\util\delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:c:\winavr-20100110\avr\include\util\delay.h ****     frequency passed by the macro F_CPU.
  69:c:\winavr-20100110\avr\include\util\delay.h **** 
  70:c:\winavr-20100110\avr\include\util\delay.h ****     \note In order for these functions to work as intended, compiler
  71:c:\winavr-20100110\avr\include\util\delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:c:\winavr-20100110\avr\include\util\delay.h ****     <em>must</em> be an expression that is a known constant at
  73:c:\winavr-20100110\avr\include\util\delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:c:\winavr-20100110\avr\include\util\delay.h ****     delay will be much longer (and basically unpredictable), and
  75:c:\winavr-20100110\avr\include\util\delay.h ****     applications that otherwise do not use floating-point calculations
  76:c:\winavr-20100110\avr\include\util\delay.h ****     will experience severe code bloat by the floating-point library
  77:c:\winavr-20100110\avr\include\util\delay.h ****     routines linked into the application.
  78:c:\winavr-20100110\avr\include\util\delay.h **** 
  79:c:\winavr-20100110\avr\include\util\delay.h ****     The functions available allow the specification of microsecond, and
  80:c:\winavr-20100110\avr\include\util\delay.h ****     millisecond delays directly, using the application-supplied macro
  81:c:\winavr-20100110\avr\include\util\delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:c:\winavr-20100110\avr\include\util\delay.h **** 
  83:c:\winavr-20100110\avr\include\util\delay.h **** */
  84:c:\winavr-20100110\avr\include\util\delay.h **** 
  85:c:\winavr-20100110\avr\include\util\delay.h **** #if !defined(__DOXYGEN__)
  86:c:\winavr-20100110\avr\include\util\delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:c:\winavr-20100110\avr\include\util\delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:c:\winavr-20100110\avr\include\util\delay.h **** #endif
  89:c:\winavr-20100110\avr\include\util\delay.h **** 
  90:c:\winavr-20100110\avr\include\util\delay.h **** #ifndef F_CPU
  91:c:\winavr-20100110\avr\include\util\delay.h **** /* prevent compiler error by supplying a default */
  92:c:\winavr-20100110\avr\include\util\delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:c:\winavr-20100110\avr\include\util\delay.h **** /** \ingroup util_delay
  94:c:\winavr-20100110\avr\include\util\delay.h ****     \def F_CPU
  95:c:\winavr-20100110\avr\include\util\delay.h ****     \brief CPU frequency in Hz
  96:c:\winavr-20100110\avr\include\util\delay.h **** 
  97:c:\winavr-20100110\avr\include\util\delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:c:\winavr-20100110\avr\include\util\delay.h ****     the delay macros.  This macro is normally supplied by the
  99:c:\winavr-20100110\avr\include\util\delay.h ****     environment (e.g. from within a project header, or the project's
 100:c:\winavr-20100110\avr\include\util\delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:c:\winavr-20100110\avr\include\util\delay.h ****     fallback if no such user-provided definition could be found.
 102:c:\winavr-20100110\avr\include\util\delay.h **** 
 103:c:\winavr-20100110\avr\include\util\delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:c:\winavr-20100110\avr\include\util\delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:c:\winavr-20100110\avr\include\util\delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:c:\winavr-20100110\avr\include\util\delay.h ****     integer value.
 107:c:\winavr-20100110\avr\include\util\delay.h ****  */
 108:c:\winavr-20100110\avr\include\util\delay.h **** # define F_CPU 1000000UL
 109:c:\winavr-20100110\avr\include\util\delay.h **** #endif
 110:c:\winavr-20100110\avr\include\util\delay.h **** 
 111:c:\winavr-20100110\avr\include\util\delay.h **** #ifndef __OPTIMIZE__
 112:c:\winavr-20100110\avr\include\util\delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:c:\winavr-20100110\avr\include\util\delay.h **** #endif
 114:c:\winavr-20100110\avr\include\util\delay.h **** 
 115:c:\winavr-20100110\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:c:\winavr-20100110\avr\include\util\delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:c:\winavr-20100110\avr\include\util\delay.h ****   __STDC_HOSTED__
 118:c:\winavr-20100110\avr\include\util\delay.h **** #  include <math.h>
 119:c:\winavr-20100110\avr\include\util\delay.h **** #endif
 120:c:\winavr-20100110\avr\include\util\delay.h **** 
 121:c:\winavr-20100110\avr\include\util\delay.h **** /**
 122:c:\winavr-20100110\avr\include\util\delay.h ****    \ingroup util_delay
 123:c:\winavr-20100110\avr\include\util\delay.h **** 
 124:c:\winavr-20100110\avr\include\util\delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:c:\winavr-20100110\avr\include\util\delay.h **** 
 126:c:\winavr-20100110\avr\include\util\delay.h ****    The macro F_CPU is supposed to be defined to a
 127:c:\winavr-20100110\avr\include\util\delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:c:\winavr-20100110\avr\include\util\delay.h **** 
 129:c:\winavr-20100110\avr\include\util\delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:c:\winavr-20100110\avr\include\util\delay.h **** 
 131:c:\winavr-20100110\avr\include\util\delay.h ****    When the user request delay which exceed the maximum possible one,
 132:c:\winavr-20100110\avr\include\util\delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:c:\winavr-20100110\avr\include\util\delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:c:\winavr-20100110\avr\include\util\delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:c:\winavr-20100110\avr\include\util\delay.h ****    user will not be informed about decreased resolution.
 136:c:\winavr-20100110\avr\include\util\delay.h **** 
 137:c:\winavr-20100110\avr\include\util\delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:c:\winavr-20100110\avr\include\util\delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:c:\winavr-20100110\avr\include\util\delay.h ****    values greater than the maximal possible delay, overflows results in
 140:c:\winavr-20100110\avr\include\util\delay.h ****    no delay i.e., 0ms.
 141:c:\winavr-20100110\avr\include\util\delay.h **** 
 142:c:\winavr-20100110\avr\include\util\delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:c:\winavr-20100110\avr\include\util\delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:c:\winavr-20100110\avr\include\util\delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:c:\winavr-20100110\avr\include\util\delay.h ****    microseconds of delay.
 146:c:\winavr-20100110\avr\include\util\delay.h **** 
 147:c:\winavr-20100110\avr\include\util\delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:c:\winavr-20100110\avr\include\util\delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:c:\winavr-20100110\avr\include\util\delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:c:\winavr-20100110\avr\include\util\delay.h ****    respectively.
 151:c:\winavr-20100110\avr\include\util\delay.h **** 
 152:c:\winavr-20100110\avr\include\util\delay.h ****    \note
 153:c:\winavr-20100110\avr\include\util\delay.h **** 
 154:c:\winavr-20100110\avr\include\util\delay.h ****    The implementation of _delay_ms() based on
 155:c:\winavr-20100110\avr\include\util\delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:c:\winavr-20100110\avr\include\util\delay.h ****    implementations.  In order to get functionality backward compatible
 157:c:\winavr-20100110\avr\include\util\delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:c:\winavr-20100110\avr\include\util\delay.h ****    must be defined before including this header file. Also, the
 159:c:\winavr-20100110\avr\include\util\delay.h ****    backward compatible algorithm will be chosen if the code is
 160:c:\winavr-20100110\avr\include\util\delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:c:\winavr-20100110\avr\include\util\delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:c:\winavr-20100110\avr\include\util\delay.h ****    not available to the compiler then.
 163:c:\winavr-20100110\avr\include\util\delay.h **** 
 164:c:\winavr-20100110\avr\include\util\delay.h ****  */
 165:c:\winavr-20100110\avr\include\util\delay.h **** void
 166:c:\winavr-20100110\avr\include\util\delay.h **** _delay_ms(double __ms)
 167:c:\winavr-20100110\avr\include\util\delay.h **** {
 168:c:\winavr-20100110\avr\include\util\delay.h **** 	double __tmp ;
 169:c:\winavr-20100110\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:c:\winavr-20100110\avr\include\util\delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:c:\winavr-20100110\avr\include\util\delay.h ****   __STDC_HOSTED__
 172:c:\winavr-20100110\avr\include\util\delay.h **** 	uint32_t __ticks_dc;
 173:c:\winavr-20100110\avr\include\util\delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 174:c:\winavr-20100110\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 175:c:\winavr-20100110\avr\include\util\delay.h **** 
 176:c:\winavr-20100110\avr\include\util\delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:c:\winavr-20100110\avr\include\util\delay.h **** 
 179:c:\winavr-20100110\avr\include\util\delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:c:\winavr-20100110\avr\include\util\delay.h **** 
 182:c:\winavr-20100110\avr\include\util\delay.h **** 	#else
 183:c:\winavr-20100110\avr\include\util\delay.h **** 		//round up by default
 184:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 185:c:\winavr-20100110\avr\include\util\delay.h **** 	#endif
 186:c:\winavr-20100110\avr\include\util\delay.h **** 
 187:c:\winavr-20100110\avr\include\util\delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 1051               		.loc 2 187 0
 1052 0298 8FE3      		ldi r24,lo8(-25537)
 1053 029a 9CE9      		ldi r25,hi8(-25537)
 1054 029c 0197      	1:	sbiw r24,1
 1055 029e 01F4      		brne 1b
 1056 02a0 00C0      		rjmp .
 1057 02a2 0000      		nop
 1058               	.LVL67:
 1059               	.LBE111:
 1060               	.LBE110:
 554:setup.c       **** 	_delay_ms(20); // Wait a little (for Atmel chip)
 555:setup.c       **** 	
 556:setup.c       **** 	// Set data as inputs
 557:setup.c       **** 	GBA_PORT_RAM_DATA7_0 = 0;
 1061               		.loc 1 557 0
 1062 02a4 15BA      		out 0x15,__zero_reg__
 558:setup.c       **** 	GBA_DDR_RAM_DATA7_0 = 0;
 1063               		.loc 1 558 0
 1064 02a6 14BA      		out 0x14,__zero_reg__
 559:setup.c       **** 	
 560:setup.c       **** 	// Read and transmit the 2 bytes
 561:setup.c       **** 	flashChipIdBuffer[0] = gba_read_ram_8bit_data(0x0000);
 1065               		.loc 1 561 0
 1066 02a8 80E0      		ldi r24,0
 1067 02aa 90E0      		ldi r25,0
 1068 02ac 00D0      		rcall gba_read_ram_8bit_data
 1069               	.LVL68:
 1070 02ae C0E0      		ldi r28,lo8(flashChipIdBuffer)
 1071 02b0 D0E0      		ldi r29,hi8(flashChipIdBuffer)
 1072 02b2 8883      		st Y,r24
 562:setup.c       **** 	flashChipIdBuffer[1] = gba_read_ram_8bit_data(0x0001);
 1073               		.loc 1 562 0
 1074 02b4 81E0      		ldi r24,lo8(1)
 1075 02b6 90E0      		ldi r25,0
 1076 02b8 00D0      		rcall gba_read_ram_8bit_data
 1077               	.LVL69:
 1078 02ba 8983      		std Y+1,r24
 563:setup.c       **** 	
 564:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xAA);
 1079               		.loc 1 564 0
 1080 02bc 6AEA      		ldi r22,lo8(-86)
 1081 02be 85E5      		ldi r24,lo8(85)
 1082 02c0 95E5      		ldi r25,lo8(85)
 1083 02c2 00D0      		rcall flash_write_bus_cycle
 1084               	.LVL70:
 565:setup.c       **** 	flash_write_bus_cycle(0x2AAA, 0x55);
 1085               		.loc 1 565 0
 1086 02c4 65E5      		ldi r22,lo8(85)
 1087 02c6 8AEA      		ldi r24,lo8(-86)
 1088 02c8 9AE2      		ldi r25,lo8(42)
 1089 02ca 00D0      		rcall flash_write_bus_cycle
 1090               	.LVL71:
 566:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xF0); // Software ID exit
 1091               		.loc 1 566 0
 1092 02cc 60EF      		ldi r22,lo8(-16)
 1093 02ce 85E5      		ldi r24,lo8(85)
 1094 02d0 95E5      		ldi r25,lo8(85)
 1095 02d2 00D0      		rcall flash_write_bus_cycle
 1096               	.LVL72:
 1097               	.LBB112:
 1098               	.LBB113:
 1099               		.loc 2 187 0
 1100 02d4 8FE3      		ldi r24,lo8(-25537)
 1101 02d6 9CE9      		ldi r25,hi8(-25537)
 1102 02d8 0197      	1:	sbiw r24,1
 1103 02da 01F4      		brne 1b
 1104 02dc 00C0      		rjmp .
 1105 02de 0000      		nop
 1106               	.LVL73:
 1107               	/* epilogue start */
 1108               	.LBE113:
 1109               	.LBE112:
 567:setup.c       **** 	_delay_ms(20); // Wait a little (for Atmel chip)
 568:setup.c       **** }
 1110               		.loc 1 568 0
 1111 02e0 DF91      		pop r29
 1112 02e2 CF91      		pop r28
 1113 02e4 0895      		ret
 1114               		.cfi_endproc
 1115               	.LFE31:
 1117               	.global	flash_switch_bank
 1119               	flash_switch_bank:
 1120               	.LFB32:
 569:setup.c       **** 
 570:setup.c       **** // Switch banks on the Flash
 571:setup.c       **** void flash_switch_bank(uint8_t bank) {
 1121               		.loc 1 571 0
 1122               		.cfi_startproc
 1123               	.LVL74:
 1124 02e6 CF93      		push r28
 1125               	.LCFI14:
 1126               		.cfi_def_cfa_offset 3
 1127               		.cfi_offset 28, -2
 1128               	/* prologue: function */
 1129               	/* frame size = 0 */
 1130               	/* stack size = 1 */
 1131               	.L__stack_usage = 1
 1132 02e8 C82F      		mov r28,r24
 572:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xAA);
 1133               		.loc 1 572 0
 1134 02ea 6AEA      		ldi r22,lo8(-86)
 1135 02ec 85E5      		ldi r24,lo8(85)
 1136 02ee 95E5      		ldi r25,lo8(85)
 1137               	.LVL75:
 1138 02f0 00D0      		rcall flash_write_bus_cycle
 1139               	.LVL76:
 573:setup.c       **** 	flash_write_bus_cycle(0x2AAA, 0x55);
 1140               		.loc 1 573 0
 1141 02f2 65E5      		ldi r22,lo8(85)
 1142 02f4 8AEA      		ldi r24,lo8(-86)
 1143 02f6 9AE2      		ldi r25,lo8(42)
 1144 02f8 00D0      		rcall flash_write_bus_cycle
 1145               	.LVL77:
 574:setup.c       **** 	
 575:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xB0);
 1146               		.loc 1 575 0
 1147 02fa 60EB      		ldi r22,lo8(-80)
 1148 02fc 85E5      		ldi r24,lo8(85)
 1149 02fe 95E5      		ldi r25,lo8(85)
 1150 0300 00D0      		rcall flash_write_bus_cycle
 1151               	.LVL78:
 576:setup.c       **** 	flash_write_bus_cycle(0x0000, bank);
 1152               		.loc 1 576 0
 1153 0302 6C2F      		mov r22,r28
 1154 0304 80E0      		ldi r24,0
 1155 0306 90E0      		ldi r25,0
 1156               	/* epilogue start */
 577:setup.c       **** }
 1157               		.loc 1 577 0
 1158 0308 CF91      		pop r28
 1159               	.LVL79:
 576:setup.c       **** 	flash_write_bus_cycle(0x0000, bank);
 1160               		.loc 1 576 0
 1161 030a 00C0      		rjmp flash_write_bus_cycle
 1162               	.LVL80:
 1163               		.cfi_endproc
 1164               	.LFE32:
 1166               	.global	flash_erase_4k_sector
 1168               	flash_erase_4k_sector:
 1169               	.LFB33:
 578:setup.c       **** 
 579:setup.c       **** // Erase 4K sector on Flash, expects first sector to start at 0, left shifts by 12 (A15-A12 to sele
 580:setup.c       **** // Takes 25ms after last command to erase sector
 581:setup.c       **** void flash_erase_4k_sector(uint8_t sector) {
 1170               		.loc 1 581 0
 1171               		.cfi_startproc
 1172               	.LVL81:
 1173 030c CF93      		push r28
 1174               	.LCFI15:
 1175               		.cfi_def_cfa_offset 3
 1176               		.cfi_offset 28, -2
 1177               	/* prologue: function */
 1178               	/* frame size = 0 */
 1179               	/* stack size = 1 */
 1180               	.L__stack_usage = 1
 1181 030e C82F      		mov r28,r24
 582:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xAA);
 1182               		.loc 1 582 0
 1183 0310 6AEA      		ldi r22,lo8(-86)
 1184 0312 85E5      		ldi r24,lo8(85)
 1185 0314 95E5      		ldi r25,lo8(85)
 1186               	.LVL82:
 1187 0316 00D0      		rcall flash_write_bus_cycle
 1188               	.LVL83:
 583:setup.c       **** 	flash_write_bus_cycle(0x2AAA, 0x55);
 1189               		.loc 1 583 0
 1190 0318 65E5      		ldi r22,lo8(85)
 1191 031a 8AEA      		ldi r24,lo8(-86)
 1192 031c 9AE2      		ldi r25,lo8(42)
 1193 031e 00D0      		rcall flash_write_bus_cycle
 1194               	.LVL84:
 584:setup.c       **** 	flash_write_bus_cycle(0x5555, 0x80);
 1195               		.loc 1 584 0
 1196 0320 60E8      		ldi r22,lo8(-128)
 1197 0322 85E5      		ldi r24,lo8(85)
 1198 0324 95E5      		ldi r25,lo8(85)
 1199 0326 00D0      		rcall flash_write_bus_cycle
 1200               	.LVL85:
 585:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xAA);
 1201               		.loc 1 585 0
 1202 0328 6AEA      		ldi r22,lo8(-86)
 1203 032a 85E5      		ldi r24,lo8(85)
 1204 032c 95E5      		ldi r25,lo8(85)
 1205 032e 00D0      		rcall flash_write_bus_cycle
 1206               	.LVL86:
 586:setup.c       **** 	flash_write_bus_cycle(0x2AAA, 0x55);
 1207               		.loc 1 586 0
 1208 0330 65E5      		ldi r22,lo8(85)
 1209 0332 8AEA      		ldi r24,lo8(-86)
 1210 0334 9AE2      		ldi r25,lo8(42)
 1211 0336 00D0      		rcall flash_write_bus_cycle
 1212               	.LVL87:
 587:setup.c       **** 	
 588:setup.c       **** 	flash_write_bus_cycle((uint16_t) sector << 12, 0x30);
 1213               		.loc 1 588 0
 1214 0338 60E3      		ldi r22,lo8(48)
 1215 033a 80E0      		ldi r24,0
 1216 033c 9C2F      		mov r25,r28
 1217 033e 9295      		swap r25
 1218 0340 907F      		andi r25,lo8(-16)
 1219 0342 00D0      		rcall flash_write_bus_cycle
 1220               	.LVL88:
 1221               	.LBB114:
 1222               	.LBB115:
 1223               		.loc 2 187 0
 1224 0344 8FE4      		ldi r24,lo8(-15537)
 1225 0346 93EC      		ldi r25,hi8(-15537)
 1226 0348 0197      	1:	sbiw r24,1
 1227 034a 01F4      		brne 1b
 1228 034c 00C0      		rjmp .
 1229 034e 0000      		nop
 1230               	.LVL89:
 1231               	/* epilogue start */
 1232               	.LBE115:
 1233               	.LBE114:
 589:setup.c       **** 	_delay_ms(25); // Wait 25ms for sector erase
 590:setup.c       **** }
 1234               		.loc 1 590 0
 1235 0350 CF91      		pop r28
 1236               	.LVL90:
 1237 0352 0895      		ret
 1238               		.cfi_endproc
 1239               	.LFE33:
 1241               	.global	flash_write_byte
 1243               	flash_write_byte:
 1244               	.LFB34:
 591:setup.c       **** 
 592:setup.c       **** // Write a single byte to the Flash address
 593:setup.c       **** // Takes 20us to program Flash
 594:setup.c       **** void flash_write_byte(uint16_t address, uint8_t data) {
 1245               		.loc 1 594 0
 1246               		.cfi_startproc
 1247               	.LVL91:
 1248 0354 1F93      		push r17
 1249               	.LCFI16:
 1250               		.cfi_def_cfa_offset 3
 1251               		.cfi_offset 17, -2
 1252 0356 CF93      		push r28
 1253               	.LCFI17:
 1254               		.cfi_def_cfa_offset 4
 1255               		.cfi_offset 28, -3
 1256 0358 DF93      		push r29
 1257               	.LCFI18:
 1258               		.cfi_def_cfa_offset 5
 1259               		.cfi_offset 29, -4
 1260               	/* prologue: function */
 1261               	/* frame size = 0 */
 1262               	/* stack size = 3 */
 1263               	.L__stack_usage = 3
 1264 035a EC01      		movw r28,r24
 1265 035c 162F      		mov r17,r22
 595:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xAA);
 1266               		.loc 1 595 0
 1267 035e 6AEA      		ldi r22,lo8(-86)
 1268               	.LVL92:
 1269 0360 85E5      		ldi r24,lo8(85)
 1270 0362 95E5      		ldi r25,lo8(85)
 1271               	.LVL93:
 1272 0364 00D0      		rcall flash_write_bus_cycle
 1273               	.LVL94:
 596:setup.c       **** 	flash_write_bus_cycle(0x2AAA, 0x55);
 1274               		.loc 1 596 0
 1275 0366 65E5      		ldi r22,lo8(85)
 1276 0368 8AEA      		ldi r24,lo8(-86)
 1277 036a 9AE2      		ldi r25,lo8(42)
 1278 036c 00D0      		rcall flash_write_bus_cycle
 1279               	.LVL95:
 597:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xA0);
 1280               		.loc 1 597 0
 1281 036e 60EA      		ldi r22,lo8(-96)
 1282 0370 85E5      		ldi r24,lo8(85)
 1283 0372 95E5      		ldi r25,lo8(85)
 1284 0374 00D0      		rcall flash_write_bus_cycle
 1285               	.LVL96:
 598:setup.c       **** 	
 599:setup.c       **** 	flash_write_bus_cycle(address, data);
 1286               		.loc 1 599 0
 1287 0376 612F      		mov r22,r17
 1288 0378 CE01      		movw r24,r28
 1289 037a 00D0      		rcall flash_write_bus_cycle
 1290               	.LVL97:
 1291               	.LBB116:
 1292               	.LBB117:
 188:c:\winavr-20100110\avr\include\util\delay.h **** 
 189:c:\winavr-20100110\avr\include\util\delay.h **** #else
 190:c:\winavr-20100110\avr\include\util\delay.h **** 	uint16_t __ticks;
 191:c:\winavr-20100110\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 4e3) * __ms;
 192:c:\winavr-20100110\avr\include\util\delay.h **** 	if (__tmp < 1.0)
 193:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks = 1;
 194:c:\winavr-20100110\avr\include\util\delay.h **** 	else if (__tmp > 65535)
 195:c:\winavr-20100110\avr\include\util\delay.h **** 	{
 196:c:\winavr-20100110\avr\include\util\delay.h **** 		//	__ticks = requested delay in 1/10 ms
 197:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 198:c:\winavr-20100110\avr\include\util\delay.h **** 		while(__ticks)
 199:c:\winavr-20100110\avr\include\util\delay.h **** 		{
 200:c:\winavr-20100110\avr\include\util\delay.h **** 			// wait 1/10 ms
 201:c:\winavr-20100110\avr\include\util\delay.h **** 			_delay_loop_2(((F_CPU) / 4e3) / 10);
 202:c:\winavr-20100110\avr\include\util\delay.h **** 			__ticks --;
 203:c:\winavr-20100110\avr\include\util\delay.h **** 		}
 204:c:\winavr-20100110\avr\include\util\delay.h **** 		return;
 205:c:\winavr-20100110\avr\include\util\delay.h **** 	}
 206:c:\winavr-20100110\avr\include\util\delay.h **** 	else
 207:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks = (uint16_t)__tmp;
 208:c:\winavr-20100110\avr\include\util\delay.h **** 	_delay_loop_2(__ticks);
 209:c:\winavr-20100110\avr\include\util\delay.h **** #endif
 210:c:\winavr-20100110\avr\include\util\delay.h **** }
 211:c:\winavr-20100110\avr\include\util\delay.h **** 
 212:c:\winavr-20100110\avr\include\util\delay.h **** /**
 213:c:\winavr-20100110\avr\include\util\delay.h ****    \ingroup util_delay
 214:c:\winavr-20100110\avr\include\util\delay.h **** 
 215:c:\winavr-20100110\avr\include\util\delay.h ****    Perform a delay of \c __us microseconds, using _delay_loop_1().
 216:c:\winavr-20100110\avr\include\util\delay.h **** 
 217:c:\winavr-20100110\avr\include\util\delay.h ****    The macro F_CPU is supposed to be defined to a
 218:c:\winavr-20100110\avr\include\util\delay.h ****    constant defining the CPU clock frequency (in Hertz).
 219:c:\winavr-20100110\avr\include\util\delay.h **** 
 220:c:\winavr-20100110\avr\include\util\delay.h ****    The maximal possible delay is 768 us / F_CPU in MHz.
 221:c:\winavr-20100110\avr\include\util\delay.h **** 
 222:c:\winavr-20100110\avr\include\util\delay.h ****    If the user requests a delay greater than the maximal possible one,
 223:c:\winavr-20100110\avr\include\util\delay.h ****    _delay_us() will automatically call _delay_ms() instead.  The user
 224:c:\winavr-20100110\avr\include\util\delay.h ****    will not be informed about this case.
 225:c:\winavr-20100110\avr\include\util\delay.h **** 
 226:c:\winavr-20100110\avr\include\util\delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 227:c:\winavr-20100110\avr\include\util\delay.h ****    support, maximal possible delay is 4294967.295 us/ F_CPU in MHz. For
 228:c:\winavr-20100110\avr\include\util\delay.h ****    values greater than the maximal possible delay, overflow results in
 229:c:\winavr-20100110\avr\include\util\delay.h ****    no delay i.e., 0us.
 230:c:\winavr-20100110\avr\include\util\delay.h **** 
 231:c:\winavr-20100110\avr\include\util\delay.h ****    Conversion of \c __us into clock cycles may not always result in
 232:c:\winavr-20100110\avr\include\util\delay.h ****    integer.  By default, the clock cycles rounded up to next
 233:c:\winavr-20100110\avr\include\util\delay.h ****    integer. This ensures that the user gets at least \c __us
 234:c:\winavr-20100110\avr\include\util\delay.h ****    microseconds of delay.
 235:c:\winavr-20100110\avr\include\util\delay.h **** 
 236:c:\winavr-20100110\avr\include\util\delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 237:c:\winavr-20100110\avr\include\util\delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 238:c:\winavr-20100110\avr\include\util\delay.h ****    algorithm can be made to round down, or round to closest integer,
 239:c:\winavr-20100110\avr\include\util\delay.h ****    respectively.
 240:c:\winavr-20100110\avr\include\util\delay.h **** 
 241:c:\winavr-20100110\avr\include\util\delay.h ****    \note
 242:c:\winavr-20100110\avr\include\util\delay.h **** 
 243:c:\winavr-20100110\avr\include\util\delay.h ****    The implementation of _delay_ms() based on
 244:c:\winavr-20100110\avr\include\util\delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 245:c:\winavr-20100110\avr\include\util\delay.h ****    implementations.  In order to get functionality backward compatible
 246:c:\winavr-20100110\avr\include\util\delay.h ****    with previous versions, the macro \c __DELAY_BACKWARD_COMPATIBLE__
 247:c:\winavr-20100110\avr\include\util\delay.h ****    must be defined before including this header file. Also, the
 248:c:\winavr-20100110\avr\include\util\delay.h ****    backward compatible algorithm will be chosen if the code is
 249:c:\winavr-20100110\avr\include\util\delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 250:c:\winavr-20100110\avr\include\util\delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 251:c:\winavr-20100110\avr\include\util\delay.h ****    not available to the compiler then.
 252:c:\winavr-20100110\avr\include\util\delay.h **** 
 253:c:\winavr-20100110\avr\include\util\delay.h ****  */
 254:c:\winavr-20100110\avr\include\util\delay.h **** void
 255:c:\winavr-20100110\avr\include\util\delay.h **** _delay_us(double __us)
 256:c:\winavr-20100110\avr\include\util\delay.h **** {
 257:c:\winavr-20100110\avr\include\util\delay.h **** 	double __tmp ;
 258:c:\winavr-20100110\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 259:c:\winavr-20100110\avr\include\util\delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 260:c:\winavr-20100110\avr\include\util\delay.h ****   __STDC_HOSTED__
 261:c:\winavr-20100110\avr\include\util\delay.h **** 	uint32_t __ticks_dc;
 262:c:\winavr-20100110\avr\include\util\delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 263:c:\winavr-20100110\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 264:c:\winavr-20100110\avr\include\util\delay.h **** 
 265:c:\winavr-20100110\avr\include\util\delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 266:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 267:c:\winavr-20100110\avr\include\util\delay.h **** 
 268:c:\winavr-20100110\avr\include\util\delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 269:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 270:c:\winavr-20100110\avr\include\util\delay.h **** 
 271:c:\winavr-20100110\avr\include\util\delay.h **** 	#else
 272:c:\winavr-20100110\avr\include\util\delay.h **** 		//round up by default
 273:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 274:c:\winavr-20100110\avr\include\util\delay.h **** 	#endif
 275:c:\winavr-20100110\avr\include\util\delay.h **** 
 276:c:\winavr-20100110\avr\include\util\delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 1293               		.loc 2 276 0
 1294 037c 85E3      		ldi r24,lo8(53)
 1295 037e 8A95      	1:	dec r24
 1296 0380 01F4      		brne 1b
 1297 0382 0000      		nop
 1298               	.LVL98:
 1299               	/* epilogue start */
 1300               	.LBE117:
 1301               	.LBE116:
 600:setup.c       **** 	_delay_us(20); // Wait byte program time
 601:setup.c       **** }
 1302               		.loc 1 601 0
 1303 0384 DF91      		pop r29
 1304 0386 CF91      		pop r28
 1305               	.LVL99:
 1306 0388 1F91      		pop r17
 1307               	.LVL100:
 1308 038a 0895      		ret
 1309               		.cfi_endproc
 1310               	.LFE34:
 1312               	.global	flash_write_sector
 1314               	flash_write_sector:
 1315               	.LFB35:
 602:setup.c       **** 
 603:setup.c       **** // Write a sector (128 bytes) to the Atmel flash
 604:setup.c       **** // Takes 20ms for write cycle
 605:setup.c       **** void flash_write_sector(uint16_t sector) {
 1316               		.loc 1 605 0
 1317               		.cfi_startproc
 1318               	.LVL101:
 1319 038c EF92      		push r14
 1320               	.LCFI19:
 1321               		.cfi_def_cfa_offset 3
 1322               		.cfi_offset 14, -2
 1323 038e FF92      		push r15
 1324               	.LCFI20:
 1325               		.cfi_def_cfa_offset 4
 1326               		.cfi_offset 15, -3
 1327 0390 0F93      		push r16
 1328               	.LCFI21:
 1329               		.cfi_def_cfa_offset 5
 1330               		.cfi_offset 16, -4
 1331 0392 1F93      		push r17
 1332               	.LCFI22:
 1333               		.cfi_def_cfa_offset 6
 1334               		.cfi_offset 17, -5
 1335 0394 CF93      		push r28
 1336               	.LCFI23:
 1337               		.cfi_def_cfa_offset 7
 1338               		.cfi_offset 28, -6
 1339 0396 DF93      		push r29
 1340               	.LCFI24:
 1341               		.cfi_def_cfa_offset 8
 1342               		.cfi_offset 29, -7
 1343               	/* prologue: function */
 1344               	/* frame size = 0 */
 1345               	/* stack size = 6 */
 1346               	.L__stack_usage = 6
 1347 0398 8C01      		movw r16,r24
 606:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xAA);
 1348               		.loc 1 606 0
 1349 039a 6AEA      		ldi r22,lo8(-86)
 1350 039c 85E5      		ldi r24,lo8(85)
 1351 039e 95E5      		ldi r25,lo8(85)
 1352               	.LVL102:
 1353 03a0 00D0      		rcall flash_write_bus_cycle
 1354               	.LVL103:
 607:setup.c       **** 	flash_write_bus_cycle(0x2AAA, 0x55);
 1355               		.loc 1 607 0
 1356 03a2 65E5      		ldi r22,lo8(85)
 1357 03a4 8AEA      		ldi r24,lo8(-86)
 1358 03a6 9AE2      		ldi r25,lo8(42)
 1359 03a8 00D0      		rcall flash_write_bus_cycle
 1360               	.LVL104:
 608:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xA0);
 1361               		.loc 1 608 0
 1362 03aa 60EA      		ldi r22,lo8(-96)
 1363 03ac 85E5      		ldi r24,lo8(85)
 1364 03ae 95E5      		ldi r25,lo8(85)
 1365 03b0 00D0      		rcall flash_write_bus_cycle
 1366               	.LVL105:
 1367               	.LBB118:
 609:setup.c       **** 	
 610:setup.c       **** 	// Write the bytes (A0-A6 byte address, A7-A15 sector address)
 611:setup.c       **** 	for (uint8_t x = 0; x < 128; x++) {
 612:setup.c       **** 		flash_write_bus_cycle((uint16_t) (sector << 7) | (uint16_t) x, receivedBuffer[x]);
 1368               		.loc 1 612 0
 1369 03b2 1695      		lsr r17
 1370 03b4 102F      		mov r17,r16
 1371 03b6 0027      		clr r16
 1372 03b8 1795      		ror r17
 1373 03ba 0795      		ror r16
 1374               	.LVL106:
 1375 03bc 90E0      		ldi r25,lo8(receivedBuffer)
 1376 03be E92E      		mov r14,r25
 1377 03c0 90E0      		ldi r25,hi8(receivedBuffer)
 1378 03c2 F92E      		mov r15,r25
 1379 03c4 C0E0      		ldi r28,0
 1380 03c6 D0E0      		ldi r29,0
 1381               	.LVL107:
 1382               	.L66:
 1383               		.loc 1 612 0 is_stmt 0 discriminator 3
 1384 03c8 F701      		movw r30,r14
 1385 03ca 6191      		ld r22,Z+
 1386 03cc 7F01      		movw r14,r30
 1387 03ce CE01      		movw r24,r28
 1388 03d0 802B      		or r24,r16
 1389 03d2 912B      		or r25,r17
 1390 03d4 00D0      		rcall flash_write_bus_cycle
 1391               	.LVL108:
 1392 03d6 2196      		adiw r28,1
 1393               	.LVL109:
 611:setup.c       **** 		flash_write_bus_cycle((uint16_t) (sector << 7) | (uint16_t) x, receivedBuffer[x]);
 1394               		.loc 1 611 0 is_stmt 1 discriminator 3
 1395 03d8 C038      		cpi r28,-128
 1396 03da D105      		cpc r29,__zero_reg__
 1397 03dc 01F4      		brne .L66
 1398               	.LVL110:
 1399               	.LBE118:
 1400               	.LBB119:
 1401               	.LBB120:
 187:c:\winavr-20100110\avr\include\util\delay.h **** 
 1402               		.loc 2 187 0
 1403 03de 8FE3      		ldi r24,lo8(-25537)
 1404 03e0 9CE9      		ldi r25,hi8(-25537)
 1405 03e2 0197      	1:	sbiw r24,1
 1406 03e4 01F4      		brne 1b
 1407 03e6 00C0      		rjmp .
 1408 03e8 0000      		nop
 1409               	.LVL111:
 1410               	/* epilogue start */
 1411               	.LBE120:
 1412               	.LBE119:
 613:setup.c       **** 	}
 614:setup.c       **** 	_delay_ms(20); // Wait sector program time
 615:setup.c       **** }
 1413               		.loc 1 615 0
 1414 03ea DF91      		pop r29
 1415 03ec CF91      		pop r28
 1416               	.LVL112:
 1417 03ee 1F91      		pop r17
 1418 03f0 0F91      		pop r16
 1419 03f2 FF90      		pop r15
 1420 03f4 EF90      		pop r14
 1421 03f6 0895      		ret
 1422               		.cfi_endproc
 1423               	.LFE35:
 1425               	.global	gb_flash_read_byte
 1427               	gb_flash_read_byte:
 1428               	.LFB36:
 616:setup.c       **** 
 617:setup.c       **** 
 618:setup.c       **** 
 619:setup.c       **** // ---------- GB FLASH CARTS ----------
 620:setup.c       **** 
 621:setup.c       **** // Read a byte from the flash (No CS pin pulse)
 622:setup.c       **** uint8_t gb_flash_read_byte(uint16_t address) {
 1429               		.loc 1 622 0
 1430               		.cfi_startproc
 1431               	.LVL113:
 1432               	/* prologue: function */
 1433               	/* frame size = 0 */
 1434               	/* stack size = 0 */
 1435               	.L__stack_usage = 0
 623:setup.c       **** 	PORT_DATA7_0 = 0;
 1436               		.loc 1 623 0
 1437 03f8 15BA      		out 0x15,__zero_reg__
 624:setup.c       **** 	DDR_DATA7_0 = 0;
 1438               		.loc 1 624 0
 1439 03fa 14BA      		out 0x14,__zero_reg__
 625:setup.c       **** 	
 626:setup.c       **** 	set_16bit_address(address);
 1440               		.loc 1 626 0
 1441 03fc 00D0      		rcall set_16bit_address
 1442               	.LVL114:
 627:setup.c       **** 	
 628:setup.c       **** 	rdPin_low;
 1443               		.loc 1 628 0
 1444 03fe 9598      		cbi 0x12,5
 629:setup.c       **** 	asm volatile("nop"); // Delay a little
 1445               		.loc 1 629 0
 1446               	/* #APP */
 1447               	 ;  629 "setup.c" 1
 1448 0400 0000      		nop
 1449               	 ;  0 "" 2
 630:setup.c       **** 	asm volatile("nop");
 1450               		.loc 1 630 0
 1451               	 ;  630 "setup.c" 1
 1452 0402 0000      		nop
 1453               	 ;  0 "" 2
 631:setup.c       **** 	uint8_t data = PIN_DATA7_0; // Read data
 1454               		.loc 1 631 0
 1455               	/* #NOAPP */
 1456 0404 83B3      		in r24,0x13
 1457               	.LVL115:
 632:setup.c       **** 	rdPin_high;
 1458               		.loc 1 632 0
 1459 0406 959A      		sbi 0x12,5
 633:setup.c       **** 	
 634:setup.c       **** 	return data;
 635:setup.c       **** }
 1460               		.loc 1 635 0
 1461 0408 0895      		ret
 1462               		.cfi_endproc
 1463               	.LFE36:
 1465               	.global	gb_flash_write_bus_cycle
 1467               	gb_flash_write_bus_cycle:
 1468               	.LFB37:
 636:setup.c       **** 
 637:setup.c       **** // Set the address and data for the write byte cycle to the flash
 638:setup.c       **** void gb_flash_write_bus_cycle(uint16_t address, uint8_t data) {
 1469               		.loc 1 638 0
 1470               		.cfi_startproc
 1471               	.LVL116:
 1472 040a CF93      		push r28
 1473               	.LCFI25:
 1474               		.cfi_def_cfa_offset 3
 1475               		.cfi_offset 28, -2
 1476               	/* prologue: function */
 1477               	/* frame size = 0 */
 1478               	/* stack size = 1 */
 1479               	.L__stack_usage = 1
 1480 040c C62F      		mov r28,r22
 639:setup.c       **** 	DDR_DATA7_0 = 0xFF; // Set data pins as outputs
 1481               		.loc 1 639 0
 1482 040e 2FEF      		ldi r18,lo8(-1)
 1483 0410 24BB      		out 0x14,r18
 640:setup.c       **** 	set_16bit_address(address);
 1484               		.loc 1 640 0
 1485 0412 00D0      		rcall set_16bit_address
 1486               	.LVL117:
 641:setup.c       **** 	PORT_DATA7_0 = data;
 1487               		.loc 1 641 0
 1488 0414 C5BB      		out 0x15,r28
 642:setup.c       **** 	
 643:setup.c       **** 	if (flashWriteWePin == WE_AS_AUDIO_PIN) { // Audio pin
 1489               		.loc 1 643 0
 1490 0416 8091 0000 		lds r24,flashWriteWePin
 1491 041a 8134      		cpi r24,lo8(65)
 1492 041c 01F4      		brne .L70
 1493               	.LVL118:
 1494               	.LBB123:
 1495               	.LBB124:
 644:setup.c       **** 		audioPin_low; // WE low
 1496               		.loc 1 644 0
 1497 041e 3998      		cbi 0x7,1
 645:setup.c       **** 		asm volatile("nop");
 1498               		.loc 1 645 0
 1499               	/* #APP */
 1500               	 ;  645 "setup.c" 1
 1501 0420 0000      		nop
 1502               	 ;  0 "" 2
 646:setup.c       **** 		asm volatile("nop");
 1503               		.loc 1 646 0
 1504               	 ;  646 "setup.c" 1
 1505 0422 0000      		nop
 1506               	 ;  0 "" 2
 647:setup.c       **** 		asm volatile("nop");
 1507               		.loc 1 647 0
 1508               	 ;  647 "setup.c" 1
 1509 0424 0000      		nop
 1510               	 ;  0 "" 2
 648:setup.c       **** 		audioPin_high; // WE high
 1511               		.loc 1 648 0
 1512               	/* #NOAPP */
 1513 0426 399A      		sbi 0x7,1
 1514 0428 00C0      		rjmp .L69
 1515               	.LVL119:
 1516               	.L70:
 1517               	.LBE124:
 1518               	.LBE123:
 649:setup.c       **** 	}
 650:setup.c       **** 	else { // WR pin
 651:setup.c       **** 		wrPin_low; // WE low
 1519               		.loc 1 651 0
 1520 042a 9698      		cbi 0x12,6
 652:setup.c       **** 		asm volatile("nop");
 1521               		.loc 1 652 0
 1522               	/* #APP */
 1523               	 ;  652 "setup.c" 1
 1524 042c 0000      		nop
 1525               	 ;  0 "" 2
 653:setup.c       **** 		asm volatile("nop");
 1526               		.loc 1 653 0
 1527               	 ;  653 "setup.c" 1
 1528 042e 0000      		nop
 1529               	 ;  0 "" 2
 654:setup.c       **** 		asm volatile("nop");
 1530               		.loc 1 654 0
 1531               	 ;  654 "setup.c" 1
 1532 0430 0000      		nop
 1533               	 ;  0 "" 2
 655:setup.c       **** 		wrPin_high; // WE high
 1534               		.loc 1 655 0
 1535               	/* #NOAPP */
 1536 0432 969A      		sbi 0x12,6
 1537               	.L69:
 1538               	/* epilogue start */
 656:setup.c       **** 	}
 657:setup.c       **** }
 1539               		.loc 1 657 0
 1540 0434 CF91      		pop r28
 1541               	.LVL120:
 1542 0436 0895      		ret
 1543               		.cfi_endproc
 1544               	.LFE37:
 1546               	.global	gb_flash_write_byte
 1548               	gb_flash_write_byte:
 1549               	.LFB38:
 658:setup.c       **** 
 659:setup.c       **** // Write a single byte to the Flash address. Takes 10-50us to program each byte.
 660:setup.c       **** void gb_flash_write_byte(uint16_t address, uint8_t data) {
 1550               		.loc 1 660 0
 1551               		.cfi_startproc
 1552               	.LVL121:
 1553 0438 1F93      		push r17
 1554               	.LCFI26:
 1555               		.cfi_def_cfa_offset 3
 1556               		.cfi_offset 17, -2
 1557 043a CF93      		push r28
 1558               	.LCFI27:
 1559               		.cfi_def_cfa_offset 4
 1560               		.cfi_offset 28, -3
 1561 043c DF93      		push r29
 1562               	.LCFI28:
 1563               		.cfi_def_cfa_offset 5
 1564               		.cfi_offset 29, -4
 1565               	/* prologue: function */
 1566               	/* frame size = 0 */
 1567               	/* stack size = 3 */
 1568               	.L__stack_usage = 3
 1569 043e EC01      		movw r28,r24
 1570 0440 162F      		mov r17,r22
 661:setup.c       **** 	gb_flash_write_bus_cycle(flashWriteCycle[0][0], flashWriteCycle[0][1]);
 1571               		.loc 1 661 0
 1572 0442 6091 0000 		lds r22,flashWriteCycle+2
 1573               	.LVL122:
 1574 0446 8091 0000 		lds r24,flashWriteCycle
 1575 044a 9091 0000 		lds r25,flashWriteCycle+1
 1576               	.LVL123:
 1577 044e 00D0      		rcall gb_flash_write_bus_cycle
 1578               	.LVL124:
 662:setup.c       **** 	gb_flash_write_bus_cycle(flashWriteCycle[1][0], flashWriteCycle[1][1]);
 1579               		.loc 1 662 0
 1580 0450 6091 0000 		lds r22,flashWriteCycle+6
 1581 0454 8091 0000 		lds r24,flashWriteCycle+4
 1582 0458 9091 0000 		lds r25,flashWriteCycle+4+1
 1583 045c 00D0      		rcall gb_flash_write_bus_cycle
 1584               	.LVL125:
 663:setup.c       **** 	gb_flash_write_bus_cycle(flashWriteCycle[2][0], flashWriteCycle[2][1]);
 1585               		.loc 1 663 0
 1586 045e 6091 0000 		lds r22,flashWriteCycle+10
 1587 0462 8091 0000 		lds r24,flashWriteCycle+8
 1588 0466 9091 0000 		lds r25,flashWriteCycle+8+1
 1589 046a 00D0      		rcall gb_flash_write_bus_cycle
 1590               	.LVL126:
 664:setup.c       **** 	gb_flash_write_bus_cycle(address, data);
 1591               		.loc 1 664 0
 1592 046c 612F      		mov r22,r17
 1593 046e CE01      		movw r24,r28
 1594 0470 00D0      		rcall gb_flash_write_bus_cycle
 1595               	.LVL127:
 1596               	.LBB125:
 1597               	.LBB126:
 1598               		.loc 2 276 0
 1599 0472 8AE1      		ldi r24,lo8(26)
 1600 0474 8A95      	1:	dec r24
 1601 0476 01F4      		brne 1b
 1602 0478 00C0      		rjmp .
 1603               	.LVL128:
 1604               	.LBE126:
 1605               	.LBE125:
 665:setup.c       **** 	_delay_us(10); // Wait byte program time
 666:setup.c       **** 	
 667:setup.c       **** 	// Set data pins inputs
 668:setup.c       **** 	PORT_DATA7_0 = 0;
 1606               		.loc 1 668 0
 1607 047a 15BA      		out 0x15,__zero_reg__
 669:setup.c       **** 	DDR_DATA7_0 = 0;
 1608               		.loc 1 669 0
 1609 047c 14BA      		out 0x14,__zero_reg__
 670:setup.c       **** 	
 671:setup.c       **** 	// Verify data
 672:setup.c       **** 	uint8_t dataVerify = gb_flash_read_byte(address);
 1610               		.loc 1 672 0
 1611 047e CE01      		movw r24,r28
 1612 0480 00D0      		rcall gb_flash_read_byte
 1613               	.LVL129:
 1614               	.L73:
 673:setup.c       **** 	while (data != dataVerify) {
 1615               		.loc 1 673 0
 1616 0482 8117      		cp r24,r17
 1617 0484 01F0      		breq .L75
 674:setup.c       **** 		dataVerify = gb_flash_read_byte(address);
 1618               		.loc 1 674 0
 1619 0486 CE01      		movw r24,r28
 1620               	.LVL130:
 1621 0488 00D0      		rcall gb_flash_read_byte
 1622               	.LVL131:
 1623               	.LBB127:
 1624               	.LBB128:
 1625               		.loc 2 276 0
 1626 048a 9DE0      		ldi r25,lo8(13)
 1627 048c 9A95      	1:	dec r25
 1628 048e 01F4      		brne 1b
 1629 0490 0000      		nop
 1630 0492 00C0      		rjmp .L73
 1631               	.LVL132:
 1632               	.L75:
 1633               	/* epilogue start */
 1634               	.LBE128:
 1635               	.LBE127:
 675:setup.c       **** 		_delay_us(5);
 676:setup.c       **** 	}
 677:setup.c       **** }
 1636               		.loc 1 677 0
 1637 0494 DF91      		pop r29
 1638 0496 CF91      		pop r28
 1639               	.LVL133:
 1640 0498 1F91      		pop r17
 1641               	.LVL134:
 1642 049a 0895      		ret
 1643               		.cfi_endproc
 1644               	.LFE38:
 1646               	.global	gb_flash_write_byte_bank1_commands
 1648               	gb_flash_write_byte_bank1_commands:
 1649               	.LFB39:
 678:setup.c       **** 
 679:setup.c       **** // Write a single byte to the Flash address. Takes 10-50us to program each byte. 
 680:setup.c       **** // Switch to bank 1 to issue flash commands, then switch back to the bank we were at before
 681:setup.c       **** void gb_flash_write_byte_bank1_commands(uint16_t address, uint8_t data) {
 1650               		.loc 1 681 0
 1651               		.cfi_startproc
 1652               	.LVL135:
 1653 049c FF92      		push r15
 1654               	.LCFI29:
 1655               		.cfi_def_cfa_offset 3
 1656               		.cfi_offset 15, -2
 1657 049e 0F93      		push r16
 1658               	.LCFI30:
 1659               		.cfi_def_cfa_offset 4
 1660               		.cfi_offset 16, -3
 1661 04a0 1F93      		push r17
 1662               	.LCFI31:
 1663               		.cfi_def_cfa_offset 5
 1664               		.cfi_offset 17, -4
 1665 04a2 CF93      		push r28
 1666               	.LCFI32:
 1667               		.cfi_def_cfa_offset 6
 1668               		.cfi_offset 28, -5
 1669 04a4 DF93      		push r29
 1670               	.LCFI33:
 1671               		.cfi_def_cfa_offset 7
 1672               		.cfi_offset 29, -6
 1673               	/* prologue: function */
 1674               	/* frame size = 0 */
 1675               	/* stack size = 5 */
 1676               	.L__stack_usage = 5
 1677 04a6 EC01      		movw r28,r24
 1678 04a8 162F      		mov r17,r22
 682:setup.c       **** 	// Set bank 1
 683:setup.c       **** 	DDR_DATA7_0 = 0xFF;
 1679               		.loc 1 683 0
 1680 04aa FF24      		clr r15
 1681 04ac FA94      		dec r15
 1682 04ae F4BA      		out 0x14,r15
 1683               	.LVL136:
 1684               	.LBB129:
 1685               	.LBB130:
 243:setup.c       **** 	PORT_ADDR7_0 = (address & 0xFF);
 1686               		.loc 1 243 0
 1687 04b0 01E2      		ldi r16,lo8(33)
 1688 04b2 0BBB      		out 0x1b,r16
 244:setup.c       **** }
 1689               		.loc 1 244 0
 1690 04b4 18BA      		out 0x18,__zero_reg__
 1691               	.LVL137:
 1692               	.LBE130:
 1693               	.LBE129:
 684:setup.c       **** 	set_16bit_address(0x2100);
 685:setup.c       **** 	PORT_DATA7_0 = 1;
 1694               		.loc 1 685 0
 1695 04b6 81E0      		ldi r24,lo8(1)
 1696               	.LVL138:
 1697 04b8 85BB      		out 0x15,r24
 686:setup.c       **** 	wrPin_low; // Pulse WR
 1698               		.loc 1 686 0
 1699 04ba 9698      		cbi 0x12,6
 687:setup.c       **** 	asm volatile("nop");
 1700               		.loc 1 687 0
 1701               	/* #APP */
 1702               	 ;  687 "setup.c" 1
 1703 04bc 0000      		nop
 1704               	 ;  0 "" 2
 688:setup.c       **** 	wrPin_high;
 1705               		.loc 1 688 0
 1706               	/* #NOAPP */
 1707 04be 969A      		sbi 0x12,6
 689:setup.c       **** 	
 690:setup.c       **** 	gb_flash_write_bus_cycle(flashWriteCycle[0][0], flashWriteCycle[0][1]);
 1708               		.loc 1 690 0
 1709 04c0 6091 0000 		lds r22,flashWriteCycle+2
 1710               	.LVL139:
 1711 04c4 8091 0000 		lds r24,flashWriteCycle
 1712 04c8 9091 0000 		lds r25,flashWriteCycle+1
 1713 04cc 00D0      		rcall gb_flash_write_bus_cycle
 1714               	.LVL140:
 691:setup.c       **** 	gb_flash_write_bus_cycle(flashWriteCycle[1][0], flashWriteCycle[1][1]);
 1715               		.loc 1 691 0
 1716 04ce 6091 0000 		lds r22,flashWriteCycle+6
 1717 04d2 8091 0000 		lds r24,flashWriteCycle+4
 1718 04d6 9091 0000 		lds r25,flashWriteCycle+4+1
 1719 04da 00D0      		rcall gb_flash_write_bus_cycle
 1720               	.LVL141:
 692:setup.c       **** 	gb_flash_write_bus_cycle(flashWriteCycle[2][0], flashWriteCycle[2][1]);
 1721               		.loc 1 692 0
 1722 04dc 6091 0000 		lds r22,flashWriteCycle+10
 1723 04e0 8091 0000 		lds r24,flashWriteCycle+8
 1724 04e4 9091 0000 		lds r25,flashWriteCycle+8+1
 1725 04e8 00D0      		rcall gb_flash_write_bus_cycle
 1726               	.LVL142:
 693:setup.c       **** 	
 694:setup.c       **** 	
 695:setup.c       **** 	// Set bank back
 696:setup.c       **** 	DDR_DATA7_0 = 0xFF;
 1727               		.loc 1 696 0
 1728 04ea F4BA      		out 0x14,r15
 1729               	.LVL143:
 1730               	.LBB131:
 1731               	.LBB132:
 243:setup.c       **** 	PORT_ADDR7_0 = (address & 0xFF);
 1732               		.loc 1 243 0
 1733 04ec 0BBB      		out 0x1b,r16
 244:setup.c       **** }
 1734               		.loc 1 244 0
 1735 04ee 18BA      		out 0x18,__zero_reg__
 1736               	.LVL144:
 1737               	.LBE132:
 1738               	.LBE131:
 697:setup.c       **** 	set_16bit_address(0x2100);
 698:setup.c       **** 	PORT_DATA7_0 = lastBankAccessed;
 1739               		.loc 1 698 0
 1740 04f0 8091 0000 		lds r24,lastBankAccessed
 1741 04f4 85BB      		out 0x15,r24
 699:setup.c       **** 	wrPin_low; // Pulse WR
 1742               		.loc 1 699 0
 1743 04f6 9698      		cbi 0x12,6
 700:setup.c       **** 	asm volatile("nop");
 1744               		.loc 1 700 0
 1745               	/* #APP */
 1746               	 ;  700 "setup.c" 1
 1747 04f8 0000      		nop
 1748               	 ;  0 "" 2
 701:setup.c       **** 	wrPin_high;
 1749               		.loc 1 701 0
 1750               	/* #NOAPP */
 1751 04fa 969A      		sbi 0x12,6
 702:setup.c       **** 	
 703:setup.c       **** 	gb_flash_write_bus_cycle(address, data);
 1752               		.loc 1 703 0
 1753 04fc 612F      		mov r22,r17
 1754 04fe CE01      		movw r24,r28
 1755 0500 00D0      		rcall gb_flash_write_bus_cycle
 1756               	.LVL145:
 1757               	.LBB133:
 1758               	.LBB134:
 1759               		.loc 2 276 0
 1760 0502 8AE1      		ldi r24,lo8(26)
 1761 0504 8A95      	1:	dec r24
 1762 0506 01F4      		brne 1b
 1763 0508 00C0      		rjmp .
 1764               	.LVL146:
 1765               	.LBE134:
 1766               	.LBE133:
 704:setup.c       **** 	_delay_us(10); // Wait byte program time
 705:setup.c       **** 	
 706:setup.c       **** 	// Set data pins inputs
 707:setup.c       **** 	PORT_DATA7_0 = 0;
 1767               		.loc 1 707 0
 1768 050a 15BA      		out 0x15,__zero_reg__
 708:setup.c       **** 	DDR_DATA7_0 = 0;
 1769               		.loc 1 708 0
 1770 050c 14BA      		out 0x14,__zero_reg__
 709:setup.c       **** 	
 710:setup.c       **** 	// Verify data
 711:setup.c       **** 	uint8_t dataVerify = gb_flash_read_byte(address);
 1771               		.loc 1 711 0
 1772 050e CE01      		movw r24,r28
 1773 0510 00D0      		rcall gb_flash_read_byte
 1774               	.LVL147:
 1775               	.L77:
 712:setup.c       **** 	while (data != dataVerify) {
 1776               		.loc 1 712 0
 1777 0512 8117      		cp r24,r17
 1778 0514 01F0      		breq .L79
 713:setup.c       **** 		dataVerify = gb_flash_read_byte(address);
 1779               		.loc 1 713 0
 1780 0516 CE01      		movw r24,r28
 1781               	.LVL148:
 1782 0518 00D0      		rcall gb_flash_read_byte
 1783               	.LVL149:
 1784               	.LBB135:
 1785               	.LBB136:
 1786               		.loc 2 276 0
 1787 051a 9DE0      		ldi r25,lo8(13)
 1788 051c 9A95      	1:	dec r25
 1789 051e 01F4      		brne 1b
 1790 0520 0000      		nop
 1791 0522 00C0      		rjmp .L77
 1792               	.LVL150:
 1793               	.L79:
 1794               	/* epilogue start */
 1795               	.LBE136:
 1796               	.LBE135:
 714:setup.c       **** 		_delay_us(5);
 715:setup.c       **** 	}
 716:setup.c       **** }
 1797               		.loc 1 716 0
 1798 0524 DF91      		pop r29
 1799 0526 CF91      		pop r28
 1800               	.LVL151:
 1801 0528 1F91      		pop r17
 1802               	.LVL152:
 1803 052a 0F91      		pop r16
 1804 052c FF90      		pop r15
 1805 052e 0895      		ret
 1806               		.cfi_endproc
 1807               	.LFE39:
 1809               	.global	gba_flash_write_bus_cycle
 1811               	gba_flash_write_bus_cycle:
 1812               	.LFB40:
 717:setup.c       **** 
 718:setup.c       **** 
 719:setup.c       **** 
 720:setup.c       **** // ---------- GBA FLASH CARTS ----------
 721:setup.c       **** 
 722:setup.c       **** // Set the 24 bit address and 16 bit data for the write byte cycle to the flash (pulse WR pin)
 723:setup.c       **** void gba_flash_write_bus_cycle(uint32_t address, uint16_t data) {
 1813               		.loc 1 723 0
 1814               		.cfi_startproc
 1815               	.LVL153:
 1816 0530 0F93      		push r16
 1817               	.LCFI34:
 1818               		.cfi_def_cfa_offset 3
 1819               		.cfi_offset 16, -2
 1820 0532 1F93      		push r17
 1821               	.LCFI35:
 1822               		.cfi_def_cfa_offset 4
 1823               		.cfi_offset 17, -3
 1824               	/* prologue: function */
 1825               	/* frame size = 0 */
 1826               	/* stack size = 2 */
 1827               	.L__stack_usage = 2
 724:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = (address >> 16);
 1828               		.loc 1 724 0
 1829 0534 8C01      		movw r16,r24
 1830 0536 2227      		clr r18
 1831 0538 3327      		clr r19
 1832 053a 05BB      		out 0x15,r16
 725:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = (address >> 8);
 1833               		.loc 1 725 0
 1834 053c 072F      		mov r16,r23
 1835 053e 182F      		mov r17,r24
 1836 0540 292F      		mov r18,r25
 1837 0542 3327      		clr r19
 1838 0544 0BBB      		out 0x1b,r16
 726:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = (address & 0xFF);
 1839               		.loc 1 726 0
 1840 0546 68BB      		out 0x18,r22
 727:setup.c       **** 	
 728:setup.c       **** 	cs_mreqPin_low;
 1841               		.loc 1 728 0
 1842 0548 9498      		cbi 0x12,4
 729:setup.c       **** 	
 730:setup.c       **** 	GBA_PORT_ROM_DATA15_8 = data >> 8; // Set data
 1843               		.loc 1 730 0
 1844 054a 5BBB      		out 0x1b,r21
 731:setup.c       **** 	GBA_PORT_ROM_DATA7_0 = data & 0xFF;
 1845               		.loc 1 731 0
 1846 054c 48BB      		out 0x18,r20
 732:setup.c       **** 	
 733:setup.c       **** 	wrPin_low;
 1847               		.loc 1 733 0
 1848 054e 9698      		cbi 0x12,6
 734:setup.c       **** 	asm volatile("nop");
 1849               		.loc 1 734 0
 1850               	/* #APP */
 1851               	 ;  734 "setup.c" 1
 1852 0550 0000      		nop
 1853               	 ;  0 "" 2
 735:setup.c       **** 	asm volatile("nop");
 1854               		.loc 1 735 0
 1855               	 ;  735 "setup.c" 1
 1856 0552 0000      		nop
 1857               	 ;  0 "" 2
 736:setup.c       **** 	asm volatile("nop");
 1858               		.loc 1 736 0
 1859               	 ;  736 "setup.c" 1
 1860 0554 0000      		nop
 1861               	 ;  0 "" 2
 737:setup.c       **** 	wrPin_high;
 1862               		.loc 1 737 0
 1863               	/* #NOAPP */
 1864 0556 969A      		sbi 0x12,6
 738:setup.c       **** 	cs_mreqPin_high;
 1865               		.loc 1 738 0
 1866 0558 949A      		sbi 0x12,4
 1867               	/* epilogue start */
 739:setup.c       **** }
 1868               		.loc 1 739 0
 1869 055a 1F91      		pop r17
 1870 055c 0F91      		pop r16
 1871 055e 0895      		ret
 1872               		.cfi_endproc
 1873               	.LFE40:
 1875               	.global	gba_flash_write_cycle_start_swapped
 1877               	gba_flash_write_cycle_start_swapped:
 1878               	.LFB41:
 740:setup.c       **** 
 741:setup.c       **** // Send the first 3 write cycles to the flash (swapped D0/D1)
 742:setup.c       **** void gba_flash_write_cycle_start_swapped(void) {
 1879               		.loc 1 742 0
 1880               		.cfi_startproc
 1881               	/* prologue: function */
 1882               	/* frame size = 0 */
 1883               	/* stack size = 0 */
 1884               	.L__stack_usage = 0
 743:setup.c       **** 	// Set outputs
 744:setup.c       **** 	GBA_DDR_ROM_ADDR23_16 = 0xFF;
 1885               		.loc 1 744 0
 1886 0560 8FEF      		ldi r24,lo8(-1)
 1887 0562 84BB      		out 0x14,r24
 745:setup.c       **** 	GBA_DDR_ROM_ADDR15_8 = 0xFF;
 1888               		.loc 1 745 0
 1889 0564 8ABB      		out 0x1a,r24
 746:setup.c       **** 	GBA_DDR_ROM_ADDR7_0 = 0xFF;
 1890               		.loc 1 746 0
 1891 0566 87BB      		out 0x17,r24
 747:setup.c       **** 	
 748:setup.c       **** 	// 0x555, 0xA9
 749:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = 0;
 1892               		.loc 1 749 0
 1893 0568 15BA      		out 0x15,__zero_reg__
 750:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = 0x05;
 1894               		.loc 1 750 0
 1895 056a 95E0      		ldi r25,lo8(5)
 1896 056c 9BBB      		out 0x1b,r25
 751:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = 0x55;
 1897               		.loc 1 751 0
 1898 056e 85E5      		ldi r24,lo8(85)
 1899 0570 88BB      		out 0x18,r24
 752:setup.c       **** 	cs_mreqPin_low;
 1900               		.loc 1 752 0
 1901 0572 9498      		cbi 0x12,4
 753:setup.c       **** 	GBA_PORT_ROM_DATA15_8 = 0; // Set data
 1902               		.loc 1 753 0
 1903 0574 1BBA      		out 0x1b,__zero_reg__
 754:setup.c       **** 	GBA_PORT_ROM_DATA7_0 = 0xA9;
 1904               		.loc 1 754 0
 1905 0576 29EA      		ldi r18,lo8(-87)
 1906 0578 28BB      		out 0x18,r18
 755:setup.c       **** 	wrPin_low;
 1907               		.loc 1 755 0
 1908 057a 9698      		cbi 0x12,6
 756:setup.c       **** 	asm volatile("nop");
 1909               		.loc 1 756 0
 1910               	/* #APP */
 1911               	 ;  756 "setup.c" 1
 1912 057c 0000      		nop
 1913               	 ;  0 "" 2
 757:setup.c       **** 	asm volatile("nop");
 1914               		.loc 1 757 0
 1915               	 ;  757 "setup.c" 1
 1916 057e 0000      		nop
 1917               	 ;  0 "" 2
 758:setup.c       **** 	asm volatile("nop");
 1918               		.loc 1 758 0
 1919               	 ;  758 "setup.c" 1
 1920 0580 0000      		nop
 1921               	 ;  0 "" 2
 759:setup.c       **** 	wrPin_high;
 1922               		.loc 1 759 0
 1923               	/* #NOAPP */
 1924 0582 969A      		sbi 0x12,6
 760:setup.c       **** 	cs_mreqPin_high;
 1925               		.loc 1 760 0
 1926 0584 949A      		sbi 0x12,4
 761:setup.c       **** 	
 762:setup.c       **** 	// 0x2AA, 0x56
 763:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = 0;
 1927               		.loc 1 763 0
 1928 0586 15BA      		out 0x15,__zero_reg__
 764:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = 0x02;
 1929               		.loc 1 764 0
 1930 0588 22E0      		ldi r18,lo8(2)
 1931 058a 2BBB      		out 0x1b,r18
 765:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = 0xAA;
 1932               		.loc 1 765 0
 1933 058c 2AEA      		ldi r18,lo8(-86)
 1934 058e 28BB      		out 0x18,r18
 766:setup.c       **** 	cs_mreqPin_low;
 1935               		.loc 1 766 0
 1936 0590 9498      		cbi 0x12,4
 767:setup.c       **** 	GBA_PORT_ROM_DATA15_8 = 0; // Set data
 1937               		.loc 1 767 0
 1938 0592 1BBA      		out 0x1b,__zero_reg__
 768:setup.c       **** 	GBA_PORT_ROM_DATA7_0 = 0x56;
 1939               		.loc 1 768 0
 1940 0594 26E5      		ldi r18,lo8(86)
 1941 0596 28BB      		out 0x18,r18
 769:setup.c       **** 	wrPin_low;
 1942               		.loc 1 769 0
 1943 0598 9698      		cbi 0x12,6
 770:setup.c       **** 	asm volatile("nop");
 1944               		.loc 1 770 0
 1945               	/* #APP */
 1946               	 ;  770 "setup.c" 1
 1947 059a 0000      		nop
 1948               	 ;  0 "" 2
 771:setup.c       **** 	asm volatile("nop");
 1949               		.loc 1 771 0
 1950               	 ;  771 "setup.c" 1
 1951 059c 0000      		nop
 1952               	 ;  0 "" 2
 772:setup.c       **** 	asm volatile("nop");
 1953               		.loc 1 772 0
 1954               	 ;  772 "setup.c" 1
 1955 059e 0000      		nop
 1956               	 ;  0 "" 2
 773:setup.c       **** 	wrPin_high;
 1957               		.loc 1 773 0
 1958               	/* #NOAPP */
 1959 05a0 969A      		sbi 0x12,6
 774:setup.c       **** 	cs_mreqPin_high;
 1960               		.loc 1 774 0
 1961 05a2 949A      		sbi 0x12,4
 775:setup.c       **** 	
 776:setup.c       **** 	// 0x555, 0xA0;
 777:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = 0;
 1962               		.loc 1 777 0
 1963 05a4 15BA      		out 0x15,__zero_reg__
 778:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = 0x05;
 1964               		.loc 1 778 0
 1965 05a6 9BBB      		out 0x1b,r25
 779:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = 0x55;
 1966               		.loc 1 779 0
 1967 05a8 88BB      		out 0x18,r24
 780:setup.c       **** 	cs_mreqPin_low;
 1968               		.loc 1 780 0
 1969 05aa 9498      		cbi 0x12,4
 781:setup.c       **** 	GBA_PORT_ROM_DATA15_8 = 0; // Set data
 1970               		.loc 1 781 0
 1971 05ac 1BBA      		out 0x1b,__zero_reg__
 782:setup.c       **** 	GBA_PORT_ROM_DATA7_0 = 0xA0;
 1972               		.loc 1 782 0
 1973 05ae 80EA      		ldi r24,lo8(-96)
 1974 05b0 88BB      		out 0x18,r24
 783:setup.c       **** 	wrPin_low;
 1975               		.loc 1 783 0
 1976 05b2 9698      		cbi 0x12,6
 784:setup.c       **** 	asm volatile("nop");
 1977               		.loc 1 784 0
 1978               	/* #APP */
 1979               	 ;  784 "setup.c" 1
 1980 05b4 0000      		nop
 1981               	 ;  0 "" 2
 785:setup.c       **** 	asm volatile("nop");
 1982               		.loc 1 785 0
 1983               	 ;  785 "setup.c" 1
 1984 05b6 0000      		nop
 1985               	 ;  0 "" 2
 786:setup.c       **** 	asm volatile("nop");
 1986               		.loc 1 786 0
 1987               	 ;  786 "setup.c" 1
 1988 05b8 0000      		nop
 1989               	 ;  0 "" 2
 787:setup.c       **** 	wrPin_high;
 1990               		.loc 1 787 0
 1991               	/* #NOAPP */
 1992 05ba 969A      		sbi 0x12,6
 788:setup.c       **** 	cs_mreqPin_high;
 1993               		.loc 1 788 0
 1994 05bc 949A      		sbi 0x12,4
 1995 05be 0895      		ret
 1996               		.cfi_endproc
 1997               	.LFE41:
 1999               	.global	gba_flash_write_cycle_start
 2001               	gba_flash_write_cycle_start:
 2002               	.LFB42:
 789:setup.c       **** }
 790:setup.c       **** 
 791:setup.c       **** 
 792:setup.c       **** // Send the first 3 write cycles to the flash
 793:setup.c       **** void gba_flash_write_cycle_start(void) {
 2003               		.loc 1 793 0
 2004               		.cfi_startproc
 2005               	/* prologue: function */
 2006               	/* frame size = 0 */
 2007               	/* stack size = 0 */
 2008               	.L__stack_usage = 0
 794:setup.c       **** 	// Set outputs
 795:setup.c       **** 	GBA_DDR_ROM_ADDR23_16 = 0xFF;
 2009               		.loc 1 795 0
 2010 05c0 8FEF      		ldi r24,lo8(-1)
 2011 05c2 84BB      		out 0x14,r24
 796:setup.c       **** 	GBA_DDR_ROM_ADDR15_8 = 0xFF;
 2012               		.loc 1 796 0
 2013 05c4 8ABB      		out 0x1a,r24
 797:setup.c       **** 	GBA_DDR_ROM_ADDR7_0 = 0xFF;
 2014               		.loc 1 797 0
 2015 05c6 87BB      		out 0x17,r24
 798:setup.c       **** 	
 799:setup.c       **** 	// 0x555, 0xAA
 800:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = 0;
 2016               		.loc 1 800 0
 2017 05c8 15BA      		out 0x15,__zero_reg__
 801:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = 0x05;
 2018               		.loc 1 801 0
 2019 05ca 95E0      		ldi r25,lo8(5)
 2020 05cc 9BBB      		out 0x1b,r25
 802:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = 0x55;
 2021               		.loc 1 802 0
 2022 05ce 85E5      		ldi r24,lo8(85)
 2023 05d0 88BB      		out 0x18,r24
 803:setup.c       **** 	cs_mreqPin_low;
 2024               		.loc 1 803 0
 2025 05d2 9498      		cbi 0x12,4
 804:setup.c       **** 	GBA_PORT_ROM_DATA15_8 = 0; // Set data
 2026               		.loc 1 804 0
 2027 05d4 1BBA      		out 0x1b,__zero_reg__
 805:setup.c       **** 	GBA_PORT_ROM_DATA7_0 = 0xAA;
 2028               		.loc 1 805 0
 2029 05d6 2AEA      		ldi r18,lo8(-86)
 2030 05d8 28BB      		out 0x18,r18
 806:setup.c       **** 	wrPin_low;
 2031               		.loc 1 806 0
 2032 05da 9698      		cbi 0x12,6
 807:setup.c       **** 	asm volatile("nop");
 2033               		.loc 1 807 0
 2034               	/* #APP */
 2035               	 ;  807 "setup.c" 1
 2036 05dc 0000      		nop
 2037               	 ;  0 "" 2
 808:setup.c       **** 	asm volatile("nop");
 2038               		.loc 1 808 0
 2039               	 ;  808 "setup.c" 1
 2040 05de 0000      		nop
 2041               	 ;  0 "" 2
 809:setup.c       **** 	asm volatile("nop");
 2042               		.loc 1 809 0
 2043               	 ;  809 "setup.c" 1
 2044 05e0 0000      		nop
 2045               	 ;  0 "" 2
 810:setup.c       **** 	wrPin_high;
 2046               		.loc 1 810 0
 2047               	/* #NOAPP */
 2048 05e2 969A      		sbi 0x12,6
 811:setup.c       **** 	cs_mreqPin_high;
 2049               		.loc 1 811 0
 2050 05e4 949A      		sbi 0x12,4
 812:setup.c       **** 	
 813:setup.c       **** 	// 0x2AA, 0x55
 814:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = 0;
 2051               		.loc 1 814 0
 2052 05e6 15BA      		out 0x15,__zero_reg__
 815:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = 0x02;
 2053               		.loc 1 815 0
 2054 05e8 32E0      		ldi r19,lo8(2)
 2055 05ea 3BBB      		out 0x1b,r19
 816:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = 0xAA;
 2056               		.loc 1 816 0
 2057 05ec 28BB      		out 0x18,r18
 817:setup.c       **** 	cs_mreqPin_low;
 2058               		.loc 1 817 0
 2059 05ee 9498      		cbi 0x12,4
 818:setup.c       **** 	GBA_PORT_ROM_DATA15_8 = 0; // Set data
 2060               		.loc 1 818 0
 2061 05f0 1BBA      		out 0x1b,__zero_reg__
 819:setup.c       **** 	GBA_PORT_ROM_DATA7_0 = 0x55;
 2062               		.loc 1 819 0
 2063 05f2 88BB      		out 0x18,r24
 820:setup.c       **** 	wrPin_low;
 2064               		.loc 1 820 0
 2065 05f4 9698      		cbi 0x12,6
 821:setup.c       **** 	asm volatile("nop");
 2066               		.loc 1 821 0
 2067               	/* #APP */
 2068               	 ;  821 "setup.c" 1
 2069 05f6 0000      		nop
 2070               	 ;  0 "" 2
 822:setup.c       **** 	asm volatile("nop");
 2071               		.loc 1 822 0
 2072               	 ;  822 "setup.c" 1
 2073 05f8 0000      		nop
 2074               	 ;  0 "" 2
 823:setup.c       **** 	asm volatile("nop");
 2075               		.loc 1 823 0
 2076               	 ;  823 "setup.c" 1
 2077 05fa 0000      		nop
 2078               	 ;  0 "" 2
 824:setup.c       **** 	wrPin_high;
 2079               		.loc 1 824 0
 2080               	/* #NOAPP */
 2081 05fc 969A      		sbi 0x12,6
 825:setup.c       **** 	cs_mreqPin_high;
 2082               		.loc 1 825 0
 2083 05fe 949A      		sbi 0x12,4
 826:setup.c       **** 	
 827:setup.c       **** 	// 0x555, 0xA0;
 828:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = 0;
 2084               		.loc 1 828 0
 2085 0600 15BA      		out 0x15,__zero_reg__
 829:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = 0x05;
 2086               		.loc 1 829 0
 2087 0602 9BBB      		out 0x1b,r25
 830:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = 0x55;
 2088               		.loc 1 830 0
 2089 0604 88BB      		out 0x18,r24
 831:setup.c       **** 	cs_mreqPin_low;
 2090               		.loc 1 831 0
 2091 0606 9498      		cbi 0x12,4
 832:setup.c       **** 	GBA_PORT_ROM_DATA15_8 = 0; // Set data
 2092               		.loc 1 832 0
 2093 0608 1BBA      		out 0x1b,__zero_reg__
 833:setup.c       **** 	GBA_PORT_ROM_DATA7_0 = 0xA0;
 2094               		.loc 1 833 0
 2095 060a 80EA      		ldi r24,lo8(-96)
 2096 060c 88BB      		out 0x18,r24
 834:setup.c       **** 	wrPin_low;
 2097               		.loc 1 834 0
 2098 060e 9698      		cbi 0x12,6
 835:setup.c       **** 	asm volatile("nop");
 2099               		.loc 1 835 0
 2100               	/* #APP */
 2101               	 ;  835 "setup.c" 1
 2102 0610 0000      		nop
 2103               	 ;  0 "" 2
 836:setup.c       **** 	asm volatile("nop");
 2104               		.loc 1 836 0
 2105               	 ;  836 "setup.c" 1
 2106 0612 0000      		nop
 2107               	 ;  0 "" 2
 837:setup.c       **** 	asm volatile("nop");
 2108               		.loc 1 837 0
 2109               	 ;  837 "setup.c" 1
 2110 0614 0000      		nop
 2111               	 ;  0 "" 2
 838:setup.c       **** 	wrPin_high;
 2112               		.loc 1 838 0
 2113               	/* #NOAPP */
 2114 0616 969A      		sbi 0x12,6
 839:setup.c       **** 	cs_mreqPin_high;
 2115               		.loc 1 839 0
 2116 0618 949A      		sbi 0x12,4
 2117 061a 0895      		ret
 2118               		.cfi_endproc
 2119               	.LFE42:
 2121               	.global	gba_flash_write_byte
 2123               	gba_flash_write_byte:
 2124               	.LFB43:
 840:setup.c       **** }	
 841:setup.c       **** 
 842:setup.c       **** 
 843:setup.c       **** // Write 2 bytes to the Flash address. Time to wait depends on Flash, we will query it to verify th
 844:setup.c       **** // Address is divided by 2 as we are in GBA mode. 
 845:setup.c       **** void gba_flash_write_byte(uint32_t address, uint16_t data, uint8_t isD0D1Swapped) {
 2125               		.loc 1 845 0
 2126               		.cfi_startproc
 2127               	.LVL154:
 2128 061c CF92      		push r12
 2129               	.LCFI36:
 2130               		.cfi_def_cfa_offset 3
 2131               		.cfi_offset 12, -2
 2132 061e DF92      		push r13
 2133               	.LCFI37:
 2134               		.cfi_def_cfa_offset 4
 2135               		.cfi_offset 13, -3
 2136 0620 EF92      		push r14
 2137               	.LCFI38:
 2138               		.cfi_def_cfa_offset 5
 2139               		.cfi_offset 14, -4
 2140 0622 FF92      		push r15
 2141               	.LCFI39:
 2142               		.cfi_def_cfa_offset 6
 2143               		.cfi_offset 15, -5
 2144 0624 CF93      		push r28
 2145               	.LCFI40:
 2146               		.cfi_def_cfa_offset 7
 2147               		.cfi_offset 28, -6
 2148 0626 DF93      		push r29
 2149               	.LCFI41:
 2150               		.cfi_def_cfa_offset 8
 2151               		.cfi_offset 29, -7
 2152               	/* prologue: function */
 2153               	/* frame size = 0 */
 2154               	/* stack size = 6 */
 2155               	.L__stack_usage = 6
 2156 0628 6B01      		movw r12,r22
 2157 062a 7C01      		movw r14,r24
 2158 062c EA01      		movw r28,r20
 846:setup.c       **** 	if (isD0D1Swapped == 0) {
 2159               		.loc 1 846 0
 2160 062e 2111      		cpse r18,__zero_reg__
 2161 0630 00C0      		rjmp .L84
 847:setup.c       **** 		gba_flash_write_cycle_start();
 2162               		.loc 1 847 0
 2163 0632 00D0      		rcall gba_flash_write_cycle_start
 2164               	.LVL155:
 2165 0634 00C0      		rjmp .L85
 2166               	.LVL156:
 2167               	.L84:
 848:setup.c       **** 	}
 849:setup.c       **** 	else {
 850:setup.c       **** 		gba_flash_write_cycle_start_swapped();
 2168               		.loc 1 850 0
 2169 0636 00D0      		rcall gba_flash_write_cycle_start_swapped
 2170               	.LVL157:
 2171               	.L85:
 851:setup.c       **** 	}
 852:setup.c       **** 	gba_flash_write_bus_cycle(address, data);
 2172               		.loc 1 852 0
 2173 0638 AE01      		movw r20,r28
 2174 063a C701      		movw r24,r14
 2175 063c B601      		movw r22,r12
 2176 063e 00D0      		rcall gba_flash_write_bus_cycle
 2177               	.LVL158:
 2178               	.LBB137:
 2179               	.LBB138:
 2180               		.loc 2 276 0
 2181 0640 25E0      		ldi r18,lo8(5)
 2182 0642 2A95      	1:	dec r18
 2183 0644 01F4      		brne 1b
 2184 0646 0000      		nop
 2185               	.LVL159:
 2186               	.LBE138:
 2187               	.LBE137:
 853:setup.c       **** 	_delay_us(2); // Wait byte program time
 854:setup.c       **** 	
 855:setup.c       **** 	// Verify data
 856:setup.c       **** 	uint16_t dataVerify = gba_read_16bit_data(address);
 2188               		.loc 1 856 0
 2189 0648 C701      		movw r24,r14
 2190 064a B601      		movw r22,r12
 2191 064c 00D0      		rcall gba_read_16bit_data
 2192               	.LVL160:
 2193               	.L86:
 857:setup.c       **** 	while (data != dataVerify) {
 2194               		.loc 1 857 0
 2195 064e 8C17      		cp r24,r28
 2196 0650 9D07      		cpc r25,r29
 2197 0652 01F0      		breq .L88
 858:setup.c       **** 		dataVerify = gba_read_16bit_data(address);
 2198               		.loc 1 858 0
 2199 0654 C701      		movw r24,r14
 2200 0656 B601      		movw r22,r12
 2201 0658 00D0      		rcall gba_read_16bit_data
 2202               	.LVL161:
 2203               	.LBB139:
 2204               	.LBB140:
 2205               		.loc 2 276 0
 2206 065a 25E0      		ldi r18,lo8(5)
 2207 065c 2A95      	1:	dec r18
 2208 065e 01F4      		brne 1b
 2209 0660 0000      		nop
 2210 0662 00C0      		rjmp .L86
 2211               	.LVL162:
 2212               	.L88:
 2213               	/* epilogue start */
 2214               	.LBE140:
 2215               	.LBE139:
 859:setup.c       **** 		_delay_us(2);
 860:setup.c       **** 	}
 861:setup.c       **** }
 2216               		.loc 1 861 0
 2217 0664 DF91      		pop r29
 2218 0666 CF91      		pop r28
 2219               	.LVL163:
 2220 0668 FF90      		pop r15
 2221 066a EF90      		pop r14
 2222 066c DF90      		pop r13
 2223 066e CF90      		pop r12
 2224               	.LVL164:
 2225 0670 0895      		ret
 2226               		.cfi_endproc
 2227               	.LFE43:
 2229               	.global	setup
 2231               	setup:
 2232               	.LFB44:
 862:setup.c       **** 
 863:setup.c       **** 
 864:setup.c       **** // Setup
 865:setup.c       **** void setup(void) {
 2233               		.loc 1 865 0
 2234               		.cfi_startproc
 2235               	/* prologue: function */
 2236               	/* frame size = 0 */
 2237               	/* stack size = 0 */
 2238               	.L__stack_usage = 0
 866:setup.c       **** 	// Turn off watchdog
 867:setup.c       **** 	MCUCSR &= ~(1<<WDRF);
 2239               		.loc 1 867 0
 2240 0672 84B7      		in r24,0x34
 2241 0674 877F      		andi r24,lo8(-9)
 2242 0676 84BF      		out 0x34,r24
 868:setup.c       **** 	WDTCR = (1<<WDCE) | (1<<WDE);
 2243               		.loc 1 868 0
 2244 0678 88E1      		ldi r24,lo8(24)
 2245 067a 81BD      		out 0x21,r24
 869:setup.c       **** 	WDTCR = 0;
 2246               		.loc 1 869 0
 2247 067c 11BC      		out 0x21,__zero_reg__
 870:setup.c       **** 	
 871:setup.c       **** 	// Reset common lines
 872:setup.c       **** 	rd_wr_csmreq_cs2_reset();
 2248               		.loc 1 872 0
 2249 067e 00D0      		rcall rd_wr_csmreq_cs2_reset
 2250               	.LVL165:
 873:setup.c       **** 	
 874:setup.c       **** 	// Set outputs
 875:setup.c       **** 	DDRD |= (1<<ACTIVITY_LED) | (1<<WR_PIN) | (1<<RD_PIN) | (1<<CS_MREQ_PIN) | (1<<LED_5V);
 2251               		.loc 1 875 0
 2252 0680 81B3      		in r24,0x11
 2253 0682 886F      		ori r24,lo8(-8)
 2254 0684 81BB      		out 0x11,r24
 876:setup.c       **** 	DDRE |= (1<<CS2_PIN) | (1<<LED_3V);
 2255               		.loc 1 876 0
 2256 0686 86B1      		in r24,0x6
 2257 0688 8560      		ori r24,lo8(5)
 2258 068a 86B9      		out 0x6,r24
 877:setup.c       **** 	
 878:setup.c       **** 	// Set all pins as inputs
 879:setup.c       **** 	PORT_DATA7_0 = 0;
 2259               		.loc 1 879 0
 2260 068c 15BA      		out 0x15,__zero_reg__
 880:setup.c       **** 	DDR_DATA7_0 = 0;
 2261               		.loc 1 880 0
 2262 068e 14BA      		out 0x14,__zero_reg__
 881:setup.c       **** 	PORT_ADDR7_0 = 0;
 2263               		.loc 1 881 0
 2264 0690 18BA      		out 0x18,__zero_reg__
 882:setup.c       **** 	DDR_ADDR7_0 = 0;
 2265               		.loc 1 882 0
 2266 0692 17BA      		out 0x17,__zero_reg__
 883:setup.c       **** 	PORT_ADDR15_8 = 0;
 2267               		.loc 1 883 0
 2268 0694 1BBA      		out 0x1b,__zero_reg__
 884:setup.c       **** 	DDR_ADDR15_8 = 0;
 2269               		.loc 1 884 0
 2270 0696 1ABA      		out 0x1a,__zero_reg__
 885:setup.c       **** 	
 886:setup.c       **** 	// Light up 3.3V or 5V
 887:setup.c       **** 	if (PIND & (1<<SWITCH_DETECT)) {
 2271               		.loc 1 887 0
 2272 0698 829B      		sbis 0x10,2
 2273 069a 00C0      		rjmp .L90
 888:setup.c       **** 		PORTD |= (1<<LED_5V);
 2274               		.loc 1 888 0
 2275 069c 979A      		sbi 0x12,7
 889:setup.c       **** 		PORTE &= ~(1<<LED_3V);
 2276               		.loc 1 889 0
 2277 069e 3898      		cbi 0x7,0
 890:setup.c       **** 		
 891:setup.c       **** 		// Set Reset low for 50ms to reset the cart (also for CPLD carts to initialise properly)
 892:setup.c       **** 		cs2Pin_low;
 2278               		.loc 1 892 0
 2279 06a0 3A98      		cbi 0x7,2
 2280               	.LVL166:
 2281               	.LBB141:
 2282               	.LBB142:
 187:c:\winavr-20100110\avr\include\util\delay.h **** 
 2283               		.loc 2 187 0
 2284 06a2 2FE7      		ldi r18,lo8(79999)
 2285 06a4 88E3      		ldi r24,hi8(79999)
 2286 06a6 91E0      		ldi r25,hlo8(79999)
 2287 06a8 2150      	1:	subi r18,1
 2288 06aa 8040      		sbci r24,0
 2289 06ac 9040      		sbci r25,0
 2290 06ae 01F4      		brne 1b
 2291 06b0 00C0      		rjmp .
 2292 06b2 0000      		nop
 2293               	.LVL167:
 2294               	.LBE142:
 2295               	.LBE141:
 893:setup.c       **** 		_delay_ms(50);
 894:setup.c       **** 		cs2Pin_high;
 2296               		.loc 1 894 0
 2297 06b4 3A9A      		sbi 0x7,2
 2298 06b6 00C0      		rjmp .L91
 2299               	.L90:
 895:setup.c       **** 	}
 896:setup.c       **** 	else {
 897:setup.c       **** 		PORTE |= (1<<LED_3V);
 2300               		.loc 1 897 0
 2301 06b8 389A      		sbi 0x7,0
 898:setup.c       **** 		PORTD &= ~(1<<LED_5V);
 2302               		.loc 1 898 0
 2303 06ba 9798      		cbi 0x12,7
 2304               	.L91:
 899:setup.c       **** 	}
 900:setup.c       **** 	
 901:setup.c       **** 	// Light LED
 902:setup.c       **** 	PORTD |= (1<<ACTIVITY_LED);
 2305               		.loc 1 902 0
 2306 06bc 939A      		sbi 0x12,3
 2307               	.LVL168:
 2308               	.LBB143:
 2309               	.LBB144:
 187:c:\winavr-20100110\avr\include\util\delay.h **** 
 2310               		.loc 2 187 0
 2311 06be 2FEF      		ldi r18,lo8(799999)
 2312 06c0 84E3      		ldi r24,hi8(799999)
 2313 06c2 9CE0      		ldi r25,hlo8(799999)
 2314 06c4 2150      	1:	subi r18,1
 2315 06c6 8040      		sbci r24,0
 2316 06c8 9040      		sbci r25,0
 2317 06ca 01F4      		brne 1b
 2318 06cc 00C0      		rjmp .
 2319 06ce 0000      		nop
 2320               	.LVL169:
 2321               	.LBE144:
 2322               	.LBE143:
 903:setup.c       **** 	_delay_ms(500);
 904:setup.c       **** 	PORTD &= ~(1<<ACTIVITY_LED);
 2323               		.loc 1 904 0
 2324 06d0 9398      		cbi 0x12,3
 905:setup.c       **** 	
 906:setup.c       **** 	// Setup USART
 907:setup.c       **** 	UBRRL = 0; // 1Mbps Baud rate
 2325               		.loc 1 907 0
 2326 06d2 19B8      		out 0x9,__zero_reg__
 908:setup.c       **** 	sbi(UCSRA, U2X); // Double rate
 2327               		.loc 1 908 0
 2328 06d4 599A      		sbi 0xb,1
 909:setup.c       **** 	sbi(UCSRB, TXEN); // Transmitter enable
 2329               		.loc 1 909 0
 2330 06d6 539A      		sbi 0xa,3
 910:setup.c       **** 	sbi(UCSRB, RXEN); // Receiver enable
 2331               		.loc 1 910 0
 2332 06d8 549A      		sbi 0xa,4
 911:setup.c       **** 	
 912:setup.c       **** 	// Turn on interrupts
 913:setup.c       **** 	sei();
 2333               		.loc 1 913 0
 2334               	/* #APP */
 2335               	 ;  913 "setup.c" 1
 2336 06da 7894      		sei
 2337               	 ;  0 "" 2
 2338               	/* #NOAPP */
 2339 06dc 0895      		ret
 2340               		.cfi_endproc
 2341               	.LFE44:
 2343               		.section	.text.startup,"ax",@progbits
 2344               	.global	main
 2346               	main:
 2347               	.LFB45:
 2348               		.file 3 "main.c"
   1:main.c        **** /*
   2:main.c        ****  GBxCart RW
   3:main.c        ****  PCB version: 1.1 or 1.2
   4:main.c        ****  Firmware version: R12
   5:main.c        ****  Author: Alex from insideGadgets (www.insidegadgets.com)
   6:main.c        ****  Created: 7/11/2016
   7:main.c        ****  Last Modified: 4/12/2018
   8:main.c        ****  
   9:main.c        ****  GBxCart RW allows you to dump your Gameboy/Gameboy Colour/Gameboy Advance games ROM, save the RAM,
  10:main.c        ****  write to certain Gameboy/Gameboy Advance flash carts.
  11:main.c        ****  
  12:main.c        ****  The ATmega8515L talks to the cartridge and interfaces with the CH340G serial to USB converter with
  13:main.c        ****  
  14:main.c        ****  
  15:main.c        ****  Set fuse bits: External 8MHz crystal, divide clock by 8 is off, boot loader is on (512 bytes), BOD
  16:main.c        ****  avrdude -p atmega8515 -c usbasp -U lfuse:w:0xaf:m -U hfuse:w:0xda:m
  17:main.c        ****  
  18:main.c        ****  Program the TinySafeBoot boot loader (modified ASM code, watchdog reset will act as a hardware res
  19:main.c        ****  avrdude -p atmega8515 -c usbasp -U flash:w:GBxCart_RW_v1.1_Rx\tsb\tsb_m8515_d0d1_resetwdt.hex
  20:main.c        ****  
  21:main.c        ****  Program GBxCart RW through TinySafeBoot
  22:main.c        ****  tsb com16:57600 fw GBxCart_RW_v1.1_Rx\main.hex
  23:main.c        ****  
  24:main.c        ****  Set TinySafeBoot delay time to 25 (T 25), gives ~0.5s in bootloader
  25:main.c        ****  tsb com16:9600 T 25
  26:main.c        ****  
  27:main.c        ****  
  28:main.c        ****  Programming shortcuts (if added in Programmers Notepad):
  29:main.c        ****  Alt + W - Program fuse
  30:main.c        ****  Alt + B - Burn bootloader
  31:main.c        ****  
  32:main.c        ****  Plug in USB then
  33:main.c        ****  Alt + T - Program
  34:main.c        ****  Alt + N - Program delay settings
  35:main.c        ****  
  36:main.c        ****  
  37:main.c        ****  */
  38:main.c        **** 
  39:main.c        **** // ATmega8515L Pin Map
  40:main.c        **** //
  41:main.c        **** // VCC (5)			GND (6)			XTAL (7 ,8)		Activity LED PD3 (9)				Switch sense PD2 (8)
  42:main.c        **** // SCK PB7 (3)		MOSI PB5 (1)	MISO PB6 (2)	RST (4)		RXD PD0 (5)			TXD PD1 (7)
  43:main.c        **** // 
  44:main.c        **** // Gameboy / Gameboy Colour
  45:main.c        **** // A0-A7 PB0-7 (40-44, 1-3) 		A8-A15 PA0-7 (37-30)			D0-D7 PC0-7 (18-25)		Audio PE1 (27)
  46:main.c        **** // 
  47:main.c        **** // Gameboy Advance
  48:main.c        **** // AD0-AD7 PB0-7 (40-44, 1-3) 	AD8-AD15 PA0-7 (37-30)		A16-23 / D0-D7 PC0-7 (19-26)
  49:main.c        **** // *WR PD6 (13)						*RD PD5 (14)					*MREQ/CS PD4 (15)			CS2/RST PE2 (16)
  50:main.c        **** 
  51:main.c        **** #define F_CPU 8000000 // 8 MHz
  52:main.c        **** #define PCB_VERSION 2
  53:main.c        **** #define FIRMWARE_VERSION 12
  54:main.c        **** 
  55:main.c        **** #include <avr/io.h>
  56:main.c        **** #include <avr/wdt.h>
  57:main.c        **** #include <avr/eeprom.h>
  58:main.c        **** #include <avr/interrupt.h>
  59:main.c        **** #include <avr/sleep.h>
  60:main.c        **** #include <util/delay.h>
  61:main.c        **** #include <stdlib.h>
  62:main.c        **** #include <string.h>
  63:main.c        **** #include "setup.c" // See defines, variables, constants, functions here
  64:main.c        **** 
  65:main.c        **** 
  66:main.c        **** int main(void) {
 2349               		.loc 3 66 0
 2350               		.cfi_startproc
 2351 0000 CF93      		push r28
 2352               	.LCFI42:
 2353               		.cfi_def_cfa_offset 3
 2354               		.cfi_offset 28, -2
 2355 0002 DF93      		push r29
 2356               	.LCFI43:
 2357               		.cfi_def_cfa_offset 4
 2358               		.cfi_offset 29, -3
 2359 0004 00D0      		rcall .
 2360               	.LCFI44:
 2361               		.cfi_def_cfa_offset 6
 2362 0006 CDB7      		in r28,__SP_L__
 2363 0008 DEB7      		in r29,__SP_H__
 2364               	.LCFI45:
 2365               		.cfi_def_cfa_register 28
 2366               	/* prologue: function */
 2367               	/* frame size = 2 */
 2368               	/* stack size = 4 */
 2369               	.L__stack_usage = 4
  67:main.c        **** 	setup();
 2370               		.loc 3 67 0
 2371 000a 00D0      		rcall setup
 2372               	.LVL170:
  68:main.c        **** 	
  69:main.c        **** 	uint32_t address = 0;
  70:main.c        **** 	uint8_t eepromSize = EEPROM_4KBIT;
  71:main.c        **** 	uint8_t cartMode = GB_MODE;
  72:main.c        **** 	uint8_t resetCommonLines = 1;
 2373               		.loc 3 72 0
 2374 000c 21E0      		ldi r18,lo8(1)
 2375 000e 2A83      		std Y+2,r18
  70:main.c        **** 	uint8_t cartMode = GB_MODE;
 2376               		.loc 3 70 0
 2377 0010 81E0      		ldi r24,lo8(1)
 2378 0012 8983      		std Y+1,r24
  69:main.c        **** 	uint8_t eepromSize = EEPROM_4KBIT;
 2379               		.loc 3 69 0
 2380 0014 C12C      		mov r12,__zero_reg__
 2381 0016 D12C      		mov r13,__zero_reg__
 2382 0018 7601      		movw r14,r12
 2383 001a B0E0      		ldi r27,lo8(eepromBuffer+8)
 2384 001c 2B2E      		mov r2,r27
 2385 001e B0E0      		ldi r27,hi8(eepromBuffer+8)
 2386 0020 3B2E      		mov r3,r27
 2387               	.LVL171:
 2388               	.L93:
  73:main.c        **** 	
  74:main.c        **** 	while(1) {
  75:main.c        **** 		if (resetCommonLines == 1) {
 2389               		.loc 3 75 0
 2390 0022 EA81      		ldd r30,Y+2
 2391 0024 E130      		cpi r30,lo8(1)
 2392 0026 01F4      		brne .L94
 2393               	.LVL172:
 2394               	.L227:
  76:main.c        **** 			rd_wr_csmreq_cs2_reset();
 2395               		.loc 3 76 0
 2396 0028 00D0      		rcall rd_wr_csmreq_cs2_reset
 2397               	.LVL173:
 2398               	.L94:
  77:main.c        **** 		}
  78:main.c        **** 		receivedChar = USART_Receive(); // Wait for 1 byte of data
 2399               		.loc 3 78 0
 2400 002a 00D0      		rcall USART_Receive
 2401               	.LVL174:
 2402 002c 8093 0000 		sts receivedChar,r24
  79:main.c        **** 		
  80:main.c        **** 		// Read the pin to find out which mode we are in, if it reads high, we are powered by 5V
  81:main.c        **** 		if (PIND & (1<<SWITCH_DETECT)) {
 2403               		.loc 3 81 0
 2404 0030 829B      		sbis 0x10,2
 2405 0032 00C0      		rjmp .L95
 2406               	.LVL175:
  82:main.c        **** 			cartMode = GB_MODE;
  83:main.c        **** 			PORTD |= (1<<LED_5V);
 2407               		.loc 3 83 0
 2408 0034 979A      		sbi 0x12,7
  84:main.c        **** 			PORTE &= ~(1<<LED_3V);
 2409               		.loc 3 84 0
 2410 0036 3898      		cbi 0x7,0
  82:main.c        **** 			cartMode = GB_MODE;
 2411               		.loc 3 82 0
 2412 0038 81E0      		ldi r24,lo8(1)
 2413 003a 00C0      		rjmp .L96
 2414               	.LVL176:
 2415               	.L95:
  85:main.c        **** 		}
  86:main.c        **** 		else {
  87:main.c        **** 			cartMode = GBA_MODE;
  88:main.c        **** 			PORTE |= (1<<LED_3V);
 2416               		.loc 3 88 0
 2417 003c 389A      		sbi 0x7,0
  89:main.c        **** 			PORTD &= ~(1<<LED_5V);
 2418               		.loc 3 89 0
 2419 003e 9798      		cbi 0x12,7
  87:main.c        **** 			PORTE |= (1<<LED_3V);
 2420               		.loc 3 87 0
 2421 0040 82E0      		ldi r24,lo8(2)
 2422               	.LVL177:
 2423               	.L96:
  90:main.c        **** 		}
  91:main.c        **** 		
  92:main.c        **** 		// Return the cart mode in use
  93:main.c        **** 		if (receivedChar == CART_MODE) {
 2424               		.loc 3 93 0
 2425 0042 9091 0000 		lds r25,receivedChar
 2426 0046 9334      		cpi r25,lo8(67)
 2427 0048 01F4      		brne .+2
 2428 004a 00C0      		rjmp .L228
  94:main.c        **** 			USART_Transmit(cartMode);
  95:main.c        **** 		}
  96:main.c        **** 		
  97:main.c        **** 		// Change to GB mode or GBA mode if requested
  98:main.c        **** 		else if (receivedChar == GB_CART_MODE) {
 2429               		.loc 3 98 0
 2430 004c 9734      		cpi r25,lo8(71)
 2431 004e 01F4      		brne .L99
  99:main.c        **** 			gb_mode();
 2432               		.loc 3 99 0
 2433 0050 00D0      		rcall gb_mode
 2434               	.LVL178:
 2435 0052 00C0      		rjmp .L93
 2436               	.LVL179:
 2437               	.L99:
 100:main.c        **** 		}
 101:main.c        **** 		else if (receivedChar == GBA_CART_MODE) {
 2438               		.loc 3 101 0
 2439 0054 9736      		cpi r25,lo8(103)
 2440 0056 01F4      		brne .+2
 2441 0058 00C0      		rjmp .L230
 102:main.c        **** 			gba_mode();
 103:main.c        **** 		}
 104:main.c        **** 		
 105:main.c        **** 		// Set address
 106:main.c        **** 		else if (receivedChar == SET_START_ADDRESS) {
 2442               		.loc 3 106 0
 2443 005a 9134      		cpi r25,lo8(65)
 2444 005c 01F4      		brne .L101
 107:main.c        **** 			usart_read_chars(); // Read start address
 2445               		.loc 3 107 0
 2446 005e 00D0      		rcall usart_read_chars
 2447               	.LVL180:
 108:main.c        **** 			address = strtol(receivedBuffer, NULL, 16); // Convert address string in hex to dec
 2448               		.loc 3 108 0
 2449 0060 40E1      		ldi r20,lo8(16)
 2450 0062 50E0      		ldi r21,0
 2451 0064 60E0      		ldi r22,0
 2452 0066 70E0      		ldi r23,0
 2453 0068 80E0      		ldi r24,lo8(receivedBuffer)
 2454 006a 90E0      		ldi r25,hi8(receivedBuffer)
 2455 006c 00D0      		rcall strtol
 2456               	.LVL181:
 2457 006e 6B01      		movw r12,r22
 2458 0070 7C01      		movw r14,r24
 2459               	.LVL182:
 2460 0072 00C0      		rjmp .L93
 2461               	.LVL183:
 2462               	.L101:
 109:main.c        **** 		}
 110:main.c        **** 		
 111:main.c        **** 		
 112:main.c        **** 		// ****** Gameboy / Gameboy Colour ******
 113:main.c        **** 		
 114:main.c        **** 		// Read 64 bytes of ROM/RAM from address (and increment) until anything but 1 is received
 115:main.c        **** 		else if (receivedChar == READ_ROM_RAM) {
 2463               		.loc 3 115 0
 2464 0074 9235      		cpi r25,lo8(82)
 2465 0076 01F4      		brne .L102
 116:main.c        **** 			gb_mode();
 2466               		.loc 3 116 0
 2467 0078 00D0      		rcall gb_mode
 2468               	.LVL184:
 117:main.c        **** 			receivedChar = '1';
 2469               		.loc 3 117 0
 2470 007a F1E3      		ldi r31,lo8(49)
 2471 007c F093 0000 		sts receivedChar,r31
 2472               	.LVL185:
 2473               	.L103:
 118:main.c        **** 			while (receivedChar == '1') {
 2474               		.loc 3 118 0
 2475 0080 8091 0000 		lds r24,receivedChar
 2476 0084 8133      		cpi r24,lo8(49)
 2477 0086 01F4      		brne .L93
 119:main.c        **** 				PORTD |= (1<<ACTIVITY_LED);
 2478               		.loc 3 119 0
 2479 0088 939A      		sbi 0x12,3
 2480               	.LVL186:
 2481 008a 00E0      		ldi r16,0
 2482 008c 10E0      		ldi r17,0
 2483               	.LVL187:
 2484               	.L104:
 2485               	.LBB145:
 120:main.c        **** 				for (uint8_t x = 0; x < 64; x++) {
 121:main.c        **** 					USART_Transmit(read_8bit_data(address));
 2486               		.loc 3 121 0 discriminator 3
 2487 008e C801      		movw r24,r16
 2488 0090 8C0D      		add r24,r12
 2489 0092 9D1D      		adc r25,r13
 2490 0094 00D0      		rcall read_8bit_data
 2491               	.LVL188:
 2492 0096 00D0      		rcall USART_Transmit
 2493               	.LVL189:
 2494 0098 0F5F      		subi r16,-1
 2495 009a 1F4F      		sbci r17,-1
 2496               	.LVL190:
 120:main.c        **** 				for (uint8_t x = 0; x < 64; x++) {
 2497               		.loc 3 120 0 discriminator 3
 2498 009c 0034      		cpi r16,64
 2499 009e 1105      		cpc r17,__zero_reg__
 2500 00a0 01F4      		brne .L104
 2501 00a2 20E4      		ldi r18,64
 2502 00a4 C20E      		add r12,r18
 2503 00a6 D11C      		adc r13,__zero_reg__
 2504 00a8 E11C      		adc r14,__zero_reg__
 2505 00aa F11C      		adc r15,__zero_reg__
 2506               	.LBE145:
 122:main.c        **** 					address++;
 123:main.c        **** 				}
 124:main.c        **** 				
 125:main.c        **** 				PORTD &= ~(1<<ACTIVITY_LED);
 2507               		.loc 3 125 0
 2508 00ac 9398      		cbi 0x12,3
 126:main.c        **** 				receivedChar = USART_Receive();
 2509               		.loc 3 126 0
 2510 00ae 00D0      		rcall USART_Receive
 2511               	.LVL191:
 2512 00b0 8093 0000 		sts receivedChar,r24
 2513 00b4 00C0      		rjmp .L103
 2514               	.LVL192:
 2515               	.L102:
 127:main.c        **** 			}
 128:main.c        **** 		}
 129:main.c        **** 		
 130:main.c        **** 		// Write 64 bytes to RAM on address (and increment)
 131:main.c        **** 		else if (receivedChar == WRITE_RAM) {
 2516               		.loc 3 131 0
 2517 00b6 9735      		cpi r25,lo8(87)
 2518 00b8 01F4      		brne .L106
 132:main.c        **** 			gb_mode();
 2519               		.loc 3 132 0
 2520 00ba 00D0      		rcall gb_mode
 2521               	.LVL193:
 133:main.c        **** 			
 134:main.c        **** 			// Read 64 bytes first as CH340G sends them all at once
 135:main.c        **** 			usart_read_bytes(64);
 2522               		.loc 3 135 0
 2523 00bc 80E4      		ldi r24,lo8(64)
 2524 00be 90E0      		ldi r25,0
 2525 00c0 00D0      		rcall usart_read_bytes
 2526               	.LVL194:
 136:main.c        **** 			
 137:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 2527               		.loc 3 137 0
 2528 00c2 939A      		sbi 0x12,3
 2529               	.LVL195:
 2530 00c4 A0E0      		ldi r26,lo8(receivedBuffer)
 2531 00c6 AA2E      		mov r10,r26
 2532 00c8 A0E0      		ldi r26,hi8(receivedBuffer)
 2533 00ca BA2E      		mov r11,r26
 2534 00cc 00E0      		ldi r16,0
 2535 00ce 10E0      		ldi r17,0
 2536               	.LVL196:
 2537               	.L107:
 2538               	.LBB146:
 138:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 139:main.c        **** 				write_8bit_data(address, receivedBuffer[x], MEMORY_WRITE);
 2539               		.loc 3 139 0 discriminator 3
 2540 00d0 F501      		movw r30,r10
 2541 00d2 6191      		ld r22,Z+
 2542 00d4 5F01      		movw r10,r30
 2543 00d6 C801      		movw r24,r16
 2544 00d8 8C0D      		add r24,r12
 2545 00da 9D1D      		adc r25,r13
 2546 00dc 41E0      		ldi r20,lo8(1)
 2547 00de 00D0      		rcall write_8bit_data
 2548               	.LVL197:
 2549 00e0 0F5F      		subi r16,-1
 2550 00e2 1F4F      		sbci r17,-1
 2551               	.LVL198:
 138:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 2552               		.loc 3 138 0 discriminator 3
 2553 00e4 0034      		cpi r16,64
 2554 00e6 1105      		cpc r17,__zero_reg__
 2555 00e8 01F4      		brne .L107
 2556 00ea F0E4      		ldi r31,64
 2557 00ec CF0E      		add r12,r31
 2558 00ee D11C      		adc r13,__zero_reg__
 2559 00f0 E11C      		adc r14,__zero_reg__
 2560 00f2 F11C      		adc r15,__zero_reg__
 2561 00f4 00C0      		rjmp .L248
 2562               	.LVL199:
 2563               	.L106:
 2564               	.LBE146:
 140:main.c        **** 				address++;
 141:main.c        **** 			}
 142:main.c        **** 			
 143:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 144:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 145:main.c        **** 		}
 146:main.c        **** 		
 147:main.c        **** 		// Set bank address and write a byte
 148:main.c        **** 		else if (receivedChar == SET_BANK) {
 2565               		.loc 3 148 0
 2566 00f6 9234      		cpi r25,lo8(66)
 2567 00f8 01F4      		brne .L108
 2568               	.LBB147:
 149:main.c        **** 			gb_mode();
 2569               		.loc 3 149 0
 2570 00fa 00D0      		rcall gb_mode
 2571               	.LVL200:
 150:main.c        **** 			
 151:main.c        **** 			usart_read_chars(); // Read start address
 2572               		.loc 3 151 0
 2573 00fc 00D0      		rcall usart_read_chars
 2574               	.LVL201:
 152:main.c        **** 			uint16_t bankaddress = strtol(receivedBuffer, NULL, 16); // Convert address string in hex to dec
 2575               		.loc 3 152 0
 2576 00fe 40E1      		ldi r20,lo8(16)
 2577 0100 50E0      		ldi r21,0
 2578 0102 60E0      		ldi r22,0
 2579 0104 70E0      		ldi r23,0
 2580 0106 80E0      		ldi r24,lo8(receivedBuffer)
 2581 0108 90E0      		ldi r25,hi8(receivedBuffer)
 2582 010a 00D0      		rcall strtol
 2583               	.LVL202:
 2584 010c 4B01      		movw r8,r22
 2585 010e 5C01      		movw r10,r24
 2586               	.LVL203:
 153:main.c        **** 			
 154:main.c        **** 			receivedChar = USART_Receive(); // Wait for bank number
 2587               		.loc 3 154 0
 2588 0110 00D0      		rcall USART_Receive
 2589               	.LVL204:
 2590 0112 8093 0000 		sts receivedChar,r24
 155:main.c        **** 			if (receivedChar == 'B') {
 2591               		.loc 3 155 0
 2592 0116 8234      		cpi r24,lo8(66)
 2593 0118 01F0      		breq .+2
 2594 011a 00C0      		rjmp .L93
 2595               	.LBB148:
 156:main.c        **** 				usart_read_chars(); // Read data
 2596               		.loc 3 156 0
 2597 011c 00D0      		rcall usart_read_chars
 2598               	.LVL205:
 157:main.c        **** 				uint8_t data = atoi(receivedBuffer); // Convert data string to dec
 2599               		.loc 3 157 0
 2600 011e 80E0      		ldi r24,lo8(receivedBuffer)
 2601 0120 90E0      		ldi r25,hi8(receivedBuffer)
 2602 0122 00D0      		rcall atoi
 2603               	.LVL206:
 158:main.c        **** 				lastBankAccessed = data; // Store the last bank accessed (used for flash carts that need it)
 2604               		.loc 3 158 0
 2605 0124 8093 0000 		sts lastBankAccessed,r24
 159:main.c        **** 				
 160:main.c        **** 				write_8bit_data(bankaddress, data, BANK_WRITE);
 2606               		.loc 3 160 0
 2607 0128 40E0      		ldi r20,0
 2608 012a 682F      		mov r22,r24
 2609 012c C401      		movw r24,r8
 2610               	.LVL207:
 2611 012e 00D0      		rcall write_8bit_data
 2612               	.LVL208:
 2613 0130 00C0      		rjmp .L93
 2614               	.LVL209:
 2615               	.L108:
 2616               	.LBE148:
 2617               	.LBE147:
 161:main.c        **** 			}
 162:main.c        **** 		}
 163:main.c        **** 		
 164:main.c        **** 		
 165:main.c        **** 		// ****** Gameboy Advance ******
 166:main.c        **** 		
 167:main.c        **** 		// ---------- ROM ----------
 168:main.c        **** 		// Read one 16bit byte from ROM using address (and increment) until anything but 1 is received
 169:main.c        **** 		else if (receivedChar == GBA_READ_ROM || receivedChar == GBA_READ_ROM_256BYTE) {
 2618               		.loc 3 169 0
 2619 0132 9237      		cpi r25,lo8(114)
 2620 0134 01F0      		breq .L109
 2621               		.loc 3 169 0 is_stmt 0 discriminator 1
 2622 0136 9A36      		cpi r25,lo8(106)
 2623 0138 01F4      		brne .L110
 2624               	.L109:
 2625               	.LBB149:
 170:main.c        **** 			gba_mode();
 2626               		.loc 3 170 0 is_stmt 1
 2627 013a 00D0      		rcall gba_mode
 2628               	.LVL210:
 171:main.c        **** 			
 172:main.c        **** 			uint8_t readEnd = 32;
 173:main.c        **** 			if (receivedChar == GBA_READ_ROM_256BYTE) {
 2629               		.loc 3 173 0
 2630 013c 8091 0000 		lds r24,receivedChar
 2631 0140 8A36      		cpi r24,lo8(106)
 2632 0142 01F4      		brne .L199
 174:main.c        **** 				readEnd = 128;
 2633               		.loc 3 174 0
 2634 0144 00E8      		ldi r16,lo8(-128)
 2635 0146 00C0      		rjmp .L111
 2636               	.L199:
 172:main.c        **** 			if (receivedChar == GBA_READ_ROM_256BYTE) {
 2637               		.loc 3 172 0
 2638 0148 00E2      		ldi r16,lo8(32)
 2639               	.L111:
 2640               	.LVL211:
 175:main.c        **** 			}
 176:main.c        **** 			
 177:main.c        **** 			receivedChar = '1';
 2641               		.loc 3 177 0
 2642 014a 21E3      		ldi r18,lo8(49)
 2643 014c 2093 0000 		sts receivedChar,r18
 2644 0150 8824      		clr r8
 2645 0152 8A94      		dec r8
 2646 0154 800E      		add r8,r16
 2647 0156 912C      		mov r9,__zero_reg__
 2648 0158 A12C      		mov r10,__zero_reg__
 2649 015a B12C      		mov r11,__zero_reg__
 2650 015c 8FEF      		ldi r24,-1
 2651 015e 881A      		sub r8,r24
 2652 0160 980A      		sbc r9,r24
 2653 0162 A80A      		sbc r10,r24
 2654 0164 B80A      		sbc r11,r24
 2655               	.LVL212:
 2656               	.L112:
 178:main.c        **** 			while (receivedChar == '1') {
 2657               		.loc 3 178 0
 2658 0166 8091 0000 		lds r24,receivedChar
 2659 016a 8133      		cpi r24,lo8(49)
 2660 016c 01F0      		breq .+2
 2661 016e 00C0      		rjmp .L93
 179:main.c        **** 				PORTD |= (1<<ACTIVITY_LED);
 2662               		.loc 3 179 0
 2663 0170 939A      		sbi 0x12,3
 2664               	.LVL213:
 2665 0172 2601      		movw r4,r12
 2666 0174 3701      		movw r6,r14
 2667               	.LVL214:
 2668               	.L113:
 2669               	.LBB150:
 2670               	.LBB151:
 180:main.c        **** 				
 181:main.c        **** 				for (uint8_t x = 0; x < readEnd; x++) {
 182:main.c        **** 					uint16_t dataRead = gba_read_16bit_data(address);
 2671               		.loc 3 182 0 discriminator 3
 2672 0176 C301      		movw r24,r6
 2673 0178 B201      		movw r22,r4
 2674 017a 00D0      		rcall gba_read_16bit_data
 2675               	.LVL215:
 2676 017c 192F      		mov r17,r25
 2677               	.LVL216:
 183:main.c        **** 					
 184:main.c        **** 					// Low byte & High byte
 185:main.c        **** 					USART_Transmit(dataRead & 0xFF);
 2678               		.loc 3 185 0 discriminator 3
 2679 017e 00D0      		rcall USART_Transmit
 2680               	.LVL217:
 186:main.c        **** 					USART_Transmit(dataRead >> 8);
 2681               		.loc 3 186 0 discriminator 3
 2682 0180 812F      		mov r24,r17
 2683 0182 00D0      		rcall USART_Transmit
 2684               	.LVL218:
 187:main.c        **** 					
 188:main.c        **** 					address++;
 2685               		.loc 3 188 0 discriminator 3
 2686 0184 9FEF      		ldi r25,-1
 2687 0186 491A      		sub r4,r25
 2688 0188 590A      		sbc r5,r25
 2689 018a 690A      		sbc r6,r25
 2690 018c 790A      		sbc r7,r25
 2691               	.LVL219:
 2692               	.LBE151:
 181:main.c        **** 					uint16_t dataRead = gba_read_16bit_data(address);
 2693               		.loc 3 181 0 discriminator 3
 2694 018e 842D      		mov r24,r4
 2695 0190 8C19      		sub r24,r12
 2696 0192 8017      		cp r24,r16
 2697 0194 00F0      		brlo .L113
 2698 0196 C80C      		add r12,r8
 2699 0198 D91C      		adc r13,r9
 2700 019a EA1C      		adc r14,r10
 2701 019c FB1C      		adc r15,r11
 2702               	.LVL220:
 2703               	.LBE150:
 189:main.c        **** 				}
 190:main.c        **** 				
 191:main.c        **** 				PORTD &= ~(1<<ACTIVITY_LED);
 2704               		.loc 3 191 0
 2705 019e 9398      		cbi 0x12,3
 192:main.c        **** 				receivedChar = USART_Receive();
 2706               		.loc 3 192 0
 2707 01a0 00D0      		rcall USART_Receive
 2708               	.LVL221:
 2709 01a2 8093 0000 		sts receivedChar,r24
 2710 01a6 00C0      		rjmp .L112
 2711               	.LVL222:
 2712               	.L110:
 2713               	.LBE149:
 193:main.c        **** 			}
 194:main.c        **** 		}
 195:main.c        **** 		
 196:main.c        **** 		// ---------- SRAM ----------
 197:main.c        **** 		// Read RAM from address (and increment) until anything but 1 is received
 198:main.c        **** 		else if (receivedChar == GBA_READ_SRAM) {
 2714               		.loc 3 198 0
 2715 01a8 9D36      		cpi r25,lo8(109)
 2716 01aa 01F4      		brne .L115
 199:main.c        **** 			gb_mode(); // Set GB mode as it uses 16 bit address with 8 bit data
 2717               		.loc 3 199 0
 2718 01ac 00D0      		rcall gb_mode
 2719               	.LVL223:
 200:main.c        **** 			
 201:main.c        **** 			receivedChar = '1';
 2720               		.loc 3 201 0
 2721 01ae E1E3      		ldi r30,lo8(49)
 2722 01b0 E093 0000 		sts receivedChar,r30
 2723               	.LVL224:
 2724               	.L116:
 202:main.c        **** 			while (receivedChar == '1') {
 2725               		.loc 3 202 0
 2726 01b4 8091 0000 		lds r24,receivedChar
 2727 01b8 8133      		cpi r24,lo8(49)
 2728 01ba 01F4      		brne .L230
 203:main.c        **** 				PORTD |= (1<<ACTIVITY_LED);
 2729               		.loc 3 203 0
 2730 01bc 939A      		sbi 0x12,3
 2731               	.LVL225:
 2732 01be 00E0      		ldi r16,0
 2733 01c0 10E0      		ldi r17,0
 2734               	.LVL226:
 2735               	.L117:
 2736               	.LBB152:
 204:main.c        **** 				for (uint8_t x = 0; x < 64; x++) {
 205:main.c        **** 					USART_Transmit(gba_read_ram_8bit_data(address));
 2737               		.loc 3 205 0 discriminator 3
 2738 01c2 C801      		movw r24,r16
 2739 01c4 8C0D      		add r24,r12
 2740 01c6 9D1D      		adc r25,r13
 2741 01c8 00D0      		rcall gba_read_ram_8bit_data
 2742               	.LVL227:
 2743 01ca 00D0      		rcall USART_Transmit
 2744               	.LVL228:
 2745 01cc 0F5F      		subi r16,-1
 2746 01ce 1F4F      		sbci r17,-1
 2747               	.LVL229:
 204:main.c        **** 				for (uint8_t x = 0; x < 64; x++) {
 2748               		.loc 3 204 0 discriminator 3
 2749 01d0 0034      		cpi r16,64
 2750 01d2 1105      		cpc r17,__zero_reg__
 2751 01d4 01F4      		brne .L117
 2752 01d6 F0E4      		ldi r31,64
 2753 01d8 CF0E      		add r12,r31
 2754 01da D11C      		adc r13,__zero_reg__
 2755 01dc E11C      		adc r14,__zero_reg__
 2756 01de F11C      		adc r15,__zero_reg__
 2757               	.LBE152:
 206:main.c        **** 					address++;
 207:main.c        **** 				}
 208:main.c        **** 				
 209:main.c        **** 				PORTD &= ~(1<<ACTIVITY_LED);
 2758               		.loc 3 209 0
 2759 01e0 9398      		cbi 0x12,3
 210:main.c        **** 				receivedChar = USART_Receive();
 2760               		.loc 3 210 0
 2761 01e2 00D0      		rcall USART_Receive
 2762               	.LVL230:
 2763 01e4 8093 0000 		sts receivedChar,r24
 2764 01e8 00C0      		rjmp .L116
 2765               	.LVL231:
 2766               	.L115:
 211:main.c        **** 			}
 212:main.c        **** 			
 213:main.c        **** 			gba_mode(); // Set back
 214:main.c        **** 		}
 215:main.c        **** 		
 216:main.c        **** 		// Write to RAM on address (and increment) with 64 bytes of data
 217:main.c        **** 		else if (receivedChar == GBA_WRITE_SRAM) {
 2767               		.loc 3 217 0
 2768 01ea 9737      		cpi r25,lo8(119)
 2769 01ec 01F4      		brne .L119
 218:main.c        **** 			gb_mode();
 2770               		.loc 3 218 0
 2771 01ee 00D0      		rcall gb_mode
 2772               	.LVL232:
 219:main.c        **** 			
 220:main.c        **** 			usart_read_bytes(64);
 2773               		.loc 3 220 0
 2774 01f0 80E4      		ldi r24,lo8(64)
 2775 01f2 90E0      		ldi r25,0
 2776 01f4 00D0      		rcall usart_read_bytes
 2777               	.LVL233:
 221:main.c        **** 			
 222:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 2778               		.loc 3 222 0
 2779 01f6 939A      		sbi 0x12,3
 2780               	.LVL234:
 2781 01f8 F0E0      		ldi r31,lo8(receivedBuffer)
 2782 01fa AF2E      		mov r10,r31
 2783 01fc F0E0      		ldi r31,hi8(receivedBuffer)
 2784 01fe BF2E      		mov r11,r31
 2785 0200 00E0      		ldi r16,0
 2786 0202 10E0      		ldi r17,0
 2787               	.LVL235:
 2788               	.L120:
 2789               	.LBB153:
 223:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 224:main.c        **** 				gba_write_ram_8bit_data(address, receivedBuffer[x]);
 2790               		.loc 3 224 0 discriminator 3
 2791 0204 F501      		movw r30,r10
 2792 0206 6191      		ld r22,Z+
 2793 0208 5F01      		movw r10,r30
 2794 020a C801      		movw r24,r16
 2795 020c 8C0D      		add r24,r12
 2796 020e 9D1D      		adc r25,r13
 2797 0210 00D0      		rcall gba_write_ram_8bit_data
 2798               	.LVL236:
 2799 0212 0F5F      		subi r16,-1
 2800 0214 1F4F      		sbci r17,-1
 2801               	.LVL237:
 223:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 2802               		.loc 3 223 0 discriminator 3
 2803 0216 0034      		cpi r16,64
 2804 0218 1105      		cpc r17,__zero_reg__
 2805 021a 01F4      		brne .L120
 2806               	.LVL238:
 2807               	.L233:
 2808 021c F0E4      		ldi r31,64
 2809 021e CF0E      		add r12,r31
 2810 0220 D11C      		adc r13,__zero_reg__
 2811 0222 E11C      		adc r14,__zero_reg__
 2812 0224 F11C      		adc r15,__zero_reg__
 2813               	.L232:
 2814               	.LBE153:
 225:main.c        **** 				address++;
 226:main.c        **** 			}
 227:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 2815               		.loc 3 227 0
 2816 0226 81E3      		ldi r24,lo8(49)
 2817 0228 00D0      		rcall USART_Transmit
 2818               	.LVL239:
 228:main.c        **** 			
 229:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 2819               		.loc 3 229 0
 2820 022a 9398      		cbi 0x12,3
 2821               	.L230:
 230:main.c        **** 			gba_mode(); // Set back
 2822               		.loc 3 230 0
 2823 022c 00D0      		rcall gba_mode
 2824               	.LVL240:
 2825 022e 00C0      		rjmp .L93
 2826               	.LVL241:
 2827               	.L119:
 231:main.c        **** 		}
 232:main.c        **** 		
 233:main.c        **** 		// Write 1 byte to SRAM address
 234:main.c        **** 		else if (receivedChar == GBA_WRITE_ONE_BYTE_SRAM) {
 2828               		.loc 3 234 0
 2829 0230 9F36      		cpi r25,lo8(111)
 2830 0232 01F4      		brne .L121
 2831               	.LBB154:
 235:main.c        **** 			gb_mode();
 2832               		.loc 3 235 0
 2833 0234 00D0      		rcall gb_mode
 2834               	.LVL242:
 236:main.c        **** 			
 237:main.c        **** 			uint8_t data = USART_Receive();
 2835               		.loc 3 237 0
 2836 0236 00D0      		rcall USART_Receive
 2837               	.LVL243:
 238:main.c        **** 			gba_write_ram_8bit_data(address, data);
 2838               		.loc 3 238 0
 2839 0238 682F      		mov r22,r24
 2840 023a C601      		movw r24,r12
 2841               	.LVL244:
 2842 023c 00D0      		rcall gba_write_ram_8bit_data
 2843               	.LVL245:
 2844 023e 00C0      		rjmp .L235
 2845               	.LVL246:
 2846               	.L121:
 2847               	.LBE154:
 239:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 240:main.c        **** 			
 241:main.c        **** 			gba_mode(); // Set back
 242:main.c        **** 		}
 243:main.c        **** 		
 244:main.c        **** 		
 245:main.c        **** 		// ---------- FLASH ----------
 246:main.c        **** 		// Read the Flash Manufacturer and Device ID
 247:main.c        **** 		else if (receivedChar == GBA_FLASH_READ_ID) {
 2848               		.loc 3 247 0
 2849 0240 9936      		cpi r25,lo8(105)
 2850 0242 01F4      		brne .L122
 248:main.c        **** 			gb_mode();
 2851               		.loc 3 248 0
 2852 0244 00D0      		rcall gb_mode
 2853               	.LVL247:
 249:main.c        **** 			
 250:main.c        **** 			flash_read_chip_id();
 2854               		.loc 3 250 0
 2855 0246 00D0      		rcall flash_read_chip_id
 2856               	.LVL248:
 251:main.c        **** 			USART_Transmit(flashChipIdBuffer[0]);
 2857               		.loc 3 251 0
 2858 0248 8091 0000 		lds r24,flashChipIdBuffer
 2859 024c 00D0      		rcall USART_Transmit
 2860               	.LVL249:
 252:main.c        **** 			USART_Transmit(flashChipIdBuffer[1]);
 2861               		.loc 3 252 0
 2862 024e 8091 0000 		lds r24,flashChipIdBuffer+1
 2863               	.L234:
 2864 0252 00D0      		rcall USART_Transmit
 2865               	.LVL250:
 2866 0254 00C0      		rjmp .L230
 2867               	.LVL251:
 2868               	.L122:
 253:main.c        **** 			
 254:main.c        **** 			gba_mode(); // Set back
 255:main.c        **** 		}
 256:main.c        **** 		
 257:main.c        **** 		// Change bank
 258:main.c        **** 		else if (receivedChar == GBA_FLASH_SET_BANK) {
 2869               		.loc 3 258 0
 2870 0256 9B36      		cpi r25,lo8(107)
 2871 0258 01F4      		brne .L123
 2872               	.LBB155:
 259:main.c        **** 			usart_read_chars(); // Read data
 2873               		.loc 3 259 0
 2874 025a 00D0      		rcall usart_read_chars
 2875               	.LVL252:
 260:main.c        **** 			uint8_t bank = atoi(receivedBuffer); // Convert data string to dec
 2876               		.loc 3 260 0
 2877 025c 80E0      		ldi r24,lo8(receivedBuffer)
 2878 025e 90E0      		ldi r25,hi8(receivedBuffer)
 2879 0260 00D0      		rcall atoi
 2880               	.LVL253:
 2881 0262 182F      		mov r17,r24
 2882               	.LVL254:
 261:main.c        **** 			
 262:main.c        **** 			gb_mode();
 2883               		.loc 3 262 0
 2884 0264 00D0      		rcall gb_mode
 2885               	.LVL255:
 263:main.c        **** 			flash_switch_bank(bank);
 2886               		.loc 3 263 0
 2887 0266 812F      		mov r24,r17
 2888 0268 00D0      		rcall flash_switch_bank
 2889               	.LVL256:
 2890 026a 00C0      		rjmp .L230
 2891               	.LVL257:
 2892               	.L123:
 2893               	.LBE155:
 264:main.c        **** 			
 265:main.c        **** 			gba_mode(); // Set back
 266:main.c        **** 		}
 267:main.c        **** 		
 268:main.c        **** 		// Erase 4K sector on Flash (sector 0 to 15 for 512Kbit)
 269:main.c        **** 		else if (receivedChar == GBA_FLASH_4K_SECTOR_ERASE) {
 2894               		.loc 3 269 0
 2895 026c 9337      		cpi r25,lo8(115)
 2896 026e 01F4      		brne .L124
 2897               	.LBB156:
 270:main.c        **** 			gb_mode();
 2898               		.loc 3 270 0
 2899 0270 00D0      		rcall gb_mode
 2900               	.LVL258:
 271:main.c        **** 			
 272:main.c        **** 			usart_read_chars(); // Read sector
 2901               		.loc 3 272 0
 2902 0272 00D0      		rcall usart_read_chars
 2903               	.LVL259:
 273:main.c        **** 			uint8_t sectorAddress = strtol(receivedBuffer, NULL, 16); // Convert address string in hex to de
 2904               		.loc 3 273 0
 2905 0274 40E1      		ldi r20,lo8(16)
 2906 0276 50E0      		ldi r21,0
 2907 0278 60E0      		ldi r22,0
 2908 027a 70E0      		ldi r23,0
 2909 027c 80E0      		ldi r24,lo8(receivedBuffer)
 2910 027e 90E0      		ldi r25,hi8(receivedBuffer)
 2911 0280 00D0      		rcall strtol
 2912               	.LVL260:
 2913 0282 862F      		mov r24,r22
 2914               	.LVL261:
 274:main.c        **** 			
 275:main.c        **** 			flash_erase_4k_sector(sectorAddress);
 2915               		.loc 3 275 0
 2916 0284 00D0      		rcall flash_erase_4k_sector
 2917               	.LVL262:
 2918               	.L235:
 276:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 2919               		.loc 3 276 0
 2920 0286 81E3      		ldi r24,lo8(49)
 2921 0288 00C0      		rjmp .L234
 2922               	.LVL263:
 2923               	.L124:
 2924               	.LBE156:
 277:main.c        **** 			
 278:main.c        **** 			gba_mode(); // Set back
 279:main.c        **** 		}
 280:main.c        **** 		
 281:main.c        **** 		// Write 64 bytes to Flash address one byte write at a time (and increment)
 282:main.c        **** 		else if (receivedChar == GBA_FLASH_WRITE_BYTE) {
 2925               		.loc 3 282 0
 2926 028a 9236      		cpi r25,lo8(98)
 2927 028c 01F4      		brne .L125
 283:main.c        **** 			gb_mode();
 2928               		.loc 3 283 0
 2929 028e 00D0      		rcall gb_mode
 2930               	.LVL264:
 284:main.c        **** 			
 285:main.c        **** 			usart_read_bytes(64);
 2931               		.loc 3 285 0
 2932 0290 80E4      		ldi r24,lo8(64)
 2933 0292 90E0      		ldi r25,0
 2934 0294 00D0      		rcall usart_read_bytes
 2935               	.LVL265:
 286:main.c        **** 			
 287:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 2936               		.loc 3 287 0
 2937 0296 939A      		sbi 0x12,3
 2938               	.LVL266:
 2939 0298 E0E0      		ldi r30,lo8(receivedBuffer)
 2940 029a AE2E      		mov r10,r30
 2941 029c E0E0      		ldi r30,hi8(receivedBuffer)
 2942 029e BE2E      		mov r11,r30
 2943 02a0 00E0      		ldi r16,0
 2944 02a2 10E0      		ldi r17,0
 2945               	.LVL267:
 2946               	.L126:
 2947               	.LBB157:
 288:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 289:main.c        **** 				flash_write_byte(address, receivedBuffer[x]);
 2948               		.loc 3 289 0 discriminator 3
 2949 02a4 F501      		movw r30,r10
 2950 02a6 6191      		ld r22,Z+
 2951 02a8 5F01      		movw r10,r30
 2952 02aa C801      		movw r24,r16
 2953 02ac 8C0D      		add r24,r12
 2954 02ae 9D1D      		adc r25,r13
 2955 02b0 00D0      		rcall flash_write_byte
 2956               	.LVL268:
 2957 02b2 0F5F      		subi r16,-1
 2958 02b4 1F4F      		sbci r17,-1
 2959               	.LVL269:
 288:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 2960               		.loc 3 288 0 discriminator 3
 2961 02b6 0034      		cpi r16,64
 2962 02b8 1105      		cpc r17,__zero_reg__
 2963 02ba 01F4      		brne .L126
 2964 02bc 00C0      		rjmp .L233
 2965               	.LVL270:
 2966               	.L125:
 2967               	.LBE157:
 290:main.c        **** 				address++;
 291:main.c        **** 			}
 292:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 293:main.c        **** 			
 294:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 295:main.c        **** 			gba_mode(); // Set back
 296:main.c        **** 		}
 297:main.c        **** 		
 298:main.c        **** 		// Write 128 bytes to flash sector for Atmel flash (and increment)
 299:main.c        **** 		else if (receivedChar == GBA_FLASH_WRITE_ATMEL) {
 2968               		.loc 3 299 0
 2969 02be 9136      		cpi r25,lo8(97)
 2970 02c0 01F4      		brne .L127
 300:main.c        **** 			gb_mode();
 2971               		.loc 3 300 0
 2972 02c2 00D0      		rcall gb_mode
 2973               	.LVL271:
 301:main.c        **** 			
 302:main.c        **** 			usart_read_bytes(128);
 2974               		.loc 3 302 0
 2975 02c4 80E8      		ldi r24,lo8(-128)
 2976 02c6 90E0      		ldi r25,0
 2977 02c8 00D0      		rcall usart_read_bytes
 2978               	.LVL272:
 303:main.c        **** 			
 304:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 2979               		.loc 3 304 0
 2980 02ca 939A      		sbi 0x12,3
 305:main.c        **** 			flash_write_sector(address); // Address used as sector number
 2981               		.loc 3 305 0
 2982 02cc C601      		movw r24,r12
 2983 02ce 00D0      		rcall flash_write_sector
 2984               	.LVL273:
 306:main.c        **** 			address++;
 2985               		.loc 3 306 0
 2986 02d0 2FEF      		ldi r18,-1
 2987 02d2 C21A      		sub r12,r18
 2988 02d4 D20A      		sbc r13,r18
 2989 02d6 E20A      		sbc r14,r18
 2990 02d8 F20A      		sbc r15,r18
 2991               	.LVL274:
 2992 02da 00C0      		rjmp .L232
 2993               	.LVL275:
 2994               	.L127:
 307:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 308:main.c        **** 			
 309:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 310:main.c        **** 			gba_mode(); // Set back
 311:main.c        **** 		}
 312:main.c        **** 		
 313:main.c        **** 		
 314:main.c        **** 		// ---------- EEPROM ----------
 315:main.c        **** 		// Set EEPROM size
 316:main.c        **** 		else if (receivedChar == GBA_SET_EEPROM_SIZE) {
 2995               		.loc 3 316 0
 2996 02dc 9335      		cpi r25,lo8(83)
 2997 02de 01F4      		brne .L128
 317:main.c        **** 			usart_read_chars(); // Read size
 2998               		.loc 3 317 0
 2999 02e0 00D0      		rcall usart_read_chars
 3000               	.LVL276:
 318:main.c        **** 			eepromSize = strtol(receivedBuffer, NULL, 16); // Convert size to dec
 3001               		.loc 3 318 0
 3002 02e2 40E1      		ldi r20,lo8(16)
 3003 02e4 50E0      		ldi r21,0
 3004 02e6 60E0      		ldi r22,0
 3005 02e8 70E0      		ldi r23,0
 3006 02ea 80E0      		ldi r24,lo8(receivedBuffer)
 3007 02ec 90E0      		ldi r25,hi8(receivedBuffer)
 3008 02ee 00D0      		rcall strtol
 3009               	.LVL277:
 3010 02f0 6983      		std Y+1,r22
 3011               	.LVL278:
 3012 02f2 00C0      		rjmp .L93
 3013               	.LVL279:
 3014               	.L128:
 319:main.c        **** 		}
 320:main.c        **** 		
 321:main.c        **** 		// Read the EEPROM on address (and increment) until anything but 1 is received
 322:main.c        **** 		else if (receivedChar == GBA_READ_EEPROM) {
 3015               		.loc 3 322 0
 3016 02f4 9536      		cpi r25,lo8(101)
 3017 02f6 01F4      		brne .L129
 323:main.c        **** 			gba_eeprom_mode();
 3018               		.loc 3 323 0
 3019 02f8 00D0      		rcall gba_eeprom_mode
 3020               	.LVL280:
 324:main.c        **** 			
 325:main.c        **** 			receivedChar = '1';
 3021               		.loc 3 325 0
 3022 02fa 81E3      		ldi r24,lo8(49)
 3023               	.L236:
 326:main.c        **** 			while (receivedChar == '1') {
 327:main.c        **** 				PORTD |= (1<<ACTIVITY_LED);
 328:main.c        **** 				gba_eeprom_read(address, eepromSize);
 329:main.c        **** 				
 330:main.c        **** 				// Send back the 8 bytes of data
 331:main.c        **** 				for (uint8_t c = 0; c < 8; c++) {
 332:main.c        **** 					USART_Transmit(eepromBuffer[c]);
 333:main.c        **** 				}
 334:main.c        **** 				address++; // Increment to next 8 bytes
 335:main.c        **** 				
 336:main.c        **** 				PORTD &= ~(1<<ACTIVITY_LED);
 337:main.c        **** 				receivedChar = USART_Receive();
 3024               		.loc 3 337 0
 3025 02fc 8093 0000 		sts receivedChar,r24
 326:main.c        **** 			while (receivedChar == '1') {
 3026               		.loc 3 326 0
 3027 0300 8091 0000 		lds r24,receivedChar
 3028 0304 8133      		cpi r24,lo8(49)
 3029 0306 01F0      		breq .+2
 3030 0308 00C0      		rjmp .L230
 327:main.c        **** 				gba_eeprom_read(address, eepromSize);
 3031               		.loc 3 327 0
 3032 030a 939A      		sbi 0x12,3
 328:main.c        **** 				
 3033               		.loc 3 328 0
 3034 030c 6981      		ldd r22,Y+1
 3035 030e C601      		movw r24,r12
 3036 0310 00D0      		rcall gba_eeprom_read
 3037               	.LVL281:
 3038 0312 00E0      		ldi r16,lo8(eepromBuffer)
 3039 0314 10E0      		ldi r17,hi8(eepromBuffer)
 3040               	.LVL282:
 3041               	.L131:
 3042               	.LBB158:
 332:main.c        **** 				}
 3043               		.loc 3 332 0 discriminator 3
 3044 0316 F801      		movw r30,r16
 3045 0318 8191      		ld r24,Z+
 3046 031a 8F01      		movw r16,r30
 3047               	.LVL283:
 3048 031c 00D0      		rcall USART_Transmit
 3049               	.LVL284:
 331:main.c        **** 					USART_Transmit(eepromBuffer[c]);
 3050               		.loc 3 331 0 discriminator 3
 3051 031e 2016      		cp r2,r16
 3052 0320 3106      		cpc r3,r17
 3053 0322 01F4      		brne .L131
 3054               	.LBE158:
 334:main.c        **** 				
 3055               		.loc 3 334 0
 3056 0324 FFEF      		ldi r31,-1
 3057 0326 CF1A      		sub r12,r31
 3058 0328 DF0A      		sbc r13,r31
 3059 032a EF0A      		sbc r14,r31
 3060 032c FF0A      		sbc r15,r31
 3061               	.LVL285:
 336:main.c        **** 				receivedChar = USART_Receive();
 3062               		.loc 3 336 0
 3063 032e 9398      		cbi 0x12,3
 3064               		.loc 3 337 0
 3065 0330 00D0      		rcall USART_Receive
 3066               	.LVL286:
 3067 0332 00C0      		rjmp .L236
 3068               	.LVL287:
 3069               	.L129:
 338:main.c        **** 			}
 339:main.c        **** 			
 340:main.c        **** 			gba_mode(); // Set back
 341:main.c        **** 		}
 342:main.c        **** 		
 343:main.c        **** 		// Write 8 bytes to the EEPROM address (and increment)
 344:main.c        **** 		else if (receivedChar == GBA_WRITE_EEPROM) {
 3070               		.loc 3 344 0
 3071 0334 9037      		cpi r25,lo8(112)
 3072 0336 01F4      		brne .L133
 345:main.c        **** 			gba_eeprom_mode();
 3073               		.loc 3 345 0
 3074 0338 00D0      		rcall gba_eeprom_mode
 3075               	.LVL288:
 3076 033a 00E0      		ldi r16,lo8(eepromBuffer)
 3077 033c 10E0      		ldi r17,hi8(eepromBuffer)
 3078               	.LVL289:
 3079               	.L134:
 3080               	.LBB159:
 346:main.c        **** 			
 347:main.c        **** 			// Read 8 bytes from USART and place in buffer
 348:main.c        **** 			for (uint8_t x = 0; x < 8; x++) {
 349:main.c        **** 				eepromBuffer[x] = USART_Receive();
 3081               		.loc 3 349 0 discriminator 3
 3082 033e 00D0      		rcall USART_Receive
 3083               	.LVL290:
 3084 0340 F801      		movw r30,r16
 3085 0342 8193      		st Z+,r24
 3086 0344 8F01      		movw r16,r30
 3087               	.LVL291:
 348:main.c        **** 				eepromBuffer[x] = USART_Receive();
 3088               		.loc 3 348 0 discriminator 3
 3089 0346 2E16      		cp r2,r30
 3090 0348 3F06      		cpc r3,r31
 3091 034a 01F4      		brne .L134
 3092               	.LBE159:
 350:main.c        **** 			}
 351:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 3093               		.loc 3 351 0
 3094 034c 939A      		sbi 0x12,3
 352:main.c        **** 			
 353:main.c        **** 			gba_eeprom_write(address, eepromSize);
 3095               		.loc 3 353 0
 3096 034e 6981      		ldd r22,Y+1
 3097 0350 C601      		movw r24,r12
 3098 0352 00D0      		rcall gba_eeprom_write
 3099               	.LVL292:
 354:main.c        **** 			address++;
 3100               		.loc 3 354 0
 3101 0354 FFEF      		ldi r31,-1
 3102 0356 CF1A      		sub r12,r31
 3103 0358 DF0A      		sbc r13,r31
 3104 035a EF0A      		sbc r14,r31
 3105 035c FF0A      		sbc r15,r31
 3106               	.LVL293:
 3107               	.LBB160:
 3108               	.LBB161:
 187:c:\winavr-20100110\avr\include\util\delay.h **** 
 3109               		.loc 2 187 0
 3110 035e 8FE7      		ldi r24,lo8(15999)
 3111 0360 9EE3      		ldi r25,hi8(15999)
 3112 0362 0197      	1:	sbiw r24,1
 3113 0364 01F4      		brne 1b
 3114 0366 00C0      		rjmp .
 3115 0368 0000      		nop
 3116               	.LVL294:
 3117 036a 00C0      		rjmp .L232
 3118               	.LVL295:
 3119               	.L133:
 3120               	.LBE161:
 3121               	.LBE160:
 355:main.c        **** 			
 356:main.c        **** 			_delay_ms(8); // Wait for EEPROM to write data (8ms)
 357:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 358:main.c        **** 			
 359:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 360:main.c        **** 			gba_mode(); // Set back
 361:main.c        **** 		}
 362:main.c        **** 		
 363:main.c        **** 		
 364:main.c        **** 		// ---------- GB FLASH CARTS ----------
 365:main.c        **** 		// Select which pin need to pulse as WE (Audio or WR)
 366:main.c        **** 		else if (receivedChar == GB_FLASH_WE_PIN) {
 3122               		.loc 3 366 0
 3123 036c 9035      		cpi r25,lo8(80)
 3124 036e 01F4      		brne .L135
 367:main.c        **** 			flashWriteWePin = USART_Receive();
 3125               		.loc 3 367 0
 3126 0370 00D0      		rcall USART_Receive
 3127               	.LVL296:
 3128 0372 8093 0000 		sts flashWriteWePin,r24
 368:main.c        **** 			
 369:main.c        **** 			if (flashWriteWePin == WE_AS_AUDIO_PIN) {
 3129               		.loc 3 369 0
 3130 0376 8134      		cpi r24,lo8(65)
 3131 0378 01F0      		breq .+2
 3132 037a 00C0      		rjmp .L93
 370:main.c        **** 				DDRE |= (1<<AUDIO_PIN);
 3133               		.loc 3 370 0
 3134 037c 319A      		sbi 0x6,1
 371:main.c        **** 				audioPin_high;
 3135               		.loc 3 371 0
 3136 037e 399A      		sbi 0x7,1
 3137 0380 00C0      		rjmp .L93
 3138               	.LVL297:
 3139               	.L135:
 372:main.c        **** 			}
 373:main.c        **** 		}
 374:main.c        **** 		
 375:main.c        **** 		// Some flash carts may require changing the bank back to 1 in order to accept flash chip command
 376:main.c        **** 		else if (receivedChar == GB_FLASH_BANK_1_COMMAND_WRITES) {
 3140               		.loc 3 376 0
 3141 0382 9E34      		cpi r25,lo8(78)
 3142 0384 01F4      		brne .L136
 377:main.c        **** 			flashBank1CommandWrites = 1;
 3143               		.loc 3 377 0
 3144 0386 91E0      		ldi r25,lo8(1)
 3145 0388 9093 0000 		sts flashBank1CommandWrites,r25
 3146 038c 00C0      		rjmp .L93
 3147               	.L136:
 378:main.c        **** 		}
 379:main.c        **** 		
 380:main.c        **** 		// Load the program method to use
 381:main.c        **** 		else if (receivedChar == GB_FLASH_PROGRAM_METHOD) {
 3148               		.loc 3 381 0
 3149 038e 9534      		cpi r25,lo8(69)
 3150 0390 01F4      		brne .L137
 3151 0392 00E0      		ldi r16,lo8(flashWriteCycle)
 3152 0394 10E0      		ldi r17,hi8(flashWriteCycle)
 3153               	.LVL298:
 3154               	.L138:
 3155               	.LBB162:
 382:main.c        **** 			for (uint8_t x = 0; x < 3; x++) {
 383:main.c        **** 				usart_read_chars(); // Address
 3156               		.loc 3 383 0 discriminator 3
 3157 0396 00D0      		rcall usart_read_chars
 3158               	.LVL299:
 384:main.c        **** 				flashWriteCycle[x][0] = strtol(receivedBuffer, NULL, 16);
 3159               		.loc 3 384 0 discriminator 3
 3160 0398 40E1      		ldi r20,lo8(16)
 3161 039a 50E0      		ldi r21,0
 3162 039c 60E0      		ldi r22,0
 3163 039e 70E0      		ldi r23,0
 3164 03a0 80E0      		ldi r24,lo8(receivedBuffer)
 3165 03a2 90E0      		ldi r25,hi8(receivedBuffer)
 3166 03a4 00D0      		rcall strtol
 3167               	.LVL300:
 3168 03a6 F801      		movw r30,r16
 3169 03a8 7183      		std Z+1,r23
 3170 03aa 6083      		st Z,r22
 385:main.c        **** 				USART_Transmit(SEND_ACK);
 3171               		.loc 3 385 0 discriminator 3
 3172 03ac 81E3      		ldi r24,lo8(49)
 3173 03ae 00D0      		rcall USART_Transmit
 3174               	.LVL301:
 386:main.c        **** 				
 387:main.c        **** 				usart_read_chars(); // Data
 3175               		.loc 3 387 0 discriminator 3
 3176 03b0 00D0      		rcall usart_read_chars
 3177               	.LVL302:
 388:main.c        **** 				flashWriteCycle[x][1] = strtol(receivedBuffer, NULL, 16);
 3178               		.loc 3 388 0 discriminator 3
 3179 03b2 40E1      		ldi r20,lo8(16)
 3180 03b4 50E0      		ldi r21,0
 3181 03b6 60E0      		ldi r22,0
 3182 03b8 70E0      		ldi r23,0
 3183 03ba 80E0      		ldi r24,lo8(receivedBuffer)
 3184 03bc 90E0      		ldi r25,hi8(receivedBuffer)
 3185 03be 00D0      		rcall strtol
 3186               	.LVL303:
 3187 03c0 F801      		movw r30,r16
 3188 03c2 7383      		std Z+3,r23
 3189 03c4 6283      		std Z+2,r22
 389:main.c        **** 				USART_Transmit(SEND_ACK);
 3190               		.loc 3 389 0 discriminator 3
 3191 03c6 81E3      		ldi r24,lo8(49)
 3192 03c8 00D0      		rcall USART_Transmit
 3193               	.LVL304:
 3194 03ca 0C5F      		subi r16,-4
 3195 03cc 1F4F      		sbci r17,-1
 382:main.c        **** 				usart_read_chars(); // Address
 3196               		.loc 3 382 0 discriminator 3
 3197 03ce F0E0      		ldi r31,hi8(flashWriteCycle+12)
 3198 03d0 0030      		cpi r16,lo8(flashWriteCycle+12)
 3199 03d2 1F07      		cpc r17,r31
 3200 03d4 01F4      		brne .L138
 3201 03d6 00C0      		rjmp .L93
 3202               	.LVL305:
 3203               	.L137:
 3204               	.LBE162:
 390:main.c        **** 			}
 391:main.c        **** 		}
 392:main.c        **** 		
 393:main.c        **** 		// Write address and one byte to Flash, pulse a pin
 394:main.c        **** 		else if (receivedChar == GB_FLASH_WRITE_BYTE) {
 3205               		.loc 3 394 0
 3206 03d8 9634      		cpi r25,lo8(70)
 3207 03da 01F4      		brne .L139
 3208               	.LBB163:
 395:main.c        **** 			usart_read_chars(); // Read address
 3209               		.loc 3 395 0
 3210 03dc 00D0      		rcall usart_read_chars
 3211               	.LVL306:
 396:main.c        **** 			uint16_t flashAddress = strtol(receivedBuffer, NULL, 16);
 3212               		.loc 3 396 0
 3213 03de 40E1      		ldi r20,lo8(16)
 3214 03e0 50E0      		ldi r21,0
 3215 03e2 60E0      		ldi r22,0
 3216 03e4 70E0      		ldi r23,0
 3217 03e6 80E0      		ldi r24,lo8(receivedBuffer)
 3218 03e8 90E0      		ldi r25,hi8(receivedBuffer)
 3219 03ea 00D0      		rcall strtol
 3220               	.LVL307:
 3221 03ec 4B01      		movw r8,r22
 3222 03ee 5C01      		movw r10,r24
 3223               	.LVL308:
 397:main.c        **** 			
 398:main.c        **** 			usart_read_chars(); // Read data byte
 3224               		.loc 3 398 0
 3225 03f0 00D0      		rcall usart_read_chars
 3226               	.LVL309:
 399:main.c        **** 			uint8_t flashByte = strtol(receivedBuffer, NULL, 16);
 3227               		.loc 3 399 0
 3228 03f2 40E1      		ldi r20,lo8(16)
 3229 03f4 50E0      		ldi r21,0
 3230 03f6 60E0      		ldi r22,0
 3231 03f8 70E0      		ldi r23,0
 3232 03fa 80E0      		ldi r24,lo8(receivedBuffer)
 3233 03fc 90E0      		ldi r25,hi8(receivedBuffer)
 3234 03fe 00D0      		rcall strtol
 3235               	.LVL310:
 400:main.c        **** 			
 401:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 3236               		.loc 3 401 0
 3237 0400 939A      		sbi 0x12,3
 402:main.c        **** 			gb_flash_write_bus_cycle(flashAddress, flashByte);
 3238               		.loc 3 402 0
 3239 0402 C401      		movw r24,r8
 3240 0404 00D0      		rcall gb_flash_write_bus_cycle
 3241               	.LVL311:
 3242 0406 00C0      		rjmp .L248
 3243               	.LVL312:
 3244               	.L139:
 3245               	.LBE163:
 403:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 404:main.c        **** 			
 405:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 406:main.c        **** 		}
 407:main.c        **** 		
 408:main.c        **** 		// Write 64 bytes to Flash address one byte write at a time (and increment), pulse a pin
 409:main.c        **** 		else if (receivedChar == GB_FLASH_WRITE_64BYTE) {
 3246               		.loc 3 409 0
 3247 0408 9435      		cpi r25,lo8(84)
 3248 040a 01F4      		brne .L140
 410:main.c        **** 			usart_read_bytes(64);
 3249               		.loc 3 410 0
 3250 040c 80E4      		ldi r24,lo8(64)
 3251 040e 90E0      		ldi r25,0
 3252               	.LVL313:
 3253 0410 00D0      		rcall usart_read_bytes
 3254               	.LVL314:
 411:main.c        **** 			
 412:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 3255               		.loc 3 412 0
 3256 0412 939A      		sbi 0x12,3
 3257               	.LVL315:
 3258 0414 60E0      		ldi r22,lo8(receivedBuffer)
 3259 0416 A62E      		mov r10,r22
 3260 0418 60E0      		ldi r22,hi8(receivedBuffer)
 3261 041a B62E      		mov r11,r22
 3262 041c 70E4      		ldi r23,lo8(64)
 3263 041e 972E      		mov r9,r23
 3264 0420 8601      		movw r16,r12
 3265 0422 0050      		subi r16,lo8(receivedBuffer)
 3266 0424 1040      		sbci r17,hi8(receivedBuffer)
 3267               	.LVL316:
 3268               	.L143:
 3269               	.LBB164:
 413:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 414:main.c        **** 				if (flashBank1CommandWrites == 0) {
 3270               		.loc 3 414 0
 3271 0426 8091 0000 		lds r24,flashBank1CommandWrites
 415:main.c        **** 					gb_flash_write_byte(address, receivedBuffer[x]);
 3272               		.loc 3 415 0
 3273 042a F501      		movw r30,r10
 3274 042c 6081      		ld r22,Z
 414:main.c        **** 					gb_flash_write_byte(address, receivedBuffer[x]);
 3275               		.loc 3 414 0
 3276 042e 8111      		cpse r24,__zero_reg__
 3277 0430 00C0      		rjmp .L141
 3278               		.loc 3 415 0
 3279 0432 C801      		movw r24,r16
 3280 0434 8A0D      		add r24,r10
 3281 0436 9B1D      		adc r25,r11
 3282 0438 00D0      		rcall gb_flash_write_byte
 3283               	.LVL317:
 3284 043a 00C0      		rjmp .L142
 3285               	.L141:
 416:main.c        **** 				}
 417:main.c        **** 				else { // Some flash carts need to change to bank 1 to issue flash commands
 418:main.c        **** 					gb_flash_write_byte_bank1_commands(address, receivedBuffer[x]);
 3286               		.loc 3 418 0
 3287 043c C801      		movw r24,r16
 3288 043e 8A0D      		add r24,r10
 3289 0440 9B1D      		adc r25,r11
 3290 0442 00D0      		rcall gb_flash_write_byte_bank1_commands
 3291               	.LVL318:
 3292               	.L142:
 3293 0444 9A94      		dec r9
 3294 0446 FFEF      		ldi r31,-1
 3295 0448 AF1A      		sub r10,r31
 3296 044a BF0A      		sbc r11,r31
 3297               	.LVL319:
 413:main.c        **** 				if (flashBank1CommandWrites == 0) {
 3298               		.loc 3 413 0 discriminator 2
 3299 044c 9110      		cpse r9,__zero_reg__
 3300 044e 00C0      		rjmp .L143
 3301 0450 20E4      		ldi r18,64
 3302 0452 C20E      		add r12,r18
 3303 0454 D11C      		adc r13,__zero_reg__
 3304 0456 E11C      		adc r14,__zero_reg__
 3305 0458 F11C      		adc r15,__zero_reg__
 3306 045a 00C0      		rjmp .L237
 3307               	.LVL320:
 3308               	.L140:
 3309               	.LBE164:
 419:main.c        **** 				}
 420:main.c        **** 				address++;
 421:main.c        **** 			}
 422:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 423:main.c        **** 			
 424:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 425:main.c        **** 		}
 426:main.c        **** 		
 427:main.c        **** 		// Buffered programming, write 32 bytes to Flash address
 428:main.c        **** 		else if (receivedChar == GB_FLASH_WRITE_BUFFERED_32BYTE) {
 3310               		.loc 3 428 0
 3311 045c 9935      		cpi r25,lo8(89)
 3312 045e 01F0      		breq .+2
 3313 0460 00C0      		rjmp .L144
 3314               	.LBB165:
 429:main.c        **** 			usart_read_bytes(32);
 3315               		.loc 3 429 0
 3316 0462 80E2      		ldi r24,lo8(32)
 3317 0464 90E0      		ldi r25,0
 3318               	.LVL321:
 3319 0466 00D0      		rcall usart_read_bytes
 3320               	.LVL322:
 430:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 3321               		.loc 3 430 0
 3322 0468 939A      		sbi 0x12,3
 431:main.c        **** 			
 432:main.c        **** 			// Setup buffered write
 433:main.c        **** 			gb_flash_write_bus_cycle(0xAAA, 0xAA);
 3323               		.loc 3 433 0
 3324 046a 6AEA      		ldi r22,lo8(-86)
 3325 046c 8AEA      		ldi r24,lo8(-86)
 3326 046e 9AE0      		ldi r25,lo8(10)
 3327 0470 00D0      		rcall gb_flash_write_bus_cycle
 3328               	.LVL323:
 434:main.c        **** 			gb_flash_write_bus_cycle(0x555, 0x55);
 3329               		.loc 3 434 0
 3330 0472 65E5      		ldi r22,lo8(85)
 3331 0474 85E5      		ldi r24,lo8(85)
 3332 0476 95E0      		ldi r25,lo8(5)
 3333 0478 00D0      		rcall gb_flash_write_bus_cycle
 3334               	.LVL324:
 435:main.c        **** 			gb_flash_write_bus_cycle(address, 0x25);
 3335               		.loc 3 435 0
 3336 047a 5601      		movw r10,r12
 3337 047c 65E2      		ldi r22,lo8(37)
 3338 047e C601      		movw r24,r12
 3339 0480 00D0      		rcall gb_flash_write_bus_cycle
 3340               	.LVL325:
 436:main.c        **** 			gb_flash_write_bus_cycle(address, 0x1F); // Length
 3341               		.loc 3 436 0
 3342 0482 6FE1      		ldi r22,lo8(31)
 3343 0484 C601      		movw r24,r12
 3344 0486 00D0      		rcall gb_flash_write_bus_cycle
 3345               	.LVL326:
 3346               	.LBB166:
 3347               	.LBB167:
 3348               		.loc 2 276 0
 3349 0488 82E0      		ldi r24,lo8(2)
 3350 048a 8A95      	1:	dec r24
 3351 048c 01F4      		brne 1b
 3352 048e 00C0      		rjmp .
 3353               	.LVL327:
 3354 0490 00E0      		ldi r16,lo8(receivedBuffer)
 3355 0492 10E0      		ldi r17,hi8(receivedBuffer)
 3356 0494 812C      		mov r8,__zero_reg__
 3357 0496 912C      		mov r9,__zero_reg__
 3358               	.LVL328:
 3359               	.L145:
 3360               	.LBE167:
 3361               	.LBE166:
 3362               	.LBB168:
 437:main.c        **** 			_delay_us(1);
 438:main.c        **** 			
 439:main.c        **** 			// Write data
 440:main.c        **** 			for (uint8_t x = 0; x < 32; x++) {
 441:main.c        **** 				gb_flash_write_bus_cycle(address, receivedBuffer[x]);
 3363               		.loc 3 441 0 discriminator 3
 3364 0498 F801      		movw r30,r16
 3365 049a 6191      		ld r22,Z+
 3366 049c 8F01      		movw r16,r30
 3367 049e C401      		movw r24,r8
 3368 04a0 8A0D      		add r24,r10
 3369 04a2 9B1D      		adc r25,r11
 3370 04a4 00D0      		rcall gb_flash_write_bus_cycle
 3371               	.LVL329:
 3372 04a6 FFEF      		ldi r31,-1
 3373 04a8 8F1A      		sub r8,r31
 3374 04aa 9F0A      		sbc r9,r31
 3375               	.LVL330:
 440:main.c        **** 				gb_flash_write_bus_cycle(address, receivedBuffer[x]);
 3376               		.loc 3 440 0 discriminator 3
 3377 04ac 20E2      		ldi r18,32
 3378 04ae 8216      		cp r8,r18
 3379 04b0 9104      		cpc r9,__zero_reg__
 3380 04b2 01F4      		brne .L145
 3381 04b4 80E2      		ldi r24,32
 3382 04b6 C80E      		add r12,r24
 3383 04b8 D11C      		adc r13,__zero_reg__
 3384 04ba E11C      		adc r14,__zero_reg__
 3385 04bc F11C      		adc r15,__zero_reg__
 3386               	.LBE168:
 442:main.c        **** 				address++;
 443:main.c        **** 			}
 444:main.c        **** 			
 445:main.c        **** 			// Write buffer to flash
 446:main.c        **** 			gb_flash_write_bus_cycle(address-32, 0x29);
 3387               		.loc 3 446 0
 3388 04be C601      		movw r24,r12
 3389 04c0 8097      		sbiw r24,32
 3390 04c2 69E2      		ldi r22,lo8(41)
 3391 04c4 00D0      		rcall gb_flash_write_bus_cycle
 3392               	.LVL331:
 3393               	.LBB169:
 3394               	.LBB170:
 3395               		.loc 2 276 0
 3396 04c6 EFE8      		ldi r30,lo8(399)
 3397 04c8 F1E0      		ldi r31,hi8(399)
 3398 04ca 3197      	1:	sbiw r30,1
 3399 04cc 01F4      		brne 1b
 3400 04ce 00C0      		rjmp .
 3401 04d0 0000      		nop
 3402               	.LVL332:
 3403               	.LBE170:
 3404               	.LBE169:
 447:main.c        **** 			_delay_us(200);
 448:main.c        **** 			
 449:main.c        **** 			// Verify last byte written
 450:main.c        **** 			uint8_t dataVerify = gb_flash_read_byte(address-1);
 3405               		.loc 3 450 0
 3406 04d2 8601      		movw r16,r12
 3407 04d4 0150      		subi r16,1
 3408 04d6 1109      		sbc r17,__zero_reg__
 3409 04d8 C801      		movw r24,r16
 3410 04da 00D0      		rcall gb_flash_read_byte
 3411               	.LVL333:
 451:main.c        **** 			uint8_t verifyCount = 0;
 452:main.c        **** 			while (dataVerify != receivedBuffer[31]) {
 3412               		.loc 3 452 0
 3413 04dc 58EC      		ldi r21,lo8(-56)
 3414 04de B52E      		mov r11,r21
 3415               	.LVL334:
 3416               	.L146:
 3417 04e0 9091 0000 		lds r25,receivedBuffer+31
 3418 04e4 8917      		cp r24,r25
 3419 04e6 01F4      		brne .+2
 3420 04e8 00C0      		rjmp .L237
 453:main.c        **** 				dataVerify = gb_flash_read_byte(address-1);
 3421               		.loc 3 453 0
 3422 04ea C801      		movw r24,r16
 3423               	.LVL335:
 3424 04ec 00D0      		rcall gb_flash_read_byte
 3425               	.LVL336:
 3426               	.LBB171:
 3427               	.LBB172:
 3428               		.loc 2 276 0
 3429 04ee FDE0      		ldi r31,lo8(13)
 3430 04f0 FA95      	1:	dec r31
 3431 04f2 01F4      		brne 1b
 3432 04f4 0000      		nop
 3433               	.LVL337:
 3434 04f6 BA94      		dec r11
 3435               	.LVL338:
 3436               	.LBE172:
 3437               	.LBE171:
 454:main.c        **** 				_delay_us(5);
 455:main.c        **** 				verifyCount++;
 456:main.c        **** 				
 457:main.c        **** 				if (verifyCount >= 200) {
 3438               		.loc 3 457 0
 3439 04f8 B110      		cpse r11,__zero_reg__
 3440 04fa 00C0      		rjmp .L146
 3441               	.LVL339:
 3442               	.LBB173:
 3443               	.LBB174:
 187:c:\winavr-20100110\avr\include\util\delay.h **** 
 3444               		.loc 2 187 0
 3445 04fc 2FEF      		ldi r18,lo8(799999)
 3446 04fe 84E3      		ldi r24,hi8(799999)
 3447 0500 9CE0      		ldi r25,hlo8(799999)
 3448 0502 2150      	1:	subi r18,1
 3449 0504 8040      		sbci r24,0
 3450 0506 9040      		sbci r25,0
 3451 0508 01F4      		brne 1b
 3452               	.LVL340:
 3453 050a 00C0      		rjmp .
 3454 050c 0000      		nop
 3455 050e 00C0      		rjmp .L237
 3456               	.LVL341:
 3457               	.L144:
 3458               	.LBE174:
 3459               	.LBE173:
 3460               	.LBE165:
 458:main.c        **** 					_delay_ms(500);
 459:main.c        **** 					break;
 460:main.c        **** 				}
 461:main.c        **** 			}
 462:main.c        **** 			
 463:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 464:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 465:main.c        **** 		}
 466:main.c        **** 		
 467:main.c        **** 		// Buffered programming, write 256 bytes to Flash address
 468:main.c        **** 		else if (receivedChar == GB_FLASH_WRITE_256BYTE) {
 3461               		.loc 3 468 0
 3462 0510 9835      		cpi r25,lo8(88)
 3463 0512 01F0      		breq .+2
 3464 0514 00C0      		rjmp .L149
 3465               	.LBB175:
 469:main.c        **** 			usart_read_bytes(256);
 3466               		.loc 3 469 0
 3467 0516 80E0      		ldi r24,0
 3468 0518 91E0      		ldi r25,lo8(1)
 3469               	.LVL342:
 3470 051a 00D0      		rcall usart_read_bytes
 3471               	.LVL343:
 470:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 3472               		.loc 3 470 0
 3473 051c 939A      		sbi 0x12,3
 471:main.c        **** 			
 472:main.c        **** 			// Setup buffered write
 473:main.c        **** 			gb_flash_write_bus_cycle(0xAAA, 0xA9);
 3474               		.loc 3 473 0
 3475 051e 69EA      		ldi r22,lo8(-87)
 3476 0520 8AEA      		ldi r24,lo8(-86)
 3477 0522 9AE0      		ldi r25,lo8(10)
 3478 0524 00D0      		rcall gb_flash_write_bus_cycle
 3479               	.LVL344:
 474:main.c        **** 			gb_flash_write_bus_cycle(0x555, 0x56);
 3480               		.loc 3 474 0
 3481 0526 66E5      		ldi r22,lo8(86)
 3482 0528 85E5      		ldi r24,lo8(85)
 3483 052a 95E0      		ldi r25,lo8(5)
 3484 052c 00D0      		rcall gb_flash_write_bus_cycle
 3485               	.LVL345:
 475:main.c        **** 			gb_flash_write_bus_cycle(address, 0x26);
 3486               		.loc 3 475 0
 3487 052e 5601      		movw r10,r12
 3488 0530 66E2      		ldi r22,lo8(38)
 3489 0532 C601      		movw r24,r12
 3490 0534 00D0      		rcall gb_flash_write_bus_cycle
 3491               	.LVL346:
 476:main.c        **** 			gb_flash_write_bus_cycle(address, 0xFF); // Length
 3492               		.loc 3 476 0
 3493 0536 6FEF      		ldi r22,lo8(-1)
 3494 0538 C601      		movw r24,r12
 3495 053a 00D0      		rcall gb_flash_write_bus_cycle
 3496               	.LVL347:
 3497               	.LBB176:
 3498               	.LBB177:
 3499               		.loc 2 276 0
 3500 053c E5E8      		ldi r30,lo8(-123)
 3501 053e EA95      	1:	dec r30
 3502 0540 01F4      		brne 1b
 3503 0542 0000      		nop
 3504               	.LVL348:
 3505 0544 00E0      		ldi r16,lo8(receivedBuffer)
 3506 0546 10E0      		ldi r17,hi8(receivedBuffer)
 3507               	.LBE177:
 3508               	.LBE176:
 3509               	.LBB178:
 477:main.c        **** 			_delay_us(50);
 478:main.c        **** 			
 479:main.c        **** 			// Write data
 480:main.c        **** 			for (int x = 0; x < 256; x++) {
 3510               		.loc 3 480 0
 3511 0548 812C      		mov r8,__zero_reg__
 3512 054a 912C      		mov r9,__zero_reg__
 3513               	.LVL349:
 3514               	.L150:
 481:main.c        **** 				gb_flash_write_bus_cycle(address, receivedBuffer[x]);
 3515               		.loc 3 481 0 discriminator 3
 3516 054c F801      		movw r30,r16
 3517 054e 6191      		ld r22,Z+
 3518 0550 8F01      		movw r16,r30
 3519 0552 C401      		movw r24,r8
 3520 0554 8A0D      		add r24,r10
 3521 0556 9B1D      		adc r25,r11
 3522 0558 00D0      		rcall gb_flash_write_bus_cycle
 3523               	.LVL350:
 480:main.c        **** 				gb_flash_write_bus_cycle(address, receivedBuffer[x]);
 3524               		.loc 3 480 0 discriminator 3
 3525 055a FFEF      		ldi r31,-1
 3526 055c 8F1A      		sub r8,r31
 3527 055e 9F0A      		sbc r9,r31
 3528               	.LVL351:
 3529 0560 8114      		cp r8,__zero_reg__
 3530 0562 21E0      		ldi r18,1
 3531 0564 9206      		cpc r9,r18
 3532 0566 01F4      		brne .L150
 3533 0568 8FEF      		ldi r24,-1
 3534 056a D81A      		sub r13,r24
 3535 056c E80A      		sbc r14,r24
 3536 056e F80A      		sbc r15,r24
 3537               	.LBE178:
 482:main.c        **** 				address++;
 483:main.c        **** 			}
 484:main.c        **** 			
 485:main.c        **** 			// Write buffer to flash
 486:main.c        **** 			gb_flash_write_bus_cycle(address-256, 0x2A);
 3538               		.loc 3 486 0
 3539 0570 C601      		movw r24,r12
 3540 0572 9A95      		dec r25
 3541 0574 6AE2      		ldi r22,lo8(42)
 3542 0576 00D0      		rcall gb_flash_write_bus_cycle
 3543               	.LVL352:
 487:main.c        **** 			
 488:main.c        **** 			// Verify last byte written
 489:main.c        **** 			uint8_t dataVerify = gb_flash_read_byte(address-1);
 3544               		.loc 3 489 0
 3545 0578 8601      		movw r16,r12
 3546 057a 0150      		subi r16,1
 3547 057c 1109      		sbc r17,__zero_reg__
 3548 057e C801      		movw r24,r16
 3549 0580 00D0      		rcall gb_flash_read_byte
 3550               	.LVL353:
 3551               	.L151:
 490:main.c        **** 			while (dataVerify != receivedBuffer[255]) {
 3552               		.loc 3 490 0
 3553 0582 9091 0000 		lds r25,receivedBuffer+255
 3554 0586 8917      		cp r24,r25
 3555 0588 01F4      		brne .+2
 3556 058a 00C0      		rjmp .L237
 491:main.c        **** 				dataVerify = gb_flash_read_byte(address-1);
 3557               		.loc 3 491 0
 3558 058c C801      		movw r24,r16
 3559               	.LVL354:
 3560 058e 00D0      		rcall gb_flash_read_byte
 3561               	.LVL355:
 3562               	.LBB179:
 3563               	.LBB180:
 3564               		.loc 2 276 0
 3565 0590 9DE0      		ldi r25,lo8(13)
 3566 0592 9A95      	1:	dec r25
 3567 0594 01F4      		brne 1b
 3568 0596 0000      		nop
 3569 0598 00C0      		rjmp .L151
 3570               	.LVL356:
 3571               	.L149:
 3572               	.LBE180:
 3573               	.LBE179:
 3574               	.LBE175:
 492:main.c        **** 				_delay_us(5);
 493:main.c        **** 			}
 494:main.c        **** 			
 495:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 496:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 497:main.c        **** 		}
 498:main.c        **** 		
 499:main.c        **** 		
 500:main.c        **** 		// ---------- GBA FLASH CARTS ----------
 501:main.c        **** 		// Write 24 bit address, 16 bit data and pulse a pin
 502:main.c        **** 		else if (receivedChar == GBA_FLASH_CART_WRITE_BYTE) {
 3575               		.loc 3 502 0
 3576 059a 9E36      		cpi r25,lo8(110)
 3577 059c 01F4      		brne .L153
 3578               	.LBB181:
 503:main.c        **** 			usart_read_chars(); // Read address
 3579               		.loc 3 503 0
 3580 059e 00D0      		rcall usart_read_chars
 3581               	.LVL357:
 504:main.c        **** 			uint32_t flashAddress = strtol(receivedBuffer, NULL, 16); // Convert address string in hex to de
 3582               		.loc 3 504 0
 3583 05a0 40E1      		ldi r20,lo8(16)
 3584 05a2 50E0      		ldi r21,0
 3585 05a4 60E0      		ldi r22,0
 3586 05a6 70E0      		ldi r23,0
 3587 05a8 80E0      		ldi r24,lo8(receivedBuffer)
 3588 05aa 90E0      		ldi r25,hi8(receivedBuffer)
 3589 05ac 00D0      		rcall strtol
 3590               	.LVL358:
 3591 05ae 4B01      		movw r8,r22
 3592 05b0 5C01      		movw r10,r24
 3593               	.LVL359:
 505:main.c        **** 			
 506:main.c        **** 			receivedChar = USART_Receive(); // Wait for byte
 3594               		.loc 3 506 0
 3595 05b2 00D0      		rcall USART_Receive
 3596               	.LVL360:
 3597 05b4 8093 0000 		sts receivedChar,r24
 507:main.c        **** 			if (receivedChar == GBA_FLASH_CART_WRITE_BYTE) {
 3598               		.loc 3 507 0
 3599 05b8 8E36      		cpi r24,lo8(110)
 3600 05ba 01F0      		breq .+2
 3601 05bc 00C0      		rjmp .L93
 3602               	.LBB182:
 508:main.c        **** 				usart_read_chars(); // Read data
 3603               		.loc 3 508 0
 3604 05be 00D0      		rcall usart_read_chars
 3605               	.LVL361:
 509:main.c        **** 				uint16_t flashByte = strtol(receivedBuffer, NULL, 16); // Convert data byte in hex to dec
 3606               		.loc 3 509 0
 3607 05c0 40E1      		ldi r20,lo8(16)
 3608 05c2 50E0      		ldi r21,0
 3609 05c4 60E0      		ldi r22,0
 3610 05c6 70E0      		ldi r23,0
 3611 05c8 80E0      		ldi r24,lo8(receivedBuffer)
 3612 05ca 90E0      		ldi r25,hi8(receivedBuffer)
 3613 05cc 00D0      		rcall strtol
 3614               	.LVL362:
 510:main.c        **** 				
 511:main.c        **** 				PORTD |= (1<<ACTIVITY_LED);
 3615               		.loc 3 511 0
 3616 05ce 939A      		sbi 0x12,3
 512:main.c        **** 				GBA_DDR_ROM_ADDR23_16 = 0xFF;
 3617               		.loc 3 512 0
 3618 05d0 EFEF      		ldi r30,lo8(-1)
 3619 05d2 E4BB      		out 0x14,r30
 513:main.c        **** 				GBA_DDR_ROM_ADDR15_8 = 0xFF;
 3620               		.loc 3 513 0
 3621 05d4 EABB      		out 0x1a,r30
 514:main.c        **** 				GBA_DDR_ROM_ADDR7_0 = 0xFF;
 3622               		.loc 3 514 0
 3623 05d6 E7BB      		out 0x17,r30
 515:main.c        **** 				gba_flash_write_bus_cycle(flashAddress, flashByte);
 3624               		.loc 3 515 0
 3625 05d8 AB01      		movw r20,r22
 3626 05da C501      		movw r24,r10
 3627 05dc B401      		movw r22,r8
 3628               	.LVL363:
 3629 05de 00D0      		rcall gba_flash_write_bus_cycle
 3630               	.LVL364:
 3631               	.L248:
 516:main.c        **** 				PORTD &= ~(1<<ACTIVITY_LED);
 3632               		.loc 3 516 0
 3633 05e0 9398      		cbi 0x12,3
 517:main.c        **** 				
 518:main.c        **** 				USART_Transmit(SEND_ACK); // Send back acknowledgement
 3634               		.loc 3 518 0
 3635 05e2 81E3      		ldi r24,lo8(49)
 3636 05e4 00C0      		rjmp .L228
 3637               	.LVL365:
 3638               	.L153:
 3639               	.LBE182:
 3640               	.LBE181:
 519:main.c        **** 			}
 520:main.c        **** 		}
 521:main.c        **** 		
 522:main.c        **** 		// Write 64 or 256 bytes to Flash address (swapped command data bytes), combine 2 bytes and write
 523:main.c        **** 		else if (receivedChar == GBA_FLASH_WRITE_64BYTE_SWAPPED_D0D1 || receivedChar == GBA_FLASH_WRITE_2
 3641               		.loc 3 523 0
 3642 05e6 9137      		cpi r25,lo8(113)
 3643 05e8 01F0      		breq .L154
 3644               		.loc 3 523 0 is_stmt 0 discriminator 1
 3645 05ea 9437      		cpi r25,lo8(116)
 3646 05ec 01F4      		brne .L155
 3647               	.L154:
 3648               	.LBB183:
 524:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 3649               		.loc 3 524 0 is_stmt 1
 3650 05ee 939A      		sbi 0x12,3
 3651               	.LVL366:
 525:main.c        **** 			
 526:main.c        **** 			int readLength = 64;
 527:main.c        **** 			if (receivedChar == GBA_FLASH_WRITE_256BYTE_SWAPPED_D0D1) {
 3652               		.loc 3 527 0
 3653 05f0 8091 0000 		lds r24,receivedChar
 3654               	.LVL367:
 3655 05f4 8437      		cpi r24,lo8(116)
 3656 05f6 01F4      		brne .L200
 528:main.c        **** 				readLength = 256;
 3657               		.loc 3 528 0
 3658 05f8 00E0      		ldi r16,0
 3659 05fa 11E0      		ldi r17,lo8(1)
 3660 05fc 00C0      		rjmp .L156
 3661               	.L200:
 526:main.c        **** 			if (receivedChar == GBA_FLASH_WRITE_256BYTE_SWAPPED_D0D1) {
 3662               		.loc 3 526 0
 3663 05fe 00E4      		ldi r16,lo8(64)
 3664 0600 10E0      		ldi r17,0
 3665               	.L156:
 3666               	.LVL368:
 529:main.c        **** 			}
 530:main.c        **** 			usart_read_bytes(readLength);
 3667               		.loc 3 530 0
 3668 0602 C801      		movw r24,r16
 3669 0604 00D0      		rcall usart_read_bytes
 3670               	.LVL369:
 3671 0606 40E0      		ldi r20,lo8(receivedBuffer)
 3672 0608 A42E      		mov r10,r20
 3673 060a 40E0      		ldi r20,hi8(receivedBuffer)
 3674 060c B42E      		mov r11,r20
 3675 060e 2601      		movw r4,r12
 3676 0610 3701      		movw r6,r14
 3677               	.LVL370:
 3678               	.L157:
 3679               	.LBB184:
 3680               	.LBB185:
 531:main.c        **** 			
 532:main.c        **** 			for (int x = 0; x < readLength; x += 2) {
 533:main.c        **** 				uint16_t combinedBytes = (uint16_t) receivedBuffer[x+1] << 8 | (uint16_t) receivedBuffer[x];
 534:main.c        **** 				gba_flash_write_byte(address, combinedBytes, D0D1_SWAPPED);
 3681               		.loc 3 534 0 discriminator 3
 3682 0612 F501      		movw r30,r10
 3683 0614 4181      		ldd r20,Z+1
 3684 0616 50E0      		ldi r21,0
 3685 0618 542F      		mov r21,r20
 3686 061a 4427      		clr r20
 3687 061c 8081      		ld r24,Z
 3688 061e 482B      		or r20,r24
 3689 0620 21E0      		ldi r18,lo8(1)
 3690 0622 C301      		movw r24,r6
 3691 0624 B201      		movw r22,r4
 3692 0626 00D0      		rcall gba_flash_write_byte
 3693               	.LVL371:
 535:main.c        **** 				address++;
 3694               		.loc 3 535 0 discriminator 3
 3695 0628 FFEF      		ldi r31,-1
 3696 062a 4F1A      		sub r4,r31
 3697 062c 5F0A      		sbc r5,r31
 3698 062e 6F0A      		sbc r6,r31
 3699 0630 7F0A      		sbc r7,r31
 3700               	.LVL372:
 3701 0632 22E0      		ldi r18,2
 3702 0634 A20E      		add r10,r18
 3703 0636 B11C      		adc r11,__zero_reg__
 3704               	.LVL373:
 3705               	.LBE185:
 532:main.c        **** 				uint16_t combinedBytes = (uint16_t) receivedBuffer[x+1] << 8 | (uint16_t) receivedBuffer[x];
 3706               		.loc 3 532 0 discriminator 3
 3707 0638 C501      		movw r24,r10
 3708 063a 8050      		subi r24,lo8(receivedBuffer)
 3709 063c 9040      		sbci r25,hi8(receivedBuffer)
 3710 063e 8017      		cp r24,r16
 3711 0640 9107      		cpc r25,r17
 3712 0642 04F0      		brlt .L157
 3713 0644 8FEF      		ldi r24,-1
 3714 0646 C81A      		sub r12,r24
 3715 0648 D80A      		sbc r13,r24
 3716 064a E80A      		sbc r14,r24
 3717 064c F80A      		sbc r15,r24
 3718 064e 0150      		subi r16,1
 3719 0650 1109      		sbc r17,__zero_reg__
 3720               	.LVL374:
 3721 0652 1695      		lsr r17
 3722 0654 0795      		ror r16
 3723               	.LVL375:
 3724 0656 C00E      		add r12,r16
 3725 0658 D11E      		adc r13,r17
 3726 065a E11C      		adc r14,__zero_reg__
 3727 065c F11C      		adc r15,__zero_reg__
 3728 065e 00C0      		rjmp .L237
 3729               	.LVL376:
 3730               	.L155:
 3731               	.LBE184:
 3732               	.LBE183:
 536:main.c        **** 			}
 537:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 538:main.c        **** 			
 539:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 540:main.c        **** 		}
 541:main.c        **** 		
 542:main.c        **** 		// Write 256 bytes to Flash address, combine 2 bytes and write one at a time (and increment addre
 543:main.c        **** 		else if (receivedChar == GBA_FLASH_WRITE_256BYTE) {
 3733               		.loc 3 543 0
 3734 0660 9636      		cpi r25,lo8(102)
 3735 0662 01F4      		brne .L158
 3736               	.LBB186:
 544:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 3737               		.loc 3 544 0
 3738 0664 939A      		sbi 0x12,3
 3739               	.LVL377:
 545:main.c        **** 			
 546:main.c        **** 			int readLength = 256;
 547:main.c        **** 			usart_read_bytes(readLength);
 3740               		.loc 3 547 0
 3741 0666 80E0      		ldi r24,0
 3742 0668 91E0      		ldi r25,lo8(1)
 3743               	.LVL378:
 3744 066a 00D0      		rcall usart_read_bytes
 3745               	.LVL379:
 3746 066c 00E0      		ldi r16,lo8(receivedBuffer)
 3747 066e 10E0      		ldi r17,hi8(receivedBuffer)
 3748 0670 4601      		movw r8,r12
 3749 0672 5701      		movw r10,r14
 3750               	.LVL380:
 3751               	.L159:
 3752               	.LBB187:
 3753               	.LBB188:
 548:main.c        **** 			
 549:main.c        **** 			for (int x = 0; x < readLength; x += 2) {
 550:main.c        **** 				uint16_t combinedBytes = (uint16_t) receivedBuffer[x+1] << 8 | (uint16_t) receivedBuffer[x];
 551:main.c        **** 				gba_flash_write_byte(address, combinedBytes, D0D1_NOT_SWAPPED);
 3754               		.loc 3 551 0 discriminator 3
 3755 0674 F801      		movw r30,r16
 3756 0676 4181      		ldd r20,Z+1
 3757 0678 50E0      		ldi r21,0
 3758 067a 542F      		mov r21,r20
 3759 067c 4427      		clr r20
 3760 067e 8081      		ld r24,Z
 3761 0680 482B      		or r20,r24
 3762 0682 20E0      		ldi r18,0
 3763 0684 C501      		movw r24,r10
 3764 0686 B401      		movw r22,r8
 3765 0688 00D0      		rcall gba_flash_write_byte
 3766               	.LVL381:
 552:main.c        **** 				address++;
 3767               		.loc 3 552 0 discriminator 3
 3768 068a FFEF      		ldi r31,-1
 3769 068c 8F1A      		sub r8,r31
 3770 068e 9F0A      		sbc r9,r31
 3771 0690 AF0A      		sbc r10,r31
 3772 0692 BF0A      		sbc r11,r31
 3773               	.LVL382:
 3774 0694 0E5F      		subi r16,-2
 3775 0696 1F4F      		sbci r17,-1
 3776               	.LVL383:
 3777               	.LBE188:
 549:main.c        **** 				uint16_t combinedBytes = (uint16_t) receivedBuffer[x+1] << 8 | (uint16_t) receivedBuffer[x];
 3778               		.loc 3 549 0 discriminator 3
 3779 0698 20E0      		ldi r18,hi8(receivedBuffer+256)
 3780 069a 0030      		cpi r16,lo8(receivedBuffer+256)
 3781 069c 1207      		cpc r17,r18
 3782 069e 01F4      		brne .L159
 3783 06a0 80E8      		ldi r24,-128
 3784 06a2 C80E      		add r12,r24
 3785 06a4 D11C      		adc r13,__zero_reg__
 3786 06a6 E11C      		adc r14,__zero_reg__
 3787 06a8 F11C      		adc r15,__zero_reg__
 3788 06aa 00C0      		rjmp .L237
 3789               	.LVL384:
 3790               	.L158:
 3791               	.LBE187:
 3792               	.LBE186:
 553:main.c        **** 			}
 554:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 555:main.c        **** 			
 556:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 557:main.c        **** 		}
 558:main.c        **** 		
 559:main.c        **** 		// Intel flash command based chips
 560:main.c        **** 		// Write 64 bytes to Flash address, combine 2 bytes and write one at a time (and increment addres
 561:main.c        **** 		else if (receivedChar == GBA_FLASH_WRITE_INTEL_64BYTE) {
 3793               		.loc 3 561 0
 3794 06ac 9C36      		cpi r25,lo8(108)
 3795 06ae 01F0      		breq .+2
 3796 06b0 00C0      		rjmp .L160
 3797               	.LBB189:
 562:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 3798               		.loc 3 562 0
 3799 06b2 939A      		sbi 0x12,3
 563:main.c        **** 			usart_read_bytes(64);
 3800               		.loc 3 563 0
 3801 06b4 80E4      		ldi r24,lo8(64)
 3802 06b6 90E0      		ldi r25,0
 3803               	.LVL385:
 3804 06b8 00D0      		rcall usart_read_bytes
 3805               	.LVL386:
 564:main.c        **** 			
 565:main.c        **** 			// Set address lines as outputs
 566:main.c        **** 			GBA_DDR_ROM_ADDR23_16 = 0xFF;
 3806               		.loc 3 566 0
 3807 06ba 9FEF      		ldi r25,lo8(-1)
 3808 06bc 94BB      		out 0x14,r25
 567:main.c        **** 			GBA_DDR_ROM_ADDR15_8 = 0xFF;
 3809               		.loc 3 567 0
 3810 06be 9ABB      		out 0x1a,r25
 568:main.c        **** 			GBA_DDR_ROM_ADDR7_0 = 0xFF;
 3811               		.loc 3 568 0
 3812 06c0 97BB      		out 0x17,r25
 569:main.c        **** 			
 570:main.c        **** 			// Unlock
 571:main.c        **** 			gba_flash_write_bus_cycle(address, 0x60);
 3813               		.loc 3 571 0
 3814 06c2 40E6      		ldi r20,lo8(96)
 3815 06c4 50E0      		ldi r21,0
 3816 06c6 C701      		movw r24,r14
 3817 06c8 B601      		movw r22,r12
 3818 06ca 00D0      		rcall gba_flash_write_bus_cycle
 3819               	.LVL387:
 572:main.c        **** 			gba_flash_write_bus_cycle(address, 0xD0);
 3820               		.loc 3 572 0
 3821 06cc 40ED      		ldi r20,lo8(-48)
 3822 06ce 50E0      		ldi r21,0
 3823 06d0 C701      		movw r24,r14
 3824 06d2 B601      		movw r22,r12
 3825 06d4 00D0      		rcall gba_flash_write_bus_cycle
 3826               	.LVL388:
 573:main.c        **** 			
 574:main.c        **** 			// Buffered write command
 575:main.c        **** 			gba_flash_write_bus_cycle(address, 0xE8);
 3827               		.loc 3 575 0
 3828 06d6 48EE      		ldi r20,lo8(-24)
 3829 06d8 50E0      		ldi r21,0
 3830 06da C701      		movw r24,r14
 3831 06dc B601      		movw r22,r12
 3832 06de 00D0      		rcall gba_flash_write_bus_cycle
 3833               	.LVL389:
 3834               	.LBB190:
 3835               	.LBB191:
 3836               		.loc 2 276 0
 3837 06e0 E5E8      		ldi r30,lo8(-123)
 3838 06e2 EA95      	1:	dec r30
 3839 06e4 01F4      		brne 1b
 3840 06e6 0000      		nop
 3841               	.LVL390:
 3842               	.LBE191:
 3843               	.LBE190:
 576:main.c        **** 			_delay_us(50);
 577:main.c        **** 			
 578:main.c        **** 			// Wait for first 2 bytes to be 0x80, 0x00
 579:main.c        **** 			uint16_t dataVerify = gba_read_16bit_data(address);
 3844               		.loc 3 579 0
 3845 06e8 C701      		movw r24,r14
 3846 06ea B601      		movw r22,r12
 3847 06ec 00D0      		rcall gba_read_16bit_data
 3848               	.LVL391:
 3849               	.L161:
 580:main.c        **** 			while (dataVerify != 0x0080) {
 3850               		.loc 3 580 0
 3851 06ee 8038      		cpi r24,-128
 3852 06f0 9105      		cpc r25,__zero_reg__
 3853 06f2 01F0      		breq .L249
 581:main.c        **** 				dataVerify = gba_read_16bit_data(address);
 3854               		.loc 3 581 0
 3855 06f4 C701      		movw r24,r14
 3856 06f6 B601      		movw r22,r12
 3857 06f8 00D0      		rcall gba_read_16bit_data
 3858               	.LVL392:
 3859               	.LBB192:
 3860               	.LBB193:
 3861               		.loc 2 276 0
 3862 06fa F5E8      		ldi r31,lo8(-123)
 3863 06fc FA95      	1:	dec r31
 3864 06fe 01F4      		brne 1b
 3865 0700 0000      		nop
 3866 0702 00C0      		rjmp .L161
 3867               	.LVL393:
 3868               	.L249:
 3869               	.LBE193:
 3870               	.LBE192:
 582:main.c        **** 				_delay_us(50);
 583:main.c        **** 			}
 584:main.c        **** 			
 585:main.c        **** 			
 586:main.c        **** 			// Set address lines as outputs
 587:main.c        **** 			GBA_DDR_ROM_ADDR23_16 = 0xFF;
 3871               		.loc 3 587 0
 3872 0704 2FEF      		ldi r18,lo8(-1)
 3873 0706 24BB      		out 0x14,r18
 588:main.c        **** 			GBA_DDR_ROM_ADDR15_8 = 0xFF;
 3874               		.loc 3 588 0
 3875 0708 2ABB      		out 0x1a,r18
 589:main.c        **** 			GBA_DDR_ROM_ADDR7_0 = 0xFF;
 3876               		.loc 3 589 0
 3877 070a 27BB      		out 0x17,r18
 590:main.c        **** 			
 591:main.c        **** 			// Set length
 592:main.c        **** 			gba_flash_write_bus_cycle(address, 0x1F);
 3878               		.loc 3 592 0
 3879 070c 4FE1      		ldi r20,lo8(31)
 3880 070e 50E0      		ldi r21,0
 3881 0710 C701      		movw r24,r14
 3882 0712 B601      		movw r22,r12
 3883 0714 00D0      		rcall gba_flash_write_bus_cycle
 3884               	.LVL394:
 3885 0716 00E0      		ldi r16,lo8(receivedBuffer)
 3886 0718 10E0      		ldi r17,hi8(receivedBuffer)
 3887 071a 4601      		movw r8,r12
 3888 071c 5701      		movw r10,r14
 3889               	.LVL395:
 3890               	.L163:
 3891               	.LBB194:
 3892               	.LBB195:
 593:main.c        **** 			
 594:main.c        **** 			// Write data
 595:main.c        **** 			for (int x = 0; x < 64; x += 2) {
 596:main.c        **** 				uint16_t combinedBytes = (uint16_t) receivedBuffer[x+1] << 8 | (uint16_t) receivedBuffer[x];
 597:main.c        **** 				gba_flash_write_bus_cycle(address, combinedBytes);
 3893               		.loc 3 597 0 discriminator 3
 3894 071e F801      		movw r30,r16
 3895 0720 4181      		ldd r20,Z+1
 3896 0722 50E0      		ldi r21,0
 3897 0724 542F      		mov r21,r20
 3898 0726 4427      		clr r20
 3899 0728 8081      		ld r24,Z
 3900 072a 482B      		or r20,r24
 3901 072c C501      		movw r24,r10
 3902 072e B401      		movw r22,r8
 3903 0730 00D0      		rcall gba_flash_write_bus_cycle
 3904               	.LVL396:
 598:main.c        **** 				address++;
 3905               		.loc 3 598 0 discriminator 3
 3906 0732 FFEF      		ldi r31,-1
 3907 0734 8F1A      		sub r8,r31
 3908 0736 9F0A      		sbc r9,r31
 3909 0738 AF0A      		sbc r10,r31
 3910 073a BF0A      		sbc r11,r31
 3911               	.LVL397:
 3912 073c 0E5F      		subi r16,-2
 3913 073e 1F4F      		sbci r17,-1
 3914               	.LVL398:
 3915               	.LBE195:
 595:main.c        **** 				uint16_t combinedBytes = (uint16_t) receivedBuffer[x+1] << 8 | (uint16_t) receivedBuffer[x];
 3916               		.loc 3 595 0 discriminator 3
 3917 0740 20E0      		ldi r18,hi8(receivedBuffer+64)
 3918 0742 0030      		cpi r16,lo8(receivedBuffer+64)
 3919 0744 1207      		cpc r17,r18
 3920 0746 01F4      		brne .L163
 3921 0748 80E2      		ldi r24,32
 3922 074a C80E      		add r12,r24
 3923 074c D11C      		adc r13,__zero_reg__
 3924 074e E11C      		adc r14,__zero_reg__
 3925 0750 F11C      		adc r15,__zero_reg__
 3926               	.LBE194:
 599:main.c        **** 			}
 600:main.c        **** 			
 601:main.c        **** 			// Write buffer to flash
 602:main.c        **** 			gba_flash_write_bus_cycle(address, 0xD0);
 3927               		.loc 3 602 0
 3928 0752 40ED      		ldi r20,lo8(-48)
 3929 0754 50E0      		ldi r21,0
 3930 0756 C701      		movw r24,r14
 3931 0758 B601      		movw r22,r12
 3932 075a 00D0      		rcall gba_flash_write_bus_cycle
 3933               	.LVL399:
 3934               	.LBB196:
 3935               	.LBB197:
 3936               		.loc 2 276 0
 3937 075c EFE6      		ldi r30,lo8(879)
 3938 075e F3E0      		ldi r31,hi8(879)
 3939 0760 3197      	1:	sbiw r30,1
 3940 0762 01F4      		brne 1b
 3941 0764 00C0      		rjmp .
 3942 0766 0000      		nop
 3943               	.LVL400:
 3944               	.LBE197:
 3945               	.LBE196:
 603:main.c        **** 			_delay_us(440);
 604:main.c        **** 			
 605:main.c        **** 			// Wait for first 2 bytes to be 0x80, 0x00
 606:main.c        **** 			dataVerify = gba_read_16bit_data(address);
 3946               		.loc 3 606 0
 3947 0768 C701      		movw r24,r14
 3948 076a B601      		movw r22,r12
 3949 076c 00D0      		rcall gba_read_16bit_data
 3950               	.LVL401:
 3951               	.L164:
 607:main.c        **** 			while (dataVerify != 0x0080) {
 3952               		.loc 3 607 0
 3953 076e 8038      		cpi r24,-128
 3954 0770 9105      		cpc r25,__zero_reg__
 3955 0772 01F0      		breq .L250
 608:main.c        **** 				dataVerify = gba_read_16bit_data(address);
 3956               		.loc 3 608 0
 3957 0774 C701      		movw r24,r14
 3958 0776 B601      		movw r22,r12
 3959 0778 00D0      		rcall gba_read_16bit_data
 3960               	.LVL402:
 3961               	.LBB198:
 3962               	.LBB199:
 3963               		.loc 2 276 0
 3964 077a F5E8      		ldi r31,lo8(-123)
 3965 077c FA95      	1:	dec r31
 3966 077e 01F4      		brne 1b
 3967 0780 0000      		nop
 3968 0782 00C0      		rjmp .L164
 3969               	.LVL403:
 3970               	.L250:
 3971               	.LBE199:
 3972               	.LBE198:
 609:main.c        **** 				_delay_us(50);
 610:main.c        **** 			}
 611:main.c        **** 			
 612:main.c        **** 			
 613:main.c        **** 			// Set address lines as outputs
 614:main.c        **** 			GBA_DDR_ROM_ADDR23_16 = 0xFF;
 3973               		.loc 3 614 0
 3974 0784 2FEF      		ldi r18,lo8(-1)
 3975 0786 24BB      		out 0x14,r18
 615:main.c        **** 			GBA_DDR_ROM_ADDR15_8 = 0xFF;
 3976               		.loc 3 615 0
 3977 0788 2ABB      		out 0x1a,r18
 616:main.c        **** 			GBA_DDR_ROM_ADDR7_0 = 0xFF;
 3978               		.loc 3 616 0
 3979 078a 27BB      		out 0x17,r18
 617:main.c        **** 			
 618:main.c        **** 			// Back to reading mode
 619:main.c        **** 			gba_flash_write_bus_cycle(address, 0xFF);
 3980               		.loc 3 619 0
 3981 078c 4FEF      		ldi r20,lo8(-1)
 3982 078e 50E0      		ldi r21,0
 3983 0790 C701      		movw r24,r14
 3984 0792 B601      		movw r22,r12
 3985 0794 00D0      		rcall gba_flash_write_bus_cycle
 3986               	.LVL404:
 3987               	.L237:
 620:main.c        **** 			
 621:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 3988               		.loc 3 621 0
 3989 0796 81E3      		ldi r24,lo8(49)
 3990 0798 00C0      		rjmp .L231
 3991               	.LVL405:
 3992               	.L160:
 3993               	.LBE189:
 622:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 623:main.c        **** 		}
 624:main.c        **** 		
 625:main.c        **** 		
 626:main.c        **** 		// ---------- General commands ----------
 627:main.c        **** 		// Set any pin as input/output
 628:main.c        **** 		// Reads the DDR/PORT (e.g. DDRB/PORTB is 'B') and the hex value that represents pins to set to a
 629:main.c        **** 		else if (receivedChar == SET_INPUT || receivedChar == SET_OUTPUT) {
 3994               		.loc 3 629 0
 3995 079a 9934      		cpi r25,lo8(73)
 3996 079c 01F0      		breq .L166
 3997               		.loc 3 629 0 is_stmt 0 discriminator 1
 3998 079e 9F34      		cpi r25,lo8(79)
 3999 07a0 01F0      		breq .+2
 4000 07a2 00C0      		rjmp .L167
 4001               	.L166:
 4002               	.LBB200:
 630:main.c        **** 			char portChar = USART_Receive();
 4003               		.loc 3 630 0 is_stmt 1
 4004 07a4 00D0      		rcall USART_Receive
 4005               	.LVL406:
 4006 07a6 182F      		mov r17,r24
 4007               	.LVL407:
 631:main.c        **** 			usart_read_chars();
 4008               		.loc 3 631 0
 4009 07a8 00D0      		rcall usart_read_chars
 4010               	.LVL408:
 632:main.c        **** 			uint8_t setValue = strtol(receivedBuffer, NULL, 16);
 4011               		.loc 3 632 0
 4012 07aa 40E1      		ldi r20,lo8(16)
 4013 07ac 50E0      		ldi r21,0
 4014 07ae 60E0      		ldi r22,0
 4015 07b0 70E0      		ldi r23,0
 4016 07b2 80E0      		ldi r24,lo8(receivedBuffer)
 4017 07b4 90E0      		ldi r25,hi8(receivedBuffer)
 4018 07b6 00D0      		rcall strtol
 4019               	.LVL409:
 633:main.c        **** 			
 634:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 4020               		.loc 3 634 0
 4021 07b8 939A      		sbi 0x12,3
 635:main.c        **** 			if (receivedChar == SET_INPUT) {
 4022               		.loc 3 635 0
 4023 07ba 8091 0000 		lds r24,receivedChar
 4024 07be 8934      		cpi r24,lo8(73)
 4025 07c0 01F4      		brne .L168
 636:main.c        **** 				if (portChar == 'A') {
 4026               		.loc 3 636 0
 4027 07c2 1134      		cpi r17,lo8(65)
 4028 07c4 01F4      		brne .L169
 637:main.c        **** 					DDRA &= ~(setValue);
 4029               		.loc 3 637 0
 4030 07c6 8AB3      		in r24,0x1a
 4031 07c8 6095      		com r22
 4032               	.LVL410:
 4033 07ca 6823      		and r22,r24
 4034               	.LVL411:
 4035 07cc 00C0      		rjmp .L239
 4036               	.LVL412:
 4037               	.L169:
 638:main.c        **** 				}
 639:main.c        **** 				else if (portChar == 'B') {
 4038               		.loc 3 639 0
 4039 07ce 1234      		cpi r17,lo8(66)
 4040 07d0 01F4      		brne .L171
 640:main.c        **** 					DDRB &= ~(setValue);
 4041               		.loc 3 640 0
 4042 07d2 87B3      		in r24,0x17
 4043 07d4 6095      		com r22
 4044               	.LVL413:
 4045 07d6 6823      		and r22,r24
 4046               	.LVL414:
 4047 07d8 00C0      		rjmp .L240
 4048               	.LVL415:
 4049               	.L171:
 641:main.c        **** 				}
 642:main.c        **** 				else if (portChar == 'C') {
 4050               		.loc 3 642 0
 4051 07da 1334      		cpi r17,lo8(67)
 4052 07dc 01F4      		brne .L172
 643:main.c        **** 					DDRC &= ~(setValue);
 4053               		.loc 3 643 0
 4054 07de 84B3      		in r24,0x14
 4055 07e0 6095      		com r22
 4056               	.LVL416:
 4057 07e2 6823      		and r22,r24
 4058               	.LVL417:
 4059 07e4 00C0      		rjmp .L245
 4060               	.LVL418:
 4061               	.L172:
 644:main.c        **** 				}
 645:main.c        **** 				else if (portChar == 'D') {
 4062               		.loc 3 645 0
 4063 07e6 1434      		cpi r17,lo8(68)
 4064 07e8 01F4      		brne .L173
 646:main.c        **** 					DDRD &= ~(setValue);
 4065               		.loc 3 646 0
 4066 07ea 81B3      		in r24,0x11
 4067 07ec 6095      		com r22
 4068               	.LVL419:
 4069 07ee 6823      		and r22,r24
 4070               	.LVL420:
 4071 07f0 00C0      		rjmp .L246
 4072               	.LVL421:
 4073               	.L173:
 647:main.c        **** 				}
 648:main.c        **** 				else if (portChar == 'E') {
 4074               		.loc 3 648 0
 4075 07f2 1534      		cpi r17,lo8(69)
 4076 07f4 01F0      		breq .+2
 4077 07f6 00C0      		rjmp .L192
 649:main.c        **** 					DDRE &= ~(setValue);
 4078               		.loc 3 649 0
 4079 07f8 86B1      		in r24,0x6
 4080 07fa 6095      		com r22
 4081               	.LVL422:
 4082 07fc 6823      		and r22,r24
 4083               	.LVL423:
 4084 07fe 00C0      		rjmp .L247
 4085               	.LVL424:
 4086               	.L168:
 650:main.c        **** 				}
 651:main.c        **** 			}
 652:main.c        **** 			else if (receivedChar == SET_OUTPUT) {
 4087               		.loc 3 652 0
 4088 0800 8F34      		cpi r24,lo8(79)
 4089 0802 01F0      		breq .+2
 4090 0804 00C0      		rjmp .L192
 653:main.c        **** 				if (portChar == 'A') {
 4091               		.loc 3 653 0
 4092 0806 1134      		cpi r17,lo8(65)
 4093 0808 01F4      		brne .L174
 654:main.c        **** 					DDRA |= (setValue);
 4094               		.loc 3 654 0
 4095 080a 8AB3      		in r24,0x1a
 4096 080c 682B      		or r22,r24
 4097               	.LVL425:
 4098               	.L239:
 4099 080e 6ABB      		out 0x1a,r22
 4100 0810 00C0      		rjmp .L192
 4101               	.LVL426:
 4102               	.L174:
 655:main.c        **** 				}
 656:main.c        **** 				else if (portChar == 'B') {
 4103               		.loc 3 656 0
 4104 0812 1234      		cpi r17,lo8(66)
 4105 0814 01F4      		brne .L175
 657:main.c        **** 					DDRB |= (setValue);
 4106               		.loc 3 657 0
 4107 0816 87B3      		in r24,0x17
 4108 0818 682B      		or r22,r24
 4109               	.LVL427:
 4110               	.L240:
 4111 081a 67BB      		out 0x17,r22
 4112 081c 00C0      		rjmp .L192
 4113               	.LVL428:
 4114               	.L175:
 658:main.c        **** 				}
 659:main.c        **** 				else if (portChar == 'C') {
 4115               		.loc 3 659 0
 4116 081e 1334      		cpi r17,lo8(67)
 4117 0820 01F4      		brne .L176
 660:main.c        **** 					DDRC |= (setValue);
 4118               		.loc 3 660 0
 4119 0822 84B3      		in r24,0x14
 4120 0824 682B      		or r22,r24
 4121               	.LVL429:
 4122               	.L245:
 4123 0826 64BB      		out 0x14,r22
 4124 0828 00C0      		rjmp .L192
 4125               	.LVL430:
 4126               	.L176:
 661:main.c        **** 				}
 662:main.c        **** 				else if (portChar == 'D') {
 4127               		.loc 3 662 0
 4128 082a 1434      		cpi r17,lo8(68)
 4129 082c 01F4      		brne .L177
 663:main.c        **** 					DDRD |= (setValue);
 4130               		.loc 3 663 0
 4131 082e 81B3      		in r24,0x11
 4132 0830 682B      		or r22,r24
 4133               	.LVL431:
 4134               	.L246:
 4135 0832 61BB      		out 0x11,r22
 4136 0834 00C0      		rjmp .L192
 4137               	.LVL432:
 4138               	.L177:
 664:main.c        **** 				}
 665:main.c        **** 				else if (portChar == 'E') {
 4139               		.loc 3 665 0
 4140 0836 1534      		cpi r17,lo8(69)
 4141 0838 01F0      		breq .+2
 4142 083a 00C0      		rjmp .L192
 666:main.c        **** 					DDRE |= (setValue);
 4143               		.loc 3 666 0
 4144 083c 86B1      		in r24,0x6
 4145 083e 682B      		or r22,r24
 4146               	.LVL433:
 4147               	.L247:
 4148 0840 66B9      		out 0x6,r22
 4149 0842 00C0      		rjmp .L192
 4150               	.LVL434:
 4151               	.L167:
 4152               	.LBE200:
 667:main.c        **** 				}
 668:main.c        **** 			}
 669:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 670:main.c        **** 		}
 671:main.c        **** 		
 672:main.c        **** 		// Set pin output as low
 673:main.c        **** 		else if (receivedChar == SET_OUTPUT_LOW) {
 4153               		.loc 3 673 0
 4154 0844 9C34      		cpi r25,lo8(76)
 4155 0846 01F4      		brne .L178
 4156               	.LBB201:
 674:main.c        **** 			char portChar = USART_Receive();			
 4157               		.loc 3 674 0
 4158 0848 00D0      		rcall USART_Receive
 4159               	.LVL435:
 4160 084a 182F      		mov r17,r24
 4161               	.LVL436:
 675:main.c        **** 			usart_read_chars();
 4162               		.loc 3 675 0
 4163 084c 00D0      		rcall usart_read_chars
 4164               	.LVL437:
 676:main.c        **** 			uint8_t setValue = strtol(receivedBuffer, NULL, 16);
 4165               		.loc 3 676 0
 4166 084e 40E1      		ldi r20,lo8(16)
 4167 0850 50E0      		ldi r21,0
 4168 0852 60E0      		ldi r22,0
 4169 0854 70E0      		ldi r23,0
 4170 0856 80E0      		ldi r24,lo8(receivedBuffer)
 4171 0858 90E0      		ldi r25,hi8(receivedBuffer)
 4172 085a 00D0      		rcall strtol
 4173               	.LVL438:
 677:main.c        **** 			
 678:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 4174               		.loc 3 678 0
 4175 085c 939A      		sbi 0x12,3
 679:main.c        **** 			if (portChar == 'A') {
 4176               		.loc 3 679 0
 4177 085e 1134      		cpi r17,lo8(65)
 4178 0860 01F4      		brne .L179
 680:main.c        **** 				PORTA &= ~(setValue);
 4179               		.loc 3 680 0
 4180 0862 8BB3      		in r24,0x1b
 4181 0864 6095      		com r22
 4182               	.LVL439:
 4183 0866 6823      		and r22,r24
 4184               	.LVL440:
 4185 0868 00C0      		rjmp .L244
 4186               	.LVL441:
 4187               	.L179:
 681:main.c        **** 			}
 682:main.c        **** 			else if (portChar == 'B') {
 4188               		.loc 3 682 0
 4189 086a 1234      		cpi r17,lo8(66)
 4190 086c 01F4      		brne .L181
 683:main.c        **** 				PORTB &= ~(setValue);
 4191               		.loc 3 683 0
 4192 086e 88B3      		in r24,0x18
 4193 0870 6095      		com r22
 4194               	.LVL442:
 4195 0872 6823      		and r22,r24
 4196               	.LVL443:
 4197 0874 00C0      		rjmp .L243
 4198               	.LVL444:
 4199               	.L181:
 684:main.c        **** 			}
 685:main.c        **** 			else if (portChar == 'C') {
 4200               		.loc 3 685 0
 4201 0876 1334      		cpi r17,lo8(67)
 4202 0878 01F4      		brne .L182
 686:main.c        **** 				PORTC &= ~(setValue);
 4203               		.loc 3 686 0
 4204 087a 85B3      		in r24,0x15
 4205 087c 6095      		com r22
 4206               	.LVL445:
 4207 087e 6823      		and r22,r24
 4208               	.LVL446:
 4209 0880 00C0      		rjmp .L242
 4210               	.LVL447:
 4211               	.L182:
 687:main.c        **** 			}
 688:main.c        **** 			else if (portChar == 'D') {
 4212               		.loc 3 688 0
 4213 0882 1434      		cpi r17,lo8(68)
 4214 0884 01F4      		brne .L183
 689:main.c        **** 				PORTD &= ~(setValue);
 4215               		.loc 3 689 0
 4216 0886 82B3      		in r24,0x12
 4217 0888 6095      		com r22
 4218               	.LVL448:
 4219 088a 6823      		and r22,r24
 4220               	.LVL449:
 4221 088c 00C0      		rjmp .L241
 4222               	.LVL450:
 4223               	.L183:
 690:main.c        **** 			}
 691:main.c        **** 			else if (portChar == 'E') {
 4224               		.loc 3 691 0
 4225 088e 1534      		cpi r17,lo8(69)
 4226 0890 01F0      		breq .+2
 4227 0892 00C0      		rjmp .L192
 692:main.c        **** 				PORTE &= ~(setValue);
 4228               		.loc 3 692 0
 4229 0894 87B1      		in r24,0x7
 4230 0896 6095      		com r22
 4231               	.LVL451:
 4232 0898 6823      		and r22,r24
 4233               	.LVL452:
 4234 089a 00C0      		rjmp .L238
 4235               	.LVL453:
 4236               	.L178:
 4237               	.LBE201:
 693:main.c        **** 			}
 694:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 695:main.c        **** 		}
 696:main.c        **** 		
 697:main.c        **** 		// Set pin output as high
 698:main.c        **** 		else if (receivedChar == SET_OUTPUT_HIGH) {
 4238               		.loc 3 698 0
 4239 089c 9834      		cpi r25,lo8(72)
 4240 089e 01F4      		brne .L184
 4241               	.LBB202:
 699:main.c        **** 			char portChar = USART_Receive();			
 4242               		.loc 3 699 0
 4243 08a0 00D0      		rcall USART_Receive
 4244               	.LVL454:
 4245 08a2 182F      		mov r17,r24
 4246               	.LVL455:
 700:main.c        **** 			usart_read_chars();
 4247               		.loc 3 700 0
 4248 08a4 00D0      		rcall usart_read_chars
 4249               	.LVL456:
 701:main.c        **** 			uint8_t setValue = strtol(receivedBuffer, NULL, 16);
 4250               		.loc 3 701 0
 4251 08a6 40E1      		ldi r20,lo8(16)
 4252 08a8 50E0      		ldi r21,0
 4253 08aa 60E0      		ldi r22,0
 4254 08ac 70E0      		ldi r23,0
 4255 08ae 80E0      		ldi r24,lo8(receivedBuffer)
 4256 08b0 90E0      		ldi r25,hi8(receivedBuffer)
 4257 08b2 00D0      		rcall strtol
 4258               	.LVL457:
 702:main.c        **** 			
 703:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 4259               		.loc 3 703 0
 4260 08b4 939A      		sbi 0x12,3
 704:main.c        **** 			if (portChar == 'A') {
 4261               		.loc 3 704 0
 4262 08b6 1134      		cpi r17,lo8(65)
 4263 08b8 01F4      		brne .L185
 705:main.c        **** 				PORTA |= (setValue);
 4264               		.loc 3 705 0
 4265 08ba 8BB3      		in r24,0x1b
 4266 08bc 682B      		or r22,r24
 4267               	.LVL458:
 4268               	.L244:
 4269 08be 6BBB      		out 0x1b,r22
 4270 08c0 00C0      		rjmp .L192
 4271               	.LVL459:
 4272               	.L185:
 706:main.c        **** 			}
 707:main.c        **** 			else if (portChar == 'B') {
 4273               		.loc 3 707 0
 4274 08c2 1234      		cpi r17,lo8(66)
 4275 08c4 01F4      		brne .L187
 708:main.c        **** 				PORTB |= (setValue);
 4276               		.loc 3 708 0
 4277 08c6 88B3      		in r24,0x18
 4278 08c8 682B      		or r22,r24
 4279               	.LVL460:
 4280               	.L243:
 4281 08ca 68BB      		out 0x18,r22
 4282 08cc 00C0      		rjmp .L192
 4283               	.LVL461:
 4284               	.L187:
 709:main.c        **** 			}
 710:main.c        **** 			else if (portChar == 'C') {
 4285               		.loc 3 710 0
 4286 08ce 1334      		cpi r17,lo8(67)
 4287 08d0 01F4      		brne .L188
 711:main.c        **** 				PORTC |= (setValue);
 4288               		.loc 3 711 0
 4289 08d2 85B3      		in r24,0x15
 4290 08d4 682B      		or r22,r24
 4291               	.LVL462:
 4292               	.L242:
 4293 08d6 65BB      		out 0x15,r22
 4294 08d8 00C0      		rjmp .L192
 4295               	.LVL463:
 4296               	.L188:
 712:main.c        **** 			}
 713:main.c        **** 			else if (portChar == 'D') {
 4297               		.loc 3 713 0
 4298 08da 1434      		cpi r17,lo8(68)
 4299 08dc 01F4      		brne .L189
 714:main.c        **** 				PORTD |= (setValue);
 4300               		.loc 3 714 0
 4301 08de 82B3      		in r24,0x12
 4302 08e0 682B      		or r22,r24
 4303               	.LVL464:
 4304               	.L241:
 4305 08e2 62BB      		out 0x12,r22
 4306 08e4 00C0      		rjmp .L192
 4307               	.LVL465:
 4308               	.L189:
 715:main.c        **** 			}
 716:main.c        **** 			else if (portChar == 'E') {
 4309               		.loc 3 716 0
 4310 08e6 1534      		cpi r17,lo8(69)
 4311 08e8 01F4      		brne .L192
 717:main.c        **** 				PORTE |= (setValue);
 4312               		.loc 3 717 0
 4313 08ea 87B1      		in r24,0x7
 4314 08ec 682B      		or r22,r24
 4315               	.LVL466:
 4316               	.L238:
 4317 08ee 67B9      		out 0x7,r22
 4318 08f0 00C0      		rjmp .L192
 4319               	.LVL467:
 4320               	.L184:
 4321               	.LBE202:
 718:main.c        **** 			}
 719:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 720:main.c        **** 		}
 721:main.c        **** 		
 722:main.c        **** 		// Read all pins of a PORT and return the value
 723:main.c        **** 		else if (receivedChar == READ_INPUT) {
 4322               		.loc 3 723 0
 4323 08f2 9434      		cpi r25,lo8(68)
 4324 08f4 01F4      		brne .L190
 4325               	.LBB203:
 724:main.c        **** 			char portChar = USART_Receive();			
 4326               		.loc 3 724 0
 4327 08f6 00D0      		rcall USART_Receive
 4328               	.LVL468:
 725:main.c        **** 			
 726:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 4329               		.loc 3 726 0
 4330 08f8 939A      		sbi 0x12,3
 727:main.c        **** 			if (portChar == 'A') {
 4331               		.loc 3 727 0
 4332 08fa 8134      		cpi r24,lo8(65)
 4333 08fc 01F4      		brne .L191
 728:main.c        **** 				USART_Transmit(PINA);
 4334               		.loc 3 728 0
 4335 08fe 89B3      		in r24,0x19
 4336               	.LVL469:
 4337 0900 00C0      		rjmp .L231
 4338               	.LVL470:
 4339               	.L191:
 729:main.c        **** 			}
 730:main.c        **** 			else if (portChar == 'B') {
 4340               		.loc 3 730 0
 4341 0902 8234      		cpi r24,lo8(66)
 4342 0904 01F4      		brne .L193
 731:main.c        **** 				USART_Transmit(PINB);
 4343               		.loc 3 731 0
 4344 0906 86B3      		in r24,0x16
 4345               	.LVL471:
 4346 0908 00C0      		rjmp .L231
 4347               	.LVL472:
 4348               	.L193:
 732:main.c        **** 			}
 733:main.c        **** 			else if (portChar == 'C') {
 4349               		.loc 3 733 0
 4350 090a 8334      		cpi r24,lo8(67)
 4351 090c 01F4      		brne .L194
 734:main.c        **** 				USART_Transmit(PINC);
 4352               		.loc 3 734 0
 4353 090e 83B3      		in r24,0x13
 4354               	.LVL473:
 4355 0910 00C0      		rjmp .L231
 4356               	.LVL474:
 4357               	.L194:
 735:main.c        **** 			}
 736:main.c        **** 			else if (portChar == 'D') {
 4358               		.loc 3 736 0
 4359 0912 8434      		cpi r24,lo8(68)
 4360 0914 01F4      		brne .L195
 737:main.c        **** 				USART_Transmit(PIND);
 4361               		.loc 3 737 0
 4362 0916 80B3      		in r24,0x10
 4363               	.LVL475:
 4364 0918 00C0      		rjmp .L231
 4365               	.LVL476:
 4366               	.L195:
 738:main.c        **** 			}
 739:main.c        **** 			else if (portChar == 'E') {
 4367               		.loc 3 739 0
 4368 091a 8534      		cpi r24,lo8(69)
 4369 091c 01F4      		brne .L192
 740:main.c        **** 				USART_Transmit(PINE);
 4370               		.loc 3 740 0
 4371 091e 85B1      		in r24,0x5
 4372               	.LVL477:
 4373               	.L231:
 4374 0920 00D0      		rcall USART_Transmit
 4375               	.LVL478:
 4376               	.L192:
 741:main.c        **** 			}
 742:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 4377               		.loc 3 742 0
 4378 0922 9398      		cbi 0x12,3
 4379               	.LBE203:
 4380 0924 00C0      		rjmp .L93
 4381               	.LVL479:
 4382               	.L190:
 743:main.c        **** 		}
 744:main.c        **** 		
 745:main.c        **** 		// Set the reset common lines variable on or off, useful if you are controlling all the pins dire
 746:main.c        **** 		else if (receivedChar == RESET_COMMON_LINES) {
 4383               		.loc 3 746 0
 4384 0926 9D34      		cpi r25,lo8(77)
 4385 0928 01F4      		brne .L196
 4386               	.LBB204:
 747:main.c        **** 			char commonChar = USART_Receive();
 4387               		.loc 3 747 0
 4388 092a 00D0      		rcall USART_Receive
 4389               	.LVL480:
 748:main.c        **** 			if (commonChar == '1') {
 4390               		.loc 3 748 0
 4391 092c 8133      		cpi r24,lo8(49)
 4392 092e 01F4      		brne .L251
 749:main.c        **** 				resetCommonLines = 1;
 4393               		.loc 3 749 0
 4394 0930 91E0      		ldi r25,lo8(1)
 4395 0932 9A83      		std Y+2,r25
 4396 0934 00C0      		rjmp .L227
 4397               	.L251:
 750:main.c        **** 			}
 751:main.c        **** 			else if (commonChar == '0') {
 4398               		.loc 3 751 0
 4399 0936 8033      		cpi r24,lo8(48)
 4400 0938 01F0      		breq .+2
 4401 093a 00C0      		rjmp .L93
 752:main.c        **** 				resetCommonLines = 0;
 4402               		.loc 3 752 0
 4403 093c 1A82      		std Y+2,__zero_reg__
 4404 093e 00C0      		rjmp .L94
 4405               	.LVL481:
 4406               	.L196:
 4407               	.LBE204:
 753:main.c        **** 			}
 754:main.c        **** 		}
 755:main.c        **** 		
 756:main.c        **** 		// Send back the PCB version number
 757:main.c        **** 		else if (receivedChar == READ_PCB_VERSION) {
 4408               		.loc 3 757 0
 4409 0940 9836      		cpi r25,lo8(104)
 4410 0942 01F4      		brne .L197
 758:main.c        **** 			USART_Transmit(PCB_VERSION);
 4411               		.loc 3 758 0
 4412 0944 82E0      		ldi r24,lo8(2)
 4413               	.LVL482:
 4414 0946 00C0      		rjmp .L228
 4415               	.LVL483:
 4416               	.L197:
 759:main.c        **** 		}
 760:main.c        **** 		
 761:main.c        **** 		// Send back the firmware version number
 762:main.c        **** 		else if (receivedChar == READ_FIRMWARE_VERSION) {
 4417               		.loc 3 762 0
 4418 0948 9635      		cpi r25,lo8(86)
 4419 094a 01F4      		brne .L198
 763:main.c        **** 			USART_Transmit(FIRMWARE_VERSION);
 4420               		.loc 3 763 0
 4421 094c 8CE0      		ldi r24,lo8(12)
 4422               	.LVL484:
 4423               	.L228:
 4424 094e 00D0      		rcall USART_Transmit
 4425               	.LVL485:
 4426 0950 00C0      		rjmp .L93
 4427               	.LVL486:
 4428               	.L198:
 764:main.c        **** 		}
 765:main.c        **** 		
 766:main.c        **** 		// Reset the AVR if it matches the number
 767:main.c        **** 		else if (receivedChar == RESET_AVR) {
 4429               		.loc 3 767 0
 4430 0952 9A32      		cpi r25,lo8(42)
 4431 0954 01F0      		breq .+2
 4432 0956 00C0      		rjmp .L93
 4433               	.LBB205:
 768:main.c        **** 			usart_read_chars();
 4434               		.loc 3 768 0
 4435 0958 00D0      		rcall usart_read_chars
 4436               	.LVL487:
 769:main.c        **** 			uint32_t resetValue = strtol(receivedBuffer, NULL, 16);
 4437               		.loc 3 769 0
 4438 095a 40E1      		ldi r20,lo8(16)
 4439 095c 50E0      		ldi r21,0
 4440 095e 60E0      		ldi r22,0
 4441 0960 70E0      		ldi r23,0
 4442 0962 80E0      		ldi r24,lo8(receivedBuffer)
 4443 0964 90E0      		ldi r25,hi8(receivedBuffer)
 4444 0966 00D0      		rcall strtol
 4445               	.LVL488:
 770:main.c        **** 			if (resetValue == RESET_VALUE) {
 4446               		.loc 3 770 0
 4447 0968 613E      		cpi r22,-31
 4448 096a 754E      		sbci r23,-27
 4449 096c 8740      		sbci r24,7
 4450 096e 9105      		cpc r25,__zero_reg__
 4451 0970 01F0      		breq .+2
 4452 0972 00C0      		rjmp .L93
 771:main.c        **** 				// Clear watchdog flag
 772:main.c        **** 				MCUCSR &= ~(1<<WDRF);
 4453               		.loc 3 772 0
 4454 0974 84B7      		in r24,0x34
 4455 0976 877F      		andi r24,lo8(-9)
 4456 0978 84BF      		out 0x34,r24
 773:main.c        **** 				
 774:main.c        **** 				// Start timed sequence
 775:main.c        **** 				WDTCR = (1<<WDCE) | (1<<WDE);
 4457               		.loc 3 775 0
 4458 097a F8E1      		ldi r31,lo8(24)
 4459 097c F1BD      		out 0x21,r31
 776:main.c        **** 				
 777:main.c        **** 				// Reset in 250 ms
 778:main.c        **** 				WDTCR = (1<<WDP2) | (1<<WDE);
 4460               		.loc 3 778 0
 4461 097e 2CE0      		ldi r18,lo8(12)
 4462 0980 21BD      		out 0x21,r18
 4463               	.LVL489:
 4464               	.LBB206:
 4465               	.LBB207:
 4466               		.file 4 "c:\\winavr-20100110\\avr\\include\\util\\delay_basic.h"
   1:c:\winavr-20100110\avr\include\util\delay_basic.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:c:\winavr-20100110\avr\include\util\delay_basic.h ****    Copyright (c) 2007 Joerg Wunsch
   3:c:\winavr-20100110\avr\include\util\delay_basic.h ****    All rights reserved.
   4:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
   5:c:\winavr-20100110\avr\include\util\delay_basic.h ****    Redistribution and use in source and binary forms, with or without
   6:c:\winavr-20100110\avr\include\util\delay_basic.h ****    modification, are permitted provided that the following conditions are met:
   7:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
   8:c:\winavr-20100110\avr\include\util\delay_basic.h ****    * Redistributions of source code must retain the above copyright
   9:c:\winavr-20100110\avr\include\util\delay_basic.h ****      notice, this list of conditions and the following disclaimer.
  10:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  11:c:\winavr-20100110\avr\include\util\delay_basic.h ****    * Redistributions in binary form must reproduce the above copyright
  12:c:\winavr-20100110\avr\include\util\delay_basic.h ****      notice, this list of conditions and the following disclaimer in
  13:c:\winavr-20100110\avr\include\util\delay_basic.h ****      the documentation and/or other materials provided with the
  14:c:\winavr-20100110\avr\include\util\delay_basic.h ****      distribution.
  15:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  16:c:\winavr-20100110\avr\include\util\delay_basic.h ****    * Neither the name of the copyright holders nor the names of
  17:c:\winavr-20100110\avr\include\util\delay_basic.h ****      contributors may be used to endorse or promote products derived
  18:c:\winavr-20100110\avr\include\util\delay_basic.h ****      from this software without specific prior written permission.
  19:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  20:c:\winavr-20100110\avr\include\util\delay_basic.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  21:c:\winavr-20100110\avr\include\util\delay_basic.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  22:c:\winavr-20100110\avr\include\util\delay_basic.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  23:c:\winavr-20100110\avr\include\util\delay_basic.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  24:c:\winavr-20100110\avr\include\util\delay_basic.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  25:c:\winavr-20100110\avr\include\util\delay_basic.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  26:c:\winavr-20100110\avr\include\util\delay_basic.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  27:c:\winavr-20100110\avr\include\util\delay_basic.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  28:c:\winavr-20100110\avr\include\util\delay_basic.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  29:c:\winavr-20100110\avr\include\util\delay_basic.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  30:c:\winavr-20100110\avr\include\util\delay_basic.h ****   POSSIBILITY OF SUCH DAMAGE. */
  31:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  32:c:\winavr-20100110\avr\include\util\delay_basic.h **** /* $Id$ */
  33:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  34:c:\winavr-20100110\avr\include\util\delay_basic.h **** #ifndef _UTIL_DELAY_BASIC_H_
  35:c:\winavr-20100110\avr\include\util\delay_basic.h **** #define _UTIL_DELAY_BASIC_H_ 1
  36:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  37:c:\winavr-20100110\avr\include\util\delay_basic.h **** #include <inttypes.h>
  38:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  39:c:\winavr-20100110\avr\include\util\delay_basic.h **** #if !defined(__DOXYGEN__)
  40:c:\winavr-20100110\avr\include\util\delay_basic.h **** static __inline__ void _delay_loop_1(uint8_t __count) __attribute__((__always_inline__));
  41:c:\winavr-20100110\avr\include\util\delay_basic.h **** static __inline__ void _delay_loop_2(uint16_t __count) __attribute__((__always_inline__));
  42:c:\winavr-20100110\avr\include\util\delay_basic.h **** #endif
  43:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  44:c:\winavr-20100110\avr\include\util\delay_basic.h **** /** \file */
  45:c:\winavr-20100110\avr\include\util\delay_basic.h **** /** \defgroup util_delay_basic <util/delay_basic.h>: Basic busy-wait delay loops
  46:c:\winavr-20100110\avr\include\util\delay_basic.h ****     \code
  47:c:\winavr-20100110\avr\include\util\delay_basic.h ****     #include <util/delay_basic.h>
  48:c:\winavr-20100110\avr\include\util\delay_basic.h ****     \endcode
  49:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  50:c:\winavr-20100110\avr\include\util\delay_basic.h ****     The functions in this header file implement simple delay loops
  51:c:\winavr-20100110\avr\include\util\delay_basic.h ****     that perform a busy-waiting.  They are typically used to
  52:c:\winavr-20100110\avr\include\util\delay_basic.h ****     facilitate short delays in the program execution.  They are
  53:c:\winavr-20100110\avr\include\util\delay_basic.h ****     implemented as count-down loops with a well-known CPU cycle
  54:c:\winavr-20100110\avr\include\util\delay_basic.h ****     count per loop iteration.  As such, no other processing can
  55:c:\winavr-20100110\avr\include\util\delay_basic.h ****     occur simultaneously.  It should be kept in mind that the
  56:c:\winavr-20100110\avr\include\util\delay_basic.h ****     functions described here do not disable interrupts.
  57:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  58:c:\winavr-20100110\avr\include\util\delay_basic.h ****     In general, for long delays, the use of hardware timers is
  59:c:\winavr-20100110\avr\include\util\delay_basic.h ****     much preferrable, as they free the CPU, and allow for
  60:c:\winavr-20100110\avr\include\util\delay_basic.h ****     concurrent processing of other events while the timer is
  61:c:\winavr-20100110\avr\include\util\delay_basic.h ****     running.  However, in particular for very short delays, the
  62:c:\winavr-20100110\avr\include\util\delay_basic.h ****     overhead of setting up a hardware timer is too much compared
  63:c:\winavr-20100110\avr\include\util\delay_basic.h ****     to the overall delay time.
  64:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  65:c:\winavr-20100110\avr\include\util\delay_basic.h ****     Two inline functions are provided for the actual delay algorithms.
  66:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  67:c:\winavr-20100110\avr\include\util\delay_basic.h **** */
  68:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  69:c:\winavr-20100110\avr\include\util\delay_basic.h **** /** \ingroup util_delay_basic
  70:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  71:c:\winavr-20100110\avr\include\util\delay_basic.h ****     Delay loop using an 8-bit counter \c __count, so up to 256
  72:c:\winavr-20100110\avr\include\util\delay_basic.h ****     iterations are possible.  (The value 256 would have to be passed
  73:c:\winavr-20100110\avr\include\util\delay_basic.h ****     as 0.)  The loop executes three CPU cycles per iteration, not
  74:c:\winavr-20100110\avr\include\util\delay_basic.h ****     including the overhead the compiler needs to setup the counter
  75:c:\winavr-20100110\avr\include\util\delay_basic.h ****     register.
  76:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  77:c:\winavr-20100110\avr\include\util\delay_basic.h ****     Thus, at a CPU speed of 1 MHz, delays of up to 768 microseconds
  78:c:\winavr-20100110\avr\include\util\delay_basic.h ****     can be achieved.
  79:c:\winavr-20100110\avr\include\util\delay_basic.h **** */
  80:c:\winavr-20100110\avr\include\util\delay_basic.h **** void
  81:c:\winavr-20100110\avr\include\util\delay_basic.h **** _delay_loop_1(uint8_t __count)
  82:c:\winavr-20100110\avr\include\util\delay_basic.h **** {
  83:c:\winavr-20100110\avr\include\util\delay_basic.h **** 	__asm__ volatile (
  84:c:\winavr-20100110\avr\include\util\delay_basic.h **** 		"1: dec %0" "\n\t"
  85:c:\winavr-20100110\avr\include\util\delay_basic.h **** 		"brne 1b"
  86:c:\winavr-20100110\avr\include\util\delay_basic.h **** 		: "=r" (__count)
  87:c:\winavr-20100110\avr\include\util\delay_basic.h **** 		: "0" (__count)
  88:c:\winavr-20100110\avr\include\util\delay_basic.h **** 	);
  89:c:\winavr-20100110\avr\include\util\delay_basic.h **** }
  90:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  91:c:\winavr-20100110\avr\include\util\delay_basic.h **** /** \ingroup util_delay_basic
  92:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  93:c:\winavr-20100110\avr\include\util\delay_basic.h ****     Delay loop using a 16-bit counter \c __count, so up to 65536
  94:c:\winavr-20100110\avr\include\util\delay_basic.h ****     iterations are possible.  (The value 65536 would have to be
  95:c:\winavr-20100110\avr\include\util\delay_basic.h ****     passed as 0.)  The loop executes four CPU cycles per iteration,
  96:c:\winavr-20100110\avr\include\util\delay_basic.h ****     not including the overhead the compiler requires to setup the
  97:c:\winavr-20100110\avr\include\util\delay_basic.h ****     counter register pair.
  98:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  99:c:\winavr-20100110\avr\include\util\delay_basic.h ****     Thus, at a CPU speed of 1 MHz, delays of up to about 262.1
 100:c:\winavr-20100110\avr\include\util\delay_basic.h ****     milliseconds can be achieved.
 101:c:\winavr-20100110\avr\include\util\delay_basic.h ****  */
 102:c:\winavr-20100110\avr\include\util\delay_basic.h **** void
 103:c:\winavr-20100110\avr\include\util\delay_basic.h **** _delay_loop_2(uint16_t __count)
 104:c:\winavr-20100110\avr\include\util\delay_basic.h **** {
 105:c:\winavr-20100110\avr\include\util\delay_basic.h **** 	__asm__ volatile (
 4467               		.loc 4 105 0
 4468 0982 8FEF      		ldi r24,lo8(-1)
 4469 0984 9FEF      		ldi r25,lo8(-1)
 4470               	/* #APP */
 4471               	 ;  105 "c:\winavr-20100110\avr\include\util\delay_basic.h" 1
 4472 0986 0197      		1: sbiw r24,1
 4473 0988 01F4      		brne 1b
 4474               	 ;  0 "" 2
 4475               	.LVL490:
 4476               	/* #NOAPP */
 4477 098a 00C0      		rjmp .L93
 4478               	.LBE207:
 4479               	.LBE206:
 4480               	.LBE205:
 4481               		.cfi_endproc
 4482               	.LFE45:
 4484               	.global	lastBankAccessed
 4485               		.section .bss
 4488               	lastBankAccessed:
 4489 0000 00        		.zero	1
 4490               	.global	flashBank1CommandWrites
 4493               	flashBank1CommandWrites:
 4494 0001 00        		.zero	1
 4495               		.comm	flashWriteCycle,12,1
 4496               		.comm	flashWriteWePin,1,1
 4497               		.comm	flashChipIdBuffer,2,1
 4498               		.comm	eepromBuffer,8,1
 4499               		.comm	receivedChar,1,1
 4500               		.comm	receivedBuffer,256,1
 4501               		.text
 4502               	.Letext0:
 4503               		.file 5 "c:\\winavr-20100110\\avr\\include\\stdint.h"
 4504               		.file 6 "c:\\winavr-20100110\\avr\\include\\stdlib.h"
DEFINED SYMBOLS
                            *ABS*:00000000 main.c
C:\Users\Alex\AppData\Local\Temp\ccgzx12a.s:2      *ABS*:0000003e __SP_H__
C:\Users\Alex\AppData\Local\Temp\ccgzx12a.s:3      *ABS*:0000003d __SP_L__
C:\Users\Alex\AppData\Local\Temp\ccgzx12a.s:4      *ABS*:0000003f __SREG__
C:\Users\Alex\AppData\Local\Temp\ccgzx12a.s:5      *ABS*:00000000 __tmp_reg__
C:\Users\Alex\AppData\Local\Temp\ccgzx12a.s:6      *ABS*:00000001 __zero_reg__
C:\Users\Alex\AppData\Local\Temp\ccgzx12a.s:12     .text:00000000 USART_Receive
C:\Users\Alex\AppData\Local\Temp\ccgzx12a.s:34     .text:00000008 USART_Transmit
C:\Users\Alex\AppData\Local\Temp\ccgzx12a.s:55     .text:00000010 usart_read_bytes
                            *COM*:00000100 receivedBuffer
C:\Users\Alex\AppData\Local\Temp\ccgzx12a.s:118    .text:0000003a usart_read_chars
C:\Users\Alex\AppData\Local\Temp\ccgzx12a.s:158    .text:00000050 rd_wr_csmreq_cs2_reset
C:\Users\Alex\AppData\Local\Temp\ccgzx12a.s:180    .text:0000005a gb_mode
C:\Users\Alex\AppData\Local\Temp\ccgzx12a.s:207    .text:0000006a set_16bit_address
C:\Users\Alex\AppData\Local\Temp\ccgzx12a.s:226    .text:00000070 read_8bit_data
C:\Users\Alex\AppData\Local\Temp\ccgzx12a.s:266    .text:00000082 write_8bit_data
C:\Users\Alex\AppData\Local\Temp\ccgzx12a.s:331    .text:000000ae gba_mode
C:\Users\Alex\AppData\Local\Temp\ccgzx12a.s:358    .text:000000be gba_set_24bit_address
C:\Users\Alex\AppData\Local\Temp\ccgzx12a.s:411    .text:000000ea gba_read_16bit_data
C:\Users\Alex\AppData\Local\Temp\ccgzx12a.s:459    .text:00000108 gba_read_ram_8bit_data
C:\Users\Alex\AppData\Local\Temp\ccgzx12a.s:499    .text:0000011a gba_write_ram_8bit_data
C:\Users\Alex\AppData\Local\Temp\ccgzx12a.s:553    .text:0000013a gba_eeprom_mode
C:\Users\Alex\AppData\Local\Temp\ccgzx12a.s:581    .text:0000014c gba_eeprom_set_address
C:\Users\Alex\AppData\Local\Temp\ccgzx12a.s:720    .text:000001b4 gba_eeprom_read
                            *COM*:00000008 eepromBuffer
C:\Users\Alex\AppData\Local\Temp\ccgzx12a.s:852    .text:0000020e gba_eeprom_write
C:\Users\Alex\AppData\Local\Temp\ccgzx12a.s:968    .text:00000262 flash_write_bus_cycle
C:\Users\Alex\AppData\Local\Temp\ccgzx12a.s:1014   .text:0000027c flash_read_chip_id
                            *COM*:00000002 flashChipIdBuffer
C:\Users\Alex\AppData\Local\Temp\ccgzx12a.s:1119   .text:000002e6 flash_switch_bank
C:\Users\Alex\AppData\Local\Temp\ccgzx12a.s:1168   .text:0000030c flash_erase_4k_sector
C:\Users\Alex\AppData\Local\Temp\ccgzx12a.s:1243   .text:00000354 flash_write_byte
C:\Users\Alex\AppData\Local\Temp\ccgzx12a.s:1314   .text:0000038c flash_write_sector
C:\Users\Alex\AppData\Local\Temp\ccgzx12a.s:1427   .text:000003f8 gb_flash_read_byte
C:\Users\Alex\AppData\Local\Temp\ccgzx12a.s:1467   .text:0000040a gb_flash_write_bus_cycle
                            *COM*:00000001 flashWriteWePin
C:\Users\Alex\AppData\Local\Temp\ccgzx12a.s:1548   .text:00000438 gb_flash_write_byte
                            *COM*:0000000c flashWriteCycle
C:\Users\Alex\AppData\Local\Temp\ccgzx12a.s:1648   .text:0000049c gb_flash_write_byte_bank1_commands
C:\Users\Alex\AppData\Local\Temp\ccgzx12a.s:4488   .bss:00000000 lastBankAccessed
C:\Users\Alex\AppData\Local\Temp\ccgzx12a.s:1811   .text:00000530 gba_flash_write_bus_cycle
C:\Users\Alex\AppData\Local\Temp\ccgzx12a.s:1877   .text:00000560 gba_flash_write_cycle_start_swapped
C:\Users\Alex\AppData\Local\Temp\ccgzx12a.s:2001   .text:000005c0 gba_flash_write_cycle_start
C:\Users\Alex\AppData\Local\Temp\ccgzx12a.s:2123   .text:0000061c gba_flash_write_byte
C:\Users\Alex\AppData\Local\Temp\ccgzx12a.s:2231   .text:00000672 setup
C:\Users\Alex\AppData\Local\Temp\ccgzx12a.s:2346   .text.startup:00000000 main
                            *COM*:00000001 receivedChar
C:\Users\Alex\AppData\Local\Temp\ccgzx12a.s:4493   .bss:00000001 flashBank1CommandWrites

UNDEFINED SYMBOLS
strtol
atoi
__do_clear_bss
