   1               		.file	"main.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               	.global	USART_Receive
  12               	USART_Receive:
  13               	.LFB10:
  14               		.file 1 "setup.c"
   1:setup.c       **** /*
   2:setup.c       ****  GBxCart RW
   3:setup.c       ****  PCB version: 1.0
   4:setup.c       ****  Firmware version: R2
   5:setup.c       ****  Author: Alex from insideGadgets (www.insidegadgets.com)
   6:setup.c       ****  Created: 7/11/2016
   7:setup.c       ****  Last Modified: 8/05/2017
   8:setup.c       **** 
   9:setup.c       ****  */
  10:setup.c       ****  
  11:setup.c       **** #ifndef cbi
  12:setup.c       **** #define cbi(sfr, bit) (_SFR_BYTE(sfr) &= ~_BV(bit))
  13:setup.c       **** #endif
  14:setup.c       **** #ifndef sbi
  15:setup.c       **** #define sbi(sfr, bit) (_SFR_BYTE(sfr) |= _BV(bit))
  16:setup.c       **** #endif
  17:setup.c       **** 
  18:setup.c       **** #ifndef NULL
  19:setup.c       **** #define NULL ((void *)0)
  20:setup.c       **** #endif
  21:setup.c       **** 
  22:setup.c       **** #define LOW 0
  23:setup.c       **** #define HIGH 1
  24:setup.c       **** #define false 0
  25:setup.c       **** #define true 1
  26:setup.c       **** 
  27:setup.c       **** #define SWITCH_DETECT PD2
  28:setup.c       **** #define LED PD3
  29:setup.c       **** #define WR_PIN PD4
  30:setup.c       **** #define RD_PIN PD5
  31:setup.c       **** #define CS_MREQ_PIN PD6
  32:setup.c       **** #define CS2_PIN PD7
  33:setup.c       **** 
  34:setup.c       **** #define wrPin_high	PORTD |= (1<<WR_PIN);
  35:setup.c       **** #define wrPin_low		PORTD &= ~(1<<WR_PIN);
  36:setup.c       **** #define rdPin_high	PORTD |= (1<<RD_PIN);
  37:setup.c       **** #define rdPin_low		PORTD &= ~(1<<RD_PIN);
  38:setup.c       **** #define cs_mreqPin_high		PORTD |= (1<<CS_MREQ_PIN);
  39:setup.c       **** #define cs_mreqPin_low		PORTD &= ~(1<<CS_MREQ_PIN);
  40:setup.c       **** #define cs2Pin_high		PORTD |= (1<<CS2_PIN);
  41:setup.c       **** #define cs2Pin_low		PORTD &= ~(1<<CS2_PIN);
  42:setup.c       **** 
  43:setup.c       **** #define GB_MODE 1
  44:setup.c       **** #define GBA_MODE 2
  45:setup.c       **** 
  46:setup.c       **** // GB/GBC
  47:setup.c       **** #define PORT_ADDR7_0 PORTB
  48:setup.c       **** #define PORT_ADDR15_8 PORTA
  49:setup.c       **** #define PORT_DATA7_0 PORTC
  50:setup.c       **** 
  51:setup.c       **** #define DDR_ADDR7_0 DDRB
  52:setup.c       **** #define DDR_ADDR15_8 DDRA
  53:setup.c       **** #define DDR_DATA7_0 DDRC
  54:setup.c       **** 
  55:setup.c       **** #define PIN_ADDR7_0 PINB
  56:setup.c       **** #define PIN_ADDR15_8 PINA
  57:setup.c       **** #define PIN_DATA7_0 PINC
  58:setup.c       **** 
  59:setup.c       **** #define BANK_WRITE 0
  60:setup.c       **** #define MEMORY_WRITE 1
  61:setup.c       **** 
  62:setup.c       **** // GBA
  63:setup.c       **** #define EEPROM_WRITE 1
  64:setup.c       **** #define EEPROM_READ 0
  65:setup.c       **** #define EEPROM_NONE 0
  66:setup.c       **** #define EEPROM_4KBIT 1
  67:setup.c       **** #define EEPROM_64KBIT 2
  68:setup.c       **** 
  69:setup.c       **** #define AD0 PB0
  70:setup.c       **** #define ad0Pin_high		PORTB |= (1<<AD0);
  71:setup.c       **** #define ad0Pin_low		PORTB &= ~(1<<AD0);
  72:setup.c       **** 
  73:setup.c       **** #define A23 PC7
  74:setup.c       **** #define a23Pin_high		PORTC |= (1<<A23);
  75:setup.c       **** #define a23Pin_low		PORTC &= ~(1<<A23);
  76:setup.c       **** 
  77:setup.c       **** #define GBA_DDR_ROM_ADDR7_0 DDRB
  78:setup.c       **** #define GBA_DDR_ROM_ADDR15_8 DDRA
  79:setup.c       **** #define GBA_DDR_ROM_ADDR23_16 DDRC
  80:setup.c       **** #define GBA_DDR_ROM_DATA7_0 DDRB
  81:setup.c       **** #define GBA_DDR_ROM_DATA15_8 DDRA
  82:setup.c       **** #define GBA_DDR_RAM_DATA7_0 DDRC
  83:setup.c       **** #define GBA_DDR_EEPROM_DATA7_0 DDRB
  84:setup.c       **** 
  85:setup.c       **** #define GBA_PORT_ROM_ADDR7_0 PORTB
  86:setup.c       **** #define GBA_PORT_ROM_ADDR15_8 PORTA
  87:setup.c       **** #define GBA_PORT_ROM_ADDR23_16 PORTC
  88:setup.c       **** #define GBA_PORT_ROM_DATA7_0 PORTB
  89:setup.c       **** #define GBA_PORT_ROM_DATA15_8 PORTA
  90:setup.c       **** #define GBA_PORT_RAM_DATA7_0 PORTC
  91:setup.c       **** #define GBA_PORT_EEPROM_DATA7_0 PORTB
  92:setup.c       **** 
  93:setup.c       **** #define GBA_PIN_ROM_DATA7_0 PINB
  94:setup.c       **** #define GBA_PIN_ROM_DATA15_8 PINA
  95:setup.c       **** #define GBA_PIN_RAM_DATA7_0 PINC
  96:setup.c       **** #define GBA_PIN_EEPROM_DATA7_0 PINB
  97:setup.c       **** 
  98:setup.c       **** // GB/GBC commands
  99:setup.c       **** #define SET_START_ADDRESS 'A'
 100:setup.c       **** #define READ_ROM_RAM 'R'
 101:setup.c       **** #define WRITE_RAM 'W'
 102:setup.c       **** #define SET_BANK 'B'
 103:setup.c       **** #define GB_CART_MODE 'G'
 104:setup.c       **** 
 105:setup.c       **** // GBA commands
 106:setup.c       **** #define GBA_READ_ROM 'r'
 107:setup.c       **** #define GBA_READ_SRAM 'm'
 108:setup.c       **** #define GBA_WRITE_SRAM 'w'
 109:setup.c       **** #define GBA_WRITE_ONE_BYTE_SRAM 'o'
 110:setup.c       **** #define GBA_CART_MODE 'g'
 111:setup.c       **** 
 112:setup.c       **** #define GBA_FLASH_READ_ID 'i'
 113:setup.c       **** #define GBA_FLASH_SET_BANK 'k'
 114:setup.c       **** #define GBA_FLASH_4K_SECTOR_ERASE 's'
 115:setup.c       **** #define GBA_FLASH_WRITE_BYTE 'b'
 116:setup.c       **** #define GBA_FLASH_WRITE_ATMEL 'a'
 117:setup.c       **** 
 118:setup.c       **** #define GBA_SET_EEPROM_SIZE 'S'
 119:setup.c       **** #define GBA_READ_EEPROM 'e'
 120:setup.c       **** #define GBA_WRITE_EEPROM 'p'
 121:setup.c       **** 
 122:setup.c       **** // General commands
 123:setup.c       **** #define CART_MODE 'C'
 124:setup.c       **** #define SET_INPUT 'I'
 125:setup.c       **** #define SET_OUTPUT 'O'
 126:setup.c       **** #define SET_OUTPUT_LOW 'L'
 127:setup.c       **** #define SET_OUTPUT_HIGH 'H'
 128:setup.c       **** #define READ_INPUT 'D'
 129:setup.c       **** #define RESET_COMMON_LINES 'M'
 130:setup.c       **** #define READ_FIRMWARE_VERSION 'V'
 131:setup.c       **** #define READ_PCB_VERSION 'h'
 132:setup.c       **** 
 133:setup.c       **** char receivedBuffer[129];
 134:setup.c       **** char receivedChar;
 135:setup.c       **** uint8_t eepromBuffer[8];
 136:setup.c       **** uint8_t flashChipIdBuffer[2];
 137:setup.c       **** 
 138:setup.c       **** // Receive USART data
 139:setup.c       **** uint8_t USART_Receive(void) {
  15               		.loc 1 139 0
  16               		.cfi_startproc
  17               	/* prologue: function */
  18               	/* frame size = 0 */
  19               	/* stack size = 0 */
  20               	.L__stack_usage = 0
  21               	.L3:
 140:setup.c       **** 	while ( !(UCSRA & (1<<RXC)) ); // Wait for data to be received
  22               		.loc 1 140 0 discriminator 1
  23 0000 5F9B      		sbis 0xb,7
  24 0002 00C0      		rjmp .L3
 141:setup.c       **** 	return UDR; // Get and return received data from buffer
  25               		.loc 1 141 0
  26 0004 8CB1      		in r24,0xc
 142:setup.c       **** }
  27               		.loc 1 142 0
  28 0006 0895      		ret
  29               		.cfi_endproc
  30               	.LFE10:
  32               	.global	USART_Transmit
  34               	USART_Transmit:
  35               	.LFB11:
 143:setup.c       **** 
 144:setup.c       **** // Transmit USART data
 145:setup.c       **** void USART_Transmit(unsigned char data) {
  36               		.loc 1 145 0
  37               		.cfi_startproc
  38               	/* prologue: function */
  39               	/* frame size = 0 */
  40               	/* stack size = 0 */
  41               	.L__stack_usage = 0
  42               	.LVL0:
  43               	.L7:
 146:setup.c       **** 	while ( !( UCSRA & (1<<UDRE)) ); // Wait for empty transmit buffer
  44               		.loc 1 146 0 discriminator 1
  45 0008 5D9B      		sbis 0xb,5
  46 000a 00C0      		rjmp .L7
 147:setup.c       **** 	UDR = data;
  47               		.loc 1 147 0
  48 000c 8CB9      		out 0xc,r24
  49 000e 0895      		ret
  50               		.cfi_endproc
  51               	.LFE11:
  53               	.global	usart_read_bytes
  55               	usart_read_bytes:
  56               	.LFB12:
 148:setup.c       **** }
 149:setup.c       **** 
 150:setup.c       **** // Read 1-128 bytes from the USART 
 151:setup.c       **** void usart_read_bytes(uint8_t count) {
  57               		.loc 1 151 0
  58               		.cfi_startproc
  59               	.LVL1:
  60 0010 FF92      		push r15
  61               	.LCFI0:
  62               		.cfi_def_cfa_offset 3
  63               		.cfi_offset 15, -2
  64 0012 0F93      		push r16
  65               	.LCFI1:
  66               		.cfi_def_cfa_offset 4
  67               		.cfi_offset 16, -3
  68 0014 1F93      		push r17
  69               	.LCFI2:
  70               		.cfi_def_cfa_offset 5
  71               		.cfi_offset 17, -4
  72 0016 CF93      		push r28
  73               	.LCFI3:
  74               		.cfi_def_cfa_offset 6
  75               		.cfi_offset 28, -5
  76 0018 DF93      		push r29
  77               	.LCFI4:
  78               		.cfi_def_cfa_offset 7
  79               		.cfi_offset 29, -6
  80               	/* prologue: function */
  81               	/* frame size = 0 */
  82               	/* stack size = 5 */
  83               	.L__stack_usage = 5
  84 001a F82E      		mov r15,r24
  85               	.LVL2:
  86 001c 00E0      		ldi r16,lo8(receivedBuffer)
  87 001e 10E0      		ldi r17,hi8(receivedBuffer)
  88               	.LBB42:
 152:setup.c       **** 	for (uint8_t x = 0; x < count; x++) {
  89               		.loc 1 152 0
  90 0020 E801      		movw r28,r16
  91               	.LVL3:
  92               	.L9:
  93 0022 8C2F      		mov r24,r28
  94 0024 801B      		sub r24,r16
  95               		.loc 1 152 0 is_stmt 0 discriminator 1
  96 0026 8F15      		cp r24,r15
  97 0028 00F4      		brsh .L11
 153:setup.c       **** 		receivedBuffer[x] = USART_Receive();
  98               		.loc 1 153 0 is_stmt 1 discriminator 2
  99 002a 0E94 0000 		call USART_Receive
 100               	.LVL4:
 101 002e 8993      		st Y+,r24
 102               	.LVL5:
 103 0030 00C0      		rjmp .L9
 104               	.L11:
 105               	/* epilogue start */
 106               	.LBE42:
 154:setup.c       **** 	}
 155:setup.c       **** }
 107               		.loc 1 155 0
 108 0032 DF91      		pop r29
 109 0034 CF91      		pop r28
 110               	.LVL6:
 111 0036 1F91      		pop r17
 112 0038 0F91      		pop r16
 113 003a FF90      		pop r15
 114               	.LVL7:
 115 003c 0895      		ret
 116               		.cfi_endproc
 117               	.LFE12:
 119               	.global	usart_read_chars
 121               	usart_read_chars:
 122               	.LFB13:
 156:setup.c       **** 
 157:setup.c       **** // Read the USART until a 0 (string terminator byte) is received
 158:setup.c       **** void usart_read_chars(void) {
 123               		.loc 1 158 0
 124               		.cfi_startproc
 125 003e CF93      		push r28
 126               	.LCFI5:
 127               		.cfi_def_cfa_offset 3
 128               		.cfi_offset 28, -2
 129               	/* prologue: function */
 130               	/* frame size = 0 */
 131               	/* stack size = 1 */
 132               	.L__stack_usage = 1
 133               	.LVL8:
 159:setup.c       **** 	uint8_t x = 0;
 134               		.loc 1 159 0
 135 0040 C0E0      		ldi r28,0
 136               	.LVL9:
 137               	.L14:
 160:setup.c       **** 	while (1) {
 161:setup.c       **** 		receivedBuffer[x] = USART_Receive();
 138               		.loc 1 161 0
 139 0042 0E94 0000 		call USART_Receive
 140               	.LVL10:
 141 0046 EC2F      		mov r30,r28
 142 0048 F0E0      		ldi r31,0
 143 004a E050      		subi r30,lo8(-(receivedBuffer))
 144 004c F040      		sbci r31,hi8(-(receivedBuffer))
 145 004e 8083      		st Z,r24
 162:setup.c       **** 		if (receivedBuffer[x] == 0) {
 146               		.loc 1 162 0
 147 0050 8823      		tst r24
 148 0052 01F0      		breq .L12
 163:setup.c       **** 			break;
 164:setup.c       **** 		}
 165:setup.c       **** 		x++;
 149               		.loc 1 165 0
 150 0054 CF5F      		subi r28,lo8(-(1))
 151               	.LVL11:
 166:setup.c       **** 	}
 152               		.loc 1 166 0
 153 0056 00C0      		rjmp .L14
 154               	.L12:
 155               	/* epilogue start */
 167:setup.c       **** }
 156               		.loc 1 167 0
 157 0058 CF91      		pop r28
 158               	.LVL12:
 159 005a 0895      		ret
 160               		.cfi_endproc
 161               	.LFE13:
 163               	.global	rd_wr_csmreq_cs2_reset
 165               	rd_wr_csmreq_cs2_reset:
 166               	.LFB14:
 168:setup.c       **** 
 169:setup.c       **** // Turn RD, WR, CS/MREQ and CS2 to high so they are deselected (reset state)
 170:setup.c       **** void rd_wr_csmreq_cs2_reset(void) {
 167               		.loc 1 170 0
 168               		.cfi_startproc
 169               	/* prologue: function */
 170               	/* frame size = 0 */
 171               	/* stack size = 0 */
 172               	.L__stack_usage = 0
 171:setup.c       **** 	cs2Pin_high; // CS2 off
 173               		.loc 1 171 0
 174 005c 979A      		sbi 0x12,7
 172:setup.c       **** 	cs_mreqPin_high; // CS/MREQ off
 175               		.loc 1 172 0
 176 005e 969A      		sbi 0x12,6
 173:setup.c       **** 	rdPin_high; // RD off
 177               		.loc 1 173 0
 178 0060 959A      		sbi 0x12,5
 174:setup.c       **** 	wrPin_high; // WR off
 179               		.loc 1 174 0
 180 0062 949A      		sbi 0x12,4
 181 0064 0895      		ret
 182               		.cfi_endproc
 183               	.LFE14:
 185               	.global	gb_mode
 187               	gb_mode:
 188               	.LFB15:
 175:setup.c       **** }
 176:setup.c       **** 
 177:setup.c       **** 
 178:setup.c       **** 
 179:setup.c       **** // ****** Gameboy / Gameboy Colour functions ******
 180:setup.c       **** 
 181:setup.c       **** // Set Gameboy mode
 182:setup.c       **** void gb_mode(void) {
 189               		.loc 1 182 0
 190               		.cfi_startproc
 191               	/* prologue: function */
 192               	/* frame size = 0 */
 193               	/* stack size = 0 */
 194               	.L__stack_usage = 0
 183:setup.c       **** 	// Set inputs
 184:setup.c       **** 	PORT_DATA7_0 = 0;
 195               		.loc 1 184 0
 196 0066 15BA      		out 0x15,__zero_reg__
 185:setup.c       **** 	DDR_DATA7_0 = 0;
 197               		.loc 1 185 0
 198 0068 14BA      		out 0x14,__zero_reg__
 186:setup.c       **** 	
 187:setup.c       **** 	// Set outputs
 188:setup.c       **** 	PORT_ADDR7_0 = 0;
 199               		.loc 1 188 0
 200 006a 18BA      		out 0x18,__zero_reg__
 189:setup.c       **** 	PORT_ADDR15_8 = 0;
 201               		.loc 1 189 0
 202 006c 1BBA      		out 0x1b,__zero_reg__
 190:setup.c       **** 	DDR_ADDR7_0 = 0xFF;
 203               		.loc 1 190 0
 204 006e 8FEF      		ldi r24,lo8(-1)
 205 0070 87BB      		out 0x17,r24
 191:setup.c       **** 	DDR_ADDR15_8 = 0xFF;
 206               		.loc 1 191 0
 207 0072 8ABB      		out 0x1a,r24
 208 0074 0895      		ret
 209               		.cfi_endproc
 210               	.LFE15:
 212               	.global	set_16bit_address
 214               	set_16bit_address:
 215               	.LFB16:
 192:setup.c       **** }
 193:setup.c       **** 
 194:setup.c       **** // Set the 16 bit address on A15-0
 195:setup.c       **** void set_16bit_address(uint16_t address) {
 216               		.loc 1 195 0
 217               		.cfi_startproc
 218               	.LVL13:
 219               	/* prologue: function */
 220               	/* frame size = 0 */
 221               	/* stack size = 0 */
 222               	.L__stack_usage = 0
 196:setup.c       **** 	PORT_ADDR15_8 = (address >> 8);
 223               		.loc 1 196 0
 224 0076 9BBB      		out 0x1b,r25
 197:setup.c       **** 	PORT_ADDR7_0 = (address & 0xFF);
 225               		.loc 1 197 0
 226 0078 88BB      		out 0x18,r24
 227 007a 0895      		ret
 228               		.cfi_endproc
 229               	.LFE16:
 231               	.global	read_8bit_data
 233               	read_8bit_data:
 234               	.LFB17:
 198:setup.c       **** }
 199:setup.c       **** 
 200:setup.c       **** // Set the address and read a byte from the 8 bit data line
 201:setup.c       **** uint8_t read_8bit_data(uint16_t address) {
 235               		.loc 1 201 0
 236               		.cfi_startproc
 237               	.LVL14:
 238               	/* prologue: function */
 239               	/* frame size = 0 */
 240               	/* stack size = 0 */
 241               	.L__stack_usage = 0
 202:setup.c       **** 	set_16bit_address(address);
 242               		.loc 1 202 0
 243 007c 0E94 0000 		call set_16bit_address
 244               	.LVL15:
 203:setup.c       **** 	
 204:setup.c       **** 	cs_mreqPin_low;
 245               		.loc 1 204 0
 246 0080 9698      		cbi 0x12,6
 205:setup.c       **** 	rdPin_low;
 247               		.loc 1 205 0
 248 0082 9598      		cbi 0x12,5
 206:setup.c       **** 	
 207:setup.c       **** 	asm volatile("nop"); // Delay a little (minimum needed is 1 nops, 2 nops for GB camera)
 249               		.loc 1 207 0
 250               	/* #APP */
 251               	 ;  207 "setup.c" 1
 252 0084 0000      		nop
 253               	 ;  0 "" 2
 208:setup.c       **** 	asm volatile("nop");
 254               		.loc 1 208 0
 255               	 ;  208 "setup.c" 1
 256 0086 0000      		nop
 257               	 ;  0 "" 2
 209:setup.c       **** 	uint8_t data = PIN_DATA7_0; // Read data
 258               		.loc 1 209 0
 259               	/* #NOAPP */
 260 0088 83B3      		in r24,0x13
 261               	.LVL16:
 210:setup.c       **** 	
 211:setup.c       **** 	rdPin_high;
 262               		.loc 1 211 0
 263 008a 959A      		sbi 0x12,5
 212:setup.c       **** 	cs_mreqPin_high;
 264               		.loc 1 212 0
 265 008c 969A      		sbi 0x12,6
 213:setup.c       **** 	
 214:setup.c       **** 	return data;
 215:setup.c       **** }
 266               		.loc 1 215 0
 267 008e 0895      		ret
 268               		.cfi_endproc
 269               	.LFE17:
 271               	.global	write_8bit_data
 273               	write_8bit_data:
 274               	.LFB18:
 216:setup.c       **** 
 217:setup.c       **** // Set the address and write a byte to the 8 bit data line and pulse cs/mREQ if writing to RAM
 218:setup.c       **** void write_8bit_data(uint16_t address, uint8_t data, uint8_t type) {
 275               		.loc 1 218 0
 276               		.cfi_startproc
 277               	.LVL17:
 278 0090 CF93      		push r28
 279               	.LCFI6:
 280               		.cfi_def_cfa_offset 3
 281               		.cfi_offset 28, -2
 282 0092 DF93      		push r29
 283               	.LCFI7:
 284               		.cfi_def_cfa_offset 4
 285               		.cfi_offset 29, -3
 286 0094 00D0      		rcall .
 287               	.LCFI8:
 288               		.cfi_def_cfa_offset 6
 289 0096 CDB7      		in r28,__SP_L__
 290 0098 DEB7      		in r29,__SP_H__
 291               	.LCFI9:
 292               		.cfi_def_cfa_register 28
 293               	/* prologue: function */
 294               	/* frame size = 2 */
 295               	/* stack size = 4 */
 296               	.L__stack_usage = 4
 219:setup.c       **** 	set_16bit_address(address);
 297               		.loc 1 219 0
 298 009a 4A83      		std Y+2,r20
 299 009c 6983      		std Y+1,r22
 300 009e 0E94 0000 		call set_16bit_address
 301               	.LVL18:
 220:setup.c       **** 	
 221:setup.c       **** 	DDR_DATA7_0 = 0xFF; // Set data pins as outputs
 302               		.loc 1 221 0
 303 00a2 8FEF      		ldi r24,lo8(-1)
 304 00a4 84BB      		out 0x14,r24
 222:setup.c       **** 	PORT_DATA7_0 = data; // Set data
 305               		.loc 1 222 0
 306 00a6 6981      		ldd r22,Y+1
 307 00a8 65BB      		out 0x15,r22
 223:setup.c       **** 	
 224:setup.c       **** 	// Pulse WR and mREQ if the type matches
 225:setup.c       **** 	wrPin_low;
 308               		.loc 1 225 0
 309 00aa 9498      		cbi 0x12,4
 226:setup.c       **** 	if (type == MEMORY_WRITE) {
 310               		.loc 1 226 0
 311 00ac 4A81      		ldd r20,Y+2
 312 00ae 4130      		cpi r20,lo8(1)
 313 00b0 01F4      		brne .L20
 227:setup.c       **** 		cs_mreqPin_low;
 314               		.loc 1 227 0
 315 00b2 9698      		cbi 0x12,6
 316               	.L20:
 228:setup.c       **** 	}
 229:setup.c       **** 	
 230:setup.c       **** 	asm volatile("nop");
 317               		.loc 1 230 0
 318               	/* #APP */
 319               	 ;  230 "setup.c" 1
 320 00b4 0000      		nop
 321               	 ;  0 "" 2
 231:setup.c       **** 	
 232:setup.c       **** 	if (type == MEMORY_WRITE) {
 322               		.loc 1 232 0
 323               	/* #NOAPP */
 324 00b6 4130      		cpi r20,lo8(1)
 325 00b8 01F4      		brne .L21
 233:setup.c       **** 		cs_mreqPin_high;
 326               		.loc 1 233 0
 327 00ba 969A      		sbi 0x12,6
 328               	.L21:
 234:setup.c       **** 	}
 235:setup.c       **** 	wrPin_high;
 329               		.loc 1 235 0
 330 00bc 949A      		sbi 0x12,4
 236:setup.c       **** 	
 237:setup.c       **** 	// Clear data outputs and set data pins as inputs
 238:setup.c       **** 	PORT_DATA7_0 = 0;
 331               		.loc 1 238 0
 332 00be 15BA      		out 0x15,__zero_reg__
 239:setup.c       **** 	DDR_DATA7_0 = 0;
 333               		.loc 1 239 0
 334 00c0 14BA      		out 0x14,__zero_reg__
 335               	/* epilogue start */
 240:setup.c       **** }
 336               		.loc 1 240 0
 337 00c2 0F90      		pop __tmp_reg__
 338 00c4 0F90      		pop __tmp_reg__
 339 00c6 DF91      		pop r29
 340 00c8 CF91      		pop r28
 341 00ca 0895      		ret
 342               		.cfi_endproc
 343               	.LFE18:
 345               	.global	gba_mode
 347               	gba_mode:
 348               	.LFB19:
 241:setup.c       **** 
 242:setup.c       **** 
 243:setup.c       **** 
 244:setup.c       **** // ****** Gameboy Advance functions ****** 
 245:setup.c       **** 
 246:setup.c       **** // Set GBA mode
 247:setup.c       **** void gba_mode(void) {
 349               		.loc 1 247 0
 350               		.cfi_startproc
 351               	/* prologue: function */
 352               	/* frame size = 0 */
 353               	/* stack size = 0 */
 354               	.L__stack_usage = 0
 248:setup.c       **** 	// Set outputs for reading ROM addresses as default
 249:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = 0;
 355               		.loc 1 249 0
 356 00cc 18BA      		out 0x18,__zero_reg__
 250:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = 0;
 357               		.loc 1 250 0
 358 00ce 1BBA      		out 0x1b,__zero_reg__
 251:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = 0;
 359               		.loc 1 251 0
 360 00d0 15BA      		out 0x15,__zero_reg__
 252:setup.c       **** 	GBA_DDR_ROM_ADDR7_0 = 0xFF;
 361               		.loc 1 252 0
 362 00d2 8FEF      		ldi r24,lo8(-1)
 363 00d4 87BB      		out 0x17,r24
 253:setup.c       **** 	GBA_DDR_ROM_ADDR15_8 = 0xFF;
 364               		.loc 1 253 0
 365 00d6 8ABB      		out 0x1a,r24
 254:setup.c       **** 	GBA_DDR_ROM_ADDR23_16 = 0xFF;
 366               		.loc 1 254 0
 367 00d8 84BB      		out 0x14,r24
 368 00da 0895      		ret
 369               		.cfi_endproc
 370               	.LFE19:
 372               	.global	gba_set_24bit_address
 374               	gba_set_24bit_address:
 375               	.LFB20:
 255:setup.c       **** }
 256:setup.c       **** 
 257:setup.c       **** // Set the 24 bit address on A23-0
 258:setup.c       **** void gba_set_24bit_address(uint32_t address) {	
 376               		.loc 1 258 0
 377               		.cfi_startproc
 378               	.LVL19:
 379 00dc 0F93      		push r16
 380               	.LCFI10:
 381               		.cfi_def_cfa_offset 3
 382               		.cfi_offset 16, -2
 383 00de 1F93      		push r17
 384               	.LCFI11:
 385               		.cfi_def_cfa_offset 4
 386               		.cfi_offset 17, -3
 387               	/* prologue: function */
 388               	/* frame size = 0 */
 389               	/* stack size = 2 */
 390               	.L__stack_usage = 2
 259:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = 0; // Set 0-23 address lines low and set as outputs
 391               		.loc 1 259 0
 392 00e0 15BA      		out 0x15,__zero_reg__
 260:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = 0;
 393               		.loc 1 260 0
 394 00e2 1BBA      		out 0x1b,__zero_reg__
 261:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = 0;
 395               		.loc 1 261 0
 396 00e4 18BA      		out 0x18,__zero_reg__
 262:setup.c       **** 	GBA_DDR_ROM_ADDR23_16 = 0xFF;
 397               		.loc 1 262 0
 398 00e6 2FEF      		ldi r18,lo8(-1)
 399 00e8 24BB      		out 0x14,r18
 263:setup.c       **** 	GBA_DDR_ROM_ADDR15_8 = 0xFF;
 400               		.loc 1 263 0
 401 00ea 2ABB      		out 0x1a,r18
 264:setup.c       **** 	GBA_DDR_ROM_ADDR7_0 = 0xFF;
 402               		.loc 1 264 0
 403 00ec 27BB      		out 0x17,r18
 265:setup.c       **** 	
 266:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = (address >> 16);
 404               		.loc 1 266 0
 405 00ee 8C01      		movw r16,r24
 406 00f0 2227      		clr r18
 407 00f2 3327      		clr r19
 408 00f4 05BB      		out 0x15,r16
 267:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = (address >> 8);
 409               		.loc 1 267 0
 410 00f6 072F      		mov r16,r23
 411 00f8 182F      		mov r17,r24
 412 00fa 292F      		mov r18,r25
 413 00fc 3327      		clr r19
 414 00fe 0BBB      		out 0x1b,r16
 268:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = (address & 0xFF);
 415               		.loc 1 268 0
 416 0100 68BB      		out 0x18,r22
 417               	/* epilogue start */
 269:setup.c       **** }
 418               		.loc 1 269 0
 419 0102 1F91      		pop r17
 420 0104 0F91      		pop r16
 421 0106 0895      		ret
 422               		.cfi_endproc
 423               	.LFE20:
 425               	.global	gba_read_16bit_data
 427               	gba_read_16bit_data:
 428               	.LFB21:
 270:setup.c       **** 
 271:setup.c       **** 
 272:setup.c       **** 
 273:setup.c       **** // ---------- ROM/SRAM ----------
 274:setup.c       **** 
 275:setup.c       **** // Read a byte from the 16 bit data line non-sequentially
 276:setup.c       **** uint16_t gba_read_16bit_data(uint32_t address) {
 429               		.loc 1 276 0
 430               		.cfi_startproc
 431               	.LVL20:
 432               	/* prologue: function */
 433               	/* frame size = 0 */
 434               	/* stack size = 0 */
 435               	.L__stack_usage = 0
 277:setup.c       **** 	gba_set_24bit_address(address);
 436               		.loc 1 277 0
 437 0108 0E94 0000 		call gba_set_24bit_address
 438               	.LVL21:
 278:setup.c       **** 	
 279:setup.c       **** 	cs_mreqPin_low;
 439               		.loc 1 279 0
 440 010c 9698      		cbi 0x12,6
 280:setup.c       **** 	
 281:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = 0; // Set address lines low and set as inputs
 441               		.loc 1 281 0
 442 010e 1BBA      		out 0x1b,__zero_reg__
 282:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = 0;
 443               		.loc 1 282 0
 444 0110 18BA      		out 0x18,__zero_reg__
 283:setup.c       **** 	GBA_DDR_ROM_ADDR15_8 = 0;
 445               		.loc 1 283 0
 446 0112 1ABA      		out 0x1a,__zero_reg__
 284:setup.c       **** 	GBA_DDR_ROM_ADDR7_0 = 0;
 447               		.loc 1 284 0
 448 0114 17BA      		out 0x17,__zero_reg__
 285:setup.c       **** 	
 286:setup.c       **** 	rdPin_low;
 449               		.loc 1 286 0
 450 0116 9598      		cbi 0x12,5
 287:setup.c       **** 	asm volatile("nop");
 451               		.loc 1 287 0
 452               	/* #APP */
 453               	 ;  287 "setup.c" 1
 454 0118 0000      		nop
 455               	 ;  0 "" 2
 288:setup.c       **** 	
 289:setup.c       **** 	uint16_t data = (GBA_PIN_ROM_DATA15_8 << 8) | GBA_PIN_ROM_DATA7_0; // Read data
 456               		.loc 1 289 0
 457               	/* #NOAPP */
 458 011a 29B3      		in r18,0x19
 459 011c 86B3      		in r24,0x16
 460               	.LVL22:
 290:setup.c       **** 	
 291:setup.c       **** 	rdPin_high;
 461               		.loc 1 291 0
 462 011e 959A      		sbi 0x12,5
 292:setup.c       **** 	cs_mreqPin_high;
 463               		.loc 1 292 0
 464 0120 969A      		sbi 0x12,6
 289:setup.c       **** 	
 465               		.loc 1 289 0
 466 0122 90E0      		ldi r25,0
 293:setup.c       **** 	
 294:setup.c       **** 	return data;
 295:setup.c       **** }
 467               		.loc 1 295 0
 468 0124 922B      		or r25,r18
 469 0126 0895      		ret
 470               		.cfi_endproc
 471               	.LFE21:
 473               	.global	gba_read_ram_8bit_data
 475               	gba_read_ram_8bit_data:
 476               	.LFB22:
 296:setup.c       **** 
 297:setup.c       **** // Set the address and read a byte from the 8 bit data line
 298:setup.c       **** uint8_t gba_read_ram_8bit_data(uint16_t address) {
 477               		.loc 1 298 0
 478               		.cfi_startproc
 479               	.LVL23:
 480               	/* prologue: function */
 481               	/* frame size = 0 */
 482               	/* stack size = 0 */
 483               	.L__stack_usage = 0
 299:setup.c       **** 	set_16bit_address(address);
 484               		.loc 1 299 0
 485 0128 0E94 0000 		call set_16bit_address
 486               	.LVL24:
 487               	.LBB43:
 488               	.LBB44:
 489               		.file 2 "c:\\winavr-20100110\\avr\\include\\util\\delay.h"
   1:c:\winavr-20100110\avr\include\util\delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:c:\winavr-20100110\avr\include\util\delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:c:\winavr-20100110\avr\include\util\delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:c:\winavr-20100110\avr\include\util\delay.h ****    All rights reserved.
   5:c:\winavr-20100110\avr\include\util\delay.h **** 
   6:c:\winavr-20100110\avr\include\util\delay.h ****    Redistribution and use in source and binary forms, with or without
   7:c:\winavr-20100110\avr\include\util\delay.h ****    modification, are permitted provided that the following conditions are met:
   8:c:\winavr-20100110\avr\include\util\delay.h **** 
   9:c:\winavr-20100110\avr\include\util\delay.h ****    * Redistributions of source code must retain the above copyright
  10:c:\winavr-20100110\avr\include\util\delay.h ****      notice, this list of conditions and the following disclaimer.
  11:c:\winavr-20100110\avr\include\util\delay.h **** 
  12:c:\winavr-20100110\avr\include\util\delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:c:\winavr-20100110\avr\include\util\delay.h ****      notice, this list of conditions and the following disclaimer in
  14:c:\winavr-20100110\avr\include\util\delay.h ****      the documentation and/or other materials provided with the
  15:c:\winavr-20100110\avr\include\util\delay.h ****      distribution.
  16:c:\winavr-20100110\avr\include\util\delay.h **** 
  17:c:\winavr-20100110\avr\include\util\delay.h ****    * Neither the name of the copyright holders nor the names of
  18:c:\winavr-20100110\avr\include\util\delay.h ****      contributors may be used to endorse or promote products derived
  19:c:\winavr-20100110\avr\include\util\delay.h ****      from this software without specific prior written permission.
  20:c:\winavr-20100110\avr\include\util\delay.h **** 
  21:c:\winavr-20100110\avr\include\util\delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:c:\winavr-20100110\avr\include\util\delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:c:\winavr-20100110\avr\include\util\delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:c:\winavr-20100110\avr\include\util\delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:c:\winavr-20100110\avr\include\util\delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:c:\winavr-20100110\avr\include\util\delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:c:\winavr-20100110\avr\include\util\delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:c:\winavr-20100110\avr\include\util\delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:c:\winavr-20100110\avr\include\util\delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:c:\winavr-20100110\avr\include\util\delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:c:\winavr-20100110\avr\include\util\delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:c:\winavr-20100110\avr\include\util\delay.h **** 
  33:c:\winavr-20100110\avr\include\util\delay.h **** /* $Id$ */
  34:c:\winavr-20100110\avr\include\util\delay.h **** 
  35:c:\winavr-20100110\avr\include\util\delay.h **** #ifndef _UTIL_DELAY_H_
  36:c:\winavr-20100110\avr\include\util\delay.h **** #define _UTIL_DELAY_H_ 1
  37:c:\winavr-20100110\avr\include\util\delay.h **** 
  38:c:\winavr-20100110\avr\include\util\delay.h **** #ifndef __HAS_DELAY_CYCLES
  39:c:\winavr-20100110\avr\include\util\delay.h **** #define __HAS_DELAY_CYCLES 1
  40:c:\winavr-20100110\avr\include\util\delay.h **** #endif
  41:c:\winavr-20100110\avr\include\util\delay.h **** 
  42:c:\winavr-20100110\avr\include\util\delay.h **** #include <inttypes.h>
  43:c:\winavr-20100110\avr\include\util\delay.h **** #include <util/delay_basic.h>
  44:c:\winavr-20100110\avr\include\util\delay.h **** #include <math.h>
  45:c:\winavr-20100110\avr\include\util\delay.h **** 
  46:c:\winavr-20100110\avr\include\util\delay.h **** /** \file */
  47:c:\winavr-20100110\avr\include\util\delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  48:c:\winavr-20100110\avr\include\util\delay.h ****     \code
  49:c:\winavr-20100110\avr\include\util\delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  50:c:\winavr-20100110\avr\include\util\delay.h ****     //#define F_CPU 14.7456E6
  51:c:\winavr-20100110\avr\include\util\delay.h ****     #include <util/delay.h>
  52:c:\winavr-20100110\avr\include\util\delay.h ****     \endcode
  53:c:\winavr-20100110\avr\include\util\delay.h **** 
  54:c:\winavr-20100110\avr\include\util\delay.h ****     \note As an alternative method, it is possible to pass the
  55:c:\winavr-20100110\avr\include\util\delay.h ****     F_CPU macro down to the compiler from the Makefile.
  56:c:\winavr-20100110\avr\include\util\delay.h ****     Obviously, in that case, no \c \#define statement should be
  57:c:\winavr-20100110\avr\include\util\delay.h ****     used.
  58:c:\winavr-20100110\avr\include\util\delay.h **** 
  59:c:\winavr-20100110\avr\include\util\delay.h ****     The functions in this header file are wrappers around the basic
  60:c:\winavr-20100110\avr\include\util\delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  61:c:\winavr-20100110\avr\include\util\delay.h ****     convenience functions where actual time values can be specified
  62:c:\winavr-20100110\avr\include\util\delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  63:c:\winavr-20100110\avr\include\util\delay.h ****     that compile-time constant expressions will be eliminated by
  64:c:\winavr-20100110\avr\include\util\delay.h ****     compiler optimization so floating-point expressions can be used
  65:c:\winavr-20100110\avr\include\util\delay.h ****     to calculate the number of delay cycles needed based on the CPU
  66:c:\winavr-20100110\avr\include\util\delay.h ****     frequency passed by the macro F_CPU.
  67:c:\winavr-20100110\avr\include\util\delay.h **** 
  68:c:\winavr-20100110\avr\include\util\delay.h ****     \note In order for these functions to work as intended, compiler
  69:c:\winavr-20100110\avr\include\util\delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  70:c:\winavr-20100110\avr\include\util\delay.h ****     <em>must</em> be an expression that is a known constant at
  71:c:\winavr-20100110\avr\include\util\delay.h ****     compile-time.  If these requirements are not met, the resulting
  72:c:\winavr-20100110\avr\include\util\delay.h ****     delay will be much longer (and basically unpredictable), and
  73:c:\winavr-20100110\avr\include\util\delay.h ****     applications that otherwise do not use floating-point calculations
  74:c:\winavr-20100110\avr\include\util\delay.h ****     will experience severe code bloat by the floating-point library
  75:c:\winavr-20100110\avr\include\util\delay.h ****     routines linked into the application.
  76:c:\winavr-20100110\avr\include\util\delay.h **** 
  77:c:\winavr-20100110\avr\include\util\delay.h ****     The functions available allow the specification of microsecond, and
  78:c:\winavr-20100110\avr\include\util\delay.h ****     millisecond delays directly, using the application-supplied macro
  79:c:\winavr-20100110\avr\include\util\delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  80:c:\winavr-20100110\avr\include\util\delay.h **** 
  81:c:\winavr-20100110\avr\include\util\delay.h **** */
  82:c:\winavr-20100110\avr\include\util\delay.h **** 
  83:c:\winavr-20100110\avr\include\util\delay.h **** #if !defined(__DOXYGEN__)
  84:c:\winavr-20100110\avr\include\util\delay.h **** static inline void _delay_us(double __us) __attribute__((always_inline));
  85:c:\winavr-20100110\avr\include\util\delay.h **** static inline void _delay_ms(double __ms) __attribute__((always_inline));
  86:c:\winavr-20100110\avr\include\util\delay.h **** #endif
  87:c:\winavr-20100110\avr\include\util\delay.h **** 
  88:c:\winavr-20100110\avr\include\util\delay.h **** #ifndef F_CPU
  89:c:\winavr-20100110\avr\include\util\delay.h **** /* prevent compiler error by supplying a default */
  90:c:\winavr-20100110\avr\include\util\delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  91:c:\winavr-20100110\avr\include\util\delay.h **** # define F_CPU 1000000UL
  92:c:\winavr-20100110\avr\include\util\delay.h **** #endif
  93:c:\winavr-20100110\avr\include\util\delay.h **** 
  94:c:\winavr-20100110\avr\include\util\delay.h **** #ifndef __OPTIMIZE__
  95:c:\winavr-20100110\avr\include\util\delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
  96:c:\winavr-20100110\avr\include\util\delay.h **** #endif
  97:c:\winavr-20100110\avr\include\util\delay.h **** 
  98:c:\winavr-20100110\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
  99:c:\winavr-20100110\avr\include\util\delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 100:c:\winavr-20100110\avr\include\util\delay.h ****   __STDC_HOSTED__
 101:c:\winavr-20100110\avr\include\util\delay.h **** #  include <math.h>
 102:c:\winavr-20100110\avr\include\util\delay.h **** #endif
 103:c:\winavr-20100110\avr\include\util\delay.h **** 
 104:c:\winavr-20100110\avr\include\util\delay.h **** /**
 105:c:\winavr-20100110\avr\include\util\delay.h ****    \ingroup util_delay
 106:c:\winavr-20100110\avr\include\util\delay.h **** 
 107:c:\winavr-20100110\avr\include\util\delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 108:c:\winavr-20100110\avr\include\util\delay.h **** 
 109:c:\winavr-20100110\avr\include\util\delay.h ****    The macro F_CPU is supposed to be defined to a
 110:c:\winavr-20100110\avr\include\util\delay.h ****    constant defining the CPU clock frequency (in Hertz).
 111:c:\winavr-20100110\avr\include\util\delay.h **** 
 112:c:\winavr-20100110\avr\include\util\delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 113:c:\winavr-20100110\avr\include\util\delay.h **** 
 114:c:\winavr-20100110\avr\include\util\delay.h ****    When the user request delay which exceed the maximum possible one,
 115:c:\winavr-20100110\avr\include\util\delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 116:c:\winavr-20100110\avr\include\util\delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 117:c:\winavr-20100110\avr\include\util\delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 118:c:\winavr-20100110\avr\include\util\delay.h ****    user will not be informed about decreased resolution.
 119:c:\winavr-20100110\avr\include\util\delay.h **** 
 120:c:\winavr-20100110\avr\include\util\delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 121:c:\winavr-20100110\avr\include\util\delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 122:c:\winavr-20100110\avr\include\util\delay.h ****    values greater than the maximal possible delay, overflows results in
 123:c:\winavr-20100110\avr\include\util\delay.h ****    no delay i.e., 0ms.
 124:c:\winavr-20100110\avr\include\util\delay.h **** 
 125:c:\winavr-20100110\avr\include\util\delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 126:c:\winavr-20100110\avr\include\util\delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 127:c:\winavr-20100110\avr\include\util\delay.h ****    the user gets atleast __us microseconds of delay.
 128:c:\winavr-20100110\avr\include\util\delay.h **** 
 129:c:\winavr-20100110\avr\include\util\delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 130:c:\winavr-20100110\avr\include\util\delay.h ****    to round down and round to closest integer.
 131:c:\winavr-20100110\avr\include\util\delay.h **** 
 132:c:\winavr-20100110\avr\include\util\delay.h ****    Note: The new implementation of _delay_ms(double __ms) with 
 133:c:\winavr-20100110\avr\include\util\delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible. 
 134:c:\winavr-20100110\avr\include\util\delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 135:c:\winavr-20100110\avr\include\util\delay.h ****    Also, the backward compatible
 136:c:\winavr-20100110\avr\include\util\delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 137:c:\winavr-20100110\avr\include\util\delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 138:c:\winavr-20100110\avr\include\util\delay.h ****    required for rounding are not available to the compiler then.
 139:c:\winavr-20100110\avr\include\util\delay.h **** 
 140:c:\winavr-20100110\avr\include\util\delay.h ****  */
 141:c:\winavr-20100110\avr\include\util\delay.h **** void
 142:c:\winavr-20100110\avr\include\util\delay.h **** _delay_ms(double __ms)
 143:c:\winavr-20100110\avr\include\util\delay.h **** {
 144:c:\winavr-20100110\avr\include\util\delay.h **** 	double __tmp ; 
 145:c:\winavr-20100110\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 146:c:\winavr-20100110\avr\include\util\delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 147:c:\winavr-20100110\avr\include\util\delay.h ****   __STDC_HOSTED__
 148:c:\winavr-20100110\avr\include\util\delay.h **** 	uint32_t __ticks_dc;
 149:c:\winavr-20100110\avr\include\util\delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 150:c:\winavr-20100110\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 151:c:\winavr-20100110\avr\include\util\delay.h **** 
 152:c:\winavr-20100110\avr\include\util\delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 153:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 154:c:\winavr-20100110\avr\include\util\delay.h **** 
 155:c:\winavr-20100110\avr\include\util\delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 156:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 157:c:\winavr-20100110\avr\include\util\delay.h **** 
 158:c:\winavr-20100110\avr\include\util\delay.h **** 	#else
 159:c:\winavr-20100110\avr\include\util\delay.h **** 		//round up by default
 160:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 161:c:\winavr-20100110\avr\include\util\delay.h **** 	#endif
 162:c:\winavr-20100110\avr\include\util\delay.h **** 
 163:c:\winavr-20100110\avr\include\util\delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 164:c:\winavr-20100110\avr\include\util\delay.h **** 
 165:c:\winavr-20100110\avr\include\util\delay.h **** #else
 166:c:\winavr-20100110\avr\include\util\delay.h **** 	uint16_t __ticks;
 167:c:\winavr-20100110\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 4e3) * __ms;
 168:c:\winavr-20100110\avr\include\util\delay.h **** 	if (__tmp < 1.0)
 169:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks = 1;
 170:c:\winavr-20100110\avr\include\util\delay.h **** 	else if (__tmp > 65535)
 171:c:\winavr-20100110\avr\include\util\delay.h **** 	{
 172:c:\winavr-20100110\avr\include\util\delay.h **** 		//	__ticks = requested delay in 1/10 ms
 173:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 174:c:\winavr-20100110\avr\include\util\delay.h **** 		while(__ticks)
 175:c:\winavr-20100110\avr\include\util\delay.h **** 		{
 176:c:\winavr-20100110\avr\include\util\delay.h **** 			// wait 1/10 ms
 177:c:\winavr-20100110\avr\include\util\delay.h **** 			_delay_loop_2(((F_CPU) / 4e3) / 10);
 178:c:\winavr-20100110\avr\include\util\delay.h **** 			__ticks --;
 179:c:\winavr-20100110\avr\include\util\delay.h **** 		}
 180:c:\winavr-20100110\avr\include\util\delay.h **** 		return;
 181:c:\winavr-20100110\avr\include\util\delay.h **** 	}
 182:c:\winavr-20100110\avr\include\util\delay.h **** 	else
 183:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks = (uint16_t)__tmp;
 184:c:\winavr-20100110\avr\include\util\delay.h **** 	_delay_loop_2(__ticks);
 185:c:\winavr-20100110\avr\include\util\delay.h **** #endif
 186:c:\winavr-20100110\avr\include\util\delay.h **** }
 187:c:\winavr-20100110\avr\include\util\delay.h **** 
 188:c:\winavr-20100110\avr\include\util\delay.h **** /**
 189:c:\winavr-20100110\avr\include\util\delay.h ****    \ingroup util_delay
 190:c:\winavr-20100110\avr\include\util\delay.h **** 
 191:c:\winavr-20100110\avr\include\util\delay.h ****    Perform a delay of \c __us microseconds, using _delay_loop_1().
 192:c:\winavr-20100110\avr\include\util\delay.h **** 
 193:c:\winavr-20100110\avr\include\util\delay.h ****    The macro F_CPU is supposed to be defined to a
 194:c:\winavr-20100110\avr\include\util\delay.h ****    constant defining the CPU clock frequency (in Hertz).
 195:c:\winavr-20100110\avr\include\util\delay.h **** 
 196:c:\winavr-20100110\avr\include\util\delay.h ****    The maximal possible delay is 768 us / F_CPU in MHz.
 197:c:\winavr-20100110\avr\include\util\delay.h **** 
 198:c:\winavr-20100110\avr\include\util\delay.h ****    If the user requests a delay greater than the maximal possible one,
 199:c:\winavr-20100110\avr\include\util\delay.h ****    _delay_us() will automatically call _delay_ms() instead.  The user
 200:c:\winavr-20100110\avr\include\util\delay.h ****    will not be informed about this case.
 201:c:\winavr-20100110\avr\include\util\delay.h **** 
 202:c:\winavr-20100110\avr\include\util\delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 203:c:\winavr-20100110\avr\include\util\delay.h ****    support, maximal possible delay is 4294967.295 us/ F_CPU in MHz. For
 204:c:\winavr-20100110\avr\include\util\delay.h ****    values greater than the maximal possible delay, overflow results in
 205:c:\winavr-20100110\avr\include\util\delay.h ****    no delay i.e., 0us.
 206:c:\winavr-20100110\avr\include\util\delay.h ****   
 207:c:\winavr-20100110\avr\include\util\delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 208:c:\winavr-20100110\avr\include\util\delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 209:c:\winavr-20100110\avr\include\util\delay.h ****    the user gets atleast __us microseconds of delay.
 210:c:\winavr-20100110\avr\include\util\delay.h **** 
 211:c:\winavr-20100110\avr\include\util\delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 212:c:\winavr-20100110\avr\include\util\delay.h ****    to round down and round to closest integer.
 213:c:\winavr-20100110\avr\include\util\delay.h ****  
 214:c:\winavr-20100110\avr\include\util\delay.h ****    Note: The new implementation of _delay_us(double __us) with 
 215:c:\winavr-20100110\avr\include\util\delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible.
 216:c:\winavr-20100110\avr\include\util\delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 217:c:\winavr-20100110\avr\include\util\delay.h ****    Also, the backward compatible
 218:c:\winavr-20100110\avr\include\util\delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 219:c:\winavr-20100110\avr\include\util\delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 220:c:\winavr-20100110\avr\include\util\delay.h ****    required for rounding are not available to the compiler then.
 221:c:\winavr-20100110\avr\include\util\delay.h **** 
 222:c:\winavr-20100110\avr\include\util\delay.h ****  */
 223:c:\winavr-20100110\avr\include\util\delay.h **** void
 224:c:\winavr-20100110\avr\include\util\delay.h **** _delay_us(double __us)
 225:c:\winavr-20100110\avr\include\util\delay.h **** {
 226:c:\winavr-20100110\avr\include\util\delay.h **** 	double __tmp ; 
 227:c:\winavr-20100110\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 228:c:\winavr-20100110\avr\include\util\delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 229:c:\winavr-20100110\avr\include\util\delay.h ****   __STDC_HOSTED__
 230:c:\winavr-20100110\avr\include\util\delay.h **** 	uint32_t __ticks_dc;
 231:c:\winavr-20100110\avr\include\util\delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 232:c:\winavr-20100110\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 233:c:\winavr-20100110\avr\include\util\delay.h **** 
 234:c:\winavr-20100110\avr\include\util\delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 235:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 236:c:\winavr-20100110\avr\include\util\delay.h **** 
 237:c:\winavr-20100110\avr\include\util\delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 238:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 239:c:\winavr-20100110\avr\include\util\delay.h **** 
 240:c:\winavr-20100110\avr\include\util\delay.h **** 	#else
 241:c:\winavr-20100110\avr\include\util\delay.h **** 		//round up by default
 242:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 243:c:\winavr-20100110\avr\include\util\delay.h **** 	#endif
 244:c:\winavr-20100110\avr\include\util\delay.h **** 
 245:c:\winavr-20100110\avr\include\util\delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 490               		.loc 2 245 0
 491 012c 8AE1      		ldi r24,lo8(26)
 492 012e 8A95      		1: dec r24
 493 0130 01F4      		brne 1b
 494 0132 00C0      		rjmp .
 495               	.LBE44:
 496               	.LBE43:
 300:setup.c       **** 	_delay_us(10);
 301:setup.c       **** 	rdPin_low;
 497               		.loc 1 301 0
 498 0134 9598      		cbi 0x12,5
 499               	.LVL25:
 500               	.LBB45:
 501               	.LBB46:
 502               		.loc 2 245 0
 503 0136 8AE1      		ldi r24,lo8(26)
 504 0138 8A95      		1: dec r24
 505 013a 01F4      		brne 1b
 506 013c 00C0      		rjmp .
 507               	.LBE46:
 508               	.LBE45:
 302:setup.c       **** 	_delay_us(10);
 303:setup.c       **** 	cs2Pin_low; // CS2 pin low for SRAM/Flash select
 509               		.loc 1 303 0
 510 013e 9798      		cbi 0x12,7
 304:setup.c       **** 	
 305:setup.c       **** 	asm volatile("nop"); // Delay a little (minimum needed is 2)
 511               		.loc 1 305 0
 512               	/* #APP */
 513               	 ;  305 "setup.c" 1
 514 0140 0000      		nop
 515               	 ;  0 "" 2
 306:setup.c       **** 	asm volatile("nop");
 516               		.loc 1 306 0
 517               	 ;  306 "setup.c" 1
 518 0142 0000      		nop
 519               	 ;  0 "" 2
 520               	.LVL26:
 521               	/* #NOAPP */
 522               	.LBB47:
 523               	.LBB48:
 524               		.loc 2 245 0
 525 0144 8AE1      		ldi r24,lo8(26)
 526 0146 8A95      		1: dec r24
 527 0148 01F4      		brne 1b
 528 014a 00C0      		rjmp .
 529               	.LBE48:
 530               	.LBE47:
 307:setup.c       **** 	
 308:setup.c       **** 	_delay_us(10);
 309:setup.c       **** 	
 310:setup.c       **** 	uint8_t data = GBA_PIN_RAM_DATA7_0; // Read data
 531               		.loc 1 310 0
 532 014c 83B3      		in r24,0x13
 533               	.LVL27:
 311:setup.c       **** 	
 312:setup.c       **** 	cs2Pin_high;
 534               		.loc 1 312 0
 535 014e 979A      		sbi 0x12,7
 313:setup.c       **** 	rdPin_high;
 536               		.loc 1 313 0
 537 0150 959A      		sbi 0x12,5
 314:setup.c       **** 	
 315:setup.c       **** 	return data;
 316:setup.c       **** }
 538               		.loc 1 316 0
 539 0152 0895      		ret
 540               		.cfi_endproc
 541               	.LFE22:
 543               	.global	gba_write_ram_8bit_data
 545               	gba_write_ram_8bit_data:
 546               	.LFB23:
 317:setup.c       **** 
 318:setup.c       **** // Set the address and write a byte to the 8 bit data line 
 319:setup.c       **** void gba_write_ram_8bit_data(uint16_t address, uint8_t data) {
 547               		.loc 1 319 0
 548               		.cfi_startproc
 549               	.LVL28:
 550 0154 CF93      		push r28
 551               	.LCFI12:
 552               		.cfi_def_cfa_offset 3
 553               		.cfi_offset 28, -2
 554 0156 DF93      		push r29
 555               	.LCFI13:
 556               		.cfi_def_cfa_offset 4
 557               		.cfi_offset 29, -3
 558 0158 1F92      		push __zero_reg__
 559               	.LCFI14:
 560               		.cfi_def_cfa_offset 5
 561 015a CDB7      		in r28,__SP_L__
 562 015c DEB7      		in r29,__SP_H__
 563               	.LCFI15:
 564               		.cfi_def_cfa_register 28
 565               	/* prologue: function */
 566               	/* frame size = 1 */
 567               	/* stack size = 3 */
 568               	.L__stack_usage = 3
 320:setup.c       **** 	set_16bit_address(address);
 569               		.loc 1 320 0
 570 015e 6983      		std Y+1,r22
 571 0160 0E94 0000 		call set_16bit_address
 572               	.LVL29:
 321:setup.c       **** 	
 322:setup.c       **** 	GBA_DDR_RAM_DATA7_0 = 0xFF; // Set data pins as outputs
 573               		.loc 1 322 0
 574 0164 8FEF      		ldi r24,lo8(-1)
 575 0166 84BB      		out 0x14,r24
 323:setup.c       **** 	GBA_PORT_RAM_DATA7_0 = data; // Set data
 576               		.loc 1 323 0
 577 0168 6981      		ldd r22,Y+1
 578 016a 65BB      		out 0x15,r22
 324:setup.c       **** 	
 325:setup.c       **** 	// Pulse WR
 326:setup.c       **** 	wrPin_low;
 579               		.loc 1 326 0
 580 016c 9498      		cbi 0x12,4
 327:setup.c       **** 	cs2Pin_low; // CS2 pin low for SRAM/Flash select
 581               		.loc 1 327 0
 582 016e 9798      		cbi 0x12,7
 328:setup.c       **** 	
 329:setup.c       **** 	asm volatile("nop");
 583               		.loc 1 329 0
 584               	/* #APP */
 585               	 ;  329 "setup.c" 1
 586 0170 0000      		nop
 587               	 ;  0 "" 2
 330:setup.c       **** 	asm volatile("nop");
 588               		.loc 1 330 0
 589               	 ;  330 "setup.c" 1
 590 0172 0000      		nop
 591               	 ;  0 "" 2
 331:setup.c       **** 	
 332:setup.c       **** 	cs2Pin_high;
 592               		.loc 1 332 0
 593               	/* #NOAPP */
 594 0174 979A      		sbi 0x12,7
 333:setup.c       **** 	wrPin_high;
 595               		.loc 1 333 0
 596 0176 949A      		sbi 0x12,4
 334:setup.c       **** 	
 335:setup.c       **** 	// Clear data outputs and set data pins as inputs
 336:setup.c       **** 	GBA_PORT_RAM_DATA7_0 = 0;
 597               		.loc 1 336 0
 598 0178 15BA      		out 0x15,__zero_reg__
 337:setup.c       **** 	GBA_DDR_RAM_DATA7_0 = 0;
 599               		.loc 1 337 0
 600 017a 14BA      		out 0x14,__zero_reg__
 601               	/* epilogue start */
 338:setup.c       **** }
 602               		.loc 1 338 0
 603 017c 0F90      		pop __tmp_reg__
 604 017e DF91      		pop r29
 605 0180 CF91      		pop r28
 606 0182 0895      		ret
 607               		.cfi_endproc
 608               	.LFE23:
 610               	.global	gba_eeprom_mode
 612               	gba_eeprom_mode:
 613               	.LFB24:
 339:setup.c       **** 
 340:setup.c       **** 
 341:setup.c       **** 
 342:setup.c       **** // ---------- EEPROM ----------
 343:setup.c       **** 
 344:setup.c       **** // Set address/data all high (includes AD0/A23)
 345:setup.c       **** void gba_eeprom_mode (void) {
 614               		.loc 1 345 0
 615               		.cfi_startproc
 616               	/* prologue: function */
 617               	/* frame size = 0 */
 618               	/* stack size = 0 */
 619               	.L__stack_usage = 0
 346:setup.c       **** 	GBA_DDR_ROM_ADDR7_0 = 0xFF;
 620               		.loc 1 346 0
 621 0184 8FEF      		ldi r24,lo8(-1)
 622 0186 87BB      		out 0x17,r24
 347:setup.c       **** 	GBA_DDR_ROM_ADDR15_8 = 0xFF;
 623               		.loc 1 347 0
 624 0188 8ABB      		out 0x1a,r24
 348:setup.c       **** 	GBA_DDR_ROM_ADDR23_16 = 0xFF;
 625               		.loc 1 348 0
 626 018a 84BB      		out 0x14,r24
 349:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = 0x80;
 627               		.loc 1 349 0
 628 018c 90E8      		ldi r25,lo8(-128)
 629 018e 98BB      		out 0x18,r25
 350:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = 0xFF;
 630               		.loc 1 350 0
 631 0190 8BBB      		out 0x1b,r24
 351:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = 0xFF;
 632               		.loc 1 351 0
 633 0192 85BB      		out 0x15,r24
 634 0194 0895      		ret
 635               		.cfi_endproc
 636               	.LFE24:
 638               	.global	gba_eeprom_set_address
 640               	gba_eeprom_set_address:
 641               	.LFB25:
 352:setup.c       **** }
 353:setup.c       **** 
 354:setup.c       **** // Send out EEPROM address serially (WR clock, AD0 data out)
 355:setup.c       **** void gba_eeprom_set_address(uint16_t address, uint8_t eepromSize, uint8_t command) {
 642               		.loc 1 355 0
 643               		.cfi_startproc
 644               	.LVL30:
 645               	/* prologue: function */
 646               	/* frame size = 0 */
 647               	/* stack size = 0 */
 648               	.L__stack_usage = 0
 356:setup.c       **** 	cs_mreqPin_low;
 649               		.loc 1 356 0
 650 0196 9698      		cbi 0x12,6
 651               	.LVL31:
 357:setup.c       **** 	
 358:setup.c       **** 	int8_t x = 0;
 359:setup.c       **** 	if (eepromSize == EEPROM_64KBIT) {
 652               		.loc 1 359 0
 653 0198 6230      		cpi r22,lo8(2)
 654 019a 01F4      		brne .L29
 360:setup.c       **** 		if (command == EEPROM_READ) {
 655               		.loc 1 360 0
 656 019c 4111      		cpse r20,__zero_reg__
 657 019e 00C0      		rjmp .L30
 361:setup.c       **** 			address |= (1<<15) | (1<<14); // Set upper 2 bits high for read request
 658               		.loc 1 361 0
 659 01a0 906C      		ori r25,192
 660               	.LVL32:
 661               	.L39:
 362:setup.c       **** 		}
 363:setup.c       **** 		else {
 364:setup.c       **** 			address |= (1<<15); // Set upper 1 bit high for write request
 365:setup.c       **** 		}
 366:setup.c       **** 		x = 15;
 662               		.loc 1 366 0
 663 01a2 5FE0      		ldi r21,lo8(15)
 664               	.L32:
 665               	.LVL33:
 367:setup.c       **** 	}
 368:setup.c       **** 	else {
 369:setup.c       **** 		if (command == EEPROM_READ) {
 370:setup.c       **** 			address |= (1<<7) | (1<<6);
 371:setup.c       **** 		}
 372:setup.c       **** 		else {
 373:setup.c       **** 			address |= (1<<7);
 374:setup.c       **** 		}
 375:setup.c       **** 		x = 7;
 376:setup.c       **** 	}
 377:setup.c       **** 	
 378:setup.c       **** 	// Loop through address, 8 or 16 bits depending on EEPROM (includes the 2 bits for request type)
 379:setup.c       **** 	while (x >= 0) {
 380:setup.c       **** 		if (address & (1<<x)) {
 666               		.loc 1 380 0 discriminator 1
 667 01a4 61E0      		ldi r22,lo8(1)
 668 01a6 70E0      		ldi r23,0
 669               	.LVL34:
 670 01a8 00C0      		rjmp .L31
 671               	.LVL35:
 672               	.L30:
 364:setup.c       **** 		}
 673               		.loc 1 364 0
 674 01aa 9068      		ori r25,128
 675               	.LVL36:
 676 01ac 00C0      		rjmp .L39
 677               	.L29:
 369:setup.c       **** 			address |= (1<<7) | (1<<6);
 678               		.loc 1 369 0
 679 01ae 4111      		cpse r20,__zero_reg__
 680 01b0 00C0      		rjmp .L33
 370:setup.c       **** 		}
 681               		.loc 1 370 0
 682 01b2 806C      		ori r24,192
 683               	.LVL37:
 684 01b4 00C0      		rjmp .L38
 685               	.L33:
 373:setup.c       **** 		}
 686               		.loc 1 373 0
 687 01b6 8068      		ori r24,128
 688               	.LVL38:
 689               	.L38:
 375:setup.c       **** 	}
 690               		.loc 1 375 0
 691 01b8 57E0      		ldi r21,lo8(7)
 692 01ba 00C0      		rjmp .L32
 693               	.LVL39:
 694               	.L34:
 381:setup.c       **** 			ad0Pin_high;
 382:setup.c       **** 		}
 383:setup.c       **** 		else {
 384:setup.c       **** 			ad0Pin_low;
 695               		.loc 1 384 0
 696 01bc C098      		cbi 0x18,0
 697               	.L35:
 385:setup.c       **** 		}
 386:setup.c       **** 		
 387:setup.c       **** 		wrPin_low; // CLK
 698               		.loc 1 387 0
 699 01be 9498      		cbi 0x12,4
 388:setup.c       **** 		asm ("nop");
 700               		.loc 1 388 0
 701               	/* #APP */
 702               	 ;  388 "setup.c" 1
 703 01c0 0000      		nop
 704               	 ;  0 "" 2
 389:setup.c       **** 		asm ("nop");
 705               		.loc 1 389 0
 706               	 ;  389 "setup.c" 1
 707 01c2 0000      		nop
 708               	 ;  0 "" 2
 390:setup.c       **** 		wrPin_high; 
 709               		.loc 1 390 0
 710               	/* #NOAPP */
 711 01c4 949A      		sbi 0x12,4
 391:setup.c       **** 		asm ("nop");
 712               		.loc 1 391 0
 713               	/* #APP */
 714               	 ;  391 "setup.c" 1
 715 01c6 0000      		nop
 716               	 ;  0 "" 2
 392:setup.c       **** 		asm ("nop");
 717               		.loc 1 392 0
 718               	 ;  392 "setup.c" 1
 719 01c8 0000      		nop
 720               	 ;  0 "" 2
 721               	/* #NOAPP */
 722 01ca 5150      		subi r21,lo8(-(-1))
 723               	.LVL40:
 379:setup.c       **** 		if (address & (1<<x)) {
 724               		.loc 1 379 0
 725 01cc 57FD      		sbrc r21,7
 726 01ce 00C0      		rjmp .L40
 727               	.L31:
 380:setup.c       **** 			ad0Pin_high;
 728               		.loc 1 380 0
 729 01d0 9B01      		movw r18,r22
 730 01d2 052E      		mov r0,r21
 731 01d4 00C0      		rjmp 2f
 732               		1:
 733 01d6 220F      		lsl r18
 734 01d8 331F      		rol r19
 735               		2:
 736 01da 0A94      		dec r0
 737 01dc 02F4      		brpl 1b
 738 01de 2823      		and r18,r24
 739 01e0 3923      		and r19,r25
 740 01e2 232B      		or r18,r19
 741 01e4 01F0      		breq .L34
 381:setup.c       **** 		}
 742               		.loc 1 381 0
 743 01e6 C09A      		sbi 0x18,0
 744 01e8 00C0      		rjmp .L35
 745               	.L40:
 393:setup.c       **** 		
 394:setup.c       **** 		x--;
 395:setup.c       **** 	}
 396:setup.c       **** 	
 397:setup.c       **** 	// Only send stop bit (0) and WR/CS high if reading, as writing is done in 1 continuous chunk
 398:setup.c       **** 	if (command == EEPROM_READ) {  
 746               		.loc 1 398 0
 747 01ea 4111      		cpse r20,__zero_reg__
 748 01ec 00C0      		rjmp .L28
 399:setup.c       **** 		ad0Pin_low;
 749               		.loc 1 399 0
 750 01ee C098      		cbi 0x18,0
 400:setup.c       **** 		asm ("nop");
 751               		.loc 1 400 0
 752               	/* #APP */
 753               	 ;  400 "setup.c" 1
 754 01f0 0000      		nop
 755               	 ;  0 "" 2
 401:setup.c       **** 		wrPin_low;
 756               		.loc 1 401 0
 757               	/* #NOAPP */
 758 01f2 9498      		cbi 0x12,4
 402:setup.c       **** 		asm ("nop");
 759               		.loc 1 402 0
 760               	/* #APP */
 761               	 ;  402 "setup.c" 1
 762 01f4 0000      		nop
 763               	 ;  0 "" 2
 403:setup.c       **** 		asm ("nop");
 764               		.loc 1 403 0
 765               	 ;  403 "setup.c" 1
 766 01f6 0000      		nop
 767               	 ;  0 "" 2
 404:setup.c       **** 		
 405:setup.c       **** 		wrPin_high;
 768               		.loc 1 405 0
 769               	/* #NOAPP */
 770 01f8 949A      		sbi 0x12,4
 406:setup.c       **** 		cs_mreqPin_high;
 771               		.loc 1 406 0
 772 01fa 969A      		sbi 0x12,6
 773               	.L28:
 774 01fc 0895      		ret
 775               		.cfi_endproc
 776               	.LFE25:
 778               	.global	gba_eeprom_read
 780               	gba_eeprom_read:
 781               	.LFB26:
 407:setup.c       **** 	}
 408:setup.c       **** }
 409:setup.c       **** 
 410:setup.c       **** // Read 8 bytes from the EEPROM address, data is valid on rising edge
 411:setup.c       **** void gba_eeprom_read(uint16_t address, uint8_t eepromSize) {
 782               		.loc 1 411 0
 783               		.cfi_startproc
 784               	.LVL41:
 785               	/* prologue: function */
 786               	/* frame size = 0 */
 787               	/* stack size = 0 */
 788               	.L__stack_usage = 0
 412:setup.c       **** 	gba_eeprom_set_address(address, eepromSize, EEPROM_READ);
 789               		.loc 1 412 0
 790 01fe 40E0      		ldi r20,0
 791 0200 0E94 0000 		call gba_eeprom_set_address
 792               	.LVL42:
 413:setup.c       **** 	
 414:setup.c       **** 	// Set AD0 pin as input
 415:setup.c       **** 	GBA_PORT_EEPROM_DATA7_0 &= ~(1<<AD0);
 793               		.loc 1 415 0
 794 0204 C098      		cbi 0x18,0
 416:setup.c       **** 	GBA_DDR_EEPROM_DATA7_0 &= ~(1<<AD0);
 795               		.loc 1 416 0
 796 0206 B898      		cbi 0x17,0
 417:setup.c       **** 	
 418:setup.c       **** 	cs_mreqPin_low;
 797               		.loc 1 418 0
 798 0208 9698      		cbi 0x12,6
 799               	.LVL43:
 800 020a 84E0      		ldi r24,lo8(4)
 801               	.LVL44:
 802               	.L44:
 803               	.LBB49:
 419:setup.c       **** 	
 420:setup.c       **** 	// Ignore first 4 bits
 421:setup.c       **** 	for (int8_t x = 0; x < 4; x++) {
 422:setup.c       **** 		rdPin_low; // CLK
 804               		.loc 1 422 0 discriminator 2
 805 020c 9598      		cbi 0x12,5
 423:setup.c       **** 		asm ("nop");
 806               		.loc 1 423 0 discriminator 2
 807               	/* #APP */
 808               	 ;  423 "setup.c" 1
 809 020e 0000      		nop
 810               	 ;  0 "" 2
 424:setup.c       **** 		asm ("nop");
 811               		.loc 1 424 0 discriminator 2
 812               	 ;  424 "setup.c" 1
 813 0210 0000      		nop
 814               	 ;  0 "" 2
 425:setup.c       **** 		rdPin_high; 
 815               		.loc 1 425 0 discriminator 2
 816               	/* #NOAPP */
 817 0212 959A      		sbi 0x12,5
 426:setup.c       **** 		asm ("nop");
 818               		.loc 1 426 0 discriminator 2
 819               	/* #APP */
 820               	 ;  426 "setup.c" 1
 821 0214 0000      		nop
 822               	 ;  0 "" 2
 427:setup.c       **** 		asm ("nop");
 823               		.loc 1 427 0 discriminator 2
 824               	 ;  427 "setup.c" 1
 825 0216 0000      		nop
 826               	 ;  0 "" 2
 827               	.LVL45:
 828               	/* #NOAPP */
 829 0218 8150      		subi r24,lo8(-(-1))
 830               	.LVL46:
 421:setup.c       **** 		rdPin_low; // CLK
 831               		.loc 1 421 0 discriminator 2
 832 021a 01F4      		brne .L44
 833 021c E0E0      		ldi r30,lo8(eepromBuffer)
 834 021e F0E0      		ldi r31,hi8(eepromBuffer)
 835               	.LBE49:
 836               	.LBB50:
 837               	.LBB51:
 838               	.LBB52:
 428:setup.c       **** 	}
 429:setup.c       **** 	
 430:setup.c       **** 	// Read out 64 bits
 431:setup.c       **** 	for (uint8_t c = 0; c < 8; c++) {
 432:setup.c       **** 		uint8_t data = 0;
 433:setup.c       **** 		for (int8_t x = 7; x >= 0; x--) {
 434:setup.c       **** 			rdPin_low; // CLK
 435:setup.c       **** 			asm ("nop");
 436:setup.c       **** 			asm ("nop");
 437:setup.c       **** 			rdPin_high;
 438:setup.c       **** 			
 439:setup.c       **** 			if (GBA_PIN_EEPROM_DATA7_0 & (1<<AD0)) {
 440:setup.c       **** 				data |= (1<<x);
 839               		.loc 1 440 0
 840 0220 21E0      		ldi r18,lo8(1)
 841 0222 30E0      		ldi r19,0
 842               	.LVL47:
 843               	.L43:
 844               	.LBE52:
 845               	.LBE51:
 846               	.LBE50:
 418:setup.c       **** 	
 847               		.loc 1 418 0 discriminator 1
 848 0224 87E0      		ldi r24,lo8(7)
 849 0226 90E0      		ldi r25,0
 850 0228 60E0      		ldi r22,0
 851               	.LVL48:
 852               	.L48:
 853               	.LBB55:
 854               	.LBB54:
 855               	.LBB53:
 434:setup.c       **** 			asm ("nop");
 856               		.loc 1 434 0
 857 022a 9598      		cbi 0x12,5
 435:setup.c       **** 			asm ("nop");
 858               		.loc 1 435 0
 859               	/* #APP */
 860               	 ;  435 "setup.c" 1
 861 022c 0000      		nop
 862               	 ;  0 "" 2
 436:setup.c       **** 			rdPin_high;
 863               		.loc 1 436 0
 864               	 ;  436 "setup.c" 1
 865 022e 0000      		nop
 866               	 ;  0 "" 2
 437:setup.c       **** 			
 867               		.loc 1 437 0
 868               	/* #NOAPP */
 869 0230 959A      		sbi 0x12,5
 439:setup.c       **** 				data |= (1<<x);
 870               		.loc 1 439 0
 871 0232 B09B      		sbis 0x16,0
 872 0234 00C0      		rjmp .L45
 873               		.loc 1 440 0
 874 0236 A901      		movw r20,r18
 875 0238 082E      		mov r0,r24
 876 023a 00C0      		rjmp 2f
 877               		1:
 878 023c 440F      		lsl r20
 879               		2:
 880 023e 0A94      		dec r0
 881 0240 02F4      		brpl 1b
 882 0242 642B      		or r22,r20
 883               	.LVL49:
 884               	.L45:
 885               	.LVL50:
 886 0244 0197      		sbiw r24,1
 887 0246 00F4      		brcc .L48
 888               	.LBE53:
 441:setup.c       **** 			}
 442:setup.c       **** 		}
 443:setup.c       **** 		eepromBuffer[c] = data;
 889               		.loc 1 443 0
 890 0248 6193      		st Z+,r22
 891               	.LVL51:
 892               	.LBE54:
 431:setup.c       **** 		uint8_t data = 0;
 893               		.loc 1 431 0
 894 024a 80E0      		ldi r24,hi8(eepromBuffer+8)
 895 024c E030      		cpi r30,lo8(eepromBuffer+8)
 896 024e F807      		cpc r31,r24
 897               	.LVL52:
 898 0250 01F4      		brne .L43
 899               	.LBE55:
 444:setup.c       **** 	}
 445:setup.c       **** 	
 446:setup.c       **** 	cs_mreqPin_high;
 900               		.loc 1 446 0
 901 0252 969A      		sbi 0x12,6
 447:setup.c       **** 	
 448:setup.c       **** 	// Set AD0 pin as output
 449:setup.c       **** 	GBA_PORT_EEPROM_DATA7_0 |= (1<<AD0);
 902               		.loc 1 449 0
 903 0254 C09A      		sbi 0x18,0
 450:setup.c       **** 	GBA_DDR_EEPROM_DATA7_0 |= (1<<AD0);
 904               		.loc 1 450 0
 905 0256 B89A      		sbi 0x17,0
 906 0258 0895      		ret
 907               		.cfi_endproc
 908               	.LFE26:
 910               	.global	gba_eeprom_write
 912               	gba_eeprom_write:
 913               	.LFB27:
 451:setup.c       **** }
 452:setup.c       **** 
 453:setup.c       **** // Write 8 bytes to the EEPROM address
 454:setup.c       **** void gba_eeprom_write(uint16_t address, uint8_t eepromSize) {
 914               		.loc 1 454 0
 915               		.cfi_startproc
 916               	.LVL53:
 917               	/* prologue: function */
 918               	/* frame size = 0 */
 919               	/* stack size = 0 */
 920               	.L__stack_usage = 0
 455:setup.c       **** 	gba_eeprom_set_address(address, eepromSize, EEPROM_WRITE);
 921               		.loc 1 455 0
 922 025a 41E0      		ldi r20,lo8(1)
 923 025c 0E94 0000 		call gba_eeprom_set_address
 924               	.LVL54:
 925 0260 E0E0      		ldi r30,lo8(eepromBuffer)
 926 0262 F0E0      		ldi r31,hi8(eepromBuffer)
 927               	.LVL55:
 928               	.L53:
 454:setup.c       **** 	gba_eeprom_set_address(address, eepromSize, EEPROM_WRITE);
 929               		.loc 1 454 0 discriminator 1
 930 0264 87E0      		ldi r24,lo8(7)
 931 0266 90E0      		ldi r25,0
 932               	.LVL56:
 933               	.L58:
 934               	.LBB56:
 935               	.LBB57:
 456:setup.c       **** 	
 457:setup.c       **** 	// Write 64 bits
 458:setup.c       **** 	for (uint8_t c = 0; c < 8; c++) {
 459:setup.c       **** 		for (int8_t x = 7; x >= 0; x--) {
 460:setup.c       **** 			if (eepromBuffer[c] & (1<<x)) {
 936               		.loc 1 460 0
 937 0268 2081      		ld r18,Z
 938 026a 30E0      		ldi r19,0
 939 026c 082E      		mov r0,r24
 940 026e 00C0      		rjmp 2f
 941               		1:
 942 0270 3595      		asr r19
 943 0272 2795      		ror r18
 944               		2:
 945 0274 0A94      		dec r0
 946 0276 02F4      		brpl 1b
 947 0278 20FF      		sbrs r18,0
 948 027a 00C0      		rjmp .L54
 461:setup.c       **** 				ad0Pin_high;
 949               		.loc 1 461 0
 950 027c C09A      		sbi 0x18,0
 951 027e 00C0      		rjmp .L55
 952               	.L54:
 462:setup.c       **** 			}
 463:setup.c       **** 			else {
 464:setup.c       **** 				ad0Pin_low;
 953               		.loc 1 464 0
 954 0280 C098      		cbi 0x18,0
 955               	.L55:
 465:setup.c       **** 			}
 466:setup.c       **** 			
 467:setup.c       **** 			wrPin_low; // CLK
 956               		.loc 1 467 0
 957 0282 9498      		cbi 0x12,4
 468:setup.c       **** 			asm ("nop");
 958               		.loc 1 468 0
 959               	/* #APP */
 960               	 ;  468 "setup.c" 1
 961 0284 0000      		nop
 962               	 ;  0 "" 2
 469:setup.c       **** 			asm ("nop");
 963               		.loc 1 469 0
 964               	 ;  469 "setup.c" 1
 965 0286 0000      		nop
 966               	 ;  0 "" 2
 470:setup.c       **** 			wrPin_high; 
 967               		.loc 1 470 0
 968               	/* #NOAPP */
 969 0288 949A      		sbi 0x12,4
 471:setup.c       **** 			asm ("nop");
 970               		.loc 1 471 0
 971               	/* #APP */
 972               	 ;  471 "setup.c" 1
 973 028a 0000      		nop
 974               	 ;  0 "" 2
 472:setup.c       **** 			asm ("nop");
 975               		.loc 1 472 0
 976               	 ;  472 "setup.c" 1
 977 028c 0000      		nop
 978               	 ;  0 "" 2
 979               	.LVL57:
 980               	/* #NOAPP */
 981               	.LVL58:
 982 028e 0197      		sbiw r24,1
 983 0290 00F4      		brcc .L58
 984 0292 3196      		adiw r30,1
 985               	.LVL59:
 986               	.LBE57:
 458:setup.c       **** 		for (int8_t x = 7; x >= 0; x--) {
 987               		.loc 1 458 0
 988 0294 80E0      		ldi r24,hi8(eepromBuffer+8)
 989 0296 E030      		cpi r30,lo8(eepromBuffer+8)
 990 0298 F807      		cpc r31,r24
 991               	.LVL60:
 992 029a 01F4      		brne .L53
 993               	.LBE56:
 473:setup.c       **** 		}
 474:setup.c       **** 	}
 475:setup.c       **** 	
 476:setup.c       **** 	// Last bit low
 477:setup.c       **** 	ad0Pin_low;
 994               		.loc 1 477 0
 995 029c C098      		cbi 0x18,0
 478:setup.c       **** 	wrPin_low; // CLK
 996               		.loc 1 478 0
 997 029e 9498      		cbi 0x12,4
 479:setup.c       **** 	asm ("nop");
 998               		.loc 1 479 0
 999               	/* #APP */
 1000               	 ;  479 "setup.c" 1
 1001 02a0 0000      		nop
 1002               	 ;  0 "" 2
 480:setup.c       **** 	asm ("nop");
 1003               		.loc 1 480 0
 1004               	 ;  480 "setup.c" 1
 1005 02a2 0000      		nop
 1006               	 ;  0 "" 2
 481:setup.c       **** 	wrPin_high; 
 1007               		.loc 1 481 0
 1008               	/* #NOAPP */
 1009 02a4 949A      		sbi 0x12,4
 482:setup.c       **** 	asm ("nop");
 1010               		.loc 1 482 0
 1011               	/* #APP */
 1012               	 ;  482 "setup.c" 1
 1013 02a6 0000      		nop
 1014               	 ;  0 "" 2
 483:setup.c       **** 	asm ("nop");
 1015               		.loc 1 483 0
 1016               	 ;  483 "setup.c" 1
 1017 02a8 0000      		nop
 1018               	 ;  0 "" 2
 484:setup.c       **** 	
 485:setup.c       **** 	cs_mreqPin_high;
 1019               		.loc 1 485 0
 1020               	/* #NOAPP */
 1021 02aa 969A      		sbi 0x12,6
 1022 02ac 0895      		ret
 1023               		.cfi_endproc
 1024               	.LFE27:
 1026               	.global	flash_write_bus_cycle
 1028               	flash_write_bus_cycle:
 1029               	.LFB28:
 486:setup.c       **** }
 487:setup.c       **** 
 488:setup.c       **** 
 489:setup.c       **** 
 490:setup.c       **** // ---------- FLASH ----------
 491:setup.c       **** 
 492:setup.c       **** // Set the address and data for the write byte cycle to the flash
 493:setup.c       **** void flash_write_bus_cycle(uint16_t address, uint8_t data) {
 1030               		.loc 1 493 0
 1031               		.cfi_startproc
 1032               	.LVL61:
 1033 02ae CF93      		push r28
 1034               	.LCFI16:
 1035               		.cfi_def_cfa_offset 3
 1036               		.cfi_offset 28, -2
 1037 02b0 DF93      		push r29
 1038               	.LCFI17:
 1039               		.cfi_def_cfa_offset 4
 1040               		.cfi_offset 29, -3
 1041 02b2 1F92      		push __zero_reg__
 1042               	.LCFI18:
 1043               		.cfi_def_cfa_offset 5
 1044 02b4 CDB7      		in r28,__SP_L__
 1045 02b6 DEB7      		in r29,__SP_H__
 1046               	.LCFI19:
 1047               		.cfi_def_cfa_register 28
 1048               	/* prologue: function */
 1049               	/* frame size = 1 */
 1050               	/* stack size = 3 */
 1051               	.L__stack_usage = 3
 494:setup.c       **** 	GBA_DDR_RAM_DATA7_0 = 0xFF; // Set data pins as outputs
 1052               		.loc 1 494 0
 1053 02b8 2FEF      		ldi r18,lo8(-1)
 1054 02ba 24BB      		out 0x14,r18
 495:setup.c       **** 	set_16bit_address(address);
 1055               		.loc 1 495 0
 1056 02bc 6983      		std Y+1,r22
 1057 02be 0E94 0000 		call set_16bit_address
 1058               	.LVL62:
 496:setup.c       **** 	GBA_PORT_RAM_DATA7_0 = data;
 1059               		.loc 1 496 0
 1060 02c2 6981      		ldd r22,Y+1
 1061 02c4 65BB      		out 0x15,r22
 497:setup.c       **** 	
 498:setup.c       **** 	wrPin_low;
 1062               		.loc 1 498 0
 1063 02c6 9498      		cbi 0x12,4
 499:setup.c       **** 	cs2Pin_low;
 1064               		.loc 1 499 0
 1065 02c8 9798      		cbi 0x12,7
 500:setup.c       **** 	asm volatile("nop");
 1066               		.loc 1 500 0
 1067               	/* #APP */
 1068               	 ;  500 "setup.c" 1
 1069 02ca 0000      		nop
 1070               	 ;  0 "" 2
 501:setup.c       **** 	wrPin_high;
 1071               		.loc 1 501 0
 1072               	/* #NOAPP */
 1073 02cc 949A      		sbi 0x12,4
 502:setup.c       **** 	cs2Pin_high;
 1074               		.loc 1 502 0
 1075 02ce 979A      		sbi 0x12,7
 1076               	/* epilogue start */
 503:setup.c       **** }
 1077               		.loc 1 503 0
 1078 02d0 0F90      		pop __tmp_reg__
 1079 02d2 DF91      		pop r29
 1080 02d4 CF91      		pop r28
 1081 02d6 0895      		ret
 1082               		.cfi_endproc
 1083               	.LFE28:
 1085               	.global	flash_read_chip_id
 1087               	flash_read_chip_id:
 1088               	.LFB29:
 504:setup.c       **** 
 505:setup.c       **** // Read the flash manufacturer and device ID (Software ID)
 506:setup.c       **** void flash_read_chip_id(void) {
 1089               		.loc 1 506 0
 1090               		.cfi_startproc
 1091               	/* prologue: function */
 1092               	/* frame size = 0 */
 1093               	/* stack size = 0 */
 1094               	.L__stack_usage = 0
 507:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xAA);
 1095               		.loc 1 507 0
 1096 02d8 6AEA      		ldi r22,lo8(-86)
 1097 02da 85E5      		ldi r24,lo8(85)
 1098 02dc 95E5      		ldi r25,lo8(85)
 1099 02de 0E94 0000 		call flash_write_bus_cycle
 1100               	.LVL63:
 508:setup.c       **** 	flash_write_bus_cycle(0x2AAA, 0x55);
 1101               		.loc 1 508 0
 1102 02e2 65E5      		ldi r22,lo8(85)
 1103 02e4 8AEA      		ldi r24,lo8(-86)
 1104 02e6 9AE2      		ldi r25,lo8(42)
 1105 02e8 0E94 0000 		call flash_write_bus_cycle
 1106               	.LVL64:
 509:setup.c       **** 	flash_write_bus_cycle(0x5555, 0x90); // Software ID entry
 1107               		.loc 1 509 0
 1108 02ec 60E9      		ldi r22,lo8(-112)
 1109 02ee 85E5      		ldi r24,lo8(85)
 1110 02f0 95E5      		ldi r25,lo8(85)
 1111 02f2 0E94 0000 		call flash_write_bus_cycle
 1112               	.LVL65:
 1113               	.LBB58:
 1114               	.LBB59:
 163:c:\winavr-20100110\avr\include\util\delay.h **** 
 1115               		.loc 2 163 0
 1116 02f6 8FE3      		ldi r24,lo8(-25537)
 1117 02f8 9CE9      		ldi r25,hi8(-25537)
 1118 02fa 0197      		1: sbiw r24,1
 1119 02fc 01F4      		brne 1b
 1120 02fe 00C0      		rjmp .
 1121 0300 0000      		nop
 1122               	.LBE59:
 1123               	.LBE58:
 510:setup.c       **** 	_delay_ms(20); // Wait a little (for Atmel chip)
 511:setup.c       **** 	
 512:setup.c       **** 	// Set data as inputs
 513:setup.c       **** 	GBA_PORT_RAM_DATA7_0 = 0;
 1124               		.loc 1 513 0
 1125 0302 15BA      		out 0x15,__zero_reg__
 514:setup.c       **** 	GBA_DDR_RAM_DATA7_0 = 0;
 1126               		.loc 1 514 0
 1127 0304 14BA      		out 0x14,__zero_reg__
 515:setup.c       **** 	
 516:setup.c       **** 	// Read and transmit the 2 bytes
 517:setup.c       **** 	flashChipIdBuffer[0] = gba_read_ram_8bit_data(0x0000);
 1128               		.loc 1 517 0
 1129 0306 80E0      		ldi r24,0
 1130 0308 90E0      		ldi r25,0
 1131 030a 0E94 0000 		call gba_read_ram_8bit_data
 1132               	.LVL66:
 1133 030e 8093 0000 		sts flashChipIdBuffer,r24
 518:setup.c       **** 	flashChipIdBuffer[1] = gba_read_ram_8bit_data(0x0001);
 1134               		.loc 1 518 0
 1135 0312 81E0      		ldi r24,lo8(1)
 1136 0314 90E0      		ldi r25,0
 1137 0316 0E94 0000 		call gba_read_ram_8bit_data
 1138               	.LVL67:
 1139 031a 8093 0000 		sts flashChipIdBuffer+1,r24
 519:setup.c       **** 	
 520:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xAA);
 1140               		.loc 1 520 0
 1141 031e 6AEA      		ldi r22,lo8(-86)
 1142 0320 85E5      		ldi r24,lo8(85)
 1143 0322 95E5      		ldi r25,lo8(85)
 1144 0324 0E94 0000 		call flash_write_bus_cycle
 1145               	.LVL68:
 521:setup.c       **** 	flash_write_bus_cycle(0x2AAA, 0x55);
 1146               		.loc 1 521 0
 1147 0328 65E5      		ldi r22,lo8(85)
 1148 032a 8AEA      		ldi r24,lo8(-86)
 1149 032c 9AE2      		ldi r25,lo8(42)
 1150 032e 0E94 0000 		call flash_write_bus_cycle
 1151               	.LVL69:
 522:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xF0); // Software ID exit
 1152               		.loc 1 522 0
 1153 0332 60EF      		ldi r22,lo8(-16)
 1154 0334 85E5      		ldi r24,lo8(85)
 1155 0336 95E5      		ldi r25,lo8(85)
 1156 0338 0E94 0000 		call flash_write_bus_cycle
 1157               	.LVL70:
 1158               	.LBB60:
 1159               	.LBB61:
 163:c:\winavr-20100110\avr\include\util\delay.h **** 
 1160               		.loc 2 163 0
 1161 033c 8FE3      		ldi r24,lo8(-25537)
 1162 033e 9CE9      		ldi r25,hi8(-25537)
 1163 0340 0197      		1: sbiw r24,1
 1164 0342 01F4      		brne 1b
 1165 0344 00C0      		rjmp .
 1166 0346 0000      		nop
 1167 0348 0895      		ret
 1168               	.LBE61:
 1169               	.LBE60:
 1170               		.cfi_endproc
 1171               	.LFE29:
 1173               	.global	flash_switch_bank
 1175               	flash_switch_bank:
 1176               	.LFB30:
 523:setup.c       **** 	_delay_ms(20); // Wait a little (for Atmel chip)
 524:setup.c       **** }
 525:setup.c       **** 
 526:setup.c       **** // Switch banks on the Flash
 527:setup.c       **** void flash_switch_bank(uint8_t bank) {
 1177               		.loc 1 527 0
 1178               		.cfi_startproc
 1179               	.LVL71:
 1180 034a CF93      		push r28
 1181               	.LCFI20:
 1182               		.cfi_def_cfa_offset 3
 1183               		.cfi_offset 28, -2
 1184               	/* prologue: function */
 1185               	/* frame size = 0 */
 1186               	/* stack size = 1 */
 1187               	.L__stack_usage = 1
 1188 034c C82F      		mov r28,r24
 528:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xAA);
 1189               		.loc 1 528 0
 1190 034e 6AEA      		ldi r22,lo8(-86)
 1191 0350 85E5      		ldi r24,lo8(85)
 1192 0352 95E5      		ldi r25,lo8(85)
 1193               	.LVL72:
 1194 0354 0E94 0000 		call flash_write_bus_cycle
 1195               	.LVL73:
 529:setup.c       **** 	flash_write_bus_cycle(0x2AAA, 0x55);
 1196               		.loc 1 529 0
 1197 0358 65E5      		ldi r22,lo8(85)
 1198 035a 8AEA      		ldi r24,lo8(-86)
 1199 035c 9AE2      		ldi r25,lo8(42)
 1200 035e 0E94 0000 		call flash_write_bus_cycle
 1201               	.LVL74:
 530:setup.c       **** 	
 531:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xB0);
 1202               		.loc 1 531 0
 1203 0362 60EB      		ldi r22,lo8(-80)
 1204 0364 85E5      		ldi r24,lo8(85)
 1205 0366 95E5      		ldi r25,lo8(85)
 1206 0368 0E94 0000 		call flash_write_bus_cycle
 1207               	.LVL75:
 532:setup.c       **** 	flash_write_bus_cycle(0x0000, bank);
 1208               		.loc 1 532 0
 1209 036c 6C2F      		mov r22,r28
 1210 036e 80E0      		ldi r24,0
 1211 0370 90E0      		ldi r25,0
 1212               	/* epilogue start */
 533:setup.c       **** }
 1213               		.loc 1 533 0
 1214 0372 CF91      		pop r28
 1215               	.LVL76:
 532:setup.c       **** 	flash_write_bus_cycle(0x0000, bank);
 1216               		.loc 1 532 0
 1217 0374 0C94 0000 		jmp flash_write_bus_cycle
 1218               	.LVL77:
 1219               		.cfi_endproc
 1220               	.LFE30:
 1222               	.global	flash_erase_4k_sector
 1224               	flash_erase_4k_sector:
 1225               	.LFB31:
 534:setup.c       **** 
 535:setup.c       **** // Erase 4K sector on Flash, expects first sector to start at 0, left shifts by 12 (A15-A12 to sele
 536:setup.c       **** // Takes 25ms after last command to erase sector
 537:setup.c       **** void flash_erase_4k_sector(uint8_t sector) {
 1226               		.loc 1 537 0
 1227               		.cfi_startproc
 1228               	.LVL78:
 1229 0378 CF93      		push r28
 1230               	.LCFI21:
 1231               		.cfi_def_cfa_offset 3
 1232               		.cfi_offset 28, -2
 1233               	/* prologue: function */
 1234               	/* frame size = 0 */
 1235               	/* stack size = 1 */
 1236               	.L__stack_usage = 1
 1237 037a C82F      		mov r28,r24
 538:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xAA);
 1238               		.loc 1 538 0
 1239 037c 6AEA      		ldi r22,lo8(-86)
 1240 037e 85E5      		ldi r24,lo8(85)
 1241 0380 95E5      		ldi r25,lo8(85)
 1242               	.LVL79:
 1243 0382 0E94 0000 		call flash_write_bus_cycle
 1244               	.LVL80:
 539:setup.c       **** 	flash_write_bus_cycle(0x2AAA, 0x55);
 1245               		.loc 1 539 0
 1246 0386 65E5      		ldi r22,lo8(85)
 1247 0388 8AEA      		ldi r24,lo8(-86)
 1248 038a 9AE2      		ldi r25,lo8(42)
 1249 038c 0E94 0000 		call flash_write_bus_cycle
 1250               	.LVL81:
 540:setup.c       **** 	flash_write_bus_cycle(0x5555, 0x80);
 1251               		.loc 1 540 0
 1252 0390 60E8      		ldi r22,lo8(-128)
 1253 0392 85E5      		ldi r24,lo8(85)
 1254 0394 95E5      		ldi r25,lo8(85)
 1255 0396 0E94 0000 		call flash_write_bus_cycle
 1256               	.LVL82:
 541:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xAA);
 1257               		.loc 1 541 0
 1258 039a 6AEA      		ldi r22,lo8(-86)
 1259 039c 85E5      		ldi r24,lo8(85)
 1260 039e 95E5      		ldi r25,lo8(85)
 1261 03a0 0E94 0000 		call flash_write_bus_cycle
 1262               	.LVL83:
 542:setup.c       **** 	flash_write_bus_cycle(0x2AAA, 0x55);
 1263               		.loc 1 542 0
 1264 03a4 65E5      		ldi r22,lo8(85)
 1265 03a6 8AEA      		ldi r24,lo8(-86)
 1266 03a8 9AE2      		ldi r25,lo8(42)
 1267 03aa 0E94 0000 		call flash_write_bus_cycle
 1268               	.LVL84:
 543:setup.c       **** 	
 544:setup.c       **** 	flash_write_bus_cycle((uint16_t) sector << 12, 0x30);
 1269               		.loc 1 544 0
 1270 03ae 60E3      		ldi r22,lo8(48)
 1271 03b0 80E0      		ldi r24,0
 1272 03b2 9C2F      		mov r25,r28
 1273 03b4 9295      		swap r25
 1274 03b6 907F      		andi r25,lo8(-16)
 1275 03b8 0E94 0000 		call flash_write_bus_cycle
 1276               	.LVL85:
 1277               	.LBB62:
 1278               	.LBB63:
 163:c:\winavr-20100110\avr\include\util\delay.h **** 
 1279               		.loc 2 163 0
 1280 03bc 8FE4      		ldi r24,lo8(-15537)
 1281 03be 93EC      		ldi r25,hi8(-15537)
 1282 03c0 0197      		1: sbiw r24,1
 1283 03c2 01F4      		brne 1b
 1284 03c4 00C0      		rjmp .
 1285 03c6 0000      		nop
 1286               	/* epilogue start */
 1287               	.LBE63:
 1288               	.LBE62:
 545:setup.c       **** 	_delay_ms(25); // Wait 25ms for sector erase
 546:setup.c       **** }
 1289               		.loc 1 546 0
 1290 03c8 CF91      		pop r28
 1291               	.LVL86:
 1292 03ca 0895      		ret
 1293               		.cfi_endproc
 1294               	.LFE31:
 1296               	.global	flash_write_byte
 1298               	flash_write_byte:
 1299               	.LFB32:
 547:setup.c       **** 
 548:setup.c       **** // Write a single byte to the Flash address
 549:setup.c       **** // Takes 20us to program Flash
 550:setup.c       **** void flash_write_byte(uint16_t address, uint8_t data) {
 1300               		.loc 1 550 0
 1301               		.cfi_startproc
 1302               	.LVL87:
 1303 03cc 1F93      		push r17
 1304               	.LCFI22:
 1305               		.cfi_def_cfa_offset 3
 1306               		.cfi_offset 17, -2
 1307 03ce CF93      		push r28
 1308               	.LCFI23:
 1309               		.cfi_def_cfa_offset 4
 1310               		.cfi_offset 28, -3
 1311 03d0 DF93      		push r29
 1312               	.LCFI24:
 1313               		.cfi_def_cfa_offset 5
 1314               		.cfi_offset 29, -4
 1315               	/* prologue: function */
 1316               	/* frame size = 0 */
 1317               	/* stack size = 3 */
 1318               	.L__stack_usage = 3
 1319 03d2 EC01      		movw r28,r24
 1320 03d4 162F      		mov r17,r22
 551:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xAA);
 1321               		.loc 1 551 0
 1322 03d6 6AEA      		ldi r22,lo8(-86)
 1323               	.LVL88:
 1324 03d8 85E5      		ldi r24,lo8(85)
 1325 03da 95E5      		ldi r25,lo8(85)
 1326               	.LVL89:
 1327 03dc 0E94 0000 		call flash_write_bus_cycle
 1328               	.LVL90:
 552:setup.c       **** 	flash_write_bus_cycle(0x2AAA, 0x55);
 1329               		.loc 1 552 0
 1330 03e0 65E5      		ldi r22,lo8(85)
 1331 03e2 8AEA      		ldi r24,lo8(-86)
 1332 03e4 9AE2      		ldi r25,lo8(42)
 1333 03e6 0E94 0000 		call flash_write_bus_cycle
 1334               	.LVL91:
 553:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xA0);
 1335               		.loc 1 553 0
 1336 03ea 60EA      		ldi r22,lo8(-96)
 1337 03ec 85E5      		ldi r24,lo8(85)
 1338 03ee 95E5      		ldi r25,lo8(85)
 1339 03f0 0E94 0000 		call flash_write_bus_cycle
 1340               	.LVL92:
 554:setup.c       **** 	
 555:setup.c       **** 	flash_write_bus_cycle(address, data);
 1341               		.loc 1 555 0
 1342 03f4 612F      		mov r22,r17
 1343 03f6 CE01      		movw r24,r28
 1344 03f8 0E94 0000 		call flash_write_bus_cycle
 1345               	.LVL93:
 1346               	.LBB64:
 1347               	.LBB65:
 1348               		.loc 2 245 0
 1349 03fc 85E3      		ldi r24,lo8(53)
 1350 03fe 8A95      		1: dec r24
 1351 0400 01F4      		brne 1b
 1352 0402 0000      		nop
 1353               	/* epilogue start */
 1354               	.LBE65:
 1355               	.LBE64:
 556:setup.c       **** 	_delay_us(20); // Wait byte program time
 557:setup.c       **** }
 1356               		.loc 1 557 0
 1357 0404 DF91      		pop r29
 1358 0406 CF91      		pop r28
 1359               	.LVL94:
 1360 0408 1F91      		pop r17
 1361               	.LVL95:
 1362 040a 0895      		ret
 1363               		.cfi_endproc
 1364               	.LFE32:
 1366               	.global	flash_write_sector
 1368               	flash_write_sector:
 1369               	.LFB33:
 558:setup.c       **** 
 559:setup.c       **** // Write a sector (128 bytes) to the Atmel flash
 560:setup.c       **** // Takes 20ms for write cycle
 561:setup.c       **** void flash_write_sector(uint16_t sector) {
 1370               		.loc 1 561 0
 1371               		.cfi_startproc
 1372               	.LVL96:
 1373 040c EF92      		push r14
 1374               	.LCFI25:
 1375               		.cfi_def_cfa_offset 3
 1376               		.cfi_offset 14, -2
 1377 040e FF92      		push r15
 1378               	.LCFI26:
 1379               		.cfi_def_cfa_offset 4
 1380               		.cfi_offset 15, -3
 1381 0410 0F93      		push r16
 1382               	.LCFI27:
 1383               		.cfi_def_cfa_offset 5
 1384               		.cfi_offset 16, -4
 1385 0412 1F93      		push r17
 1386               	.LCFI28:
 1387               		.cfi_def_cfa_offset 6
 1388               		.cfi_offset 17, -5
 1389 0414 CF93      		push r28
 1390               	.LCFI29:
 1391               		.cfi_def_cfa_offset 7
 1392               		.cfi_offset 28, -6
 1393 0416 DF93      		push r29
 1394               	.LCFI30:
 1395               		.cfi_def_cfa_offset 8
 1396               		.cfi_offset 29, -7
 1397               	/* prologue: function */
 1398               	/* frame size = 0 */
 1399               	/* stack size = 6 */
 1400               	.L__stack_usage = 6
 1401 0418 8C01      		movw r16,r24
 562:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xAA);
 1402               		.loc 1 562 0
 1403 041a 6AEA      		ldi r22,lo8(-86)
 1404 041c 85E5      		ldi r24,lo8(85)
 1405 041e 95E5      		ldi r25,lo8(85)
 1406               	.LVL97:
 1407 0420 0E94 0000 		call flash_write_bus_cycle
 1408               	.LVL98:
 563:setup.c       **** 	flash_write_bus_cycle(0x2AAA, 0x55);
 1409               		.loc 1 563 0
 1410 0424 65E5      		ldi r22,lo8(85)
 1411 0426 8AEA      		ldi r24,lo8(-86)
 1412 0428 9AE2      		ldi r25,lo8(42)
 1413 042a 0E94 0000 		call flash_write_bus_cycle
 1414               	.LVL99:
 564:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xA0);
 1415               		.loc 1 564 0
 1416 042e 60EA      		ldi r22,lo8(-96)
 1417 0430 85E5      		ldi r24,lo8(85)
 1418 0432 95E5      		ldi r25,lo8(85)
 1419 0434 0E94 0000 		call flash_write_bus_cycle
 1420               	.LVL100:
 1421               	.LBB66:
 565:setup.c       **** 	
 566:setup.c       **** 	// Write the bytes (A0-A6 byte address, A7-A15 sector address)
 567:setup.c       **** 	for (uint8_t x = 0; x < 128; x++) {
 568:setup.c       **** 		flash_write_bus_cycle((uint16_t) (sector << 7) | (uint16_t) x, receivedBuffer[x]);
 1422               		.loc 1 568 0
 1423 0438 1695      		lsr r17
 1424 043a 102F      		mov r17,r16
 1425 043c 0027      		clr r16
 1426 043e 1795      		ror r17
 1427 0440 0795      		ror r16
 1428               	.LVL101:
 1429 0442 50E0      		ldi r21,lo8(receivedBuffer)
 1430 0444 E52E      		mov r14,r21
 1431 0446 50E0      		ldi r21,hi8(receivedBuffer)
 1432 0448 F52E      		mov r15,r21
 1433 044a C0E0      		ldi r28,0
 1434 044c D0E0      		ldi r29,0
 1435               	.LVL102:
 1436               	.L65:
 1437               		.loc 1 568 0 is_stmt 0 discriminator 2
 1438 044e F701      		movw r30,r14
 1439 0450 6191      		ld r22,Z+
 1440 0452 7F01      		movw r14,r30
 1441 0454 CE01      		movw r24,r28
 1442 0456 802B      		or r24,r16
 1443 0458 912B      		or r25,r17
 1444 045a 0E94 0000 		call flash_write_bus_cycle
 1445               	.LVL103:
 1446 045e 2196      		adiw r28,1
 1447               	.LVL104:
 567:setup.c       **** 		flash_write_bus_cycle((uint16_t) (sector << 7) | (uint16_t) x, receivedBuffer[x]);
 1448               		.loc 1 567 0 is_stmt 1 discriminator 2
 1449 0460 C038      		cpi r28,-128
 1450 0462 D105      		cpc r29,__zero_reg__
 1451 0464 01F4      		brne .L65
 1452               	.LVL105:
 1453               	.LBE66:
 1454               	.LBB67:
 1455               	.LBB68:
 163:c:\winavr-20100110\avr\include\util\delay.h **** 
 1456               		.loc 2 163 0
 1457 0466 8FE3      		ldi r24,lo8(-25537)
 1458 0468 9CE9      		ldi r25,hi8(-25537)
 1459 046a 0197      		1: sbiw r24,1
 1460 046c 01F4      		brne 1b
 1461 046e 00C0      		rjmp .
 1462 0470 0000      		nop
 1463               	/* epilogue start */
 1464               	.LBE68:
 1465               	.LBE67:
 569:setup.c       **** 	}
 570:setup.c       **** 	_delay_ms(20); // Wait sector program time
 571:setup.c       **** }
 1466               		.loc 1 571 0
 1467 0472 DF91      		pop r29
 1468 0474 CF91      		pop r28
 1469               	.LVL106:
 1470 0476 1F91      		pop r17
 1471 0478 0F91      		pop r16
 1472 047a FF90      		pop r15
 1473 047c EF90      		pop r14
 1474 047e 0895      		ret
 1475               		.cfi_endproc
 1476               	.LFE33:
 1478               	.global	setup
 1480               	setup:
 1481               	.LFB34:
 572:setup.c       **** 
 573:setup.c       **** // Setup
 574:setup.c       **** void setup(void) {
 1482               		.loc 1 574 0
 1483               		.cfi_startproc
 1484               	/* prologue: function */
 1485               	/* frame size = 0 */
 1486               	/* stack size = 0 */
 1487               	.L__stack_usage = 0
 575:setup.c       **** 	// Reset common lines
 576:setup.c       **** 	rd_wr_csmreq_cs2_reset();
 1488               		.loc 1 576 0
 1489 0480 0E94 0000 		call rd_wr_csmreq_cs2_reset
 1490               	.LVL107:
 577:setup.c       **** 	
 578:setup.c       **** 	// Set outputs
 579:setup.c       **** 	DDRD |= (1<<LED) | (1<<WR_PIN) | (1<<RD_PIN) | (1<<CS_MREQ_PIN) | (1<<CS2_PIN);
 1491               		.loc 1 579 0
 1492 0484 81B3      		in r24,0x11
 1493 0486 886F      		ori r24,lo8(-8)
 1494 0488 81BB      		out 0x11,r24
 580:setup.c       **** 	
 581:setup.c       **** 	// Set all pins as inputs
 582:setup.c       **** 	PORT_DATA7_0 = 0;
 1495               		.loc 1 582 0
 1496 048a 15BA      		out 0x15,__zero_reg__
 583:setup.c       **** 	DDR_DATA7_0 = 0;
 1497               		.loc 1 583 0
 1498 048c 14BA      		out 0x14,__zero_reg__
 584:setup.c       **** 	PORT_ADDR7_0 = 0;
 1499               		.loc 1 584 0
 1500 048e 18BA      		out 0x18,__zero_reg__
 585:setup.c       **** 	DDR_ADDR7_0 = 0;
 1501               		.loc 1 585 0
 1502 0490 17BA      		out 0x17,__zero_reg__
 586:setup.c       **** 	PORT_ADDR15_8 = 0;
 1503               		.loc 1 586 0
 1504 0492 1BBA      		out 0x1b,__zero_reg__
 587:setup.c       **** 	DDR_ADDR15_8 = 0;
 1505               		.loc 1 587 0
 1506 0494 1ABA      		out 0x1a,__zero_reg__
 588:setup.c       **** 	
 589:setup.c       **** 	// Light LED
 590:setup.c       **** 	PORTD |= (1<<LED);
 1507               		.loc 1 590 0
 1508 0496 939A      		sbi 0x12,3
 1509               	.LVL108:
 1510               	.LBB69:
 1511               	.LBB70:
 163:c:\winavr-20100110\avr\include\util\delay.h **** 
 1512               		.loc 2 163 0
 1513 0498 2FEF      		ldi r18,lo8(799999)
 1514 049a 84E3      		ldi r24,hi8(799999)
 1515 049c 9CE0      		ldi r25,hlo8(799999)
 1516 049e 2150      		1: subi r18,1
 1517 04a0 8040      		sbci r24,0
 1518 04a2 9040      		sbci r25,0
 1519 04a4 01F4      		brne 1b
 1520 04a6 00C0      		rjmp .
 1521 04a8 0000      		nop
 1522               	.LBE70:
 1523               	.LBE69:
 591:setup.c       **** 	_delay_ms(500);
 592:setup.c       **** 	PORTD &= ~(1<<LED);
 1524               		.loc 1 592 0
 1525 04aa 9398      		cbi 0x12,3
 593:setup.c       **** 	
 594:setup.c       **** 	// Setup USART
 595:setup.c       **** 	UBRRL = 0; // 1Mbps Baud rate
 1526               		.loc 1 595 0
 1527 04ac 19B8      		out 0x9,__zero_reg__
 596:setup.c       **** 	sbi(UCSRA, U2X); // Double rate
 1528               		.loc 1 596 0
 1529 04ae 599A      		sbi 0xb,1
 597:setup.c       **** 	sbi(UCSRB, TXEN); // Transmitter enable
 1530               		.loc 1 597 0
 1531 04b0 539A      		sbi 0xa,3
 598:setup.c       **** 	sbi(UCSRB, RXEN); // Receiver enable
 1532               		.loc 1 598 0
 1533 04b2 549A      		sbi 0xa,4
 599:setup.c       **** 	
 600:setup.c       **** 	// Turn on interrupts
 601:setup.c       **** 	sei();
 1534               		.loc 1 601 0
 1535               	/* #APP */
 1536               	 ;  601 "setup.c" 1
 1537 04b4 7894      		sei
 1538               	 ;  0 "" 2
 1539               	/* #NOAPP */
 1540 04b6 0895      		ret
 1541               		.cfi_endproc
 1542               	.LFE34:
 1544               		.section	.text.startup,"ax",@progbits
 1545               	.global	main
 1547               	main:
 1548               	.LFB35:
 1549               		.file 3 "main.c"
   1:main.c        **** /*
   2:main.c        ****  GBxCart RW
   3:main.c        ****  PCB version: 1.0
   4:main.c        ****  Firmware version: R2
   5:main.c        ****  Author: Alex from insideGadgets (www.insidegadgets.com)
   6:main.c        ****  Created: 7/11/2016
   7:main.c        ****  Last Modified: 8/05/2017
   8:main.c        ****  
   9:main.c        ****  GBxCart RW allows you to dump your Gameboy/Gameboy Colour/Gameboy Advance games ROM, save the RAM 
  10:main.c        ****  
  11:main.c        ****  The ATmega32A talks to the cartridge and interfaces with the CH340G serial to USB converter with t
  12:main.c        ****  
  13:main.c        ****  Remember to change your fuse bits so the ATmega32A uses an external 8MHz crystal, divide clock by 
  14:main.c        ****  avrdude -c usbasp -p atmega32 -U lfuse:w:0xef:m -U hfuse:w:0xd9:m
  15:main.c        ****  
  16:main.c        ****  */
  17:main.c        **** 
  18:main.c        **** // ATmega32A Pin Map
  19:main.c        **** //
  20:main.c        **** // VCC (5, 17, 38)		GND (6, 18, 28, 39)		AVCC (27)				XTAL (7 ,8)		LED PD3 (12)		Switch sense PD2 (
  21:main.c        **** // SCK PB7 (3)				MOSI PB5 (1)				MISO PB6 (2)			RST (4)			RXD PD0 (9)			TXD PD1 (10)
  22:main.c        **** // 
  23:main.c        **** // Gameboy / Gameboy Colour
  24:main.c        **** // A0-A7 PB0-7 (40-44, 1-3) 		A8-A15 PA0-7 (37-30)			D0-D7 PC0-7 (19-26)
  25:main.c        **** // 
  26:main.c        **** // Gameboy Advance
  27:main.c        **** // AD0-AD7 PB0-7 (40-44, 1-3) 	AD8-AD15 PA0-7 (37-30)		A16-23 / D0-D7 PC0-7 (19-26)
  28:main.c        **** // *WR PD4 (13)						*RD PD5 (14)					*MREQ/CS PD6 (15)			CS2/RST PD7 (16)
  29:main.c        **** 
  30:main.c        **** #define F_CPU 8000000 // 8 MHz
  31:main.c        **** #define PCB_VERSION 1
  32:main.c        **** #define FIRMWARE_VERSION 2
  33:main.c        **** 
  34:main.c        **** #include <avr/io.h>
  35:main.c        **** #include <avr/wdt.h>
  36:main.c        **** #include <avr/eeprom.h>
  37:main.c        **** #include <avr/interrupt.h>
  38:main.c        **** #include <avr/sleep.h>
  39:main.c        **** #include <util/delay.h>
  40:main.c        **** #include <stdlib.h>
  41:main.c        **** #include <string.h>
  42:main.c        **** #include "setup.c" // See defines, variables, constants, functions here
  43:main.c        **** 
  44:main.c        **** 
  45:main.c        **** int main(void) {
 1550               		.loc 3 45 0
 1551               		.cfi_startproc
 1552 0000 CF93      		push r28
 1553               	.LCFI31:
 1554               		.cfi_def_cfa_offset 3
 1555               		.cfi_offset 28, -2
 1556 0002 DF93      		push r29
 1557               	.LCFI32:
 1558               		.cfi_def_cfa_offset 4
 1559               		.cfi_offset 29, -3
 1560 0004 1F92      		push __zero_reg__
 1561               	.LCFI33:
 1562               		.cfi_def_cfa_offset 5
 1563 0006 CDB7      		in r28,__SP_L__
 1564 0008 DEB7      		in r29,__SP_H__
 1565               	.LCFI34:
 1566               		.cfi_def_cfa_register 28
 1567               	/* prologue: function */
 1568               	/* frame size = 1 */
 1569               	/* stack size = 3 */
 1570               	.L__stack_usage = 3
  46:main.c        **** 	setup();
 1571               		.loc 3 46 0
 1572 000a 0E94 0000 		call setup
 1573               	.LVL109:
  47:main.c        **** 	
  48:main.c        **** 	uint32_t address = 0;
  49:main.c        **** 	uint8_t eepromSize = EEPROM_4KBIT;
  50:main.c        **** 	uint8_t cartMode = GB_MODE;
  51:main.c        **** 	uint8_t resetCommonLines = 1;
 1574               		.loc 3 51 0
 1575 000e 6624      		clr r6
 1576 0010 6394      		inc r6
  49:main.c        **** 	uint8_t cartMode = GB_MODE;
 1577               		.loc 3 49 0
 1578 0012 7724      		clr r7
 1579 0014 7394      		inc r7
  48:main.c        **** 	uint8_t eepromSize = EEPROM_4KBIT;
 1580               		.loc 3 48 0
 1581 0016 C12C      		mov r12,__zero_reg__
 1582 0018 D12C      		mov r13,__zero_reg__
 1583 001a 7601      		movw r14,r12
 1584               	.LVL110:
 1585               	.L69:
  52:main.c        **** 	
  53:main.c        **** 	while(1) {
  54:main.c        **** 		if (resetCommonLines == 1) {
 1586               		.loc 3 54 0
 1587 001c 81E0      		ldi r24,lo8(1)
 1588 001e 6812      		cpse r6,r24
 1589 0020 00C0      		rjmp .L70
 1590               	.LVL111:
 1591               	.L149:
  55:main.c        **** 			rd_wr_csmreq_cs2_reset();
 1592               		.loc 3 55 0
 1593 0022 0E94 0000 		call rd_wr_csmreq_cs2_reset
 1594               	.LVL112:
 1595               	.L70:
  56:main.c        **** 		}
  57:main.c        **** 		receivedChar = USART_Receive(); // Wait for 1 byte of data
 1596               		.loc 3 57 0
 1597 0026 0E94 0000 		call USART_Receive
 1598               	.LVL113:
 1599 002a 8093 0000 		sts receivedChar,r24
  58:main.c        **** 		
  59:main.c        **** 		// Read the pin to find out which mode we are in, if high (3.3V), we are powered by 5V
  60:main.c        **** 		if (PIND & (1<<SWITCH_DETECT)) {
 1600               		.loc 3 60 0
 1601 002e 829B      		sbis 0x10,2
 1602 0030 00C0      		rjmp .L143
  61:main.c        **** 			cartMode = GB_MODE;
 1603               		.loc 3 61 0
 1604 0032 91E0      		ldi r25,lo8(1)
 1605 0034 00C0      		rjmp .L71
 1606               	.L143:
  62:main.c        **** 		}
  63:main.c        **** 		else {
  64:main.c        **** 			cartMode = GBA_MODE;
 1607               		.loc 3 64 0
 1608 0036 92E0      		ldi r25,lo8(2)
 1609               	.L71:
 1610               	.LVL114:
  65:main.c        **** 		}
  66:main.c        **** 		
  67:main.c        **** 		// Return the cart mode in use
  68:main.c        **** 		if (receivedChar == CART_MODE) {
 1611               		.loc 3 68 0
 1612 0038 8334      		cpi r24,lo8(67)
 1613 003a 01F4      		brne .L72
  69:main.c        **** 			USART_Transmit(cartMode);
 1614               		.loc 3 69 0
 1615 003c 892F      		mov r24,r25
 1616 003e 00C0      		rjmp .L155
 1617               	.L72:
  70:main.c        **** 		}
  71:main.c        **** 		
  72:main.c        **** 		// Change to GB mode or GBA mode if requested
  73:main.c        **** 		else if (receivedChar == GB_CART_MODE) {
 1618               		.loc 3 73 0
 1619 0040 8734      		cpi r24,lo8(71)
 1620 0042 01F4      		brne .L74
  74:main.c        **** 			gb_mode();
 1621               		.loc 3 74 0
 1622 0044 0E94 0000 		call gb_mode
 1623               	.LVL115:
 1624 0048 00C0      		rjmp .L73
 1625               	.LVL116:
 1626               	.L74:
  75:main.c        **** 		}
  76:main.c        **** 		else if (receivedChar == GBA_CART_MODE) {
 1627               		.loc 3 76 0
 1628 004a 8736      		cpi r24,lo8(103)
 1629 004c 01F4      		brne .+2
 1630 004e 00C0      		rjmp .L157
  77:main.c        **** 			gba_mode();
  78:main.c        **** 		}
  79:main.c        **** 		
  80:main.c        **** 		// Set address
  81:main.c        **** 		else if (receivedChar == SET_START_ADDRESS) {
 1631               		.loc 3 81 0
 1632 0050 8134      		cpi r24,lo8(65)
 1633 0052 01F4      		brne .L76
  82:main.c        **** 			usart_read_chars(); // Read start address
 1634               		.loc 3 82 0
 1635 0054 0E94 0000 		call usart_read_chars
 1636               	.LVL117:
  83:main.c        **** 			address = strtol(receivedBuffer, NULL, 16); // Convert address string in hex to dec
 1637               		.loc 3 83 0
 1638 0058 40E1      		ldi r20,lo8(16)
 1639 005a 50E0      		ldi r21,0
 1640 005c 60E0      		ldi r22,0
 1641 005e 70E0      		ldi r23,0
 1642 0060 80E0      		ldi r24,lo8(receivedBuffer)
 1643 0062 90E0      		ldi r25,hi8(receivedBuffer)
 1644 0064 0E94 0000 		call strtol
 1645               	.LVL118:
 1646 0068 6B01      		movw r12,r22
 1647 006a 7C01      		movw r14,r24
 1648               	.LVL119:
 1649 006c 00C0      		rjmp .L73
 1650               	.LVL120:
 1651               	.L76:
  84:main.c        **** 		}
  85:main.c        **** 		
  86:main.c        **** 		
  87:main.c        **** 		// ****** Gameboy / Gameboy Colour ******
  88:main.c        **** 		
  89:main.c        **** 		// Read 64 bytes of ROM/RAM from address (and increment) until anything but 1 is received
  90:main.c        **** 		else if (receivedChar == READ_ROM_RAM) {
 1652               		.loc 3 90 0
 1653 006e 8235      		cpi r24,lo8(82)
 1654 0070 01F4      		brne .L77
  91:main.c        **** 			gb_mode();
 1655               		.loc 3 91 0
 1656 0072 0E94 0000 		call gb_mode
 1657               	.LVL121:
  92:main.c        **** 			receivedChar = '1';
 1658               		.loc 3 92 0
 1659 0076 81E3      		ldi r24,lo8(49)
 1660               	.LVL122:
 1661               	.L152:
  93:main.c        **** 			while (receivedChar == '1') {
  94:main.c        **** 				PORTD |= (1<<LED);
  95:main.c        **** 				for (uint8_t x = 0; x < 64; x++) {
  96:main.c        **** 					USART_Transmit(read_8bit_data(address));
  97:main.c        **** 					address++;
  98:main.c        **** 				}
  99:main.c        **** 				
 100:main.c        **** 				PORTD &= ~(1<<LED);
 101:main.c        **** 				receivedChar = USART_Receive();
 1662               		.loc 3 101 0
 1663 0078 8093 0000 		sts receivedChar,r24
 1664               	.LVL123:
  93:main.c        **** 			while (receivedChar == '1') {
 1665               		.loc 3 93 0
 1666 007c 8091 0000 		lds r24,receivedChar
 1667 0080 8133      		cpi r24,lo8(49)
 1668 0082 01F0      		breq .+2
 1669 0084 00C0      		rjmp .L73
  94:main.c        **** 				for (uint8_t x = 0; x < 64; x++) {
 1670               		.loc 3 94 0
 1671 0086 939A      		sbi 0x12,3
 1672               	.LVL124:
 1673 0088 A12C      		mov r10,__zero_reg__
 1674 008a B12C      		mov r11,__zero_reg__
 1675               	.LVL125:
 1676               	.L80:
 1677 008c C501      		movw r24,r10
 1678 008e 8C0D      		add r24,r12
 1679 0090 9D1D      		adc r25,r13
 1680               	.LBB71:
  96:main.c        **** 					address++;
 1681               		.loc 3 96 0 discriminator 2
 1682 0092 0E94 0000 		call read_8bit_data
 1683               	.LVL126:
 1684 0096 0E94 0000 		call USART_Transmit
 1685               	.LVL127:
 1686 009a 9FEF      		ldi r25,-1
 1687 009c A91A      		sub r10,r25
 1688 009e B90A      		sbc r11,r25
 1689               	.LVL128:
  95:main.c        **** 					USART_Transmit(read_8bit_data(address));
 1690               		.loc 3 95 0 discriminator 2
 1691 00a0 E0E4      		ldi r30,64
 1692 00a2 AE16      		cp r10,r30
 1693 00a4 B104      		cpc r11,__zero_reg__
 1694 00a6 01F4      		brne .L80
 1695 00a8 F0E4      		ldi r31,64
 1696 00aa CF0E      		add r12,r31
 1697 00ac D11C      		adc r13,__zero_reg__
 1698 00ae E11C      		adc r14,__zero_reg__
 1699 00b0 F11C      		adc r15,__zero_reg__
 1700               	.LBE71:
 100:main.c        **** 				receivedChar = USART_Receive();
 1701               		.loc 3 100 0
 1702 00b2 9398      		cbi 0x12,3
 1703               		.loc 3 101 0
 1704 00b4 0E94 0000 		call USART_Receive
 1705               	.LVL129:
 1706 00b8 00C0      		rjmp .L152
 1707               	.LVL130:
 1708               	.L77:
 102:main.c        **** 			}
 103:main.c        **** 		}
 104:main.c        **** 		
 105:main.c        **** 		// Write 64 bytes to RAM on address (and increment)
 106:main.c        **** 		else if (receivedChar == WRITE_RAM) {
 1709               		.loc 3 106 0
 1710 00ba 8735      		cpi r24,lo8(87)
 1711 00bc 01F4      		brne .L82
 107:main.c        **** 			gb_mode();
 1712               		.loc 3 107 0
 1713 00be 0E94 0000 		call gb_mode
 1714               	.LVL131:
 108:main.c        **** 			
 109:main.c        **** 			// Read 64 bytes first as CH340G sends them all at once
 110:main.c        **** 			usart_read_bytes(64);
 1715               		.loc 3 110 0
 1716 00c2 80E4      		ldi r24,lo8(64)
 1717 00c4 0E94 0000 		call usart_read_bytes
 1718               	.LVL132:
 111:main.c        **** 			
 112:main.c        **** 			PORTD |= (1<<LED);
 1719               		.loc 3 112 0
 1720 00c8 939A      		sbi 0x12,3
 1721               	.LVL133:
 1722 00ca 00E0      		ldi r16,lo8(receivedBuffer)
 1723 00cc 10E0      		ldi r17,hi8(receivedBuffer)
 1724 00ce A12C      		mov r10,__zero_reg__
 1725 00d0 B12C      		mov r11,__zero_reg__
 1726               	.LVL134:
 1727               	.L84:
 1728               	.LBB72:
 113:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 114:main.c        **** 				write_8bit_data(address, receivedBuffer[x], MEMORY_WRITE);
 1729               		.loc 3 114 0 discriminator 2
 1730 00d2 F801      		movw r30,r16
 1731 00d4 6191      		ld r22,Z+
 1732 00d6 8F01      		movw r16,r30
 1733 00d8 C501      		movw r24,r10
 1734 00da 8C0D      		add r24,r12
 1735 00dc 9D1D      		adc r25,r13
 1736 00de 41E0      		ldi r20,lo8(1)
 1737 00e0 0E94 0000 		call write_8bit_data
 1738               	.LVL135:
 1739 00e4 FFEF      		ldi r31,-1
 1740 00e6 AF1A      		sub r10,r31
 1741 00e8 BF0A      		sbc r11,r31
 1742               	.LVL136:
 113:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 1743               		.loc 3 113 0 discriminator 2
 1744 00ea 80E4      		ldi r24,64
 1745 00ec A816      		cp r10,r24
 1746 00ee B104      		cpc r11,__zero_reg__
 1747 00f0 01F4      		brne .L84
 1748 00f2 90E4      		ldi r25,64
 1749 00f4 C90E      		add r12,r25
 1750 00f6 D11C      		adc r13,__zero_reg__
 1751 00f8 E11C      		adc r14,__zero_reg__
 1752 00fa F11C      		adc r15,__zero_reg__
 1753               	.LBE72:
 115:main.c        **** 				address++;
 116:main.c        **** 			}
 117:main.c        **** 			
 118:main.c        **** 			PORTD &= ~(1<<LED);
 1754               		.loc 3 118 0
 1755 00fc 9398      		cbi 0x12,3
 119:main.c        **** 			USART_Transmit('1'); // Send back acknowledgement
 1756               		.loc 3 119 0
 1757 00fe 81E3      		ldi r24,lo8(49)
 1758               	.LVL137:
 1759               	.L155:
 1760 0100 0E94 0000 		call USART_Transmit
 1761               	.LVL138:
 1762 0104 00C0      		rjmp .L73
 1763               	.LVL139:
 1764               	.L82:
 120:main.c        **** 		}
 121:main.c        **** 		
 122:main.c        **** 		// Set bank address and write a byte
 123:main.c        **** 		else if (receivedChar == SET_BANK) {
 1765               		.loc 3 123 0
 1766 0106 8234      		cpi r24,lo8(66)
 1767 0108 01F4      		brne .L85
 1768               	.LBB73:
 124:main.c        **** 			gb_mode();
 1769               		.loc 3 124 0
 1770 010a 0E94 0000 		call gb_mode
 1771               	.LVL140:
 125:main.c        **** 			
 126:main.c        **** 			usart_read_chars(); // Read start address
 1772               		.loc 3 126 0
 1773 010e 0E94 0000 		call usart_read_chars
 1774               	.LVL141:
 127:main.c        **** 			uint16_t bankaddress = strtol(receivedBuffer, NULL, 16); // Convert address string in hex to dec
 1775               		.loc 3 127 0
 1776 0112 40E1      		ldi r20,lo8(16)
 1777 0114 50E0      		ldi r21,0
 1778 0116 60E0      		ldi r22,0
 1779 0118 70E0      		ldi r23,0
 1780 011a 80E0      		ldi r24,lo8(receivedBuffer)
 1781 011c 90E0      		ldi r25,hi8(receivedBuffer)
 1782 011e 0E94 0000 		call strtol
 1783               	.LVL142:
 1784 0122 4B01      		movw r8,r22
 1785 0124 5C01      		movw r10,r24
 1786               	.LVL143:
 128:main.c        **** 			
 129:main.c        **** 			receivedChar = USART_Receive(); // Wait for bank number
 1787               		.loc 3 129 0
 1788 0126 0E94 0000 		call USART_Receive
 1789               	.LVL144:
 1790 012a 8093 0000 		sts receivedChar,r24
 130:main.c        **** 			if (receivedChar == 'B') {
 1791               		.loc 3 130 0
 1792 012e 8234      		cpi r24,lo8(66)
 1793 0130 01F0      		breq .+2
 1794 0132 00C0      		rjmp .L73
 1795               	.LBB74:
 131:main.c        **** 				usart_read_chars(); // Read data
 1796               		.loc 3 131 0
 1797 0134 0E94 0000 		call usart_read_chars
 1798               	.LVL145:
 132:main.c        **** 				uint8_t data = atoi(receivedBuffer); // Convert data string to dec
 1799               		.loc 3 132 0
 1800 0138 80E0      		ldi r24,lo8(receivedBuffer)
 1801 013a 90E0      		ldi r25,hi8(receivedBuffer)
 1802 013c 0E94 0000 		call atoi
 1803               	.LVL146:
 133:main.c        **** 				
 134:main.c        **** 				write_8bit_data(bankaddress, data, BANK_WRITE);
 1804               		.loc 3 134 0
 1805 0140 40E0      		ldi r20,0
 1806 0142 682F      		mov r22,r24
 1807 0144 C401      		movw r24,r8
 1808               	.LVL147:
 1809 0146 0E94 0000 		call write_8bit_data
 1810               	.LVL148:
 1811 014a 00C0      		rjmp .L73
 1812               	.LVL149:
 1813               	.L85:
 1814               	.LBE74:
 1815               	.LBE73:
 135:main.c        **** 			}
 136:main.c        **** 		}
 137:main.c        **** 		
 138:main.c        **** 		
 139:main.c        **** 		// ****** Gameboy Advance ******
 140:main.c        **** 		
 141:main.c        **** 		// ---------- ROM ----------
 142:main.c        **** 		// Read one 16bit byte from ROM using address (and increment) until anything but 1 is received
 143:main.c        **** 		else if (receivedChar == GBA_READ_ROM) {
 1816               		.loc 3 143 0
 1817 014c 8237      		cpi r24,lo8(114)
 1818 014e 01F4      		brne .L86
 144:main.c        **** 			gba_mode(); 
 1819               		.loc 3 144 0
 1820 0150 0E94 0000 		call gba_mode
 1821               	.LVL150:
 145:main.c        **** 			
 146:main.c        **** 			receivedChar = '1';
 1822               		.loc 3 146 0
 1823 0154 81E3      		ldi r24,lo8(49)
 1824               	.LVL151:
 1825               	.L153:
 147:main.c        **** 			while (receivedChar == '1') {
 148:main.c        **** 				PORTD |= (1<<LED);
 149:main.c        **** 				for (uint8_t x = 0; x < 32; x++) {
 150:main.c        **** 					uint16_t dataRead = gba_read_16bit_data(address);
 151:main.c        **** 					
 152:main.c        **** 					// Low byte & High byte
 153:main.c        **** 					USART_Transmit(dataRead & 0xFF);
 154:main.c        **** 					USART_Transmit(dataRead >> 8);
 155:main.c        **** 					
 156:main.c        **** 					address++;
 157:main.c        **** 				}
 158:main.c        **** 				
 159:main.c        **** 				PORTD &= ~(1<<LED);
 160:main.c        **** 				receivedChar = USART_Receive();
 1826               		.loc 3 160 0
 1827 0156 8093 0000 		sts receivedChar,r24
 1828               	.LVL152:
 147:main.c        **** 			while (receivedChar == '1') {
 1829               		.loc 3 147 0
 1830 015a 8091 0000 		lds r24,receivedChar
 1831 015e 8133      		cpi r24,lo8(49)
 1832 0160 01F0      		breq .+2
 1833 0162 00C0      		rjmp .L73
 148:main.c        **** 				for (uint8_t x = 0; x < 32; x++) {
 1834               		.loc 3 148 0
 1835 0164 939A      		sbi 0x12,3
 1836               	.LVL153:
 1837 0166 4601      		movw r8,r12
 1838 0168 5701      		movw r10,r14
 1839 016a 10E2      		ldi r17,lo8(32)
 1840 016c 1C0D      		add r17,r12
 1841               	.LVL154:
 1842               	.L89:
 1843               	.LBB75:
 1844               	.LBB76:
 150:main.c        **** 					
 1845               		.loc 3 150 0 discriminator 2
 1846 016e C501      		movw r24,r10
 1847 0170 B401      		movw r22,r8
 1848 0172 0E94 0000 		call gba_read_16bit_data
 1849               	.LVL155:
 153:main.c        **** 					USART_Transmit(dataRead >> 8);
 1850               		.loc 3 153 0 discriminator 2
 1851 0176 9983      		std Y+1,r25
 1852 0178 0E94 0000 		call USART_Transmit
 1853               	.LVL156:
 154:main.c        **** 					
 1854               		.loc 3 154 0 discriminator 2
 1855 017c 9981      		ldd r25,Y+1
 1856 017e 892F      		mov r24,r25
 1857 0180 0E94 0000 		call USART_Transmit
 1858               	.LVL157:
 156:main.c        **** 				}
 1859               		.loc 3 156 0 discriminator 2
 1860 0184 EFEF      		ldi r30,-1
 1861 0186 8E1A      		sub r8,r30
 1862 0188 9E0A      		sbc r9,r30
 1863 018a AE0A      		sbc r10,r30
 1864 018c BE0A      		sbc r11,r30
 1865               	.LVL158:
 1866               	.LBE76:
 149:main.c        **** 					uint16_t dataRead = gba_read_16bit_data(address);
 1867               		.loc 3 149 0 discriminator 2
 1868 018e 1811      		cpse r17,r8
 1869 0190 00C0      		rjmp .L89
 1870 0192 F0E2      		ldi r31,32
 1871 0194 CF0E      		add r12,r31
 1872 0196 D11C      		adc r13,__zero_reg__
 1873 0198 E11C      		adc r14,__zero_reg__
 1874 019a F11C      		adc r15,__zero_reg__
 1875               	.LVL159:
 1876               	.LBE75:
 159:main.c        **** 				receivedChar = USART_Receive();
 1877               		.loc 3 159 0
 1878 019c 9398      		cbi 0x12,3
 1879               		.loc 3 160 0
 1880 019e 0E94 0000 		call USART_Receive
 1881               	.LVL160:
 1882 01a2 00C0      		rjmp .L153
 1883               	.LVL161:
 1884               	.L86:
 161:main.c        **** 			}
 162:main.c        **** 		}
 163:main.c        **** 		
 164:main.c        **** 		
 165:main.c        **** 		// ---------- SRAM ----------
 166:main.c        **** 		// Read RAM from address (and increment) until anything but 1 is received
 167:main.c        **** 		else if (receivedChar == GBA_READ_SRAM) {
 1885               		.loc 3 167 0
 1886 01a4 8D36      		cpi r24,lo8(109)
 1887 01a6 01F4      		brne .L91
 168:main.c        **** 			gb_mode(); // Set GB mode as it uses 16 bit address with 8 bit data
 1888               		.loc 3 168 0
 1889 01a8 0E94 0000 		call gb_mode
 1890               	.LVL162:
 169:main.c        **** 			
 170:main.c        **** 			receivedChar = '1';
 1891               		.loc 3 170 0
 1892 01ac 81E3      		ldi r24,lo8(49)
 1893               	.LVL163:
 1894               	.L154:
 171:main.c        **** 			while (receivedChar == '1') {
 172:main.c        **** 				PORTD |= (1<<LED);
 173:main.c        **** 				for (uint8_t x = 0; x < 64; x++) {
 174:main.c        **** 					USART_Transmit(gba_read_ram_8bit_data(address));
 175:main.c        **** 					address++;
 176:main.c        **** 				}
 177:main.c        **** 				
 178:main.c        **** 				PORTD &= ~(1<<LED);
 179:main.c        **** 				receivedChar = USART_Receive();
 1895               		.loc 3 179 0
 1896 01ae 8093 0000 		sts receivedChar,r24
 1897               	.LVL164:
 171:main.c        **** 			while (receivedChar == '1') {
 1898               		.loc 3 171 0
 1899 01b2 8091 0000 		lds r24,receivedChar
 1900 01b6 8133      		cpi r24,lo8(49)
 1901 01b8 01F0      		breq .+2
 1902 01ba 00C0      		rjmp .L157
 172:main.c        **** 				for (uint8_t x = 0; x < 64; x++) {
 1903               		.loc 3 172 0
 1904 01bc 939A      		sbi 0x12,3
 1905               	.LVL165:
 1906 01be A12C      		mov r10,__zero_reg__
 1907 01c0 B12C      		mov r11,__zero_reg__
 1908               	.LVL166:
 1909               	.L94:
 1910 01c2 C501      		movw r24,r10
 1911 01c4 8C0D      		add r24,r12
 1912 01c6 9D1D      		adc r25,r13
 1913               	.LBB77:
 174:main.c        **** 					address++;
 1914               		.loc 3 174 0 discriminator 2
 1915 01c8 0E94 0000 		call gba_read_ram_8bit_data
 1916               	.LVL167:
 1917 01cc 0E94 0000 		call USART_Transmit
 1918               	.LVL168:
 1919 01d0 8FEF      		ldi r24,-1
 1920 01d2 A81A      		sub r10,r24
 1921 01d4 B80A      		sbc r11,r24
 1922               	.LVL169:
 173:main.c        **** 					USART_Transmit(gba_read_ram_8bit_data(address));
 1923               		.loc 3 173 0 discriminator 2
 1924 01d6 90E4      		ldi r25,64
 1925 01d8 A916      		cp r10,r25
 1926 01da B104      		cpc r11,__zero_reg__
 1927 01dc 01F4      		brne .L94
 1928 01de E0E4      		ldi r30,64
 1929 01e0 CE0E      		add r12,r30
 1930 01e2 D11C      		adc r13,__zero_reg__
 1931 01e4 E11C      		adc r14,__zero_reg__
 1932 01e6 F11C      		adc r15,__zero_reg__
 1933               	.LBE77:
 178:main.c        **** 				receivedChar = USART_Receive();
 1934               		.loc 3 178 0
 1935 01e8 9398      		cbi 0x12,3
 1936               		.loc 3 179 0
 1937 01ea 0E94 0000 		call USART_Receive
 1938               	.LVL170:
 1939 01ee 00C0      		rjmp .L154
 1940               	.LVL171:
 1941               	.L91:
 180:main.c        **** 			}
 181:main.c        **** 			
 182:main.c        **** 			gba_mode(); // Set back
 183:main.c        **** 		}
 184:main.c        **** 		
 185:main.c        **** 		// Write to RAM on address (and increment) with 64 bytes of data
 186:main.c        **** 		else if (receivedChar == GBA_WRITE_SRAM) {
 1942               		.loc 3 186 0
 1943 01f0 8737      		cpi r24,lo8(119)
 1944 01f2 01F4      		brne .L96
 187:main.c        **** 			gb_mode();
 1945               		.loc 3 187 0
 1946 01f4 0E94 0000 		call gb_mode
 1947               	.LVL172:
 188:main.c        **** 			
 189:main.c        **** 			usart_read_bytes(64);
 1948               		.loc 3 189 0
 1949 01f8 80E4      		ldi r24,lo8(64)
 1950 01fa 0E94 0000 		call usart_read_bytes
 1951               	.LVL173:
 190:main.c        **** 			
 191:main.c        **** 			PORTD |= (1<<LED);
 1952               		.loc 3 191 0
 1953 01fe 939A      		sbi 0x12,3
 1954               	.LVL174:
 1955 0200 00E0      		ldi r16,lo8(receivedBuffer)
 1956 0202 10E0      		ldi r17,hi8(receivedBuffer)
 1957 0204 A12C      		mov r10,__zero_reg__
 1958 0206 B12C      		mov r11,__zero_reg__
 1959               	.LVL175:
 1960               	.L98:
 1961               	.LBB78:
 192:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 193:main.c        **** 				gba_write_ram_8bit_data(address, receivedBuffer[x]);
 1962               		.loc 3 193 0 discriminator 2
 1963 0208 F801      		movw r30,r16
 1964 020a 6191      		ld r22,Z+
 1965 020c 8F01      		movw r16,r30
 1966 020e C501      		movw r24,r10
 1967 0210 8C0D      		add r24,r12
 1968 0212 9D1D      		adc r25,r13
 1969 0214 0E94 0000 		call gba_write_ram_8bit_data
 1970               	.LVL176:
 1971 0218 FFEF      		ldi r31,-1
 1972 021a AF1A      		sub r10,r31
 1973 021c BF0A      		sbc r11,r31
 1974               	.LVL177:
 192:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 1975               		.loc 3 192 0 discriminator 2
 1976 021e 80E4      		ldi r24,64
 1977 0220 A816      		cp r10,r24
 1978 0222 B104      		cpc r11,__zero_reg__
 1979 0224 01F4      		brne .L98
 1980 0226 00C0      		rjmp .L160
 1981               	.LVL178:
 1982               	.L96:
 1983               	.LBE78:
 194:main.c        **** 				address++;
 195:main.c        **** 			}
 196:main.c        **** 			USART_Transmit('1'); // Send back acknowledgement
 197:main.c        **** 			
 198:main.c        **** 			PORTD &= ~(1<<LED);
 199:main.c        **** 			gba_mode(); // Set back
 200:main.c        **** 		}
 201:main.c        **** 		
 202:main.c        **** 		// 'o' - Write 1 byte to SRAM address
 203:main.c        **** 		else if (receivedChar == GBA_WRITE_ONE_BYTE_SRAM) {
 1984               		.loc 3 203 0
 1985 0228 8F36      		cpi r24,lo8(111)
 1986 022a 01F4      		brne .L99
 1987               	.LBB79:
 204:main.c        **** 			gb_mode();
 1988               		.loc 3 204 0
 1989 022c 0E94 0000 		call gb_mode
 1990               	.LVL179:
 205:main.c        **** 			
 206:main.c        **** 			uint8_t data = USART_Receive();
 1991               		.loc 3 206 0
 1992 0230 0E94 0000 		call USART_Receive
 1993               	.LVL180:
 207:main.c        **** 			gba_write_ram_8bit_data(address, data);
 1994               		.loc 3 207 0
 1995 0234 682F      		mov r22,r24
 1996 0236 C601      		movw r24,r12
 1997               	.LVL181:
 1998 0238 0E94 0000 		call gba_write_ram_8bit_data
 1999               	.LVL182:
 2000 023c 00C0      		rjmp .L162
 2001               	.LVL183:
 2002               	.L99:
 2003               	.LBE79:
 208:main.c        **** 			USART_Transmit('1'); // Send back acknowledgement
 209:main.c        **** 			
 210:main.c        **** 			gba_mode(); // Set back
 211:main.c        **** 		}
 212:main.c        **** 		
 213:main.c        **** 		
 214:main.c        **** 		// ---------- FLASH ----------
 215:main.c        **** 		// Read the Flash Manufacturer and Device ID
 216:main.c        **** 		else if (receivedChar == GBA_FLASH_READ_ID) {
 2004               		.loc 3 216 0
 2005 023e 8936      		cpi r24,lo8(105)
 2006 0240 01F4      		brne .L100
 217:main.c        **** 			gb_mode();
 2007               		.loc 3 217 0
 2008 0242 0E94 0000 		call gb_mode
 2009               	.LVL184:
 218:main.c        **** 			
 219:main.c        **** 			flash_read_chip_id();
 2010               		.loc 3 219 0
 2011 0246 0E94 0000 		call flash_read_chip_id
 2012               	.LVL185:
 220:main.c        **** 			USART_Transmit(flashChipIdBuffer[0]);
 2013               		.loc 3 220 0
 2014 024a 8091 0000 		lds r24,flashChipIdBuffer
 2015 024e 0E94 0000 		call USART_Transmit
 2016               	.LVL186:
 221:main.c        **** 			USART_Transmit(flashChipIdBuffer[1]);
 2017               		.loc 3 221 0
 2018 0252 8091 0000 		lds r24,flashChipIdBuffer+1
 2019 0256 00C0      		rjmp .L161
 2020               	.LVL187:
 2021               	.L100:
 222:main.c        **** 			
 223:main.c        **** 			gba_mode(); // Set back
 224:main.c        **** 		}
 225:main.c        **** 		
 226:main.c        **** 		// Change bank
 227:main.c        **** 		else if (receivedChar == GBA_FLASH_SET_BANK) {
 2022               		.loc 3 227 0
 2023 0258 8B36      		cpi r24,lo8(107)
 2024 025a 01F4      		brne .L101
 2025               	.LBB80:
 228:main.c        **** 			usart_read_chars(); // Read data
 2026               		.loc 3 228 0
 2027 025c 0E94 0000 		call usart_read_chars
 2028               	.LVL188:
 229:main.c        **** 			uint8_t bank = atoi(receivedBuffer); // Convert data string to dec
 2029               		.loc 3 229 0
 2030 0260 80E0      		ldi r24,lo8(receivedBuffer)
 2031 0262 90E0      		ldi r25,hi8(receivedBuffer)
 2032 0264 0E94 0000 		call atoi
 2033               	.LVL189:
 230:main.c        **** 			
 231:main.c        **** 			gb_mode();
 2034               		.loc 3 231 0
 2035 0268 8983      		std Y+1,r24
 2036 026a 0E94 0000 		call gb_mode
 2037               	.LVL190:
 232:main.c        **** 			flash_switch_bank(bank);
 2038               		.loc 3 232 0
 2039 026e 8981      		ldd r24,Y+1
 2040 0270 0E94 0000 		call flash_switch_bank
 2041               	.LVL191:
 2042 0274 00C0      		rjmp .L157
 2043               	.LVL192:
 2044               	.L101:
 2045               	.LBE80:
 233:main.c        **** 			
 234:main.c        **** 			gba_mode(); // Set back
 235:main.c        **** 		}
 236:main.c        **** 		
 237:main.c        **** 		// Erase 4K sector on Flash (sector 0 to 15 for 512Kbit)
 238:main.c        **** 		else if (receivedChar == GBA_FLASH_4K_SECTOR_ERASE) {
 2046               		.loc 3 238 0
 2047 0276 8337      		cpi r24,lo8(115)
 2048 0278 01F4      		brne .L102
 2049               	.LBB81:
 239:main.c        **** 			gb_mode();
 2050               		.loc 3 239 0
 2051 027a 0E94 0000 		call gb_mode
 2052               	.LVL193:
 240:main.c        **** 			
 241:main.c        **** 			usart_read_chars(); // Read sector
 2053               		.loc 3 241 0
 2054 027e 0E94 0000 		call usart_read_chars
 2055               	.LVL194:
 242:main.c        **** 			uint8_t sectorAddress = strtol(receivedBuffer, NULL, 16); // Convert address string in hex to de
 2056               		.loc 3 242 0
 2057 0282 40E1      		ldi r20,lo8(16)
 2058 0284 50E0      		ldi r21,0
 2059 0286 60E0      		ldi r22,0
 2060 0288 70E0      		ldi r23,0
 2061 028a 80E0      		ldi r24,lo8(receivedBuffer)
 2062 028c 90E0      		ldi r25,hi8(receivedBuffer)
 2063 028e 0E94 0000 		call strtol
 2064               	.LVL195:
 2065 0292 862F      		mov r24,r22
 2066               	.LVL196:
 243:main.c        **** 			
 244:main.c        **** 			flash_erase_4k_sector(sectorAddress);
 2067               		.loc 3 244 0
 2068 0294 0E94 0000 		call flash_erase_4k_sector
 2069               	.LVL197:
 2070               	.L162:
 245:main.c        **** 			USART_Transmit('1'); // Send back acknowledgement
 2071               		.loc 3 245 0
 2072 0298 81E3      		ldi r24,lo8(49)
 2073               	.L161:
 2074 029a 0E94 0000 		call USART_Transmit
 2075               	.LVL198:
 2076 029e 00C0      		rjmp .L157
 2077               	.LVL199:
 2078               	.L102:
 2079               	.LBE81:
 246:main.c        **** 			
 247:main.c        **** 			gba_mode(); // Set back
 248:main.c        **** 		}
 249:main.c        **** 		
 250:main.c        **** 		// Write 64 bytes to Flash address one byte write at a time (and increment)
 251:main.c        **** 		else if (receivedChar == GBA_FLASH_WRITE_BYTE) {
 2080               		.loc 3 251 0
 2081 02a0 8236      		cpi r24,lo8(98)
 2082 02a2 01F4      		brne .L103
 252:main.c        **** 			gb_mode();
 2083               		.loc 3 252 0
 2084 02a4 0E94 0000 		call gb_mode
 2085               	.LVL200:
 253:main.c        **** 			
 254:main.c        **** 			usart_read_bytes(64);
 2086               		.loc 3 254 0
 2087 02a8 80E4      		ldi r24,lo8(64)
 2088 02aa 0E94 0000 		call usart_read_bytes
 2089               	.LVL201:
 255:main.c        **** 			
 256:main.c        **** 			PORTD |= (1<<LED);
 2090               		.loc 3 256 0
 2091 02ae 939A      		sbi 0x12,3
 2092               	.LVL202:
 2093 02b0 00E0      		ldi r16,lo8(receivedBuffer)
 2094 02b2 10E0      		ldi r17,hi8(receivedBuffer)
 2095 02b4 A12C      		mov r10,__zero_reg__
 2096 02b6 B12C      		mov r11,__zero_reg__
 2097               	.LVL203:
 2098               	.L105:
 2099               	.LBB82:
 257:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 258:main.c        **** 				flash_write_byte(address, receivedBuffer[x]);
 2100               		.loc 3 258 0 discriminator 2
 2101 02b8 F801      		movw r30,r16
 2102 02ba 6191      		ld r22,Z+
 2103 02bc 8F01      		movw r16,r30
 2104 02be C501      		movw r24,r10
 2105 02c0 8C0D      		add r24,r12
 2106 02c2 9D1D      		adc r25,r13
 2107 02c4 0E94 0000 		call flash_write_byte
 2108               	.LVL204:
 2109 02c8 FFEF      		ldi r31,-1
 2110 02ca AF1A      		sub r10,r31
 2111 02cc BF0A      		sbc r11,r31
 2112               	.LVL205:
 257:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 2113               		.loc 3 257 0 discriminator 2
 2114 02ce 80E4      		ldi r24,64
 2115 02d0 A816      		cp r10,r24
 2116 02d2 B104      		cpc r11,__zero_reg__
 2117 02d4 01F4      		brne .L105
 2118               	.LVL206:
 2119               	.L160:
 2120 02d6 90E4      		ldi r25,64
 2121 02d8 C90E      		add r12,r25
 2122 02da D11C      		adc r13,__zero_reg__
 2123 02dc E11C      		adc r14,__zero_reg__
 2124 02de F11C      		adc r15,__zero_reg__
 2125 02e0 00C0      		rjmp .L156
 2126               	.LVL207:
 2127               	.L103:
 2128               	.LBE82:
 259:main.c        **** 				address++;
 260:main.c        **** 			}
 261:main.c        **** 			USART_Transmit('1'); // Send back acknowledgement
 262:main.c        **** 			
 263:main.c        **** 			PORTD &= ~(1<<LED);
 264:main.c        **** 			gba_mode(); // Set back
 265:main.c        **** 		}
 266:main.c        **** 		
 267:main.c        **** 		// Write 128 bytes to flash sector for Atmel flash (and increment)
 268:main.c        **** 		else if (receivedChar == GBA_FLASH_WRITE_ATMEL) {
 2129               		.loc 3 268 0
 2130 02e2 8136      		cpi r24,lo8(97)
 2131 02e4 01F4      		brne .L73
 269:main.c        **** 			gb_mode();
 2132               		.loc 3 269 0
 2133 02e6 0E94 0000 		call gb_mode
 2134               	.LVL208:
 270:main.c        **** 			
 271:main.c        **** 			usart_read_bytes(128);
 2135               		.loc 3 271 0
 2136 02ea 80E8      		ldi r24,lo8(-128)
 2137 02ec 0E94 0000 		call usart_read_bytes
 2138               	.LVL209:
 272:main.c        **** 			
 273:main.c        **** 			PORTD |= (1<<LED);
 2139               		.loc 3 273 0
 2140 02f0 939A      		sbi 0x12,3
 274:main.c        **** 			flash_write_sector(address); // Address used as sector number
 2141               		.loc 3 274 0
 2142 02f2 C601      		movw r24,r12
 2143 02f4 0E94 0000 		call flash_write_sector
 2144               	.LVL210:
 275:main.c        **** 			address++;
 2145               		.loc 3 275 0
 2146 02f8 EFEF      		ldi r30,-1
 2147 02fa CE1A      		sub r12,r30
 2148 02fc DE0A      		sbc r13,r30
 2149 02fe EE0A      		sbc r14,r30
 2150 0300 FE0A      		sbc r15,r30
 2151               	.LVL211:
 2152               	.L156:
 276:main.c        **** 			USART_Transmit('1'); // Send back acknowledgement
 2153               		.loc 3 276 0
 2154 0302 81E3      		ldi r24,lo8(49)
 2155 0304 0E94 0000 		call USART_Transmit
 2156               	.LVL212:
 277:main.c        **** 			
 278:main.c        **** 			PORTD &= ~(1<<LED);
 2157               		.loc 3 278 0
 2158 0308 9398      		cbi 0x12,3
 2159               	.L157:
 279:main.c        **** 			gba_mode(); // Set back
 2160               		.loc 3 279 0
 2161 030a 0E94 0000 		call gba_mode
 2162               	.LVL213:
 2163               	.L73:
 280:main.c        **** 		}
 281:main.c        **** 		
 282:main.c        **** 		
 283:main.c        **** 		// ---------- EEPROM ----------
 284:main.c        **** 		// Set EEPROM size
 285:main.c        **** 		if (receivedChar == GBA_SET_EEPROM_SIZE) {
 2164               		.loc 3 285 0
 2165 030e 8091 0000 		lds r24,receivedChar
 2166 0312 8335      		cpi r24,lo8(83)
 2167 0314 01F4      		brne .L106
 286:main.c        **** 			usart_read_chars(); // Read size
 2168               		.loc 3 286 0
 2169 0316 0E94 0000 		call usart_read_chars
 2170               	.LVL214:
 287:main.c        **** 			eepromSize = strtol(receivedBuffer, NULL, 16); // Convert size to dec
 2171               		.loc 3 287 0
 2172 031a 40E1      		ldi r20,lo8(16)
 2173 031c 50E0      		ldi r21,0
 2174 031e 60E0      		ldi r22,0
 2175 0320 70E0      		ldi r23,0
 2176 0322 80E0      		ldi r24,lo8(receivedBuffer)
 2177 0324 90E0      		ldi r25,hi8(receivedBuffer)
 2178 0326 0E94 0000 		call strtol
 2179               	.LVL215:
 2180 032a 762E      		mov r7,r22
 2181               	.LVL216:
 2182 032c 00C0      		rjmp .L69
 2183               	.L106:
 288:main.c        **** 		}
 289:main.c        **** 		
 290:main.c        **** 		// Read the EEPROM on address (and increment) until anything but 1 is received
 291:main.c        **** 		else if (receivedChar == GBA_READ_EEPROM) {
 2184               		.loc 3 291 0
 2185 032e 8536      		cpi r24,lo8(101)
 2186 0330 01F4      		brne .L108
 292:main.c        **** 			gba_eeprom_mode();
 2187               		.loc 3 292 0
 2188 0332 0E94 0000 		call gba_eeprom_mode
 2189               	.LVL217:
 293:main.c        **** 			
 294:main.c        **** 			receivedChar = '1';
 2190               		.loc 3 294 0
 2191 0336 81E3      		ldi r24,lo8(49)
 2192               	.L158:
 295:main.c        **** 			while (receivedChar == '1') {
 296:main.c        **** 				PORTD |= (1<<LED);
 297:main.c        **** 				gba_eeprom_read(address, eepromSize);
 298:main.c        **** 				
 299:main.c        **** 				// Send back the 8 bytes of data
 300:main.c        **** 				for (uint8_t c = 0; c < 8; c++) {
 301:main.c        **** 					USART_Transmit(eepromBuffer[c]);
 302:main.c        **** 				}
 303:main.c        **** 				address++; // Increment to next 8 bytes
 304:main.c        **** 				
 305:main.c        **** 				PORTD &= ~(1<<LED);
 306:main.c        **** 				receivedChar = USART_Receive();
 2193               		.loc 3 306 0
 2194 0338 8093 0000 		sts receivedChar,r24
 295:main.c        **** 			while (receivedChar == '1') {
 2195               		.loc 3 295 0
 2196 033c 8091 0000 		lds r24,receivedChar
 2197 0340 8133      		cpi r24,lo8(49)
 2198 0342 01F4      		brne .L151
 296:main.c        **** 				gba_eeprom_read(address, eepromSize);
 2199               		.loc 3 296 0
 2200 0344 939A      		sbi 0x12,3
 297:main.c        **** 				
 2201               		.loc 3 297 0
 2202 0346 672D      		mov r22,r7
 2203 0348 C601      		movw r24,r12
 2204 034a 0E94 0000 		call gba_eeprom_read
 2205               	.LVL218:
 2206 034e 00E0      		ldi r16,lo8(eepromBuffer)
 2207 0350 10E0      		ldi r17,hi8(eepromBuffer)
 2208               	.LVL219:
 2209               	.L111:
 2210               	.LBB83:
 301:main.c        **** 				}
 2211               		.loc 3 301 0 discriminator 2
 2212 0352 F801      		movw r30,r16
 2213 0354 8191      		ld r24,Z+
 2214 0356 8F01      		movw r16,r30
 2215               	.LVL220:
 2216 0358 0E94 0000 		call USART_Transmit
 2217               	.LVL221:
 300:main.c        **** 					USART_Transmit(eepromBuffer[c]);
 2218               		.loc 3 300 0 discriminator 2
 2219 035c F0E0      		ldi r31,hi8(eepromBuffer+8)
 2220 035e 0030      		cpi r16,lo8(eepromBuffer+8)
 2221 0360 1F07      		cpc r17,r31
 2222 0362 01F4      		brne .L111
 2223               	.LBE83:
 303:main.c        **** 				
 2224               		.loc 3 303 0
 2225 0364 8FEF      		ldi r24,-1
 2226 0366 C81A      		sub r12,r24
 2227 0368 D80A      		sbc r13,r24
 2228 036a E80A      		sbc r14,r24
 2229 036c F80A      		sbc r15,r24
 2230               	.LVL222:
 305:main.c        **** 				receivedChar = USART_Receive();
 2231               		.loc 3 305 0
 2232 036e 9398      		cbi 0x12,3
 2233               		.loc 3 306 0
 2234 0370 0E94 0000 		call USART_Receive
 2235               	.LVL223:
 2236 0374 00C0      		rjmp .L158
 2237               	.LVL224:
 2238               	.L108:
 307:main.c        **** 			}
 308:main.c        **** 			
 309:main.c        **** 			gba_mode(); // Set back
 310:main.c        **** 		}
 311:main.c        **** 		
 312:main.c        **** 		// Write 8 bytes to the EEPROM address (and increment)
 313:main.c        **** 		else if (receivedChar == GBA_WRITE_EEPROM) {
 2239               		.loc 3 313 0
 2240 0376 8037      		cpi r24,lo8(112)
 2241 0378 01F4      		brne .L113
 314:main.c        **** 			gba_eeprom_mode();
 2242               		.loc 3 314 0
 2243 037a 0E94 0000 		call gba_eeprom_mode
 2244               	.LVL225:
 2245 037e 00E0      		ldi r16,lo8(eepromBuffer)
 2246 0380 10E0      		ldi r17,hi8(eepromBuffer)
 2247               	.LVL226:
 2248               	.L115:
 2249               	.LBB84:
 315:main.c        **** 			
 316:main.c        **** 			// Read 8 bytes from USART and place in buffer
 317:main.c        **** 			for (uint8_t x = 0; x < 8; x++) {
 318:main.c        **** 				eepromBuffer[x] = USART_Receive();
 2250               		.loc 3 318 0 discriminator 2
 2251 0382 0E94 0000 		call USART_Receive
 2252               	.LVL227:
 2253 0386 F801      		movw r30,r16
 2254 0388 8193      		st Z+,r24
 2255 038a 8F01      		movw r16,r30
 2256               	.LVL228:
 317:main.c        **** 				eepromBuffer[x] = USART_Receive();
 2257               		.loc 3 317 0 discriminator 2
 2258 038c F0E0      		ldi r31,hi8(eepromBuffer+8)
 2259 038e 0030      		cpi r16,lo8(eepromBuffer+8)
 2260 0390 1F07      		cpc r17,r31
 2261 0392 01F4      		brne .L115
 2262               	.LBE84:
 319:main.c        **** 			}
 320:main.c        **** 			PORTD |= (1<<LED);
 2263               		.loc 3 320 0
 2264 0394 939A      		sbi 0x12,3
 321:main.c        **** 			
 322:main.c        **** 			gba_eeprom_write(address, eepromSize);
 2265               		.loc 3 322 0
 2266 0396 672D      		mov r22,r7
 2267 0398 C601      		movw r24,r12
 2268 039a 0E94 0000 		call gba_eeprom_write
 2269               	.LVL229:
 323:main.c        **** 			address++;
 2270               		.loc 3 323 0
 2271 039e 8FEF      		ldi r24,-1
 2272 03a0 C81A      		sub r12,r24
 2273 03a2 D80A      		sbc r13,r24
 2274 03a4 E80A      		sbc r14,r24
 2275 03a6 F80A      		sbc r15,r24
 2276               	.LVL230:
 2277               	.LBB85:
 2278               	.LBB86:
 163:c:\winavr-20100110\avr\include\util\delay.h **** 
 2279               		.loc 2 163 0
 2280 03a8 EFE7      		ldi r30,lo8(15999)
 2281 03aa FEE3      		ldi r31,hi8(15999)
 2282 03ac 3197      		1: sbiw r30,1
 2283 03ae 01F4      		brne 1b
 2284 03b0 00C0      		rjmp .
 2285 03b2 0000      		nop
 2286               	.LBE86:
 2287               	.LBE85:
 324:main.c        **** 			
 325:main.c        **** 			_delay_ms(8); // Wait for EEPROM to write data (8ms)
 326:main.c        **** 			USART_Transmit('1'); // Send back acknowledgement
 2288               		.loc 3 326 0
 2289 03b4 81E3      		ldi r24,lo8(49)
 2290 03b6 0E94 0000 		call USART_Transmit
 2291               	.LVL231:
 327:main.c        **** 			
 328:main.c        **** 			PORTD &= ~(1<<LED);
 2292               		.loc 3 328 0
 2293 03ba 9398      		cbi 0x12,3
 2294               	.LVL232:
 2295               	.L151:
 329:main.c        **** 			gba_mode(); // Set back
 2296               		.loc 3 329 0
 2297 03bc 0E94 0000 		call gba_mode
 2298               	.LVL233:
 2299 03c0 00C0      		rjmp .L69
 2300               	.L113:
 330:main.c        **** 		}
 331:main.c        **** 		
 332:main.c        **** 		
 333:main.c        **** 		// ---------- General commands ----------
 334:main.c        **** 		// Set any pin as input/output
 335:main.c        **** 		// Reads the DDR/PORT (e.g. DDRB/PORTB is 'B') and the hex value that represents pins to set to a
 336:main.c        **** 		else if (receivedChar == SET_INPUT || receivedChar == SET_OUTPUT) {
 2301               		.loc 3 336 0
 2302 03c2 8934      		cpi r24,lo8(73)
 2303 03c4 01F0      		breq .L116
 2304               		.loc 3 336 0 is_stmt 0 discriminator 1
 2305 03c6 8F34      		cpi r24,lo8(79)
 2306 03c8 01F0      		breq .+2
 2307 03ca 00C0      		rjmp .L117
 2308               	.L116:
 2309               	.LBB87:
 337:main.c        **** 			char portChar = USART_Receive();
 2310               		.loc 3 337 0 is_stmt 1
 2311 03cc 0E94 0000 		call USART_Receive
 2312               	.LVL234:
 2313 03d0 182F      		mov r17,r24
 2314               	.LVL235:
 338:main.c        **** 			usart_read_chars();
 2315               		.loc 3 338 0
 2316 03d2 0E94 0000 		call usart_read_chars
 2317               	.LVL236:
 339:main.c        **** 			uint8_t setValue = strtol(receivedBuffer, NULL, 16);
 2318               		.loc 3 339 0
 2319 03d6 40E1      		ldi r20,lo8(16)
 2320 03d8 50E0      		ldi r21,0
 2321 03da 60E0      		ldi r22,0
 2322 03dc 70E0      		ldi r23,0
 2323 03de 80E0      		ldi r24,lo8(receivedBuffer)
 2324 03e0 90E0      		ldi r25,hi8(receivedBuffer)
 2325 03e2 0E94 0000 		call strtol
 2326               	.LVL237:
 340:main.c        **** 			
 341:main.c        **** 			PORTD |= (1<<LED);
 2327               		.loc 3 341 0
 2328 03e6 939A      		sbi 0x12,3
 342:main.c        **** 			if (receivedChar == SET_INPUT) {
 2329               		.loc 3 342 0
 2330 03e8 8091 0000 		lds r24,receivedChar
 2331 03ec 8934      		cpi r24,lo8(73)
 2332 03ee 01F4      		brne .L118
 343:main.c        **** 				if (portChar == 'A') {
 2333               		.loc 3 343 0
 2334 03f0 1134      		cpi r17,lo8(65)
 2335 03f2 01F4      		brne .L119
 344:main.c        **** 					DDRA &= ~(setValue);
 2336               		.loc 3 344 0
 2337 03f4 8AB3      		in r24,0x1a
 2338 03f6 6095      		com r22
 2339               	.LVL238:
 2340 03f8 6823      		and r22,r24
 2341               	.LVL239:
 2342 03fa 6ABB      		out 0x1a,r22
 2343 03fc 00C0      		rjmp .L138
 2344               	.LVL240:
 2345               	.L119:
 345:main.c        **** 				}
 346:main.c        **** 				else if (portChar == 'B') {
 2346               		.loc 3 346 0
 2347 03fe 1234      		cpi r17,lo8(66)
 2348 0400 01F4      		brne .L121
 347:main.c        **** 					DDRB &= ~(setValue);
 2349               		.loc 3 347 0
 2350 0402 87B3      		in r24,0x17
 2351 0404 6095      		com r22
 2352               	.LVL241:
 2353 0406 6823      		and r22,r24
 2354               	.LVL242:
 2355 0408 67BB      		out 0x17,r22
 2356 040a 00C0      		rjmp .L138
 2357               	.LVL243:
 2358               	.L121:
 348:main.c        **** 				}
 349:main.c        **** 				else if (portChar == 'C') {
 2359               		.loc 3 349 0
 2360 040c 1334      		cpi r17,lo8(67)
 2361 040e 01F4      		brne .L122
 350:main.c        **** 					DDRC &= ~(setValue);
 2362               		.loc 3 350 0
 2363 0410 84B3      		in r24,0x14
 2364 0412 6095      		com r22
 2365               	.LVL244:
 2366 0414 6823      		and r22,r24
 2367               	.LVL245:
 2368 0416 64BB      		out 0x14,r22
 2369 0418 00C0      		rjmp .L138
 2370               	.LVL246:
 2371               	.L122:
 351:main.c        **** 				}
 352:main.c        **** 				else if (portChar == 'D') {
 2372               		.loc 3 352 0
 2373 041a 1434      		cpi r17,lo8(68)
 2374 041c 01F0      		breq .+2
 2375 041e 00C0      		rjmp .L138
 353:main.c        **** 					DDRD &= ~(setValue);
 2376               		.loc 3 353 0
 2377 0420 81B3      		in r24,0x11
 2378 0422 6095      		com r22
 2379               	.LVL247:
 2380 0424 6823      		and r22,r24
 2381               	.LVL248:
 2382 0426 61BB      		out 0x11,r22
 2383 0428 00C0      		rjmp .L138
 2384               	.LVL249:
 2385               	.L118:
 354:main.c        **** 				}
 355:main.c        **** 			}
 356:main.c        **** 			else if (receivedChar == SET_OUTPUT) {
 2386               		.loc 3 356 0
 2387 042a 8F34      		cpi r24,lo8(79)
 2388 042c 01F0      		breq .+2
 2389 042e 00C0      		rjmp .L138
 357:main.c        **** 				if (portChar == 'A') {
 2390               		.loc 3 357 0
 2391 0430 1134      		cpi r17,lo8(65)
 2392 0432 01F4      		brne .L123
 358:main.c        **** 					DDRA |= (setValue);
 2393               		.loc 3 358 0
 2394 0434 8AB3      		in r24,0x1a
 2395 0436 862B      		or r24,r22
 2396 0438 8ABB      		out 0x1a,r24
 2397 043a 00C0      		rjmp .L138
 2398               	.L123:
 359:main.c        **** 				}
 360:main.c        **** 				else if (portChar == 'B') {
 2399               		.loc 3 360 0
 2400 043c 1234      		cpi r17,lo8(66)
 2401 043e 01F4      		brne .L124
 361:main.c        **** 					DDRB |= (setValue);
 2402               		.loc 3 361 0
 2403 0440 87B3      		in r24,0x17
 2404 0442 862B      		or r24,r22
 2405 0444 87BB      		out 0x17,r24
 2406 0446 00C0      		rjmp .L138
 2407               	.L124:
 362:main.c        **** 				}
 363:main.c        **** 				else if (portChar == 'C') {
 2408               		.loc 3 363 0
 2409 0448 1334      		cpi r17,lo8(67)
 2410 044a 01F4      		brne .L125
 364:main.c        **** 					DDRC |= (setValue);
 2411               		.loc 3 364 0
 2412 044c 84B3      		in r24,0x14
 2413 044e 862B      		or r24,r22
 2414 0450 84BB      		out 0x14,r24
 2415 0452 00C0      		rjmp .L138
 2416               	.L125:
 365:main.c        **** 				}
 366:main.c        **** 				else if (portChar == 'D') {
 2417               		.loc 3 366 0
 2418 0454 1434      		cpi r17,lo8(68)
 2419 0456 01F0      		breq .+2
 2420 0458 00C0      		rjmp .L138
 367:main.c        **** 					DDRD |= (setValue);
 2421               		.loc 3 367 0
 2422 045a 81B3      		in r24,0x11
 2423 045c 862B      		or r24,r22
 2424 045e 81BB      		out 0x11,r24
 2425 0460 00C0      		rjmp .L138
 2426               	.LVL250:
 2427               	.L117:
 2428               	.LBE87:
 368:main.c        **** 				}
 369:main.c        **** 			}
 370:main.c        **** 			PORTD &= ~(1<<LED);
 371:main.c        **** 		}
 372:main.c        **** 		
 373:main.c        **** 		// Set pin output as low
 374:main.c        **** 		else if (receivedChar == SET_OUTPUT_LOW) {
 2429               		.loc 3 374 0
 2430 0462 8C34      		cpi r24,lo8(76)
 2431 0464 01F4      		brne .L126
 2432               	.LBB88:
 375:main.c        **** 			char portChar = USART_Receive();			
 2433               		.loc 3 375 0
 2434 0466 0E94 0000 		call USART_Receive
 2435               	.LVL251:
 2436 046a 182F      		mov r17,r24
 2437               	.LVL252:
 376:main.c        **** 			usart_read_chars();
 2438               		.loc 3 376 0
 2439 046c 0E94 0000 		call usart_read_chars
 2440               	.LVL253:
 377:main.c        **** 			uint8_t setValue = strtol(receivedBuffer, NULL, 16);
 2441               		.loc 3 377 0
 2442 0470 40E1      		ldi r20,lo8(16)
 2443 0472 50E0      		ldi r21,0
 2444 0474 60E0      		ldi r22,0
 2445 0476 70E0      		ldi r23,0
 2446 0478 80E0      		ldi r24,lo8(receivedBuffer)
 2447 047a 90E0      		ldi r25,hi8(receivedBuffer)
 2448 047c 0E94 0000 		call strtol
 2449               	.LVL254:
 378:main.c        **** 			
 379:main.c        **** 			PORTD |= (1<<LED);
 2450               		.loc 3 379 0
 2451 0480 939A      		sbi 0x12,3
 380:main.c        **** 			if (portChar == 'A') {
 2452               		.loc 3 380 0
 2453 0482 1134      		cpi r17,lo8(65)
 2454 0484 01F4      		brne .L127
 381:main.c        **** 				PORTA &= ~(setValue);
 2455               		.loc 3 381 0
 2456 0486 8BB3      		in r24,0x1b
 2457 0488 6095      		com r22
 2458               	.LVL255:
 2459 048a 6823      		and r22,r24
 2460               	.LVL256:
 2461 048c 6BBB      		out 0x1b,r22
 2462 048e 00C0      		rjmp .L138
 2463               	.LVL257:
 2464               	.L127:
 382:main.c        **** 			}
 383:main.c        **** 			else if (portChar == 'B') {
 2465               		.loc 3 383 0
 2466 0490 1234      		cpi r17,lo8(66)
 2467 0492 01F4      		brne .L129
 384:main.c        **** 				PORTB &= ~(setValue);
 2468               		.loc 3 384 0
 2469 0494 88B3      		in r24,0x18
 2470 0496 6095      		com r22
 2471               	.LVL258:
 2472 0498 6823      		and r22,r24
 2473               	.LVL259:
 2474 049a 68BB      		out 0x18,r22
 2475 049c 00C0      		rjmp .L138
 2476               	.LVL260:
 2477               	.L129:
 385:main.c        **** 			}
 386:main.c        **** 			else if (portChar == 'C') {
 2478               		.loc 3 386 0
 2479 049e 1334      		cpi r17,lo8(67)
 2480 04a0 01F4      		brne .L130
 387:main.c        **** 				PORTC &= ~(setValue);
 2481               		.loc 3 387 0
 2482 04a2 85B3      		in r24,0x15
 2483 04a4 6095      		com r22
 2484               	.LVL261:
 2485 04a6 6823      		and r22,r24
 2486               	.LVL262:
 2487 04a8 65BB      		out 0x15,r22
 2488 04aa 00C0      		rjmp .L138
 2489               	.LVL263:
 2490               	.L130:
 388:main.c        **** 			}
 389:main.c        **** 			else if (portChar == 'D') {
 2491               		.loc 3 389 0
 2492 04ac 1434      		cpi r17,lo8(68)
 2493 04ae 01F0      		breq .+2
 2494 04b0 00C0      		rjmp .L138
 390:main.c        **** 				PORTD &= ~(setValue);
 2495               		.loc 3 390 0
 2496 04b2 82B3      		in r24,0x12
 2497 04b4 6095      		com r22
 2498               	.LVL264:
 2499 04b6 6823      		and r22,r24
 2500               	.LVL265:
 2501 04b8 62BB      		out 0x12,r22
 2502 04ba 00C0      		rjmp .L138
 2503               	.LVL266:
 2504               	.L126:
 2505               	.LBE88:
 391:main.c        **** 			}
 392:main.c        **** 			PORTD &= ~(1<<LED);
 393:main.c        **** 		}
 394:main.c        **** 		
 395:main.c        **** 		// Set pin output as high
 396:main.c        **** 		else if (receivedChar == SET_OUTPUT_HIGH) {
 2506               		.loc 3 396 0
 2507 04bc 8834      		cpi r24,lo8(72)
 2508 04be 01F4      		brne .L131
 2509               	.LBB89:
 397:main.c        **** 			char portChar = USART_Receive();			
 2510               		.loc 3 397 0
 2511 04c0 0E94 0000 		call USART_Receive
 2512               	.LVL267:
 2513 04c4 182F      		mov r17,r24
 2514               	.LVL268:
 398:main.c        **** 			usart_read_chars();
 2515               		.loc 3 398 0
 2516 04c6 0E94 0000 		call usart_read_chars
 2517               	.LVL269:
 399:main.c        **** 			uint8_t setValue = strtol(receivedBuffer, NULL, 16);
 2518               		.loc 3 399 0
 2519 04ca 40E1      		ldi r20,lo8(16)
 2520 04cc 50E0      		ldi r21,0
 2521 04ce 60E0      		ldi r22,0
 2522 04d0 70E0      		ldi r23,0
 2523 04d2 80E0      		ldi r24,lo8(receivedBuffer)
 2524 04d4 90E0      		ldi r25,hi8(receivedBuffer)
 2525 04d6 0E94 0000 		call strtol
 2526               	.LVL270:
 400:main.c        **** 			
 401:main.c        **** 			PORTD |= (1<<LED);
 2527               		.loc 3 401 0
 2528 04da 939A      		sbi 0x12,3
 402:main.c        **** 			if (portChar == 'A') {
 2529               		.loc 3 402 0
 2530 04dc 1134      		cpi r17,lo8(65)
 2531 04de 01F4      		brne .L132
 403:main.c        **** 				PORTA |= (setValue);
 2532               		.loc 3 403 0
 2533 04e0 8BB3      		in r24,0x1b
 2534 04e2 862B      		or r24,r22
 2535 04e4 8BBB      		out 0x1b,r24
 2536 04e6 00C0      		rjmp .L138
 2537               	.L132:
 404:main.c        **** 			}
 405:main.c        **** 			else if (portChar == 'B') {
 2538               		.loc 3 405 0
 2539 04e8 1234      		cpi r17,lo8(66)
 2540 04ea 01F4      		brne .L134
 406:main.c        **** 				PORTB |= (setValue);
 2541               		.loc 3 406 0
 2542 04ec 88B3      		in r24,0x18
 2543 04ee 862B      		or r24,r22
 2544 04f0 88BB      		out 0x18,r24
 2545 04f2 00C0      		rjmp .L138
 2546               	.L134:
 407:main.c        **** 			}
 408:main.c        **** 			else if (portChar == 'C') {
 2547               		.loc 3 408 0
 2548 04f4 1334      		cpi r17,lo8(67)
 2549 04f6 01F4      		brne .L135
 409:main.c        **** 				PORTC |= (setValue);
 2550               		.loc 3 409 0
 2551 04f8 85B3      		in r24,0x15
 2552 04fa 862B      		or r24,r22
 2553 04fc 85BB      		out 0x15,r24
 2554 04fe 00C0      		rjmp .L138
 2555               	.L135:
 410:main.c        **** 			}
 411:main.c        **** 			else if (portChar == 'D') {
 2556               		.loc 3 411 0
 2557 0500 1434      		cpi r17,lo8(68)
 2558 0502 01F4      		brne .L138
 412:main.c        **** 				PORTD |= (setValue);
 2559               		.loc 3 412 0
 2560 0504 82B3      		in r24,0x12
 2561 0506 862B      		or r24,r22
 2562 0508 82BB      		out 0x12,r24
 2563 050a 00C0      		rjmp .L138
 2564               	.LVL271:
 2565               	.L131:
 2566               	.LBE89:
 413:main.c        **** 			}
 414:main.c        **** 			PORTD &= ~(1<<LED);
 415:main.c        **** 		}
 416:main.c        **** 		
 417:main.c        **** 		// Read all pins of a PORT and return the value
 418:main.c        **** 		else if (receivedChar == READ_INPUT) {
 2567               		.loc 3 418 0
 2568 050c 8434      		cpi r24,lo8(68)
 2569 050e 01F4      		brne .L136
 2570               	.LBB90:
 419:main.c        **** 			char portChar = USART_Receive();			
 2571               		.loc 3 419 0
 2572 0510 0E94 0000 		call USART_Receive
 2573               	.LVL272:
 420:main.c        **** 			
 421:main.c        **** 			PORTD |= (1<<LED);
 2574               		.loc 3 421 0
 2575 0514 939A      		sbi 0x12,3
 422:main.c        **** 			if (portChar == 'A') {
 2576               		.loc 3 422 0
 2577 0516 8134      		cpi r24,lo8(65)
 2578 0518 01F4      		brne .L137
 423:main.c        **** 				USART_Transmit(PINA);
 2579               		.loc 3 423 0
 2580 051a 89B3      		in r24,0x19
 2581               	.LVL273:
 2582 051c 00C0      		rjmp .L159
 2583               	.LVL274:
 2584               	.L137:
 424:main.c        **** 			}
 425:main.c        **** 			else if (portChar == 'B') {
 2585               		.loc 3 425 0
 2586 051e 8234      		cpi r24,lo8(66)
 2587 0520 01F4      		brne .L139
 426:main.c        **** 				USART_Transmit(PINB);
 2588               		.loc 3 426 0
 2589 0522 86B3      		in r24,0x16
 2590               	.LVL275:
 2591 0524 00C0      		rjmp .L159
 2592               	.LVL276:
 2593               	.L139:
 427:main.c        **** 			}
 428:main.c        **** 			else if (portChar == 'C') {
 2594               		.loc 3 428 0
 2595 0526 8334      		cpi r24,lo8(67)
 2596 0528 01F4      		brne .L140
 429:main.c        **** 				USART_Transmit(PINC);
 2597               		.loc 3 429 0
 2598 052a 83B3      		in r24,0x13
 2599               	.LVL277:
 2600 052c 00C0      		rjmp .L159
 2601               	.LVL278:
 2602               	.L140:
 430:main.c        **** 			}
 431:main.c        **** 			else if (portChar == 'D') {
 2603               		.loc 3 431 0
 2604 052e 8434      		cpi r24,lo8(68)
 2605 0530 01F4      		brne .L138
 432:main.c        **** 				USART_Transmit(PIND);
 2606               		.loc 3 432 0
 2607 0532 80B3      		in r24,0x10
 2608               	.LVL279:
 2609               	.L159:
 2610 0534 0E94 0000 		call USART_Transmit
 2611               	.LVL280:
 2612               	.L138:
 433:main.c        **** 			}
 434:main.c        **** 			PORTD &= ~(1<<LED);
 2613               		.loc 3 434 0 discriminator 1
 2614 0538 9398      		cbi 0x12,3
 2615               	.LBE90:
 2616 053a 00C0      		rjmp .L69
 2617               	.L136:
 435:main.c        **** 		}
 436:main.c        **** 		
 437:main.c        **** 		// Set the reset common lines variable on or off, useful if you are controlling all the pins dire
 438:main.c        **** 		else if (receivedChar == RESET_COMMON_LINES) {
 2618               		.loc 3 438 0
 2619 053c 8D34      		cpi r24,lo8(77)
 2620 053e 01F4      		brne .L141
 2621               	.LBB91:
 439:main.c        **** 			char commonChar = USART_Receive();
 2622               		.loc 3 439 0
 2623 0540 0E94 0000 		call USART_Receive
 2624               	.LVL281:
 440:main.c        **** 			if (commonChar == '1') {
 2625               		.loc 3 440 0
 2626 0544 8133      		cpi r24,lo8(49)
 2627 0546 01F4      		brne .L163
 441:main.c        **** 				resetCommonLines = 1;
 2628               		.loc 3 441 0
 2629 0548 6624      		clr r6
 2630 054a 6394      		inc r6
 2631 054c 00C0      		rjmp .L149
 2632               	.L163:
 442:main.c        **** 			}
 443:main.c        **** 			else if (commonChar == '0') {
 2633               		.loc 3 443 0
 2634 054e 8033      		cpi r24,lo8(48)
 2635 0550 01F0      		breq .+2
 2636 0552 00C0      		rjmp .L69
 444:main.c        **** 				resetCommonLines = 0;
 2637               		.loc 3 444 0
 2638 0554 612C      		mov r6,__zero_reg__
 2639 0556 00C0      		rjmp .L70
 2640               	.LVL282:
 2641               	.L141:
 2642               	.LBE91:
 445:main.c        **** 			}
 446:main.c        **** 		}
 447:main.c        **** 		
 448:main.c        **** 		// Send back the PCB version number
 449:main.c        **** 		else if (receivedChar == READ_PCB_VERSION) {
 2643               		.loc 3 449 0
 2644 0558 8836      		cpi r24,lo8(104)
 2645 055a 01F4      		brne .L142
 450:main.c        **** 			USART_Transmit(PCB_VERSION);
 2646               		.loc 3 450 0
 2647 055c 81E0      		ldi r24,lo8(1)
 2648 055e 00C0      		rjmp .L150
 2649               	.L142:
 451:main.c        **** 		}
 452:main.c        **** 		
 453:main.c        **** 		// Send back the firmware version number
 454:main.c        **** 		else if (receivedChar == READ_FIRMWARE_VERSION) {
 2650               		.loc 3 454 0
 2651 0560 8635      		cpi r24,lo8(86)
 2652 0562 01F0      		breq .+2
 2653 0564 00C0      		rjmp .L69
 455:main.c        **** 			USART_Transmit(FIRMWARE_VERSION);
 2654               		.loc 3 455 0
 2655 0566 82E0      		ldi r24,lo8(2)
 2656               	.L150:
 2657 0568 0E94 0000 		call USART_Transmit
 2658               	.LVL283:
 2659 056c 00C0      		rjmp .L69
 2660               		.cfi_endproc
 2661               	.LFE35:
 2663               		.comm	flashChipIdBuffer,2,1
 2664               		.comm	eepromBuffer,8,1
 2665               		.comm	receivedChar,1,1
 2666               		.comm	receivedBuffer,129,1
 2667               		.text
 2668               	.Letext0:
 2669               		.file 4 "c:\\winavr-20100110\\avr\\include\\stdint.h"
 2670               		.file 5 "c:\\winavr-20100110\\avr\\include\\stdlib.h"
DEFINED SYMBOLS
                            *ABS*:00000000 main.c
C:\Users\Alex\AppData\Local\Temp\cc6cRim7.s:2      *ABS*:0000003e __SP_H__
C:\Users\Alex\AppData\Local\Temp\cc6cRim7.s:3      *ABS*:0000003d __SP_L__
C:\Users\Alex\AppData\Local\Temp\cc6cRim7.s:4      *ABS*:0000003f __SREG__
C:\Users\Alex\AppData\Local\Temp\cc6cRim7.s:5      *ABS*:00000000 __tmp_reg__
C:\Users\Alex\AppData\Local\Temp\cc6cRim7.s:6      *ABS*:00000001 __zero_reg__
C:\Users\Alex\AppData\Local\Temp\cc6cRim7.s:12     .text:00000000 USART_Receive
C:\Users\Alex\AppData\Local\Temp\cc6cRim7.s:34     .text:00000008 USART_Transmit
C:\Users\Alex\AppData\Local\Temp\cc6cRim7.s:55     .text:00000010 usart_read_bytes
                            *COM*:00000081 receivedBuffer
C:\Users\Alex\AppData\Local\Temp\cc6cRim7.s:121    .text:0000003e usart_read_chars
C:\Users\Alex\AppData\Local\Temp\cc6cRim7.s:165    .text:0000005c rd_wr_csmreq_cs2_reset
C:\Users\Alex\AppData\Local\Temp\cc6cRim7.s:187    .text:00000066 gb_mode
C:\Users\Alex\AppData\Local\Temp\cc6cRim7.s:214    .text:00000076 set_16bit_address
C:\Users\Alex\AppData\Local\Temp\cc6cRim7.s:233    .text:0000007c read_8bit_data
C:\Users\Alex\AppData\Local\Temp\cc6cRim7.s:273    .text:00000090 write_8bit_data
C:\Users\Alex\AppData\Local\Temp\cc6cRim7.s:347    .text:000000cc gba_mode
C:\Users\Alex\AppData\Local\Temp\cc6cRim7.s:374    .text:000000dc gba_set_24bit_address
C:\Users\Alex\AppData\Local\Temp\cc6cRim7.s:427    .text:00000108 gba_read_16bit_data
C:\Users\Alex\AppData\Local\Temp\cc6cRim7.s:475    .text:00000128 gba_read_ram_8bit_data
C:\Users\Alex\AppData\Local\Temp\cc6cRim7.s:545    .text:00000154 gba_write_ram_8bit_data
C:\Users\Alex\AppData\Local\Temp\cc6cRim7.s:612    .text:00000184 gba_eeprom_mode
C:\Users\Alex\AppData\Local\Temp\cc6cRim7.s:640    .text:00000196 gba_eeprom_set_address
C:\Users\Alex\AppData\Local\Temp\cc6cRim7.s:780    .text:000001fe gba_eeprom_read
                            *COM*:00000008 eepromBuffer
C:\Users\Alex\AppData\Local\Temp\cc6cRim7.s:912    .text:0000025a gba_eeprom_write
C:\Users\Alex\AppData\Local\Temp\cc6cRim7.s:1028   .text:000002ae flash_write_bus_cycle
C:\Users\Alex\AppData\Local\Temp\cc6cRim7.s:1087   .text:000002d8 flash_read_chip_id
                            *COM*:00000002 flashChipIdBuffer
C:\Users\Alex\AppData\Local\Temp\cc6cRim7.s:1175   .text:0000034a flash_switch_bank
C:\Users\Alex\AppData\Local\Temp\cc6cRim7.s:1224   .text:00000378 flash_erase_4k_sector
C:\Users\Alex\AppData\Local\Temp\cc6cRim7.s:1298   .text:000003cc flash_write_byte
C:\Users\Alex\AppData\Local\Temp\cc6cRim7.s:1368   .text:0000040c flash_write_sector
C:\Users\Alex\AppData\Local\Temp\cc6cRim7.s:1480   .text:00000480 setup
C:\Users\Alex\AppData\Local\Temp\cc6cRim7.s:1547   .text.startup:00000000 main
                            *COM*:00000001 receivedChar

UNDEFINED SYMBOLS
strtol
atoi
__do_clear_bss
