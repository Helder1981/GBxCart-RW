   1               		.file	"main.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               	.global	USART_Receive
  12               	USART_Receive:
  13               	.LFB10:
  14               		.file 1 "setup.c"
   1:setup.c       **** /*
   2:setup.c       ****  GBxCart RW
   3:setup.c       ****  PCB version: 1.1
   4:setup.c       ****  Firmware version: R2
   5:setup.c       ****  Author: Alex from insideGadgets (www.insidegadgets.com)
   6:setup.c       ****  Created: 7/11/2016
   7:setup.c       ****  Last Modified: 8/05/2017
   8:setup.c       ****  
   9:setup.c       ****  */
  10:setup.c       ****  
  11:setup.c       **** #ifndef cbi
  12:setup.c       **** #define cbi(sfr, bit) (_SFR_BYTE(sfr) &= ~_BV(bit))
  13:setup.c       **** #endif
  14:setup.c       **** #ifndef sbi
  15:setup.c       **** #define sbi(sfr, bit) (_SFR_BYTE(sfr) |= _BV(bit))
  16:setup.c       **** #endif
  17:setup.c       **** 
  18:setup.c       **** #ifndef NULL
  19:setup.c       **** #define NULL ((void *)0)
  20:setup.c       **** #endif
  21:setup.c       **** 
  22:setup.c       **** #define LOW 0
  23:setup.c       **** #define HIGH 1
  24:setup.c       **** #define false 0
  25:setup.c       **** #define true 1
  26:setup.c       **** 
  27:setup.c       **** #define SWITCH_DETECT PD2
  28:setup.c       **** #define ACTIVITY_LED PD3
  29:setup.c       **** #define LED_5V PD7
  30:setup.c       **** #define LED_3V PE0
  31:setup.c       **** 
  32:setup.c       **** #define WR_PIN PD6
  33:setup.c       **** #define RD_PIN PD5
  34:setup.c       **** #define CS_MREQ_PIN PD4
  35:setup.c       **** #define CS2_PIN PE2
  36:setup.c       **** 
  37:setup.c       **** #define wrPin_high	PORTD |= (1<<WR_PIN);
  38:setup.c       **** #define wrPin_low		PORTD &= ~(1<<WR_PIN);
  39:setup.c       **** #define rdPin_high	PORTD |= (1<<RD_PIN);
  40:setup.c       **** #define rdPin_low		PORTD &= ~(1<<RD_PIN);
  41:setup.c       **** #define cs_mreqPin_high		PORTD |= (1<<CS_MREQ_PIN);
  42:setup.c       **** #define cs_mreqPin_low		PORTD &= ~(1<<CS_MREQ_PIN);
  43:setup.c       **** #define cs2Pin_high		PORTE |= (1<<CS2_PIN);
  44:setup.c       **** #define cs2Pin_low		PORTE &= ~(1<<CS2_PIN);
  45:setup.c       **** 
  46:setup.c       **** #define GB_MODE 1
  47:setup.c       **** #define GBA_MODE 2
  48:setup.c       **** 
  49:setup.c       **** // GB/GBC
  50:setup.c       **** #define PORT_ADDR7_0 PORTB
  51:setup.c       **** #define PORT_ADDR15_8 PORTA
  52:setup.c       **** #define PORT_DATA7_0 PORTC
  53:setup.c       **** 
  54:setup.c       **** #define DDR_ADDR7_0 DDRB
  55:setup.c       **** #define DDR_ADDR15_8 DDRA
  56:setup.c       **** #define DDR_DATA7_0 DDRC
  57:setup.c       **** 
  58:setup.c       **** #define PIN_ADDR7_0 PINB
  59:setup.c       **** #define PIN_ADDR15_8 PINA
  60:setup.c       **** #define PIN_DATA7_0 PINC
  61:setup.c       **** 
  62:setup.c       **** #define BANK_WRITE 0
  63:setup.c       **** #define MEMORY_WRITE 1
  64:setup.c       **** 
  65:setup.c       **** // GBA
  66:setup.c       **** #define EEPROM_WRITE 1
  67:setup.c       **** #define EEPROM_READ 0
  68:setup.c       **** 
  69:setup.c       **** #define EEPROM_NONE 0
  70:setup.c       **** #define EEPROM_4KBIT 1
  71:setup.c       **** #define EEPROM_64KBIT 2
  72:setup.c       **** 
  73:setup.c       **** #define AD0 PB0
  74:setup.c       **** #define ad0Pin_high		PORTB |= (1<<AD0);
  75:setup.c       **** #define ad0Pin_low		PORTB &= ~(1<<AD0);
  76:setup.c       **** 
  77:setup.c       **** #define A23 PC7
  78:setup.c       **** #define a23Pin_high		PORTC |= (1<<A23);
  79:setup.c       **** #define a23Pin_low		PORTC &= ~(1<<A23);
  80:setup.c       **** 
  81:setup.c       **** #define GBA_DDR_ROM_ADDR7_0 DDRB
  82:setup.c       **** #define GBA_DDR_ROM_ADDR15_8 DDRA
  83:setup.c       **** #define GBA_DDR_ROM_ADDR23_16 DDRC
  84:setup.c       **** #define GBA_DDR_ROM_DATA7_0 DDRB
  85:setup.c       **** #define GBA_DDR_ROM_DATA15_8 DDRA
  86:setup.c       **** #define GBA_DDR_RAM_DATA7_0 DDRC
  87:setup.c       **** #define GBA_DDR_EEPROM_DATA7_0 DDRB
  88:setup.c       **** 
  89:setup.c       **** #define GBA_PORT_ROM_ADDR7_0 PORTB
  90:setup.c       **** #define GBA_PORT_ROM_ADDR15_8 PORTA
  91:setup.c       **** #define GBA_PORT_ROM_ADDR23_16 PORTC
  92:setup.c       **** #define GBA_PORT_ROM_DATA7_0 PORTB
  93:setup.c       **** #define GBA_PORT_ROM_DATA15_8 PORTA
  94:setup.c       **** #define GBA_PORT_RAM_DATA7_0 PORTC
  95:setup.c       **** #define GBA_PORT_EEPROM_DATA7_0 PORTB
  96:setup.c       **** 
  97:setup.c       **** #define GBA_PIN_ROM_DATA7_0 PINB
  98:setup.c       **** #define GBA_PIN_ROM_DATA15_8 PINA
  99:setup.c       **** #define GBA_PIN_RAM_DATA7_0 PINC
 100:setup.c       **** #define GBA_PIN_EEPROM_DATA7_0 PINB
 101:setup.c       **** 
 102:setup.c       **** // GB/GBC commands
 103:setup.c       **** #define SET_START_ADDRESS 'A'
 104:setup.c       **** #define READ_ROM_RAM 'R'
 105:setup.c       **** #define WRITE_RAM 'W'
 106:setup.c       **** #define SET_BANK 'B'
 107:setup.c       **** #define GB_CART_MODE 'G'
 108:setup.c       **** 
 109:setup.c       **** // GBA commands
 110:setup.c       **** #define GBA_READ_ROM 'r'
 111:setup.c       **** #define GBA_READ_SRAM 'm'
 112:setup.c       **** #define GBA_WRITE_SRAM 'w'
 113:setup.c       **** #define GBA_WRITE_ONE_BYTE_SRAM 'o'
 114:setup.c       **** #define GBA_CART_MODE 'g'
 115:setup.c       **** 
 116:setup.c       **** #define GBA_FLASH_READ_ID 'i'
 117:setup.c       **** #define GBA_FLASH_SET_BANK 'k'
 118:setup.c       **** #define GBA_FLASH_4K_SECTOR_ERASE 's'
 119:setup.c       **** #define GBA_FLASH_WRITE_BYTE 'b'
 120:setup.c       **** #define GBA_FLASH_WRITE_ATMEL 'a'
 121:setup.c       **** 
 122:setup.c       **** #define GBA_SET_EEPROM_SIZE 'S'
 123:setup.c       **** #define GBA_READ_EEPROM 'e'
 124:setup.c       **** #define GBA_WRITE_EEPROM 'p'
 125:setup.c       **** 
 126:setup.c       **** // General commands
 127:setup.c       **** #define CART_MODE 'C'
 128:setup.c       **** #define SET_INPUT 'I'
 129:setup.c       **** #define SET_OUTPUT 'O'
 130:setup.c       **** #define SET_OUTPUT_LOW 'L'
 131:setup.c       **** #define SET_OUTPUT_HIGH 'H'
 132:setup.c       **** #define READ_INPUT 'D'
 133:setup.c       **** #define RESET_COMMON_LINES 'M'
 134:setup.c       **** #define READ_FIRMWARE_VERSION 'V'
 135:setup.c       **** #define READ_PCB_VERSION 'h'
 136:setup.c       **** 
 137:setup.c       **** char receivedBuffer[129];
 138:setup.c       **** char receivedChar;
 139:setup.c       **** uint8_t eepromBuffer[8];
 140:setup.c       **** uint8_t flashChipIdBuffer[2];
 141:setup.c       **** 
 142:setup.c       **** // Receive USART data
 143:setup.c       **** uint8_t USART_Receive(void) {
  15               		.loc 1 143 0
  16               		.cfi_startproc
  17               	/* prologue: function */
  18               	/* frame size = 0 */
  19               	/* stack size = 0 */
  20               	.L__stack_usage = 0
  21               	.L3:
 144:setup.c       **** 	while ( !(UCSRA & (1<<RXC)) ); // Wait for data to be received
  22               		.loc 1 144 0 discriminator 1
  23 0000 5F9B      		sbis 0xb,7
  24 0002 00C0      		rjmp .L3
 145:setup.c       **** 	return UDR; // Get and return received data from buffer
  25               		.loc 1 145 0
  26 0004 8CB1      		in r24,0xc
 146:setup.c       **** }
  27               		.loc 1 146 0
  28 0006 0895      		ret
  29               		.cfi_endproc
  30               	.LFE10:
  32               	.global	USART_Transmit
  34               	USART_Transmit:
  35               	.LFB11:
 147:setup.c       **** 
 148:setup.c       **** // Transmit USART data
 149:setup.c       **** void USART_Transmit(unsigned char data) {
  36               		.loc 1 149 0
  37               		.cfi_startproc
  38               	/* prologue: function */
  39               	/* frame size = 0 */
  40               	/* stack size = 0 */
  41               	.L__stack_usage = 0
  42               	.LVL0:
  43               	.L7:
 150:setup.c       **** 	while ( !( UCSRA & (1<<UDRE)) ); // Wait for empty transmit buffer
  44               		.loc 1 150 0 discriminator 1
  45 0008 5D9B      		sbis 0xb,5
  46 000a 00C0      		rjmp .L7
 151:setup.c       **** 	UDR = data;
  47               		.loc 1 151 0
  48 000c 8CB9      		out 0xc,r24
  49 000e 0895      		ret
  50               		.cfi_endproc
  51               	.LFE11:
  53               	.global	usart_read_bytes
  55               	usart_read_bytes:
  56               	.LFB12:
 152:setup.c       **** }
 153:setup.c       **** 
 154:setup.c       **** // Read 1-128 bytes from the USART 
 155:setup.c       **** void usart_read_bytes(uint8_t count) {
  57               		.loc 1 155 0
  58               		.cfi_startproc
  59               	.LVL1:
  60 0010 FF92      		push r15
  61               	.LCFI0:
  62               		.cfi_def_cfa_offset 3
  63               		.cfi_offset 15, -2
  64 0012 0F93      		push r16
  65               	.LCFI1:
  66               		.cfi_def_cfa_offset 4
  67               		.cfi_offset 16, -3
  68 0014 1F93      		push r17
  69               	.LCFI2:
  70               		.cfi_def_cfa_offset 5
  71               		.cfi_offset 17, -4
  72 0016 CF93      		push r28
  73               	.LCFI3:
  74               		.cfi_def_cfa_offset 6
  75               		.cfi_offset 28, -5
  76 0018 DF93      		push r29
  77               	.LCFI4:
  78               		.cfi_def_cfa_offset 7
  79               		.cfi_offset 29, -6
  80               	/* prologue: function */
  81               	/* frame size = 0 */
  82               	/* stack size = 5 */
  83               	.L__stack_usage = 5
  84 001a F82E      		mov r15,r24
  85               	.LVL2:
  86 001c 00E0      		ldi r16,lo8(receivedBuffer)
  87 001e 10E0      		ldi r17,hi8(receivedBuffer)
  88               	.LBB36:
 156:setup.c       **** 	for (uint8_t x = 0; x < count; x++) {
  89               		.loc 1 156 0
  90 0020 E801      		movw r28,r16
  91               	.LVL3:
  92               	.L9:
  93 0022 8C2F      		mov r24,r28
  94 0024 801B      		sub r24,r16
  95               		.loc 1 156 0 is_stmt 0 discriminator 1
  96 0026 8F15      		cp r24,r15
  97 0028 00F4      		brsh .L11
 157:setup.c       **** 		receivedBuffer[x] = USART_Receive();
  98               		.loc 1 157 0 is_stmt 1 discriminator 2
  99 002a 00D0      		rcall USART_Receive
 100               	.LVL4:
 101 002c 8993      		st Y+,r24
 102               	.LVL5:
 103 002e 00C0      		rjmp .L9
 104               	.L11:
 105               	/* epilogue start */
 106               	.LBE36:
 158:setup.c       **** 	}
 159:setup.c       **** }
 107               		.loc 1 159 0
 108 0030 DF91      		pop r29
 109 0032 CF91      		pop r28
 110               	.LVL6:
 111 0034 1F91      		pop r17
 112 0036 0F91      		pop r16
 113 0038 FF90      		pop r15
 114               	.LVL7:
 115 003a 0895      		ret
 116               		.cfi_endproc
 117               	.LFE12:
 119               	.global	usart_read_chars
 121               	usart_read_chars:
 122               	.LFB13:
 160:setup.c       **** 
 161:setup.c       **** // Read the USART until a 0 (string terminator byte) is received
 162:setup.c       **** void usart_read_chars(void) {
 123               		.loc 1 162 0
 124               		.cfi_startproc
 125 003c CF93      		push r28
 126               	.LCFI5:
 127               		.cfi_def_cfa_offset 3
 128               		.cfi_offset 28, -2
 129               	/* prologue: function */
 130               	/* frame size = 0 */
 131               	/* stack size = 1 */
 132               	.L__stack_usage = 1
 133               	.LVL8:
 163:setup.c       **** 	uint8_t x = 0;
 134               		.loc 1 163 0
 135 003e C0E0      		ldi r28,0
 136               	.LVL9:
 137               	.L14:
 164:setup.c       **** 	while (1) {
 165:setup.c       **** 		receivedBuffer[x] = USART_Receive();
 138               		.loc 1 165 0
 139 0040 00D0      		rcall USART_Receive
 140               	.LVL10:
 141 0042 EC2F      		mov r30,r28
 142 0044 F0E0      		ldi r31,0
 143 0046 E050      		subi r30,lo8(-(receivedBuffer))
 144 0048 F040      		sbci r31,hi8(-(receivedBuffer))
 145 004a 8083      		st Z,r24
 166:setup.c       **** 		if (receivedBuffer[x] == 0) {
 146               		.loc 1 166 0
 147 004c 8823      		tst r24
 148 004e 01F0      		breq .L12
 167:setup.c       **** 			break;
 168:setup.c       **** 		}
 169:setup.c       **** 		x++;
 149               		.loc 1 169 0
 150 0050 CF5F      		subi r28,lo8(-(1))
 151               	.LVL11:
 170:setup.c       **** 	}
 152               		.loc 1 170 0
 153 0052 00C0      		rjmp .L14
 154               	.L12:
 155               	/* epilogue start */
 171:setup.c       **** }
 156               		.loc 1 171 0
 157 0054 CF91      		pop r28
 158               	.LVL12:
 159 0056 0895      		ret
 160               		.cfi_endproc
 161               	.LFE13:
 163               	.global	rd_wr_csmreq_cs2_reset
 165               	rd_wr_csmreq_cs2_reset:
 166               	.LFB14:
 172:setup.c       **** 
 173:setup.c       **** // Turn RD, WR, CS/MREQ and CS2 to high so they are deselected (reset state)
 174:setup.c       **** void rd_wr_csmreq_cs2_reset(void) {
 167               		.loc 1 174 0
 168               		.cfi_startproc
 169               	/* prologue: function */
 170               	/* frame size = 0 */
 171               	/* stack size = 0 */
 172               	.L__stack_usage = 0
 175:setup.c       **** 	cs2Pin_high; // CS2 off
 173               		.loc 1 175 0
 174 0058 3A9A      		sbi 0x7,2
 176:setup.c       **** 	cs_mreqPin_high; // CS/MREQ off
 175               		.loc 1 176 0
 176 005a 949A      		sbi 0x12,4
 177:setup.c       **** 	rdPin_high; // RD off
 177               		.loc 1 177 0
 178 005c 959A      		sbi 0x12,5
 178:setup.c       **** 	wrPin_high; // WR off
 179               		.loc 1 178 0
 180 005e 969A      		sbi 0x12,6
 181 0060 0895      		ret
 182               		.cfi_endproc
 183               	.LFE14:
 185               	.global	gb_mode
 187               	gb_mode:
 188               	.LFB15:
 179:setup.c       **** }
 180:setup.c       **** 
 181:setup.c       **** 
 182:setup.c       **** 
 183:setup.c       **** // ****** Gameboy / Gameboy Colour functions ******
 184:setup.c       **** 
 185:setup.c       **** // Set Gameboy mode
 186:setup.c       **** void gb_mode(void) {
 189               		.loc 1 186 0
 190               		.cfi_startproc
 191               	/* prologue: function */
 192               	/* frame size = 0 */
 193               	/* stack size = 0 */
 194               	.L__stack_usage = 0
 187:setup.c       **** 	// Set inputs
 188:setup.c       **** 	PORT_DATA7_0 = 0;
 195               		.loc 1 188 0
 196 0062 15BA      		out 0x15,__zero_reg__
 189:setup.c       **** 	DDR_DATA7_0 = 0;
 197               		.loc 1 189 0
 198 0064 14BA      		out 0x14,__zero_reg__
 190:setup.c       **** 	
 191:setup.c       **** 	// Set outputs
 192:setup.c       **** 	PORT_ADDR7_0 = 0;
 199               		.loc 1 192 0
 200 0066 18BA      		out 0x18,__zero_reg__
 193:setup.c       **** 	PORT_ADDR15_8 = 0;
 201               		.loc 1 193 0
 202 0068 1BBA      		out 0x1b,__zero_reg__
 194:setup.c       **** 	DDR_ADDR7_0 = 0xFF;
 203               		.loc 1 194 0
 204 006a 8FEF      		ldi r24,lo8(-1)
 205 006c 87BB      		out 0x17,r24
 195:setup.c       **** 	DDR_ADDR15_8 = 0xFF;
 206               		.loc 1 195 0
 207 006e 8ABB      		out 0x1a,r24
 208 0070 0895      		ret
 209               		.cfi_endproc
 210               	.LFE15:
 212               	.global	set_16bit_address
 214               	set_16bit_address:
 215               	.LFB16:
 196:setup.c       **** }
 197:setup.c       **** 
 198:setup.c       **** // Set the 16 bit address on A15-0
 199:setup.c       **** void set_16bit_address(uint16_t address) {
 216               		.loc 1 199 0
 217               		.cfi_startproc
 218               	.LVL13:
 219               	/* prologue: function */
 220               	/* frame size = 0 */
 221               	/* stack size = 0 */
 222               	.L__stack_usage = 0
 200:setup.c       **** 	PORT_ADDR15_8 = (address >> 8);
 223               		.loc 1 200 0
 224 0072 9BBB      		out 0x1b,r25
 201:setup.c       **** 	PORT_ADDR7_0 = (address & 0xFF);
 225               		.loc 1 201 0
 226 0074 88BB      		out 0x18,r24
 227 0076 0895      		ret
 228               		.cfi_endproc
 229               	.LFE16:
 231               	.global	read_8bit_data
 233               	read_8bit_data:
 234               	.LFB17:
 202:setup.c       **** }
 203:setup.c       **** 
 204:setup.c       **** // Set the address and read a byte from the 8 bit data line
 205:setup.c       **** uint8_t read_8bit_data(uint16_t address) {
 235               		.loc 1 205 0
 236               		.cfi_startproc
 237               	.LVL14:
 238               	/* prologue: function */
 239               	/* frame size = 0 */
 240               	/* stack size = 0 */
 241               	.L__stack_usage = 0
 206:setup.c       **** 	set_16bit_address(address);
 242               		.loc 1 206 0
 243 0078 00D0      		rcall set_16bit_address
 244               	.LVL15:
 207:setup.c       **** 	
 208:setup.c       **** 	cs_mreqPin_low;
 245               		.loc 1 208 0
 246 007a 9498      		cbi 0x12,4
 209:setup.c       **** 	rdPin_low;
 247               		.loc 1 209 0
 248 007c 9598      		cbi 0x12,5
 210:setup.c       **** 	
 211:setup.c       **** 	asm volatile("nop"); // Delay a little (minimum needed is 1 nops, 2 nops for GB camera)
 249               		.loc 1 211 0
 250               	/* #APP */
 251               	 ;  211 "setup.c" 1
 252 007e 0000      		nop
 253               	 ;  0 "" 2
 212:setup.c       **** 	asm volatile("nop");
 254               		.loc 1 212 0
 255               	 ;  212 "setup.c" 1
 256 0080 0000      		nop
 257               	 ;  0 "" 2
 213:setup.c       **** 	uint8_t data = PIN_DATA7_0; // Read data
 258               		.loc 1 213 0
 259               	/* #NOAPP */
 260 0082 83B3      		in r24,0x13
 261               	.LVL16:
 214:setup.c       **** 	
 215:setup.c       **** 	rdPin_high;
 262               		.loc 1 215 0
 263 0084 959A      		sbi 0x12,5
 216:setup.c       **** 	cs_mreqPin_high;
 264               		.loc 1 216 0
 265 0086 949A      		sbi 0x12,4
 217:setup.c       **** 	
 218:setup.c       **** 	return data;
 219:setup.c       **** }
 266               		.loc 1 219 0
 267 0088 0895      		ret
 268               		.cfi_endproc
 269               	.LFE17:
 271               	.global	write_8bit_data
 273               	write_8bit_data:
 274               	.LFB18:
 220:setup.c       **** 
 221:setup.c       **** // Set the address and write a byte to the 8 bit data line and pulse cs/mREQ if writing to RAM
 222:setup.c       **** void write_8bit_data(uint16_t address, uint8_t data, uint8_t type) {
 275               		.loc 1 222 0
 276               		.cfi_startproc
 277               	.LVL17:
 278 008a CF93      		push r28
 279               	.LCFI6:
 280               		.cfi_def_cfa_offset 3
 281               		.cfi_offset 28, -2
 282 008c DF93      		push r29
 283               	.LCFI7:
 284               		.cfi_def_cfa_offset 4
 285               		.cfi_offset 29, -3
 286 008e 00D0      		rcall .
 287               	.LCFI8:
 288               		.cfi_def_cfa_offset 6
 289 0090 CDB7      		in r28,__SP_L__
 290 0092 DEB7      		in r29,__SP_H__
 291               	.LCFI9:
 292               		.cfi_def_cfa_register 28
 293               	/* prologue: function */
 294               	/* frame size = 2 */
 295               	/* stack size = 4 */
 296               	.L__stack_usage = 4
 223:setup.c       **** 	set_16bit_address(address);
 297               		.loc 1 223 0
 298 0094 4A83      		std Y+2,r20
 299 0096 6983      		std Y+1,r22
 300 0098 00D0      		rcall set_16bit_address
 301               	.LVL18:
 224:setup.c       **** 	
 225:setup.c       **** 	DDR_DATA7_0 = 0xFF; // Set data pins as outputs
 302               		.loc 1 225 0
 303 009a 8FEF      		ldi r24,lo8(-1)
 304 009c 84BB      		out 0x14,r24
 226:setup.c       **** 	PORT_DATA7_0 = data; // Set data
 305               		.loc 1 226 0
 306 009e 6981      		ldd r22,Y+1
 307 00a0 65BB      		out 0x15,r22
 227:setup.c       **** 	
 228:setup.c       **** 	// Pulse WR and mREQ if the type matches
 229:setup.c       **** 	wrPin_low;
 308               		.loc 1 229 0
 309 00a2 9698      		cbi 0x12,6
 230:setup.c       **** 	if (type == MEMORY_WRITE) {
 310               		.loc 1 230 0
 311 00a4 4A81      		ldd r20,Y+2
 312 00a6 4130      		cpi r20,lo8(1)
 313 00a8 01F4      		brne .L20
 231:setup.c       **** 		cs_mreqPin_low;
 314               		.loc 1 231 0
 315 00aa 9498      		cbi 0x12,4
 316               	.L20:
 232:setup.c       **** 	}
 233:setup.c       **** 	
 234:setup.c       **** 	asm volatile("nop");
 317               		.loc 1 234 0
 318               	/* #APP */
 319               	 ;  234 "setup.c" 1
 320 00ac 0000      		nop
 321               	 ;  0 "" 2
 235:setup.c       **** 	
 236:setup.c       **** 	if (type == MEMORY_WRITE) {
 322               		.loc 1 236 0
 323               	/* #NOAPP */
 324 00ae 4130      		cpi r20,lo8(1)
 325 00b0 01F4      		brne .L21
 237:setup.c       **** 		cs_mreqPin_high;
 326               		.loc 1 237 0
 327 00b2 949A      		sbi 0x12,4
 328               	.L21:
 238:setup.c       **** 	}
 239:setup.c       **** 	wrPin_high;
 329               		.loc 1 239 0
 330 00b4 969A      		sbi 0x12,6
 240:setup.c       **** 	
 241:setup.c       **** 	// Clear data outputs and set data pins as inputs
 242:setup.c       **** 	PORT_DATA7_0 = 0;
 331               		.loc 1 242 0
 332 00b6 15BA      		out 0x15,__zero_reg__
 243:setup.c       **** 	DDR_DATA7_0 = 0;
 333               		.loc 1 243 0
 334 00b8 14BA      		out 0x14,__zero_reg__
 335               	/* epilogue start */
 244:setup.c       **** }
 336               		.loc 1 244 0
 337 00ba 0F90      		pop __tmp_reg__
 338 00bc 0F90      		pop __tmp_reg__
 339 00be DF91      		pop r29
 340 00c0 CF91      		pop r28
 341 00c2 0895      		ret
 342               		.cfi_endproc
 343               	.LFE18:
 345               	.global	gba_mode
 347               	gba_mode:
 348               	.LFB19:
 245:setup.c       **** 
 246:setup.c       **** 
 247:setup.c       **** 
 248:setup.c       **** // ****** Gameboy Advance functions ****** 
 249:setup.c       **** 
 250:setup.c       **** // Set GBA mode
 251:setup.c       **** void gba_mode(void) {
 349               		.loc 1 251 0
 350               		.cfi_startproc
 351               	/* prologue: function */
 352               	/* frame size = 0 */
 353               	/* stack size = 0 */
 354               	.L__stack_usage = 0
 252:setup.c       **** 	// Set outputs for reading ROM addresses as default
 253:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = 0;
 355               		.loc 1 253 0
 356 00c4 18BA      		out 0x18,__zero_reg__
 254:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = 0;
 357               		.loc 1 254 0
 358 00c6 1BBA      		out 0x1b,__zero_reg__
 255:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = 0;
 359               		.loc 1 255 0
 360 00c8 15BA      		out 0x15,__zero_reg__
 256:setup.c       **** 	GBA_DDR_ROM_ADDR7_0 = 0xFF;
 361               		.loc 1 256 0
 362 00ca 8FEF      		ldi r24,lo8(-1)
 363 00cc 87BB      		out 0x17,r24
 257:setup.c       **** 	GBA_DDR_ROM_ADDR15_8 = 0xFF;
 364               		.loc 1 257 0
 365 00ce 8ABB      		out 0x1a,r24
 258:setup.c       **** 	GBA_DDR_ROM_ADDR23_16 = 0xFF;
 366               		.loc 1 258 0
 367 00d0 84BB      		out 0x14,r24
 368 00d2 0895      		ret
 369               		.cfi_endproc
 370               	.LFE19:
 372               	.global	gba_set_24bit_address
 374               	gba_set_24bit_address:
 375               	.LFB20:
 259:setup.c       **** }
 260:setup.c       **** 
 261:setup.c       **** // Set the 24 bit address on A23-0
 262:setup.c       **** void gba_set_24bit_address(uint32_t address) {	
 376               		.loc 1 262 0
 377               		.cfi_startproc
 378               	.LVL19:
 379 00d4 0F93      		push r16
 380               	.LCFI10:
 381               		.cfi_def_cfa_offset 3
 382               		.cfi_offset 16, -2
 383 00d6 1F93      		push r17
 384               	.LCFI11:
 385               		.cfi_def_cfa_offset 4
 386               		.cfi_offset 17, -3
 387               	/* prologue: function */
 388               	/* frame size = 0 */
 389               	/* stack size = 2 */
 390               	.L__stack_usage = 2
 263:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = 0; // Set 0-23 address lines low and set as outputs
 391               		.loc 1 263 0
 392 00d8 15BA      		out 0x15,__zero_reg__
 264:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = 0;
 393               		.loc 1 264 0
 394 00da 1BBA      		out 0x1b,__zero_reg__
 265:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = 0;
 395               		.loc 1 265 0
 396 00dc 18BA      		out 0x18,__zero_reg__
 266:setup.c       **** 	GBA_DDR_ROM_ADDR23_16 = 0xFF;
 397               		.loc 1 266 0
 398 00de 2FEF      		ldi r18,lo8(-1)
 399 00e0 24BB      		out 0x14,r18
 267:setup.c       **** 	GBA_DDR_ROM_ADDR15_8 = 0xFF;
 400               		.loc 1 267 0
 401 00e2 2ABB      		out 0x1a,r18
 268:setup.c       **** 	GBA_DDR_ROM_ADDR7_0 = 0xFF;
 402               		.loc 1 268 0
 403 00e4 27BB      		out 0x17,r18
 269:setup.c       **** 	
 270:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = (address >> 16);
 404               		.loc 1 270 0
 405 00e6 8C01      		movw r16,r24
 406 00e8 2227      		clr r18
 407 00ea 3327      		clr r19
 408 00ec 05BB      		out 0x15,r16
 271:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = (address >> 8);
 409               		.loc 1 271 0
 410 00ee 072F      		mov r16,r23
 411 00f0 182F      		mov r17,r24
 412 00f2 292F      		mov r18,r25
 413 00f4 3327      		clr r19
 414 00f6 0BBB      		out 0x1b,r16
 272:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = (address & 0xFF);
 415               		.loc 1 272 0
 416 00f8 68BB      		out 0x18,r22
 417               	/* epilogue start */
 273:setup.c       **** }
 418               		.loc 1 273 0
 419 00fa 1F91      		pop r17
 420 00fc 0F91      		pop r16
 421 00fe 0895      		ret
 422               		.cfi_endproc
 423               	.LFE20:
 425               	.global	gba_read_16bit_data
 427               	gba_read_16bit_data:
 428               	.LFB21:
 274:setup.c       **** 
 275:setup.c       **** 
 276:setup.c       **** 
 277:setup.c       **** // ---------- ROM/SRAM ----------
 278:setup.c       **** 
 279:setup.c       **** // Read a byte from the 16 bit data line non-sequentially
 280:setup.c       **** uint16_t gba_read_16bit_data(uint32_t address) {
 429               		.loc 1 280 0
 430               		.cfi_startproc
 431               	.LVL20:
 432               	/* prologue: function */
 433               	/* frame size = 0 */
 434               	/* stack size = 0 */
 435               	.L__stack_usage = 0
 281:setup.c       **** 	gba_set_24bit_address(address);
 436               		.loc 1 281 0
 437 0100 00D0      		rcall gba_set_24bit_address
 438               	.LVL21:
 282:setup.c       **** 	
 283:setup.c       **** 	cs_mreqPin_low;
 439               		.loc 1 283 0
 440 0102 9498      		cbi 0x12,4
 284:setup.c       **** 	
 285:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = 0; // Set address lines low and set as inputs
 441               		.loc 1 285 0
 442 0104 1BBA      		out 0x1b,__zero_reg__
 286:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = 0;
 443               		.loc 1 286 0
 444 0106 18BA      		out 0x18,__zero_reg__
 287:setup.c       **** 	GBA_DDR_ROM_ADDR15_8 = 0;
 445               		.loc 1 287 0
 446 0108 1ABA      		out 0x1a,__zero_reg__
 288:setup.c       **** 	GBA_DDR_ROM_ADDR7_0 = 0;
 447               		.loc 1 288 0
 448 010a 17BA      		out 0x17,__zero_reg__
 289:setup.c       **** 	
 290:setup.c       **** 	rdPin_low;
 449               		.loc 1 290 0
 450 010c 9598      		cbi 0x12,5
 291:setup.c       **** 	asm volatile("nop");
 451               		.loc 1 291 0
 452               	/* #APP */
 453               	 ;  291 "setup.c" 1
 454 010e 0000      		nop
 455               	 ;  0 "" 2
 292:setup.c       **** 	
 293:setup.c       **** 	uint16_t data = (GBA_PIN_ROM_DATA15_8 << 8) | GBA_PIN_ROM_DATA7_0; // Read data
 456               		.loc 1 293 0
 457               	/* #NOAPP */
 458 0110 29B3      		in r18,0x19
 459 0112 86B3      		in r24,0x16
 460               	.LVL22:
 294:setup.c       **** 	
 295:setup.c       **** 	rdPin_high;
 461               		.loc 1 295 0
 462 0114 959A      		sbi 0x12,5
 296:setup.c       **** 	cs_mreqPin_high;
 463               		.loc 1 296 0
 464 0116 949A      		sbi 0x12,4
 293:setup.c       **** 	
 465               		.loc 1 293 0
 466 0118 90E0      		ldi r25,0
 297:setup.c       **** 	
 298:setup.c       **** 	return data;
 299:setup.c       **** }
 467               		.loc 1 299 0
 468 011a 922B      		or r25,r18
 469 011c 0895      		ret
 470               		.cfi_endproc
 471               	.LFE21:
 473               	.global	gba_read_ram_8bit_data
 475               	gba_read_ram_8bit_data:
 476               	.LFB22:
 300:setup.c       **** 
 301:setup.c       **** // Set the address and read a byte from the 8 bit data line
 302:setup.c       **** uint8_t gba_read_ram_8bit_data(uint16_t address) {
 477               		.loc 1 302 0
 478               		.cfi_startproc
 479               	.LVL23:
 480               	/* prologue: function */
 481               	/* frame size = 0 */
 482               	/* stack size = 0 */
 483               	.L__stack_usage = 0
 303:setup.c       **** 	set_16bit_address(address);
 484               		.loc 1 303 0
 485 011e 00D0      		rcall set_16bit_address
 486               	.LVL24:
 304:setup.c       **** 	
 305:setup.c       **** 	rdPin_low;
 487               		.loc 1 305 0
 488 0120 9598      		cbi 0x12,5
 306:setup.c       **** 	cs2Pin_low; // CS2 pin low for SRAM/Flash select
 489               		.loc 1 306 0
 490 0122 3A98      		cbi 0x7,2
 307:setup.c       **** 	
 308:setup.c       **** 	asm volatile("nop"); // Delay a little (minimum needed is 2)
 491               		.loc 1 308 0
 492               	/* #APP */
 493               	 ;  308 "setup.c" 1
 494 0124 0000      		nop
 495               	 ;  0 "" 2
 309:setup.c       **** 	asm volatile("nop");
 496               		.loc 1 309 0
 497               	 ;  309 "setup.c" 1
 498 0126 0000      		nop
 499               	 ;  0 "" 2
 310:setup.c       **** 	uint8_t data = GBA_PIN_RAM_DATA7_0; // Read data
 500               		.loc 1 310 0
 501               	/* #NOAPP */
 502 0128 83B3      		in r24,0x13
 503               	.LVL25:
 311:setup.c       **** 	
 312:setup.c       **** 	cs2Pin_high;
 504               		.loc 1 312 0
 505 012a 3A9A      		sbi 0x7,2
 313:setup.c       **** 	rdPin_high;
 506               		.loc 1 313 0
 507 012c 959A      		sbi 0x12,5
 314:setup.c       **** 	
 315:setup.c       **** 	return data;
 316:setup.c       **** }
 508               		.loc 1 316 0
 509 012e 0895      		ret
 510               		.cfi_endproc
 511               	.LFE22:
 513               	.global	gba_write_ram_8bit_data
 515               	gba_write_ram_8bit_data:
 516               	.LFB23:
 317:setup.c       **** 
 318:setup.c       **** // Set the address and write a byte to the 8 bit data line 
 319:setup.c       **** void gba_write_ram_8bit_data(uint16_t address, uint8_t data) {
 517               		.loc 1 319 0
 518               		.cfi_startproc
 519               	.LVL26:
 520 0130 CF93      		push r28
 521               	.LCFI12:
 522               		.cfi_def_cfa_offset 3
 523               		.cfi_offset 28, -2
 524 0132 DF93      		push r29
 525               	.LCFI13:
 526               		.cfi_def_cfa_offset 4
 527               		.cfi_offset 29, -3
 528 0134 1F92      		push __zero_reg__
 529               	.LCFI14:
 530               		.cfi_def_cfa_offset 5
 531 0136 CDB7      		in r28,__SP_L__
 532 0138 DEB7      		in r29,__SP_H__
 533               	.LCFI15:
 534               		.cfi_def_cfa_register 28
 535               	/* prologue: function */
 536               	/* frame size = 1 */
 537               	/* stack size = 3 */
 538               	.L__stack_usage = 3
 320:setup.c       **** 	set_16bit_address(address);
 539               		.loc 1 320 0
 540 013a 6983      		std Y+1,r22
 541 013c 00D0      		rcall set_16bit_address
 542               	.LVL27:
 321:setup.c       **** 	
 322:setup.c       **** 	GBA_DDR_RAM_DATA7_0 = 0xFF; // Set data pins as outputs
 543               		.loc 1 322 0
 544 013e 8FEF      		ldi r24,lo8(-1)
 545 0140 84BB      		out 0x14,r24
 323:setup.c       **** 	GBA_PORT_RAM_DATA7_0 = data; // Set data
 546               		.loc 1 323 0
 547 0142 6981      		ldd r22,Y+1
 548 0144 65BB      		out 0x15,r22
 324:setup.c       **** 	
 325:setup.c       **** 	// Pulse WR
 326:setup.c       **** 	wrPin_low;
 549               		.loc 1 326 0
 550 0146 9698      		cbi 0x12,6
 327:setup.c       **** 	cs2Pin_low; // CS2 pin low for SRAM/Flash select
 551               		.loc 1 327 0
 552 0148 3A98      		cbi 0x7,2
 328:setup.c       **** 	
 329:setup.c       **** 	asm volatile("nop");
 553               		.loc 1 329 0
 554               	/* #APP */
 555               	 ;  329 "setup.c" 1
 556 014a 0000      		nop
 557               	 ;  0 "" 2
 330:setup.c       **** 	asm volatile("nop");
 558               		.loc 1 330 0
 559               	 ;  330 "setup.c" 1
 560 014c 0000      		nop
 561               	 ;  0 "" 2
 331:setup.c       **** 	
 332:setup.c       **** 	cs2Pin_high;
 562               		.loc 1 332 0
 563               	/* #NOAPP */
 564 014e 3A9A      		sbi 0x7,2
 333:setup.c       **** 	wrPin_high;
 565               		.loc 1 333 0
 566 0150 969A      		sbi 0x12,6
 334:setup.c       **** 	
 335:setup.c       **** 	// Clear data outputs and set data pins as inputs
 336:setup.c       **** 	GBA_PORT_RAM_DATA7_0 = 0;
 567               		.loc 1 336 0
 568 0152 15BA      		out 0x15,__zero_reg__
 337:setup.c       **** 	GBA_DDR_RAM_DATA7_0 = 0;
 569               		.loc 1 337 0
 570 0154 14BA      		out 0x14,__zero_reg__
 571               	/* epilogue start */
 338:setup.c       **** }
 572               		.loc 1 338 0
 573 0156 0F90      		pop __tmp_reg__
 574 0158 DF91      		pop r29
 575 015a CF91      		pop r28
 576 015c 0895      		ret
 577               		.cfi_endproc
 578               	.LFE23:
 580               	.global	gba_eeprom_mode
 582               	gba_eeprom_mode:
 583               	.LFB24:
 339:setup.c       **** 
 340:setup.c       **** 
 341:setup.c       **** 
 342:setup.c       **** // ---------- EEPROM ----------
 343:setup.c       **** 
 344:setup.c       **** // Set address/data all high (includes AD0/A23)
 345:setup.c       **** void gba_eeprom_mode (void) {
 584               		.loc 1 345 0
 585               		.cfi_startproc
 586               	/* prologue: function */
 587               	/* frame size = 0 */
 588               	/* stack size = 0 */
 589               	.L__stack_usage = 0
 346:setup.c       **** 	GBA_DDR_ROM_ADDR7_0 = 0xFF;
 590               		.loc 1 346 0
 591 015e 8FEF      		ldi r24,lo8(-1)
 592 0160 87BB      		out 0x17,r24
 347:setup.c       **** 	GBA_DDR_ROM_ADDR15_8 = 0xFF;
 593               		.loc 1 347 0
 594 0162 8ABB      		out 0x1a,r24
 348:setup.c       **** 	GBA_DDR_ROM_ADDR23_16 = 0xFF;
 595               		.loc 1 348 0
 596 0164 84BB      		out 0x14,r24
 349:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = 0x80;
 597               		.loc 1 349 0
 598 0166 90E8      		ldi r25,lo8(-128)
 599 0168 98BB      		out 0x18,r25
 350:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = 0xFF;
 600               		.loc 1 350 0
 601 016a 8BBB      		out 0x1b,r24
 351:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = 0xFF;
 602               		.loc 1 351 0
 603 016c 85BB      		out 0x15,r24
 604 016e 0895      		ret
 605               		.cfi_endproc
 606               	.LFE24:
 608               	.global	gba_eeprom_set_address
 610               	gba_eeprom_set_address:
 611               	.LFB25:
 352:setup.c       **** }
 353:setup.c       **** 
 354:setup.c       **** // Send out EEPROM address serially (WR clock, AD0 data out)
 355:setup.c       **** void gba_eeprom_set_address(uint16_t address, uint8_t eepromSize, uint8_t command) {
 612               		.loc 1 355 0
 613               		.cfi_startproc
 614               	.LVL28:
 615               	/* prologue: function */
 616               	/* frame size = 0 */
 617               	/* stack size = 0 */
 618               	.L__stack_usage = 0
 356:setup.c       **** 	cs_mreqPin_low;
 619               		.loc 1 356 0
 620 0170 9498      		cbi 0x12,4
 621               	.LVL29:
 357:setup.c       **** 	
 358:setup.c       **** 	int8_t x = 0;
 359:setup.c       **** 	if (eepromSize == EEPROM_64KBIT) {
 622               		.loc 1 359 0
 623 0172 6230      		cpi r22,lo8(2)
 624 0174 01F4      		brne .L29
 360:setup.c       **** 		if (command == EEPROM_READ) {
 625               		.loc 1 360 0
 626 0176 4111      		cpse r20,__zero_reg__
 627 0178 00C0      		rjmp .L30
 361:setup.c       **** 			address |= (1<<15) | (1<<14); // Set upper 2 bits high for read request
 628               		.loc 1 361 0
 629 017a 906C      		ori r25,192
 630               	.LVL30:
 631               	.L39:
 362:setup.c       **** 		}
 363:setup.c       **** 		else {
 364:setup.c       **** 			address |= (1<<15); // Set upper 1 bit high for write request
 365:setup.c       **** 		}
 366:setup.c       **** 		x = 15;
 632               		.loc 1 366 0
 633 017c 5FE0      		ldi r21,lo8(15)
 634               	.L32:
 635               	.LVL31:
 367:setup.c       **** 	}
 368:setup.c       **** 	else {
 369:setup.c       **** 		if (command == EEPROM_READ) {
 370:setup.c       **** 			address |= (1<<7) | (1<<6);
 371:setup.c       **** 		}
 372:setup.c       **** 		else {
 373:setup.c       **** 			address |= (1<<7);
 374:setup.c       **** 		}
 375:setup.c       **** 		x = 7;
 376:setup.c       **** 	}
 377:setup.c       **** 	
 378:setup.c       **** 	// Loop through address, 8 or 16 bits depending on EEPROM (includes the 2 bits for request type)
 379:setup.c       **** 	while (x >= 0) {
 380:setup.c       **** 		if (address & (1<<x)) {
 636               		.loc 1 380 0 discriminator 1
 637 017e 61E0      		ldi r22,lo8(1)
 638 0180 70E0      		ldi r23,0
 639               	.LVL32:
 640 0182 00C0      		rjmp .L31
 641               	.LVL33:
 642               	.L30:
 364:setup.c       **** 		}
 643               		.loc 1 364 0
 644 0184 9068      		ori r25,128
 645               	.LVL34:
 646 0186 00C0      		rjmp .L39
 647               	.L29:
 369:setup.c       **** 			address |= (1<<7) | (1<<6);
 648               		.loc 1 369 0
 649 0188 4111      		cpse r20,__zero_reg__
 650 018a 00C0      		rjmp .L33
 370:setup.c       **** 		}
 651               		.loc 1 370 0
 652 018c 806C      		ori r24,192
 653               	.LVL35:
 654 018e 00C0      		rjmp .L38
 655               	.L33:
 373:setup.c       **** 		}
 656               		.loc 1 373 0
 657 0190 8068      		ori r24,128
 658               	.LVL36:
 659               	.L38:
 375:setup.c       **** 	}
 660               		.loc 1 375 0
 661 0192 57E0      		ldi r21,lo8(7)
 662 0194 00C0      		rjmp .L32
 663               	.LVL37:
 664               	.L34:
 381:setup.c       **** 			ad0Pin_high;
 382:setup.c       **** 		}
 383:setup.c       **** 		else {
 384:setup.c       **** 			ad0Pin_low;
 665               		.loc 1 384 0
 666 0196 C098      		cbi 0x18,0
 667               	.L35:
 385:setup.c       **** 		}
 386:setup.c       **** 		
 387:setup.c       **** 		wrPin_low; // CLK
 668               		.loc 1 387 0
 669 0198 9698      		cbi 0x12,6
 388:setup.c       **** 		asm ("nop");
 670               		.loc 1 388 0
 671               	/* #APP */
 672               	 ;  388 "setup.c" 1
 673 019a 0000      		nop
 674               	 ;  0 "" 2
 389:setup.c       **** 		asm ("nop");
 675               		.loc 1 389 0
 676               	 ;  389 "setup.c" 1
 677 019c 0000      		nop
 678               	 ;  0 "" 2
 390:setup.c       **** 		wrPin_high; 
 679               		.loc 1 390 0
 680               	/* #NOAPP */
 681 019e 969A      		sbi 0x12,6
 391:setup.c       **** 		asm ("nop");
 682               		.loc 1 391 0
 683               	/* #APP */
 684               	 ;  391 "setup.c" 1
 685 01a0 0000      		nop
 686               	 ;  0 "" 2
 392:setup.c       **** 		asm ("nop");
 687               		.loc 1 392 0
 688               	 ;  392 "setup.c" 1
 689 01a2 0000      		nop
 690               	 ;  0 "" 2
 691               	/* #NOAPP */
 692 01a4 5150      		subi r21,lo8(-(-1))
 693               	.LVL38:
 379:setup.c       **** 		if (address & (1<<x)) {
 694               		.loc 1 379 0
 695 01a6 57FD      		sbrc r21,7
 696 01a8 00C0      		rjmp .L40
 697               	.L31:
 380:setup.c       **** 			ad0Pin_high;
 698               		.loc 1 380 0
 699 01aa 9B01      		movw r18,r22
 700 01ac 052E      		mov r0,r21
 701 01ae 00C0      		rjmp 2f
 702               		1:
 703 01b0 220F      		lsl r18
 704 01b2 331F      		rol r19
 705               		2:
 706 01b4 0A94      		dec r0
 707 01b6 02F4      		brpl 1b
 708 01b8 2823      		and r18,r24
 709 01ba 3923      		and r19,r25
 710 01bc 232B      		or r18,r19
 711 01be 01F0      		breq .L34
 381:setup.c       **** 		}
 712               		.loc 1 381 0
 713 01c0 C09A      		sbi 0x18,0
 714 01c2 00C0      		rjmp .L35
 715               	.L40:
 393:setup.c       **** 		
 394:setup.c       **** 		x--;
 395:setup.c       **** 	}
 396:setup.c       **** 	
 397:setup.c       **** 	// Only send stop bit (0) and WR/CS high if reading, as writing is done in 1 continuous chunk
 398:setup.c       **** 	if (command == EEPROM_READ) {  
 716               		.loc 1 398 0
 717 01c4 4111      		cpse r20,__zero_reg__
 718 01c6 00C0      		rjmp .L28
 399:setup.c       **** 		ad0Pin_low;
 719               		.loc 1 399 0
 720 01c8 C098      		cbi 0x18,0
 400:setup.c       **** 		asm ("nop");
 721               		.loc 1 400 0
 722               	/* #APP */
 723               	 ;  400 "setup.c" 1
 724 01ca 0000      		nop
 725               	 ;  0 "" 2
 401:setup.c       **** 		wrPin_low;
 726               		.loc 1 401 0
 727               	/* #NOAPP */
 728 01cc 9698      		cbi 0x12,6
 402:setup.c       **** 		asm ("nop");
 729               		.loc 1 402 0
 730               	/* #APP */
 731               	 ;  402 "setup.c" 1
 732 01ce 0000      		nop
 733               	 ;  0 "" 2
 403:setup.c       **** 		asm ("nop");
 734               		.loc 1 403 0
 735               	 ;  403 "setup.c" 1
 736 01d0 0000      		nop
 737               	 ;  0 "" 2
 404:setup.c       **** 		
 405:setup.c       **** 		wrPin_high;
 738               		.loc 1 405 0
 739               	/* #NOAPP */
 740 01d2 969A      		sbi 0x12,6
 406:setup.c       **** 		cs_mreqPin_high;
 741               		.loc 1 406 0
 742 01d4 949A      		sbi 0x12,4
 743               	.L28:
 744 01d6 0895      		ret
 745               		.cfi_endproc
 746               	.LFE25:
 748               	.global	gba_eeprom_read
 750               	gba_eeprom_read:
 751               	.LFB26:
 407:setup.c       **** 	}
 408:setup.c       **** }
 409:setup.c       **** 
 410:setup.c       **** // Read 8 bytes from the EEPROM address, data is valid on rising edge
 411:setup.c       **** void gba_eeprom_read(uint16_t address, uint8_t eepromSize) {
 752               		.loc 1 411 0
 753               		.cfi_startproc
 754               	.LVL39:
 755               	/* prologue: function */
 756               	/* frame size = 0 */
 757               	/* stack size = 0 */
 758               	.L__stack_usage = 0
 412:setup.c       **** 	gba_eeprom_set_address(address, eepromSize, EEPROM_READ);
 759               		.loc 1 412 0
 760 01d8 40E0      		ldi r20,0
 761 01da 00D0      		rcall gba_eeprom_set_address
 762               	.LVL40:
 413:setup.c       **** 	
 414:setup.c       **** 	// Set AD0 pin as input
 415:setup.c       **** 	GBA_PORT_EEPROM_DATA7_0 &= ~(1<<AD0);
 763               		.loc 1 415 0
 764 01dc C098      		cbi 0x18,0
 416:setup.c       **** 	GBA_DDR_EEPROM_DATA7_0 &= ~(1<<AD0);
 765               		.loc 1 416 0
 766 01de B898      		cbi 0x17,0
 417:setup.c       **** 	
 418:setup.c       **** 	cs_mreqPin_low;
 767               		.loc 1 418 0
 768 01e0 9498      		cbi 0x12,4
 769               	.LVL41:
 770 01e2 84E0      		ldi r24,lo8(4)
 771               	.LVL42:
 772               	.L44:
 773               	.LBB37:
 419:setup.c       **** 	
 420:setup.c       **** 	// Ignore first 4 bits
 421:setup.c       **** 	for (int8_t x = 0; x < 4; x++) {
 422:setup.c       **** 		rdPin_low; // CLK
 774               		.loc 1 422 0 discriminator 2
 775 01e4 9598      		cbi 0x12,5
 423:setup.c       **** 		asm ("nop");
 776               		.loc 1 423 0 discriminator 2
 777               	/* #APP */
 778               	 ;  423 "setup.c" 1
 779 01e6 0000      		nop
 780               	 ;  0 "" 2
 424:setup.c       **** 		asm ("nop");
 781               		.loc 1 424 0 discriminator 2
 782               	 ;  424 "setup.c" 1
 783 01e8 0000      		nop
 784               	 ;  0 "" 2
 425:setup.c       **** 		rdPin_high; 
 785               		.loc 1 425 0 discriminator 2
 786               	/* #NOAPP */
 787 01ea 959A      		sbi 0x12,5
 426:setup.c       **** 		asm ("nop");
 788               		.loc 1 426 0 discriminator 2
 789               	/* #APP */
 790               	 ;  426 "setup.c" 1
 791 01ec 0000      		nop
 792               	 ;  0 "" 2
 427:setup.c       **** 		asm ("nop");
 793               		.loc 1 427 0 discriminator 2
 794               	 ;  427 "setup.c" 1
 795 01ee 0000      		nop
 796               	 ;  0 "" 2
 797               	.LVL43:
 798               	/* #NOAPP */
 799 01f0 8150      		subi r24,lo8(-(-1))
 800               	.LVL44:
 421:setup.c       **** 		rdPin_low; // CLK
 801               		.loc 1 421 0 discriminator 2
 802 01f2 01F4      		brne .L44
 803 01f4 E0E0      		ldi r30,lo8(eepromBuffer)
 804 01f6 F0E0      		ldi r31,hi8(eepromBuffer)
 805               	.LBE37:
 806               	.LBB38:
 807               	.LBB39:
 808               	.LBB40:
 428:setup.c       **** 	}
 429:setup.c       **** 	
 430:setup.c       **** 	// Read out 64 bits
 431:setup.c       **** 	for (uint8_t c = 0; c < 8; c++) {
 432:setup.c       **** 		uint8_t data = 0;
 433:setup.c       **** 		for (int8_t x = 7; x >= 0; x--) {
 434:setup.c       **** 			rdPin_low; // CLK
 435:setup.c       **** 			asm ("nop");
 436:setup.c       **** 			asm ("nop");
 437:setup.c       **** 			rdPin_high;
 438:setup.c       **** 			
 439:setup.c       **** 			if (GBA_PIN_EEPROM_DATA7_0 & (1<<AD0)) {
 440:setup.c       **** 				data |= (1<<x);
 809               		.loc 1 440 0
 810 01f8 21E0      		ldi r18,lo8(1)
 811 01fa 30E0      		ldi r19,0
 812               	.LVL45:
 813               	.L43:
 814               	.LBE40:
 815               	.LBE39:
 816               	.LBE38:
 418:setup.c       **** 	
 817               		.loc 1 418 0 discriminator 1
 818 01fc 87E0      		ldi r24,lo8(7)
 819 01fe 90E0      		ldi r25,0
 820 0200 60E0      		ldi r22,0
 821               	.LVL46:
 822               	.L48:
 823               	.LBB43:
 824               	.LBB42:
 825               	.LBB41:
 434:setup.c       **** 			asm ("nop");
 826               		.loc 1 434 0
 827 0202 9598      		cbi 0x12,5
 435:setup.c       **** 			asm ("nop");
 828               		.loc 1 435 0
 829               	/* #APP */
 830               	 ;  435 "setup.c" 1
 831 0204 0000      		nop
 832               	 ;  0 "" 2
 436:setup.c       **** 			rdPin_high;
 833               		.loc 1 436 0
 834               	 ;  436 "setup.c" 1
 835 0206 0000      		nop
 836               	 ;  0 "" 2
 437:setup.c       **** 			
 837               		.loc 1 437 0
 838               	/* #NOAPP */
 839 0208 959A      		sbi 0x12,5
 439:setup.c       **** 				data |= (1<<x);
 840               		.loc 1 439 0
 841 020a B09B      		sbis 0x16,0
 842 020c 00C0      		rjmp .L45
 843               		.loc 1 440 0
 844 020e A901      		movw r20,r18
 845 0210 082E      		mov r0,r24
 846 0212 00C0      		rjmp 2f
 847               		1:
 848 0214 440F      		lsl r20
 849               		2:
 850 0216 0A94      		dec r0
 851 0218 02F4      		brpl 1b
 852 021a 642B      		or r22,r20
 853               	.LVL47:
 854               	.L45:
 855               	.LVL48:
 856 021c 0197      		sbiw r24,1
 857 021e 00F4      		brcc .L48
 858               	.LBE41:
 441:setup.c       **** 			}
 442:setup.c       **** 		}
 443:setup.c       **** 		eepromBuffer[c] = data;
 859               		.loc 1 443 0
 860 0220 6193      		st Z+,r22
 861               	.LVL49:
 862               	.LBE42:
 431:setup.c       **** 		uint8_t data = 0;
 863               		.loc 1 431 0
 864 0222 80E0      		ldi r24,hi8(eepromBuffer+8)
 865 0224 E030      		cpi r30,lo8(eepromBuffer+8)
 866 0226 F807      		cpc r31,r24
 867               	.LVL50:
 868 0228 01F4      		brne .L43
 869               	.LBE43:
 444:setup.c       **** 	}
 445:setup.c       **** 	
 446:setup.c       **** 	cs_mreqPin_high;
 870               		.loc 1 446 0
 871 022a 949A      		sbi 0x12,4
 447:setup.c       **** 	
 448:setup.c       **** 	// Set AD0 pin as output
 449:setup.c       **** 	GBA_PORT_EEPROM_DATA7_0 |= (1<<AD0);
 872               		.loc 1 449 0
 873 022c C09A      		sbi 0x18,0
 450:setup.c       **** 	GBA_DDR_EEPROM_DATA7_0 |= (1<<AD0);
 874               		.loc 1 450 0
 875 022e B89A      		sbi 0x17,0
 876 0230 0895      		ret
 877               		.cfi_endproc
 878               	.LFE26:
 880               	.global	gba_eeprom_write
 882               	gba_eeprom_write:
 883               	.LFB27:
 451:setup.c       **** }
 452:setup.c       **** 
 453:setup.c       **** // Write 8 bytes to the EEPROM address
 454:setup.c       **** void gba_eeprom_write(uint16_t address, uint8_t eepromSize) {
 884               		.loc 1 454 0
 885               		.cfi_startproc
 886               	.LVL51:
 887               	/* prologue: function */
 888               	/* frame size = 0 */
 889               	/* stack size = 0 */
 890               	.L__stack_usage = 0
 455:setup.c       **** 	gba_eeprom_set_address(address, eepromSize, EEPROM_WRITE);
 891               		.loc 1 455 0
 892 0232 41E0      		ldi r20,lo8(1)
 893 0234 00D0      		rcall gba_eeprom_set_address
 894               	.LVL52:
 895 0236 E0E0      		ldi r30,lo8(eepromBuffer)
 896 0238 F0E0      		ldi r31,hi8(eepromBuffer)
 897               	.LVL53:
 898               	.L53:
 454:setup.c       **** 	gba_eeprom_set_address(address, eepromSize, EEPROM_WRITE);
 899               		.loc 1 454 0 discriminator 1
 900 023a 87E0      		ldi r24,lo8(7)
 901 023c 90E0      		ldi r25,0
 902               	.LVL54:
 903               	.L58:
 904               	.LBB44:
 905               	.LBB45:
 456:setup.c       **** 	
 457:setup.c       **** 	// Write 64 bits
 458:setup.c       **** 	for (uint8_t c = 0; c < 8; c++) {
 459:setup.c       **** 		for (int8_t x = 7; x >= 0; x--) {
 460:setup.c       **** 			if (eepromBuffer[c] & (1<<x)) {
 906               		.loc 1 460 0
 907 023e 2081      		ld r18,Z
 908 0240 30E0      		ldi r19,0
 909 0242 082E      		mov r0,r24
 910 0244 00C0      		rjmp 2f
 911               		1:
 912 0246 3595      		asr r19
 913 0248 2795      		ror r18
 914               		2:
 915 024a 0A94      		dec r0
 916 024c 02F4      		brpl 1b
 917 024e 20FF      		sbrs r18,0
 918 0250 00C0      		rjmp .L54
 461:setup.c       **** 				ad0Pin_high;
 919               		.loc 1 461 0
 920 0252 C09A      		sbi 0x18,0
 921 0254 00C0      		rjmp .L55
 922               	.L54:
 462:setup.c       **** 			}
 463:setup.c       **** 			else {
 464:setup.c       **** 				ad0Pin_low;
 923               		.loc 1 464 0
 924 0256 C098      		cbi 0x18,0
 925               	.L55:
 465:setup.c       **** 			}
 466:setup.c       **** 			
 467:setup.c       **** 			wrPin_low; // CLK
 926               		.loc 1 467 0
 927 0258 9698      		cbi 0x12,6
 468:setup.c       **** 			asm ("nop");
 928               		.loc 1 468 0
 929               	/* #APP */
 930               	 ;  468 "setup.c" 1
 931 025a 0000      		nop
 932               	 ;  0 "" 2
 469:setup.c       **** 			asm ("nop");
 933               		.loc 1 469 0
 934               	 ;  469 "setup.c" 1
 935 025c 0000      		nop
 936               	 ;  0 "" 2
 470:setup.c       **** 			wrPin_high; 
 937               		.loc 1 470 0
 938               	/* #NOAPP */
 939 025e 969A      		sbi 0x12,6
 471:setup.c       **** 			asm ("nop");
 940               		.loc 1 471 0
 941               	/* #APP */
 942               	 ;  471 "setup.c" 1
 943 0260 0000      		nop
 944               	 ;  0 "" 2
 472:setup.c       **** 			asm ("nop");
 945               		.loc 1 472 0
 946               	 ;  472 "setup.c" 1
 947 0262 0000      		nop
 948               	 ;  0 "" 2
 949               	.LVL55:
 950               	/* #NOAPP */
 951               	.LVL56:
 952 0264 0197      		sbiw r24,1
 953 0266 00F4      		brcc .L58
 954 0268 3196      		adiw r30,1
 955               	.LVL57:
 956               	.LBE45:
 458:setup.c       **** 		for (int8_t x = 7; x >= 0; x--) {
 957               		.loc 1 458 0
 958 026a 80E0      		ldi r24,hi8(eepromBuffer+8)
 959 026c E030      		cpi r30,lo8(eepromBuffer+8)
 960 026e F807      		cpc r31,r24
 961               	.LVL58:
 962 0270 01F4      		brne .L53
 963               	.LBE44:
 473:setup.c       **** 		}
 474:setup.c       **** 	}
 475:setup.c       **** 	
 476:setup.c       **** 	// Last bit low
 477:setup.c       **** 	ad0Pin_low;
 964               		.loc 1 477 0
 965 0272 C098      		cbi 0x18,0
 478:setup.c       **** 	wrPin_low; // CLK
 966               		.loc 1 478 0
 967 0274 9698      		cbi 0x12,6
 479:setup.c       **** 	asm ("nop");
 968               		.loc 1 479 0
 969               	/* #APP */
 970               	 ;  479 "setup.c" 1
 971 0276 0000      		nop
 972               	 ;  0 "" 2
 480:setup.c       **** 	asm ("nop");
 973               		.loc 1 480 0
 974               	 ;  480 "setup.c" 1
 975 0278 0000      		nop
 976               	 ;  0 "" 2
 481:setup.c       **** 	wrPin_high; 
 977               		.loc 1 481 0
 978               	/* #NOAPP */
 979 027a 969A      		sbi 0x12,6
 482:setup.c       **** 	asm ("nop");
 980               		.loc 1 482 0
 981               	/* #APP */
 982               	 ;  482 "setup.c" 1
 983 027c 0000      		nop
 984               	 ;  0 "" 2
 483:setup.c       **** 	asm ("nop");
 985               		.loc 1 483 0
 986               	 ;  483 "setup.c" 1
 987 027e 0000      		nop
 988               	 ;  0 "" 2
 484:setup.c       **** 	
 485:setup.c       **** 	cs_mreqPin_high;
 989               		.loc 1 485 0
 990               	/* #NOAPP */
 991 0280 949A      		sbi 0x12,4
 992 0282 0895      		ret
 993               		.cfi_endproc
 994               	.LFE27:
 996               	.global	flash_write_bus_cycle
 998               	flash_write_bus_cycle:
 999               	.LFB28:
 486:setup.c       **** }
 487:setup.c       **** 
 488:setup.c       **** 
 489:setup.c       **** 
 490:setup.c       **** // ---------- FLASH ----------
 491:setup.c       **** 
 492:setup.c       **** // Set the address and data for the write byte cycle to the flash
 493:setup.c       **** void flash_write_bus_cycle(uint16_t address, uint8_t data) {
 1000               		.loc 1 493 0
 1001               		.cfi_startproc
 1002               	.LVL59:
 1003 0284 CF93      		push r28
 1004               	.LCFI16:
 1005               		.cfi_def_cfa_offset 3
 1006               		.cfi_offset 28, -2
 1007 0286 DF93      		push r29
 1008               	.LCFI17:
 1009               		.cfi_def_cfa_offset 4
 1010               		.cfi_offset 29, -3
 1011 0288 1F92      		push __zero_reg__
 1012               	.LCFI18:
 1013               		.cfi_def_cfa_offset 5
 1014 028a CDB7      		in r28,__SP_L__
 1015 028c DEB7      		in r29,__SP_H__
 1016               	.LCFI19:
 1017               		.cfi_def_cfa_register 28
 1018               	/* prologue: function */
 1019               	/* frame size = 1 */
 1020               	/* stack size = 3 */
 1021               	.L__stack_usage = 3
 494:setup.c       **** 	GBA_DDR_RAM_DATA7_0 = 0xFF; // Set data pins as outputs
 1022               		.loc 1 494 0
 1023 028e 2FEF      		ldi r18,lo8(-1)
 1024 0290 24BB      		out 0x14,r18
 495:setup.c       **** 	set_16bit_address(address);
 1025               		.loc 1 495 0
 1026 0292 6983      		std Y+1,r22
 1027 0294 00D0      		rcall set_16bit_address
 1028               	.LVL60:
 496:setup.c       **** 	GBA_PORT_RAM_DATA7_0 = data;
 1029               		.loc 1 496 0
 1030 0296 6981      		ldd r22,Y+1
 1031 0298 65BB      		out 0x15,r22
 497:setup.c       **** 	
 498:setup.c       **** 	wrPin_low;
 1032               		.loc 1 498 0
 1033 029a 9698      		cbi 0x12,6
 499:setup.c       **** 	cs2Pin_low;
 1034               		.loc 1 499 0
 1035 029c 3A98      		cbi 0x7,2
 500:setup.c       **** 	asm volatile("nop");
 1036               		.loc 1 500 0
 1037               	/* #APP */
 1038               	 ;  500 "setup.c" 1
 1039 029e 0000      		nop
 1040               	 ;  0 "" 2
 501:setup.c       **** 	wrPin_high;
 1041               		.loc 1 501 0
 1042               	/* #NOAPP */
 1043 02a0 969A      		sbi 0x12,6
 502:setup.c       **** 	cs2Pin_high;
 1044               		.loc 1 502 0
 1045 02a2 3A9A      		sbi 0x7,2
 1046               	/* epilogue start */
 503:setup.c       **** }
 1047               		.loc 1 503 0
 1048 02a4 0F90      		pop __tmp_reg__
 1049 02a6 DF91      		pop r29
 1050 02a8 CF91      		pop r28
 1051 02aa 0895      		ret
 1052               		.cfi_endproc
 1053               	.LFE28:
 1055               	.global	flash_read_chip_id
 1057               	flash_read_chip_id:
 1058               	.LFB29:
 504:setup.c       **** 
 505:setup.c       **** // Read the flash manufacturer and device ID (Software ID)
 506:setup.c       **** void flash_read_chip_id(void) {
 1059               		.loc 1 506 0
 1060               		.cfi_startproc
 1061               	/* prologue: function */
 1062               	/* frame size = 0 */
 1063               	/* stack size = 0 */
 1064               	.L__stack_usage = 0
 507:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xAA);
 1065               		.loc 1 507 0
 1066 02ac 6AEA      		ldi r22,lo8(-86)
 1067 02ae 85E5      		ldi r24,lo8(85)
 1068 02b0 95E5      		ldi r25,lo8(85)
 1069 02b2 00D0      		rcall flash_write_bus_cycle
 1070               	.LVL61:
 508:setup.c       **** 	flash_write_bus_cycle(0x2AAA, 0x55);
 1071               		.loc 1 508 0
 1072 02b4 65E5      		ldi r22,lo8(85)
 1073 02b6 8AEA      		ldi r24,lo8(-86)
 1074 02b8 9AE2      		ldi r25,lo8(42)
 1075 02ba 00D0      		rcall flash_write_bus_cycle
 1076               	.LVL62:
 509:setup.c       **** 	flash_write_bus_cycle(0x5555, 0x90); // Software ID entry
 1077               		.loc 1 509 0
 1078 02bc 60E9      		ldi r22,lo8(-112)
 1079 02be 85E5      		ldi r24,lo8(85)
 1080 02c0 95E5      		ldi r25,lo8(85)
 1081 02c2 00D0      		rcall flash_write_bus_cycle
 1082               	.LVL63:
 1083               	.LBB46:
 1084               	.LBB47:
 1085               		.file 2 "c:\\winavr-20100110\\avr\\include\\util\\delay.h"
   1:c:\winavr-20100110\avr\include\util\delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:c:\winavr-20100110\avr\include\util\delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:c:\winavr-20100110\avr\include\util\delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:c:\winavr-20100110\avr\include\util\delay.h ****    All rights reserved.
   5:c:\winavr-20100110\avr\include\util\delay.h **** 
   6:c:\winavr-20100110\avr\include\util\delay.h ****    Redistribution and use in source and binary forms, with or without
   7:c:\winavr-20100110\avr\include\util\delay.h ****    modification, are permitted provided that the following conditions are met:
   8:c:\winavr-20100110\avr\include\util\delay.h **** 
   9:c:\winavr-20100110\avr\include\util\delay.h ****    * Redistributions of source code must retain the above copyright
  10:c:\winavr-20100110\avr\include\util\delay.h ****      notice, this list of conditions and the following disclaimer.
  11:c:\winavr-20100110\avr\include\util\delay.h **** 
  12:c:\winavr-20100110\avr\include\util\delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:c:\winavr-20100110\avr\include\util\delay.h ****      notice, this list of conditions and the following disclaimer in
  14:c:\winavr-20100110\avr\include\util\delay.h ****      the documentation and/or other materials provided with the
  15:c:\winavr-20100110\avr\include\util\delay.h ****      distribution.
  16:c:\winavr-20100110\avr\include\util\delay.h **** 
  17:c:\winavr-20100110\avr\include\util\delay.h ****    * Neither the name of the copyright holders nor the names of
  18:c:\winavr-20100110\avr\include\util\delay.h ****      contributors may be used to endorse or promote products derived
  19:c:\winavr-20100110\avr\include\util\delay.h ****      from this software without specific prior written permission.
  20:c:\winavr-20100110\avr\include\util\delay.h **** 
  21:c:\winavr-20100110\avr\include\util\delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:c:\winavr-20100110\avr\include\util\delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:c:\winavr-20100110\avr\include\util\delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:c:\winavr-20100110\avr\include\util\delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:c:\winavr-20100110\avr\include\util\delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:c:\winavr-20100110\avr\include\util\delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:c:\winavr-20100110\avr\include\util\delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:c:\winavr-20100110\avr\include\util\delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:c:\winavr-20100110\avr\include\util\delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:c:\winavr-20100110\avr\include\util\delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:c:\winavr-20100110\avr\include\util\delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:c:\winavr-20100110\avr\include\util\delay.h **** 
  33:c:\winavr-20100110\avr\include\util\delay.h **** /* $Id$ */
  34:c:\winavr-20100110\avr\include\util\delay.h **** 
  35:c:\winavr-20100110\avr\include\util\delay.h **** #ifndef _UTIL_DELAY_H_
  36:c:\winavr-20100110\avr\include\util\delay.h **** #define _UTIL_DELAY_H_ 1
  37:c:\winavr-20100110\avr\include\util\delay.h **** 
  38:c:\winavr-20100110\avr\include\util\delay.h **** #ifndef __HAS_DELAY_CYCLES
  39:c:\winavr-20100110\avr\include\util\delay.h **** #define __HAS_DELAY_CYCLES 1
  40:c:\winavr-20100110\avr\include\util\delay.h **** #endif
  41:c:\winavr-20100110\avr\include\util\delay.h **** 
  42:c:\winavr-20100110\avr\include\util\delay.h **** #include <inttypes.h>
  43:c:\winavr-20100110\avr\include\util\delay.h **** #include <util/delay_basic.h>
  44:c:\winavr-20100110\avr\include\util\delay.h **** #include <math.h>
  45:c:\winavr-20100110\avr\include\util\delay.h **** 
  46:c:\winavr-20100110\avr\include\util\delay.h **** /** \file */
  47:c:\winavr-20100110\avr\include\util\delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  48:c:\winavr-20100110\avr\include\util\delay.h ****     \code
  49:c:\winavr-20100110\avr\include\util\delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  50:c:\winavr-20100110\avr\include\util\delay.h ****     //#define F_CPU 14.7456E6
  51:c:\winavr-20100110\avr\include\util\delay.h ****     #include <util/delay.h>
  52:c:\winavr-20100110\avr\include\util\delay.h ****     \endcode
  53:c:\winavr-20100110\avr\include\util\delay.h **** 
  54:c:\winavr-20100110\avr\include\util\delay.h ****     \note As an alternative method, it is possible to pass the
  55:c:\winavr-20100110\avr\include\util\delay.h ****     F_CPU macro down to the compiler from the Makefile.
  56:c:\winavr-20100110\avr\include\util\delay.h ****     Obviously, in that case, no \c \#define statement should be
  57:c:\winavr-20100110\avr\include\util\delay.h ****     used.
  58:c:\winavr-20100110\avr\include\util\delay.h **** 
  59:c:\winavr-20100110\avr\include\util\delay.h ****     The functions in this header file are wrappers around the basic
  60:c:\winavr-20100110\avr\include\util\delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  61:c:\winavr-20100110\avr\include\util\delay.h ****     convenience functions where actual time values can be specified
  62:c:\winavr-20100110\avr\include\util\delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  63:c:\winavr-20100110\avr\include\util\delay.h ****     that compile-time constant expressions will be eliminated by
  64:c:\winavr-20100110\avr\include\util\delay.h ****     compiler optimization so floating-point expressions can be used
  65:c:\winavr-20100110\avr\include\util\delay.h ****     to calculate the number of delay cycles needed based on the CPU
  66:c:\winavr-20100110\avr\include\util\delay.h ****     frequency passed by the macro F_CPU.
  67:c:\winavr-20100110\avr\include\util\delay.h **** 
  68:c:\winavr-20100110\avr\include\util\delay.h ****     \note In order for these functions to work as intended, compiler
  69:c:\winavr-20100110\avr\include\util\delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  70:c:\winavr-20100110\avr\include\util\delay.h ****     <em>must</em> be an expression that is a known constant at
  71:c:\winavr-20100110\avr\include\util\delay.h ****     compile-time.  If these requirements are not met, the resulting
  72:c:\winavr-20100110\avr\include\util\delay.h ****     delay will be much longer (and basically unpredictable), and
  73:c:\winavr-20100110\avr\include\util\delay.h ****     applications that otherwise do not use floating-point calculations
  74:c:\winavr-20100110\avr\include\util\delay.h ****     will experience severe code bloat by the floating-point library
  75:c:\winavr-20100110\avr\include\util\delay.h ****     routines linked into the application.
  76:c:\winavr-20100110\avr\include\util\delay.h **** 
  77:c:\winavr-20100110\avr\include\util\delay.h ****     The functions available allow the specification of microsecond, and
  78:c:\winavr-20100110\avr\include\util\delay.h ****     millisecond delays directly, using the application-supplied macro
  79:c:\winavr-20100110\avr\include\util\delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  80:c:\winavr-20100110\avr\include\util\delay.h **** 
  81:c:\winavr-20100110\avr\include\util\delay.h **** */
  82:c:\winavr-20100110\avr\include\util\delay.h **** 
  83:c:\winavr-20100110\avr\include\util\delay.h **** #if !defined(__DOXYGEN__)
  84:c:\winavr-20100110\avr\include\util\delay.h **** static inline void _delay_us(double __us) __attribute__((always_inline));
  85:c:\winavr-20100110\avr\include\util\delay.h **** static inline void _delay_ms(double __ms) __attribute__((always_inline));
  86:c:\winavr-20100110\avr\include\util\delay.h **** #endif
  87:c:\winavr-20100110\avr\include\util\delay.h **** 
  88:c:\winavr-20100110\avr\include\util\delay.h **** #ifndef F_CPU
  89:c:\winavr-20100110\avr\include\util\delay.h **** /* prevent compiler error by supplying a default */
  90:c:\winavr-20100110\avr\include\util\delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  91:c:\winavr-20100110\avr\include\util\delay.h **** # define F_CPU 1000000UL
  92:c:\winavr-20100110\avr\include\util\delay.h **** #endif
  93:c:\winavr-20100110\avr\include\util\delay.h **** 
  94:c:\winavr-20100110\avr\include\util\delay.h **** #ifndef __OPTIMIZE__
  95:c:\winavr-20100110\avr\include\util\delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
  96:c:\winavr-20100110\avr\include\util\delay.h **** #endif
  97:c:\winavr-20100110\avr\include\util\delay.h **** 
  98:c:\winavr-20100110\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
  99:c:\winavr-20100110\avr\include\util\delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 100:c:\winavr-20100110\avr\include\util\delay.h ****   __STDC_HOSTED__
 101:c:\winavr-20100110\avr\include\util\delay.h **** #  include <math.h>
 102:c:\winavr-20100110\avr\include\util\delay.h **** #endif
 103:c:\winavr-20100110\avr\include\util\delay.h **** 
 104:c:\winavr-20100110\avr\include\util\delay.h **** /**
 105:c:\winavr-20100110\avr\include\util\delay.h ****    \ingroup util_delay
 106:c:\winavr-20100110\avr\include\util\delay.h **** 
 107:c:\winavr-20100110\avr\include\util\delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 108:c:\winavr-20100110\avr\include\util\delay.h **** 
 109:c:\winavr-20100110\avr\include\util\delay.h ****    The macro F_CPU is supposed to be defined to a
 110:c:\winavr-20100110\avr\include\util\delay.h ****    constant defining the CPU clock frequency (in Hertz).
 111:c:\winavr-20100110\avr\include\util\delay.h **** 
 112:c:\winavr-20100110\avr\include\util\delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 113:c:\winavr-20100110\avr\include\util\delay.h **** 
 114:c:\winavr-20100110\avr\include\util\delay.h ****    When the user request delay which exceed the maximum possible one,
 115:c:\winavr-20100110\avr\include\util\delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 116:c:\winavr-20100110\avr\include\util\delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 117:c:\winavr-20100110\avr\include\util\delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 118:c:\winavr-20100110\avr\include\util\delay.h ****    user will not be informed about decreased resolution.
 119:c:\winavr-20100110\avr\include\util\delay.h **** 
 120:c:\winavr-20100110\avr\include\util\delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 121:c:\winavr-20100110\avr\include\util\delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 122:c:\winavr-20100110\avr\include\util\delay.h ****    values greater than the maximal possible delay, overflows results in
 123:c:\winavr-20100110\avr\include\util\delay.h ****    no delay i.e., 0ms.
 124:c:\winavr-20100110\avr\include\util\delay.h **** 
 125:c:\winavr-20100110\avr\include\util\delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 126:c:\winavr-20100110\avr\include\util\delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 127:c:\winavr-20100110\avr\include\util\delay.h ****    the user gets atleast __us microseconds of delay.
 128:c:\winavr-20100110\avr\include\util\delay.h **** 
 129:c:\winavr-20100110\avr\include\util\delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 130:c:\winavr-20100110\avr\include\util\delay.h ****    to round down and round to closest integer.
 131:c:\winavr-20100110\avr\include\util\delay.h **** 
 132:c:\winavr-20100110\avr\include\util\delay.h ****    Note: The new implementation of _delay_ms(double __ms) with 
 133:c:\winavr-20100110\avr\include\util\delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible. 
 134:c:\winavr-20100110\avr\include\util\delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 135:c:\winavr-20100110\avr\include\util\delay.h ****    Also, the backward compatible
 136:c:\winavr-20100110\avr\include\util\delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 137:c:\winavr-20100110\avr\include\util\delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 138:c:\winavr-20100110\avr\include\util\delay.h ****    required for rounding are not available to the compiler then.
 139:c:\winavr-20100110\avr\include\util\delay.h **** 
 140:c:\winavr-20100110\avr\include\util\delay.h ****  */
 141:c:\winavr-20100110\avr\include\util\delay.h **** void
 142:c:\winavr-20100110\avr\include\util\delay.h **** _delay_ms(double __ms)
 143:c:\winavr-20100110\avr\include\util\delay.h **** {
 144:c:\winavr-20100110\avr\include\util\delay.h **** 	double __tmp ; 
 145:c:\winavr-20100110\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 146:c:\winavr-20100110\avr\include\util\delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 147:c:\winavr-20100110\avr\include\util\delay.h ****   __STDC_HOSTED__
 148:c:\winavr-20100110\avr\include\util\delay.h **** 	uint32_t __ticks_dc;
 149:c:\winavr-20100110\avr\include\util\delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 150:c:\winavr-20100110\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 151:c:\winavr-20100110\avr\include\util\delay.h **** 
 152:c:\winavr-20100110\avr\include\util\delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 153:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 154:c:\winavr-20100110\avr\include\util\delay.h **** 
 155:c:\winavr-20100110\avr\include\util\delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 156:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 157:c:\winavr-20100110\avr\include\util\delay.h **** 
 158:c:\winavr-20100110\avr\include\util\delay.h **** 	#else
 159:c:\winavr-20100110\avr\include\util\delay.h **** 		//round up by default
 160:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 161:c:\winavr-20100110\avr\include\util\delay.h **** 	#endif
 162:c:\winavr-20100110\avr\include\util\delay.h **** 
 163:c:\winavr-20100110\avr\include\util\delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 1086               		.loc 2 163 0
 1087 02c4 8FE3      		ldi r24,lo8(-25537)
 1088 02c6 9CE9      		ldi r25,hi8(-25537)
 1089 02c8 0197      		1: sbiw r24,1
 1090 02ca 01F4      		brne 1b
 1091 02cc 00C0      		rjmp .
 1092 02ce 0000      		nop
 1093               	.LBE47:
 1094               	.LBE46:
 510:setup.c       **** 	_delay_ms(20); // Wait a little (for Atmel chip)
 511:setup.c       **** 	
 512:setup.c       **** 	// Set data as inputs
 513:setup.c       **** 	GBA_PORT_RAM_DATA7_0 = 0;
 1095               		.loc 1 513 0
 1096 02d0 15BA      		out 0x15,__zero_reg__
 514:setup.c       **** 	GBA_DDR_RAM_DATA7_0 = 0;
 1097               		.loc 1 514 0
 1098 02d2 14BA      		out 0x14,__zero_reg__
 515:setup.c       **** 	
 516:setup.c       **** 	// Read and transmit the 2 bytes
 517:setup.c       **** 	flashChipIdBuffer[0] = gba_read_ram_8bit_data(0x0000);
 1099               		.loc 1 517 0
 1100 02d4 80E0      		ldi r24,0
 1101 02d6 90E0      		ldi r25,0
 1102 02d8 00D0      		rcall gba_read_ram_8bit_data
 1103               	.LVL64:
 1104 02da 8093 0000 		sts flashChipIdBuffer,r24
 518:setup.c       **** 	flashChipIdBuffer[1] = gba_read_ram_8bit_data(0x0001);
 1105               		.loc 1 518 0
 1106 02de 81E0      		ldi r24,lo8(1)
 1107 02e0 90E0      		ldi r25,0
 1108 02e2 00D0      		rcall gba_read_ram_8bit_data
 1109               	.LVL65:
 1110 02e4 8093 0000 		sts flashChipIdBuffer+1,r24
 519:setup.c       **** 	
 520:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xAA);
 1111               		.loc 1 520 0
 1112 02e8 6AEA      		ldi r22,lo8(-86)
 1113 02ea 85E5      		ldi r24,lo8(85)
 1114 02ec 95E5      		ldi r25,lo8(85)
 1115 02ee 00D0      		rcall flash_write_bus_cycle
 1116               	.LVL66:
 521:setup.c       **** 	flash_write_bus_cycle(0x2AAA, 0x55);
 1117               		.loc 1 521 0
 1118 02f0 65E5      		ldi r22,lo8(85)
 1119 02f2 8AEA      		ldi r24,lo8(-86)
 1120 02f4 9AE2      		ldi r25,lo8(42)
 1121 02f6 00D0      		rcall flash_write_bus_cycle
 1122               	.LVL67:
 522:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xF0); // Software ID exit
 1123               		.loc 1 522 0
 1124 02f8 60EF      		ldi r22,lo8(-16)
 1125 02fa 85E5      		ldi r24,lo8(85)
 1126 02fc 95E5      		ldi r25,lo8(85)
 1127 02fe 00D0      		rcall flash_write_bus_cycle
 1128               	.LVL68:
 1129               	.LBB48:
 1130               	.LBB49:
 1131               		.loc 2 163 0
 1132 0300 8FE3      		ldi r24,lo8(-25537)
 1133 0302 9CE9      		ldi r25,hi8(-25537)
 1134 0304 0197      		1: sbiw r24,1
 1135 0306 01F4      		brne 1b
 1136 0308 00C0      		rjmp .
 1137 030a 0000      		nop
 1138 030c 0895      		ret
 1139               	.LBE49:
 1140               	.LBE48:
 1141               		.cfi_endproc
 1142               	.LFE29:
 1144               	.global	flash_switch_bank
 1146               	flash_switch_bank:
 1147               	.LFB30:
 523:setup.c       **** 	_delay_ms(20); // Wait a little (for Atmel chip)
 524:setup.c       **** }
 525:setup.c       **** 
 526:setup.c       **** // Switch banks on the Flash
 527:setup.c       **** void flash_switch_bank(uint8_t bank) {
 1148               		.loc 1 527 0
 1149               		.cfi_startproc
 1150               	.LVL69:
 1151 030e CF93      		push r28
 1152               	.LCFI20:
 1153               		.cfi_def_cfa_offset 3
 1154               		.cfi_offset 28, -2
 1155               	/* prologue: function */
 1156               	/* frame size = 0 */
 1157               	/* stack size = 1 */
 1158               	.L__stack_usage = 1
 1159 0310 C82F      		mov r28,r24
 528:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xAA);
 1160               		.loc 1 528 0
 1161 0312 6AEA      		ldi r22,lo8(-86)
 1162 0314 85E5      		ldi r24,lo8(85)
 1163 0316 95E5      		ldi r25,lo8(85)
 1164               	.LVL70:
 1165 0318 00D0      		rcall flash_write_bus_cycle
 1166               	.LVL71:
 529:setup.c       **** 	flash_write_bus_cycle(0x2AAA, 0x55);
 1167               		.loc 1 529 0
 1168 031a 65E5      		ldi r22,lo8(85)
 1169 031c 8AEA      		ldi r24,lo8(-86)
 1170 031e 9AE2      		ldi r25,lo8(42)
 1171 0320 00D0      		rcall flash_write_bus_cycle
 1172               	.LVL72:
 530:setup.c       **** 	
 531:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xB0);
 1173               		.loc 1 531 0
 1174 0322 60EB      		ldi r22,lo8(-80)
 1175 0324 85E5      		ldi r24,lo8(85)
 1176 0326 95E5      		ldi r25,lo8(85)
 1177 0328 00D0      		rcall flash_write_bus_cycle
 1178               	.LVL73:
 532:setup.c       **** 	flash_write_bus_cycle(0x0000, bank);
 1179               		.loc 1 532 0
 1180 032a 6C2F      		mov r22,r28
 1181 032c 80E0      		ldi r24,0
 1182 032e 90E0      		ldi r25,0
 1183               	/* epilogue start */
 533:setup.c       **** }
 1184               		.loc 1 533 0
 1185 0330 CF91      		pop r28
 1186               	.LVL74:
 532:setup.c       **** 	flash_write_bus_cycle(0x0000, bank);
 1187               		.loc 1 532 0
 1188 0332 00C0      		rjmp flash_write_bus_cycle
 1189               	.LVL75:
 1190               		.cfi_endproc
 1191               	.LFE30:
 1193               	.global	flash_erase_4k_sector
 1195               	flash_erase_4k_sector:
 1196               	.LFB31:
 534:setup.c       **** 
 535:setup.c       **** // Erase 4K sector on Flash, expects first sector to start at 0, left shifts by 12 (A15-A12 to sele
 536:setup.c       **** // Takes 25ms after last command to erase sector
 537:setup.c       **** void flash_erase_4k_sector(uint8_t sector) {
 1197               		.loc 1 537 0
 1198               		.cfi_startproc
 1199               	.LVL76:
 1200 0334 CF93      		push r28
 1201               	.LCFI21:
 1202               		.cfi_def_cfa_offset 3
 1203               		.cfi_offset 28, -2
 1204               	/* prologue: function */
 1205               	/* frame size = 0 */
 1206               	/* stack size = 1 */
 1207               	.L__stack_usage = 1
 1208 0336 C82F      		mov r28,r24
 538:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xAA);
 1209               		.loc 1 538 0
 1210 0338 6AEA      		ldi r22,lo8(-86)
 1211 033a 85E5      		ldi r24,lo8(85)
 1212 033c 95E5      		ldi r25,lo8(85)
 1213               	.LVL77:
 1214 033e 00D0      		rcall flash_write_bus_cycle
 1215               	.LVL78:
 539:setup.c       **** 	flash_write_bus_cycle(0x2AAA, 0x55);
 1216               		.loc 1 539 0
 1217 0340 65E5      		ldi r22,lo8(85)
 1218 0342 8AEA      		ldi r24,lo8(-86)
 1219 0344 9AE2      		ldi r25,lo8(42)
 1220 0346 00D0      		rcall flash_write_bus_cycle
 1221               	.LVL79:
 540:setup.c       **** 	flash_write_bus_cycle(0x5555, 0x80);
 1222               		.loc 1 540 0
 1223 0348 60E8      		ldi r22,lo8(-128)
 1224 034a 85E5      		ldi r24,lo8(85)
 1225 034c 95E5      		ldi r25,lo8(85)
 1226 034e 00D0      		rcall flash_write_bus_cycle
 1227               	.LVL80:
 541:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xAA);
 1228               		.loc 1 541 0
 1229 0350 6AEA      		ldi r22,lo8(-86)
 1230 0352 85E5      		ldi r24,lo8(85)
 1231 0354 95E5      		ldi r25,lo8(85)
 1232 0356 00D0      		rcall flash_write_bus_cycle
 1233               	.LVL81:
 542:setup.c       **** 	flash_write_bus_cycle(0x2AAA, 0x55);
 1234               		.loc 1 542 0
 1235 0358 65E5      		ldi r22,lo8(85)
 1236 035a 8AEA      		ldi r24,lo8(-86)
 1237 035c 9AE2      		ldi r25,lo8(42)
 1238 035e 00D0      		rcall flash_write_bus_cycle
 1239               	.LVL82:
 543:setup.c       **** 	
 544:setup.c       **** 	flash_write_bus_cycle((uint16_t) sector << 12, 0x30);
 1240               		.loc 1 544 0
 1241 0360 60E3      		ldi r22,lo8(48)
 1242 0362 80E0      		ldi r24,0
 1243 0364 9C2F      		mov r25,r28
 1244 0366 9295      		swap r25
 1245 0368 907F      		andi r25,lo8(-16)
 1246 036a 00D0      		rcall flash_write_bus_cycle
 1247               	.LVL83:
 1248               	.LBB50:
 1249               	.LBB51:
 1250               		.loc 2 163 0
 1251 036c 8FE4      		ldi r24,lo8(-15537)
 1252 036e 93EC      		ldi r25,hi8(-15537)
 1253 0370 0197      		1: sbiw r24,1
 1254 0372 01F4      		brne 1b
 1255 0374 00C0      		rjmp .
 1256 0376 0000      		nop
 1257               	/* epilogue start */
 1258               	.LBE51:
 1259               	.LBE50:
 545:setup.c       **** 	_delay_ms(25); // Wait 25ms for sector erase
 546:setup.c       **** }
 1260               		.loc 1 546 0
 1261 0378 CF91      		pop r28
 1262               	.LVL84:
 1263 037a 0895      		ret
 1264               		.cfi_endproc
 1265               	.LFE31:
 1267               	.global	flash_write_byte
 1269               	flash_write_byte:
 1270               	.LFB32:
 547:setup.c       **** 
 548:setup.c       **** // Write a single byte to the Flash address
 549:setup.c       **** // Takes 20us to program Flash
 550:setup.c       **** void flash_write_byte(uint16_t address, uint8_t data) {
 1271               		.loc 1 550 0
 1272               		.cfi_startproc
 1273               	.LVL85:
 1274 037c 1F93      		push r17
 1275               	.LCFI22:
 1276               		.cfi_def_cfa_offset 3
 1277               		.cfi_offset 17, -2
 1278 037e CF93      		push r28
 1279               	.LCFI23:
 1280               		.cfi_def_cfa_offset 4
 1281               		.cfi_offset 28, -3
 1282 0380 DF93      		push r29
 1283               	.LCFI24:
 1284               		.cfi_def_cfa_offset 5
 1285               		.cfi_offset 29, -4
 1286               	/* prologue: function */
 1287               	/* frame size = 0 */
 1288               	/* stack size = 3 */
 1289               	.L__stack_usage = 3
 1290 0382 EC01      		movw r28,r24
 1291 0384 162F      		mov r17,r22
 551:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xAA);
 1292               		.loc 1 551 0
 1293 0386 6AEA      		ldi r22,lo8(-86)
 1294               	.LVL86:
 1295 0388 85E5      		ldi r24,lo8(85)
 1296 038a 95E5      		ldi r25,lo8(85)
 1297               	.LVL87:
 1298 038c 00D0      		rcall flash_write_bus_cycle
 1299               	.LVL88:
 552:setup.c       **** 	flash_write_bus_cycle(0x2AAA, 0x55);
 1300               		.loc 1 552 0
 1301 038e 65E5      		ldi r22,lo8(85)
 1302 0390 8AEA      		ldi r24,lo8(-86)
 1303 0392 9AE2      		ldi r25,lo8(42)
 1304 0394 00D0      		rcall flash_write_bus_cycle
 1305               	.LVL89:
 553:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xA0);
 1306               		.loc 1 553 0
 1307 0396 60EA      		ldi r22,lo8(-96)
 1308 0398 85E5      		ldi r24,lo8(85)
 1309 039a 95E5      		ldi r25,lo8(85)
 1310 039c 00D0      		rcall flash_write_bus_cycle
 1311               	.LVL90:
 554:setup.c       **** 	
 555:setup.c       **** 	flash_write_bus_cycle(address, data);
 1312               		.loc 1 555 0
 1313 039e 612F      		mov r22,r17
 1314 03a0 CE01      		movw r24,r28
 1315 03a2 00D0      		rcall flash_write_bus_cycle
 1316               	.LVL91:
 1317               	.LBB52:
 1318               	.LBB53:
 164:c:\winavr-20100110\avr\include\util\delay.h **** 
 165:c:\winavr-20100110\avr\include\util\delay.h **** #else
 166:c:\winavr-20100110\avr\include\util\delay.h **** 	uint16_t __ticks;
 167:c:\winavr-20100110\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 4e3) * __ms;
 168:c:\winavr-20100110\avr\include\util\delay.h **** 	if (__tmp < 1.0)
 169:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks = 1;
 170:c:\winavr-20100110\avr\include\util\delay.h **** 	else if (__tmp > 65535)
 171:c:\winavr-20100110\avr\include\util\delay.h **** 	{
 172:c:\winavr-20100110\avr\include\util\delay.h **** 		//	__ticks = requested delay in 1/10 ms
 173:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 174:c:\winavr-20100110\avr\include\util\delay.h **** 		while(__ticks)
 175:c:\winavr-20100110\avr\include\util\delay.h **** 		{
 176:c:\winavr-20100110\avr\include\util\delay.h **** 			// wait 1/10 ms
 177:c:\winavr-20100110\avr\include\util\delay.h **** 			_delay_loop_2(((F_CPU) / 4e3) / 10);
 178:c:\winavr-20100110\avr\include\util\delay.h **** 			__ticks --;
 179:c:\winavr-20100110\avr\include\util\delay.h **** 		}
 180:c:\winavr-20100110\avr\include\util\delay.h **** 		return;
 181:c:\winavr-20100110\avr\include\util\delay.h **** 	}
 182:c:\winavr-20100110\avr\include\util\delay.h **** 	else
 183:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks = (uint16_t)__tmp;
 184:c:\winavr-20100110\avr\include\util\delay.h **** 	_delay_loop_2(__ticks);
 185:c:\winavr-20100110\avr\include\util\delay.h **** #endif
 186:c:\winavr-20100110\avr\include\util\delay.h **** }
 187:c:\winavr-20100110\avr\include\util\delay.h **** 
 188:c:\winavr-20100110\avr\include\util\delay.h **** /**
 189:c:\winavr-20100110\avr\include\util\delay.h ****    \ingroup util_delay
 190:c:\winavr-20100110\avr\include\util\delay.h **** 
 191:c:\winavr-20100110\avr\include\util\delay.h ****    Perform a delay of \c __us microseconds, using _delay_loop_1().
 192:c:\winavr-20100110\avr\include\util\delay.h **** 
 193:c:\winavr-20100110\avr\include\util\delay.h ****    The macro F_CPU is supposed to be defined to a
 194:c:\winavr-20100110\avr\include\util\delay.h ****    constant defining the CPU clock frequency (in Hertz).
 195:c:\winavr-20100110\avr\include\util\delay.h **** 
 196:c:\winavr-20100110\avr\include\util\delay.h ****    The maximal possible delay is 768 us / F_CPU in MHz.
 197:c:\winavr-20100110\avr\include\util\delay.h **** 
 198:c:\winavr-20100110\avr\include\util\delay.h ****    If the user requests a delay greater than the maximal possible one,
 199:c:\winavr-20100110\avr\include\util\delay.h ****    _delay_us() will automatically call _delay_ms() instead.  The user
 200:c:\winavr-20100110\avr\include\util\delay.h ****    will not be informed about this case.
 201:c:\winavr-20100110\avr\include\util\delay.h **** 
 202:c:\winavr-20100110\avr\include\util\delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 203:c:\winavr-20100110\avr\include\util\delay.h ****    support, maximal possible delay is 4294967.295 us/ F_CPU in MHz. For
 204:c:\winavr-20100110\avr\include\util\delay.h ****    values greater than the maximal possible delay, overflow results in
 205:c:\winavr-20100110\avr\include\util\delay.h ****    no delay i.e., 0us.
 206:c:\winavr-20100110\avr\include\util\delay.h ****   
 207:c:\winavr-20100110\avr\include\util\delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 208:c:\winavr-20100110\avr\include\util\delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 209:c:\winavr-20100110\avr\include\util\delay.h ****    the user gets atleast __us microseconds of delay.
 210:c:\winavr-20100110\avr\include\util\delay.h **** 
 211:c:\winavr-20100110\avr\include\util\delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 212:c:\winavr-20100110\avr\include\util\delay.h ****    to round down and round to closest integer.
 213:c:\winavr-20100110\avr\include\util\delay.h ****  
 214:c:\winavr-20100110\avr\include\util\delay.h ****    Note: The new implementation of _delay_us(double __us) with 
 215:c:\winavr-20100110\avr\include\util\delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible.
 216:c:\winavr-20100110\avr\include\util\delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 217:c:\winavr-20100110\avr\include\util\delay.h ****    Also, the backward compatible
 218:c:\winavr-20100110\avr\include\util\delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 219:c:\winavr-20100110\avr\include\util\delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 220:c:\winavr-20100110\avr\include\util\delay.h ****    required for rounding are not available to the compiler then.
 221:c:\winavr-20100110\avr\include\util\delay.h **** 
 222:c:\winavr-20100110\avr\include\util\delay.h ****  */
 223:c:\winavr-20100110\avr\include\util\delay.h **** void
 224:c:\winavr-20100110\avr\include\util\delay.h **** _delay_us(double __us)
 225:c:\winavr-20100110\avr\include\util\delay.h **** {
 226:c:\winavr-20100110\avr\include\util\delay.h **** 	double __tmp ; 
 227:c:\winavr-20100110\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 228:c:\winavr-20100110\avr\include\util\delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 229:c:\winavr-20100110\avr\include\util\delay.h ****   __STDC_HOSTED__
 230:c:\winavr-20100110\avr\include\util\delay.h **** 	uint32_t __ticks_dc;
 231:c:\winavr-20100110\avr\include\util\delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 232:c:\winavr-20100110\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 233:c:\winavr-20100110\avr\include\util\delay.h **** 
 234:c:\winavr-20100110\avr\include\util\delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 235:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 236:c:\winavr-20100110\avr\include\util\delay.h **** 
 237:c:\winavr-20100110\avr\include\util\delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 238:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 239:c:\winavr-20100110\avr\include\util\delay.h **** 
 240:c:\winavr-20100110\avr\include\util\delay.h **** 	#else
 241:c:\winavr-20100110\avr\include\util\delay.h **** 		//round up by default
 242:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 243:c:\winavr-20100110\avr\include\util\delay.h **** 	#endif
 244:c:\winavr-20100110\avr\include\util\delay.h **** 
 245:c:\winavr-20100110\avr\include\util\delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 1319               		.loc 2 245 0
 1320 03a4 85E3      		ldi r24,lo8(53)
 1321 03a6 8A95      		1: dec r24
 1322 03a8 01F4      		brne 1b
 1323 03aa 0000      		nop
 1324               	/* epilogue start */
 1325               	.LBE53:
 1326               	.LBE52:
 556:setup.c       **** 	_delay_us(20); // Wait byte program time
 557:setup.c       **** }
 1327               		.loc 1 557 0
 1328 03ac DF91      		pop r29
 1329 03ae CF91      		pop r28
 1330               	.LVL92:
 1331 03b0 1F91      		pop r17
 1332               	.LVL93:
 1333 03b2 0895      		ret
 1334               		.cfi_endproc
 1335               	.LFE32:
 1337               	.global	flash_write_sector
 1339               	flash_write_sector:
 1340               	.LFB33:
 558:setup.c       **** 
 559:setup.c       **** // Write a sector (128 bytes) to the Atmel flash
 560:setup.c       **** // Takes 20ms for write cycle
 561:setup.c       **** void flash_write_sector(uint16_t sector) {
 1341               		.loc 1 561 0
 1342               		.cfi_startproc
 1343               	.LVL94:
 1344 03b4 EF92      		push r14
 1345               	.LCFI25:
 1346               		.cfi_def_cfa_offset 3
 1347               		.cfi_offset 14, -2
 1348 03b6 FF92      		push r15
 1349               	.LCFI26:
 1350               		.cfi_def_cfa_offset 4
 1351               		.cfi_offset 15, -3
 1352 03b8 0F93      		push r16
 1353               	.LCFI27:
 1354               		.cfi_def_cfa_offset 5
 1355               		.cfi_offset 16, -4
 1356 03ba 1F93      		push r17
 1357               	.LCFI28:
 1358               		.cfi_def_cfa_offset 6
 1359               		.cfi_offset 17, -5
 1360 03bc CF93      		push r28
 1361               	.LCFI29:
 1362               		.cfi_def_cfa_offset 7
 1363               		.cfi_offset 28, -6
 1364 03be DF93      		push r29
 1365               	.LCFI30:
 1366               		.cfi_def_cfa_offset 8
 1367               		.cfi_offset 29, -7
 1368               	/* prologue: function */
 1369               	/* frame size = 0 */
 1370               	/* stack size = 6 */
 1371               	.L__stack_usage = 6
 1372 03c0 8C01      		movw r16,r24
 562:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xAA);
 1373               		.loc 1 562 0
 1374 03c2 6AEA      		ldi r22,lo8(-86)
 1375 03c4 85E5      		ldi r24,lo8(85)
 1376 03c6 95E5      		ldi r25,lo8(85)
 1377               	.LVL95:
 1378 03c8 00D0      		rcall flash_write_bus_cycle
 1379               	.LVL96:
 563:setup.c       **** 	flash_write_bus_cycle(0x2AAA, 0x55);
 1380               		.loc 1 563 0
 1381 03ca 65E5      		ldi r22,lo8(85)
 1382 03cc 8AEA      		ldi r24,lo8(-86)
 1383 03ce 9AE2      		ldi r25,lo8(42)
 1384 03d0 00D0      		rcall flash_write_bus_cycle
 1385               	.LVL97:
 564:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xA0);
 1386               		.loc 1 564 0
 1387 03d2 60EA      		ldi r22,lo8(-96)
 1388 03d4 85E5      		ldi r24,lo8(85)
 1389 03d6 95E5      		ldi r25,lo8(85)
 1390 03d8 00D0      		rcall flash_write_bus_cycle
 1391               	.LVL98:
 1392               	.LBB54:
 565:setup.c       **** 	
 566:setup.c       **** 	// Write the bytes (A0-A6 byte address, A7-A15 sector address)
 567:setup.c       **** 	for (uint8_t x = 0; x < 128; x++) {
 568:setup.c       **** 		flash_write_bus_cycle((uint16_t) (sector << 7) | (uint16_t) x, receivedBuffer[x]);
 1393               		.loc 1 568 0
 1394 03da 1695      		lsr r17
 1395 03dc 102F      		mov r17,r16
 1396 03de 0027      		clr r16
 1397 03e0 1795      		ror r17
 1398 03e2 0795      		ror r16
 1399               	.LVL99:
 1400 03e4 50E0      		ldi r21,lo8(receivedBuffer)
 1401 03e6 E52E      		mov r14,r21
 1402 03e8 50E0      		ldi r21,hi8(receivedBuffer)
 1403 03ea F52E      		mov r15,r21
 1404 03ec C0E0      		ldi r28,0
 1405 03ee D0E0      		ldi r29,0
 1406               	.LVL100:
 1407               	.L65:
 1408               		.loc 1 568 0 is_stmt 0 discriminator 2
 1409 03f0 F701      		movw r30,r14
 1410 03f2 6191      		ld r22,Z+
 1411 03f4 7F01      		movw r14,r30
 1412 03f6 CE01      		movw r24,r28
 1413 03f8 802B      		or r24,r16
 1414 03fa 912B      		or r25,r17
 1415 03fc 00D0      		rcall flash_write_bus_cycle
 1416               	.LVL101:
 1417 03fe 2196      		adiw r28,1
 1418               	.LVL102:
 567:setup.c       **** 		flash_write_bus_cycle((uint16_t) (sector << 7) | (uint16_t) x, receivedBuffer[x]);
 1419               		.loc 1 567 0 is_stmt 1 discriminator 2
 1420 0400 C038      		cpi r28,-128
 1421 0402 D105      		cpc r29,__zero_reg__
 1422 0404 01F4      		brne .L65
 1423               	.LVL103:
 1424               	.LBE54:
 1425               	.LBB55:
 1426               	.LBB56:
 163:c:\winavr-20100110\avr\include\util\delay.h **** 
 1427               		.loc 2 163 0
 1428 0406 8FE3      		ldi r24,lo8(-25537)
 1429 0408 9CE9      		ldi r25,hi8(-25537)
 1430 040a 0197      		1: sbiw r24,1
 1431 040c 01F4      		brne 1b
 1432 040e 00C0      		rjmp .
 1433 0410 0000      		nop
 1434               	/* epilogue start */
 1435               	.LBE56:
 1436               	.LBE55:
 569:setup.c       **** 	}
 570:setup.c       **** 	_delay_ms(20); // Wait sector program time
 571:setup.c       **** }
 1437               		.loc 1 571 0
 1438 0412 DF91      		pop r29
 1439 0414 CF91      		pop r28
 1440               	.LVL104:
 1441 0416 1F91      		pop r17
 1442 0418 0F91      		pop r16
 1443 041a FF90      		pop r15
 1444 041c EF90      		pop r14
 1445 041e 0895      		ret
 1446               		.cfi_endproc
 1447               	.LFE33:
 1449               	.global	setup
 1451               	setup:
 1452               	.LFB34:
 572:setup.c       **** 
 573:setup.c       **** // Setup
 574:setup.c       **** void setup(void) {
 1453               		.loc 1 574 0
 1454               		.cfi_startproc
 1455               	/* prologue: function */
 1456               	/* frame size = 0 */
 1457               	/* stack size = 0 */
 1458               	.L__stack_usage = 0
 575:setup.c       **** 	// Reset common lines
 576:setup.c       **** 	rd_wr_csmreq_cs2_reset();
 1459               		.loc 1 576 0
 1460 0420 00D0      		rcall rd_wr_csmreq_cs2_reset
 1461               	.LVL105:
 577:setup.c       **** 	
 578:setup.c       **** 	// Set outputs
 579:setup.c       **** 	DDRD |= (1<<ACTIVITY_LED) | (1<<WR_PIN) | (1<<RD_PIN) | (1<<CS_MREQ_PIN) | (1<<LED_5V);
 1462               		.loc 1 579 0
 1463 0422 81B3      		in r24,0x11
 1464 0424 886F      		ori r24,lo8(-8)
 1465 0426 81BB      		out 0x11,r24
 580:setup.c       **** 	DDRE |= (1<<CS2_PIN) | (1<<LED_3V);
 1466               		.loc 1 580 0
 1467 0428 86B1      		in r24,0x6
 1468 042a 8560      		ori r24,lo8(5)
 1469 042c 86B9      		out 0x6,r24
 581:setup.c       **** 	
 582:setup.c       **** 	// Set all pins as inputs
 583:setup.c       **** 	PORT_DATA7_0 = 0;
 1470               		.loc 1 583 0
 1471 042e 15BA      		out 0x15,__zero_reg__
 584:setup.c       **** 	DDR_DATA7_0 = 0;
 1472               		.loc 1 584 0
 1473 0430 14BA      		out 0x14,__zero_reg__
 585:setup.c       **** 	PORT_ADDR7_0 = 0;
 1474               		.loc 1 585 0
 1475 0432 18BA      		out 0x18,__zero_reg__
 586:setup.c       **** 	DDR_ADDR7_0 = 0;
 1476               		.loc 1 586 0
 1477 0434 17BA      		out 0x17,__zero_reg__
 587:setup.c       **** 	PORT_ADDR15_8 = 0;
 1478               		.loc 1 587 0
 1479 0436 1BBA      		out 0x1b,__zero_reg__
 588:setup.c       **** 	DDR_ADDR15_8 = 0;
 1480               		.loc 1 588 0
 1481 0438 1ABA      		out 0x1a,__zero_reg__
 589:setup.c       **** 	
 590:setup.c       **** 	// Light up 3.3V or 5V
 591:setup.c       **** 	if (PIND & (1<<SWITCH_DETECT)) {
 1482               		.loc 1 591 0
 1483 043a 829B      		sbis 0x10,2
 1484 043c 00C0      		rjmp .L68
 592:setup.c       **** 		PORTD |= (1<<LED_5V);
 1485               		.loc 1 592 0
 1486 043e 979A      		sbi 0x12,7
 593:setup.c       **** 		PORTE &= ~(1<<LED_3V);
 1487               		.loc 1 593 0
 1488 0440 3898      		cbi 0x7,0
 1489 0442 00C0      		rjmp .L69
 1490               	.L68:
 594:setup.c       **** 	}
 595:setup.c       **** 	else {
 596:setup.c       **** 		PORTE |= (1<<LED_3V);
 1491               		.loc 1 596 0
 1492 0444 389A      		sbi 0x7,0
 597:setup.c       **** 		PORTD &= ~(1<<LED_5V);
 1493               		.loc 1 597 0
 1494 0446 9798      		cbi 0x12,7
 1495               	.L69:
 598:setup.c       **** 	}
 599:setup.c       **** 	
 600:setup.c       **** 	// Light LED
 601:setup.c       **** 	PORTD |= (1<<ACTIVITY_LED);
 1496               		.loc 1 601 0
 1497 0448 939A      		sbi 0x12,3
 1498               	.LVL106:
 1499               	.LBB57:
 1500               	.LBB58:
 163:c:\winavr-20100110\avr\include\util\delay.h **** 
 1501               		.loc 2 163 0
 1502 044a 2FEF      		ldi r18,lo8(799999)
 1503 044c 84E3      		ldi r24,hi8(799999)
 1504 044e 9CE0      		ldi r25,hlo8(799999)
 1505 0450 2150      		1: subi r18,1
 1506 0452 8040      		sbci r24,0
 1507 0454 9040      		sbci r25,0
 1508 0456 01F4      		brne 1b
 1509 0458 00C0      		rjmp .
 1510 045a 0000      		nop
 1511               	.LBE58:
 1512               	.LBE57:
 602:setup.c       **** 	_delay_ms(500);
 603:setup.c       **** 	PORTD &= ~(1<<ACTIVITY_LED);
 1513               		.loc 1 603 0
 1514 045c 9398      		cbi 0x12,3
 604:setup.c       **** 	
 605:setup.c       **** 	// Setup USART
 606:setup.c       **** 	UBRRL = 0; // 1Mbps Baud rate
 1515               		.loc 1 606 0
 1516 045e 19B8      		out 0x9,__zero_reg__
 607:setup.c       **** 	sbi(UCSRA, U2X); // Double rate
 1517               		.loc 1 607 0
 1518 0460 599A      		sbi 0xb,1
 608:setup.c       **** 	sbi(UCSRB, TXEN); // Transmitter enable
 1519               		.loc 1 608 0
 1520 0462 539A      		sbi 0xa,3
 609:setup.c       **** 	sbi(UCSRB, RXEN); // Receiver enable
 1521               		.loc 1 609 0
 1522 0464 549A      		sbi 0xa,4
 610:setup.c       **** 	
 611:setup.c       **** 	// Turn on interrupts
 612:setup.c       **** 	sei();
 1523               		.loc 1 612 0
 1524               	/* #APP */
 1525               	 ;  612 "setup.c" 1
 1526 0466 7894      		sei
 1527               	 ;  0 "" 2
 1528               	/* #NOAPP */
 1529 0468 0895      		ret
 1530               		.cfi_endproc
 1531               	.LFE34:
 1533               		.section	.text.startup,"ax",@progbits
 1534               	.global	main
 1536               	main:
 1537               	.LFB35:
 1538               		.file 3 "main.c"
   1:main.c        **** /*
   2:main.c        ****  GBxCart RW
   3:main.c        ****  PCB version: 1.1
   4:main.c        ****  Firmware version: R2
   5:main.c        ****  Author: Alex from insideGadgets (www.insidegadgets.com)
   6:main.c        ****  Created: 7/11/2016
   7:main.c        ****  Last Modified: 8/05/2017
   8:main.c        ****  
   9:main.c        ****  GBxCart RW allows you to dump your Gameboy/Gameboy Colour/Gameboy Advance games ROM, save the RAM 
  10:main.c        ****  
  11:main.c        ****  The ATmega8515L talks to the cartridge and interfaces with the CH340G serial to USB converter with
  12:main.c        ****  
  13:main.c        ****  Remember to change your fuse bits so the ATmega8515L uses an external 8MHz crystal, divide clock b
  14:main.c        ****  avrdude -c usbasp -p atmega8515 -U lfuse:w:0xef:m -U hfuse:w:0xd9:m
  15:main.c        ****  
  16:main.c        ****  */
  17:main.c        **** 
  18:main.c        **** // ATmega8515L Pin Map
  19:main.c        **** //
  20:main.c        **** // VCC (5)			GND (6)			XTAL (7 ,8)		Activity LED PD3 (9)				Switch sense PD2 (8)
  21:main.c        **** // SCK PB7 (3)		MOSI PB5 (1)	MISO PB6 (2)	RST (4)		RXD PD0 (5)			TXD PD1 (7)
  22:main.c        **** // 
  23:main.c        **** // Gameboy / Gameboy Colour
  24:main.c        **** // A0-A7 PB0-7 (40-44, 1-3) 		A8-A15 PA0-7 (37-30)			D0-D7 PC0-7 (18-25)
  25:main.c        **** // 
  26:main.c        **** // Gameboy Advance
  27:main.c        **** // AD0-AD7 PB0-7 (40-44, 1-3) 	AD8-AD15 PA0-7 (37-30)		A16-23 / D0-D7 PC0-7 (19-26)
  28:main.c        **** // *WR PD6 (13)						*RD PD5 (14)					*MREQ/CS PD4 (15)			CS2/RST PE2 (16)
  29:main.c        **** 
  30:main.c        **** #define F_CPU 8000000 // 8 MHz
  31:main.c        **** #define PCB_VERSION 2
  32:main.c        **** #define FIRMWARE_VERSION 2
  33:main.c        **** 
  34:main.c        **** #include <avr/io.h>
  35:main.c        **** #include <avr/wdt.h>
  36:main.c        **** #include <avr/eeprom.h>
  37:main.c        **** #include <avr/interrupt.h>
  38:main.c        **** #include <avr/sleep.h>
  39:main.c        **** #include <util/delay.h>
  40:main.c        **** #include <stdlib.h>
  41:main.c        **** #include <string.h>
  42:main.c        **** #include "setup.c" // See defines, variables, constants, functions here
  43:main.c        **** 
  44:main.c        **** 
  45:main.c        **** int main(void) {
 1539               		.loc 3 45 0
 1540               		.cfi_startproc
 1541 0000 CF93      		push r28
 1542               	.LCFI31:
 1543               		.cfi_def_cfa_offset 3
 1544               		.cfi_offset 28, -2
 1545 0002 DF93      		push r29
 1546               	.LCFI32:
 1547               		.cfi_def_cfa_offset 4
 1548               		.cfi_offset 29, -3
 1549 0004 1F92      		push __zero_reg__
 1550               	.LCFI33:
 1551               		.cfi_def_cfa_offset 5
 1552 0006 CDB7      		in r28,__SP_L__
 1553 0008 DEB7      		in r29,__SP_H__
 1554               	.LCFI34:
 1555               		.cfi_def_cfa_register 28
 1556               	/* prologue: function */
 1557               	/* frame size = 1 */
 1558               	/* stack size = 3 */
 1559               	.L__stack_usage = 3
  46:main.c        **** 	setup();
 1560               		.loc 3 46 0
 1561 000a 00D0      		rcall setup
 1562               	.LVL107:
  47:main.c        **** 	
  48:main.c        **** 	uint32_t address = 0;
  49:main.c        **** 	uint8_t eepromSize = EEPROM_4KBIT;
  50:main.c        **** 	uint8_t cartMode = GB_MODE;
  51:main.c        **** 	uint8_t resetCommonLines = 1;
 1563               		.loc 3 51 0
 1564 000c 6624      		clr r6
 1565 000e 6394      		inc r6
  49:main.c        **** 	uint8_t cartMode = GB_MODE;
 1566               		.loc 3 49 0
 1567 0010 7724      		clr r7
 1568 0012 7394      		inc r7
  48:main.c        **** 	uint8_t eepromSize = EEPROM_4KBIT;
 1569               		.loc 3 48 0
 1570 0014 C12C      		mov r12,__zero_reg__
 1571 0016 D12C      		mov r13,__zero_reg__
 1572 0018 7601      		movw r14,r12
 1573               	.LVL108:
 1574               	.L71:
  52:main.c        **** 	
  53:main.c        **** 	while(1) {
  54:main.c        **** 		if (resetCommonLines == 1) {
 1575               		.loc 3 54 0
 1576 001a 81E0      		ldi r24,lo8(1)
 1577 001c 6812      		cpse r6,r24
 1578 001e 00C0      		rjmp .L72
 1579               	.LVL109:
 1580               	.L156:
  55:main.c        **** 			rd_wr_csmreq_cs2_reset();
 1581               		.loc 3 55 0
 1582 0020 00D0      		rcall rd_wr_csmreq_cs2_reset
 1583               	.LVL110:
 1584               	.L72:
  56:main.c        **** 		}
  57:main.c        **** 		receivedChar = USART_Receive(); // Wait for 1 byte of data
 1585               		.loc 3 57 0
 1586 0022 00D0      		rcall USART_Receive
 1587               	.LVL111:
 1588 0024 8093 0000 		sts receivedChar,r24
  58:main.c        **** 		
  59:main.c        **** 		// Read the pin to find out which mode we are in, if high (3.3V), we are powered by 5V
  60:main.c        **** 		if (PIND & (1<<SWITCH_DETECT)) {
 1589               		.loc 3 60 0
 1590 0028 829B      		sbis 0x10,2
 1591 002a 00C0      		rjmp .L73
 1592               	.LVL112:
  61:main.c        **** 			cartMode = GB_MODE;
  62:main.c        **** 			PORTD |= (1<<LED_5V);
 1593               		.loc 3 62 0
 1594 002c 979A      		sbi 0x12,7
  63:main.c        **** 			PORTE &= ~(1<<LED_3V);
 1595               		.loc 3 63 0
 1596 002e 3898      		cbi 0x7,0
  61:main.c        **** 			cartMode = GB_MODE;
 1597               		.loc 3 61 0
 1598 0030 81E0      		ldi r24,lo8(1)
 1599 0032 00C0      		rjmp .L74
 1600               	.LVL113:
 1601               	.L73:
  64:main.c        **** 		}
  65:main.c        **** 		else {
  66:main.c        **** 			cartMode = GBA_MODE;
  67:main.c        **** 			PORTE |= (1<<LED_3V);
 1602               		.loc 3 67 0
 1603 0034 389A      		sbi 0x7,0
  68:main.c        **** 			PORTD &= ~(1<<LED_5V);
 1604               		.loc 3 68 0
 1605 0036 9798      		cbi 0x12,7
  66:main.c        **** 			PORTE |= (1<<LED_3V);
 1606               		.loc 3 66 0
 1607 0038 82E0      		ldi r24,lo8(2)
 1608               	.LVL114:
 1609               	.L74:
  69:main.c        **** 		}
  70:main.c        **** 		
  71:main.c        **** 		// Return the cart mode in use
  72:main.c        **** 		if (receivedChar == CART_MODE) {
 1610               		.loc 3 72 0
 1611 003a 9091 0000 		lds r25,receivedChar
 1612 003e 9334      		cpi r25,lo8(67)
 1613 0040 01F4      		brne .+2
 1614 0042 00C0      		rjmp .L162
  73:main.c        **** 			USART_Transmit(cartMode);
  74:main.c        **** 		}
  75:main.c        **** 		
  76:main.c        **** 		// Change to GB mode or GBA mode if requested
  77:main.c        **** 		else if (receivedChar == GB_CART_MODE) {
 1615               		.loc 3 77 0
 1616 0044 9734      		cpi r25,lo8(71)
 1617 0046 01F4      		brne .L77
  78:main.c        **** 			gb_mode();
 1618               		.loc 3 78 0
 1619 0048 00D0      		rcall gb_mode
 1620               	.LVL115:
 1621 004a 00C0      		rjmp .L76
 1622               	.LVL116:
 1623               	.L77:
  79:main.c        **** 		}
  80:main.c        **** 		else if (receivedChar == GBA_CART_MODE) {
 1624               		.loc 3 80 0
 1625 004c 9736      		cpi r25,lo8(103)
 1626 004e 01F4      		brne .+2
 1627 0050 00C0      		rjmp .L164
  81:main.c        **** 			gba_mode();
  82:main.c        **** 		}
  83:main.c        **** 		
  84:main.c        **** 		// Set address
  85:main.c        **** 		else if (receivedChar == SET_START_ADDRESS) {
 1628               		.loc 3 85 0
 1629 0052 9134      		cpi r25,lo8(65)
 1630 0054 01F4      		brne .L79
  86:main.c        **** 			usart_read_chars(); // Read start address
 1631               		.loc 3 86 0
 1632 0056 00D0      		rcall usart_read_chars
 1633               	.LVL117:
  87:main.c        **** 			address = strtol(receivedBuffer, NULL, 16); // Convert address string in hex to dec
 1634               		.loc 3 87 0
 1635 0058 40E1      		ldi r20,lo8(16)
 1636 005a 50E0      		ldi r21,0
 1637 005c 60E0      		ldi r22,0
 1638 005e 70E0      		ldi r23,0
 1639 0060 80E0      		ldi r24,lo8(receivedBuffer)
 1640 0062 90E0      		ldi r25,hi8(receivedBuffer)
 1641 0064 00D0      		rcall strtol
 1642               	.LVL118:
 1643 0066 6B01      		movw r12,r22
 1644 0068 7C01      		movw r14,r24
 1645               	.LVL119:
 1646 006a 00C0      		rjmp .L76
 1647               	.LVL120:
 1648               	.L79:
  88:main.c        **** 		}
  89:main.c        **** 		
  90:main.c        **** 		
  91:main.c        **** 		// ****** Gameboy / Gameboy Colour ******
  92:main.c        **** 		
  93:main.c        **** 		// Read 64 bytes of ROM/RAM from address (and increment) until anything but 1 is received
  94:main.c        **** 		else if (receivedChar == READ_ROM_RAM) {
 1649               		.loc 3 94 0
 1650 006c 9235      		cpi r25,lo8(82)
 1651 006e 01F4      		brne .L80
  95:main.c        **** 			gb_mode();
 1652               		.loc 3 95 0
 1653 0070 00D0      		rcall gb_mode
 1654               	.LVL121:
  96:main.c        **** 			receivedChar = '1';
 1655               		.loc 3 96 0
 1656 0072 81E3      		ldi r24,lo8(49)
 1657               	.LVL122:
 1658               	.L159:
  97:main.c        **** 			while (receivedChar == '1') {
  98:main.c        **** 				PORTD |= (1<<ACTIVITY_LED);
  99:main.c        **** 				for (uint8_t x = 0; x < 64; x++) {
 100:main.c        **** 					USART_Transmit(read_8bit_data(address));
 101:main.c        **** 					address++;
 102:main.c        **** 				}
 103:main.c        **** 				
 104:main.c        **** 				PORTD &= ~(1<<ACTIVITY_LED);
 105:main.c        **** 				receivedChar = USART_Receive();
 1659               		.loc 3 105 0
 1660 0074 8093 0000 		sts receivedChar,r24
 1661               	.LVL123:
  97:main.c        **** 			while (receivedChar == '1') {
 1662               		.loc 3 97 0
 1663 0078 8091 0000 		lds r24,receivedChar
 1664 007c 8133      		cpi r24,lo8(49)
 1665 007e 01F0      		breq .+2
 1666 0080 00C0      		rjmp .L76
  98:main.c        **** 				for (uint8_t x = 0; x < 64; x++) {
 1667               		.loc 3 98 0
 1668 0082 939A      		sbi 0x12,3
 1669               	.LVL124:
 1670 0084 A12C      		mov r10,__zero_reg__
 1671 0086 B12C      		mov r11,__zero_reg__
 1672               	.LVL125:
 1673               	.L83:
 1674 0088 C501      		movw r24,r10
 1675 008a 8C0D      		add r24,r12
 1676 008c 9D1D      		adc r25,r13
 1677               	.LBB59:
 100:main.c        **** 					address++;
 1678               		.loc 3 100 0 discriminator 2
 1679 008e 00D0      		rcall read_8bit_data
 1680               	.LVL126:
 1681 0090 00D0      		rcall USART_Transmit
 1682               	.LVL127:
 1683 0092 9FEF      		ldi r25,-1
 1684 0094 A91A      		sub r10,r25
 1685 0096 B90A      		sbc r11,r25
 1686               	.LVL128:
  99:main.c        **** 					USART_Transmit(read_8bit_data(address));
 1687               		.loc 3 99 0 discriminator 2
 1688 0098 E0E4      		ldi r30,64
 1689 009a AE16      		cp r10,r30
 1690 009c B104      		cpc r11,__zero_reg__
 1691 009e 01F4      		brne .L83
 1692 00a0 F0E4      		ldi r31,64
 1693 00a2 CF0E      		add r12,r31
 1694 00a4 D11C      		adc r13,__zero_reg__
 1695 00a6 E11C      		adc r14,__zero_reg__
 1696 00a8 F11C      		adc r15,__zero_reg__
 1697               	.LBE59:
 104:main.c        **** 				receivedChar = USART_Receive();
 1698               		.loc 3 104 0
 1699 00aa 9398      		cbi 0x12,3
 1700               		.loc 3 105 0
 1701 00ac 00D0      		rcall USART_Receive
 1702               	.LVL129:
 1703 00ae 00C0      		rjmp .L159
 1704               	.LVL130:
 1705               	.L80:
 106:main.c        **** 			}
 107:main.c        **** 		}
 108:main.c        **** 		
 109:main.c        **** 		// Write 64 bytes to RAM on address (and increment)
 110:main.c        **** 		else if (receivedChar == WRITE_RAM) {
 1706               		.loc 3 110 0
 1707 00b0 9735      		cpi r25,lo8(87)
 1708 00b2 01F4      		brne .L85
 111:main.c        **** 			gb_mode();
 1709               		.loc 3 111 0
 1710 00b4 00D0      		rcall gb_mode
 1711               	.LVL131:
 112:main.c        **** 			
 113:main.c        **** 			// Read 64 bytes first as CH340G sends them all at once
 114:main.c        **** 			usart_read_bytes(64);
 1712               		.loc 3 114 0
 1713 00b6 80E4      		ldi r24,lo8(64)
 1714 00b8 00D0      		rcall usart_read_bytes
 1715               	.LVL132:
 115:main.c        **** 			
 116:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 1716               		.loc 3 116 0
 1717 00ba 939A      		sbi 0x12,3
 1718               	.LVL133:
 1719 00bc 00E0      		ldi r16,lo8(receivedBuffer)
 1720 00be 10E0      		ldi r17,hi8(receivedBuffer)
 1721 00c0 A12C      		mov r10,__zero_reg__
 1722 00c2 B12C      		mov r11,__zero_reg__
 1723               	.LVL134:
 1724               	.L87:
 1725               	.LBB60:
 117:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 118:main.c        **** 				write_8bit_data(address, receivedBuffer[x], MEMORY_WRITE);
 1726               		.loc 3 118 0 discriminator 2
 1727 00c4 F801      		movw r30,r16
 1728 00c6 6191      		ld r22,Z+
 1729 00c8 8F01      		movw r16,r30
 1730 00ca C501      		movw r24,r10
 1731 00cc 8C0D      		add r24,r12
 1732 00ce 9D1D      		adc r25,r13
 1733 00d0 41E0      		ldi r20,lo8(1)
 1734 00d2 00D0      		rcall write_8bit_data
 1735               	.LVL135:
 1736 00d4 FFEF      		ldi r31,-1
 1737 00d6 AF1A      		sub r10,r31
 1738 00d8 BF0A      		sbc r11,r31
 1739               	.LVL136:
 117:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 1740               		.loc 3 117 0 discriminator 2
 1741 00da 80E4      		ldi r24,64
 1742 00dc A816      		cp r10,r24
 1743 00de B104      		cpc r11,__zero_reg__
 1744 00e0 01F4      		brne .L87
 1745 00e2 90E4      		ldi r25,64
 1746 00e4 C90E      		add r12,r25
 1747 00e6 D11C      		adc r13,__zero_reg__
 1748 00e8 E11C      		adc r14,__zero_reg__
 1749 00ea F11C      		adc r15,__zero_reg__
 1750               	.LBE60:
 119:main.c        **** 				address++;
 120:main.c        **** 			}
 121:main.c        **** 			
 122:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 1751               		.loc 3 122 0
 1752 00ec 9398      		cbi 0x12,3
 123:main.c        **** 			USART_Transmit('1'); // Send back acknowledgement
 1753               		.loc 3 123 0
 1754 00ee 81E3      		ldi r24,lo8(49)
 1755               	.LVL137:
 1756               	.L162:
 1757 00f0 00D0      		rcall USART_Transmit
 1758               	.LVL138:
 1759 00f2 00C0      		rjmp .L76
 1760               	.LVL139:
 1761               	.L85:
 124:main.c        **** 		}
 125:main.c        **** 		
 126:main.c        **** 		// Set bank address and write a byte
 127:main.c        **** 		else if (receivedChar == SET_BANK) {
 1762               		.loc 3 127 0
 1763 00f4 9234      		cpi r25,lo8(66)
 1764 00f6 01F4      		brne .L88
 1765               	.LBB61:
 128:main.c        **** 			gb_mode();
 1766               		.loc 3 128 0
 1767 00f8 00D0      		rcall gb_mode
 1768               	.LVL140:
 129:main.c        **** 			
 130:main.c        **** 			usart_read_chars(); // Read start address
 1769               		.loc 3 130 0
 1770 00fa 00D0      		rcall usart_read_chars
 1771               	.LVL141:
 131:main.c        **** 			uint16_t bankaddress = strtol(receivedBuffer, NULL, 16); // Convert address string in hex to dec
 1772               		.loc 3 131 0
 1773 00fc 40E1      		ldi r20,lo8(16)
 1774 00fe 50E0      		ldi r21,0
 1775 0100 60E0      		ldi r22,0
 1776 0102 70E0      		ldi r23,0
 1777 0104 80E0      		ldi r24,lo8(receivedBuffer)
 1778 0106 90E0      		ldi r25,hi8(receivedBuffer)
 1779 0108 00D0      		rcall strtol
 1780               	.LVL142:
 1781 010a 4B01      		movw r8,r22
 1782 010c 5C01      		movw r10,r24
 1783               	.LVL143:
 132:main.c        **** 			
 133:main.c        **** 			receivedChar = USART_Receive(); // Wait for bank number
 1784               		.loc 3 133 0
 1785 010e 00D0      		rcall USART_Receive
 1786               	.LVL144:
 1787 0110 8093 0000 		sts receivedChar,r24
 134:main.c        **** 			if (receivedChar == 'B') {
 1788               		.loc 3 134 0
 1789 0114 8234      		cpi r24,lo8(66)
 1790 0116 01F0      		breq .+2
 1791 0118 00C0      		rjmp .L76
 1792               	.LBB62:
 135:main.c        **** 				usart_read_chars(); // Read data
 1793               		.loc 3 135 0
 1794 011a 00D0      		rcall usart_read_chars
 1795               	.LVL145:
 136:main.c        **** 				uint8_t data = atoi(receivedBuffer); // Convert data string to dec
 1796               		.loc 3 136 0
 1797 011c 80E0      		ldi r24,lo8(receivedBuffer)
 1798 011e 90E0      		ldi r25,hi8(receivedBuffer)
 1799 0120 00D0      		rcall atoi
 1800               	.LVL146:
 137:main.c        **** 				
 138:main.c        **** 				write_8bit_data(bankaddress, data, BANK_WRITE);
 1801               		.loc 3 138 0
 1802 0122 40E0      		ldi r20,0
 1803 0124 682F      		mov r22,r24
 1804 0126 C401      		movw r24,r8
 1805               	.LVL147:
 1806 0128 00D0      		rcall write_8bit_data
 1807               	.LVL148:
 1808 012a 00C0      		rjmp .L76
 1809               	.LVL149:
 1810               	.L88:
 1811               	.LBE62:
 1812               	.LBE61:
 139:main.c        **** 			}
 140:main.c        **** 		}
 141:main.c        **** 		
 142:main.c        **** 		
 143:main.c        **** 		// ****** Gameboy Advance ******
 144:main.c        **** 		
 145:main.c        **** 		// ---------- ROM ----------
 146:main.c        **** 		// Read one 16bit byte from ROM using address (and increment) until anything but 1 is received
 147:main.c        **** 		else if (receivedChar == GBA_READ_ROM) {
 1813               		.loc 3 147 0
 1814 012c 9237      		cpi r25,lo8(114)
 1815 012e 01F4      		brne .L89
 148:main.c        **** 			gba_mode(); 
 1816               		.loc 3 148 0
 1817 0130 00D0      		rcall gba_mode
 1818               	.LVL150:
 149:main.c        **** 			
 150:main.c        **** 			receivedChar = '1';
 1819               		.loc 3 150 0
 1820 0132 81E3      		ldi r24,lo8(49)
 1821               	.LVL151:
 1822               	.L160:
 151:main.c        **** 			while (receivedChar == '1') {
 152:main.c        **** 				PORTD |= (1<<ACTIVITY_LED);
 153:main.c        **** 				for (uint8_t x = 0; x < 32; x++) {
 154:main.c        **** 					uint16_t dataRead = gba_read_16bit_data(address);
 155:main.c        **** 					
 156:main.c        **** 					// Low byte & High byte
 157:main.c        **** 					USART_Transmit(dataRead & 0xFF);
 158:main.c        **** 					USART_Transmit(dataRead >> 8);
 159:main.c        **** 					
 160:main.c        **** 					address++;
 161:main.c        **** 				}
 162:main.c        **** 				
 163:main.c        **** 				PORTD &= ~(1<<ACTIVITY_LED);
 164:main.c        **** 				receivedChar = USART_Receive();
 1823               		.loc 3 164 0
 1824 0134 8093 0000 		sts receivedChar,r24
 1825               	.LVL152:
 151:main.c        **** 			while (receivedChar == '1') {
 1826               		.loc 3 151 0
 1827 0138 8091 0000 		lds r24,receivedChar
 1828 013c 8133      		cpi r24,lo8(49)
 1829 013e 01F0      		breq .+2
 1830 0140 00C0      		rjmp .L76
 152:main.c        **** 				for (uint8_t x = 0; x < 32; x++) {
 1831               		.loc 3 152 0
 1832 0142 939A      		sbi 0x12,3
 1833               	.LVL153:
 1834 0144 4601      		movw r8,r12
 1835 0146 5701      		movw r10,r14
 1836 0148 10E2      		ldi r17,lo8(32)
 1837 014a 1C0D      		add r17,r12
 1838               	.LVL154:
 1839               	.L92:
 1840               	.LBB63:
 1841               	.LBB64:
 154:main.c        **** 					
 1842               		.loc 3 154 0 discriminator 2
 1843 014c C501      		movw r24,r10
 1844 014e B401      		movw r22,r8
 1845 0150 00D0      		rcall gba_read_16bit_data
 1846               	.LVL155:
 157:main.c        **** 					USART_Transmit(dataRead >> 8);
 1847               		.loc 3 157 0 discriminator 2
 1848 0152 9983      		std Y+1,r25
 1849 0154 00D0      		rcall USART_Transmit
 1850               	.LVL156:
 158:main.c        **** 					
 1851               		.loc 3 158 0 discriminator 2
 1852 0156 9981      		ldd r25,Y+1
 1853 0158 892F      		mov r24,r25
 1854 015a 00D0      		rcall USART_Transmit
 1855               	.LVL157:
 160:main.c        **** 				}
 1856               		.loc 3 160 0 discriminator 2
 1857 015c EFEF      		ldi r30,-1
 1858 015e 8E1A      		sub r8,r30
 1859 0160 9E0A      		sbc r9,r30
 1860 0162 AE0A      		sbc r10,r30
 1861 0164 BE0A      		sbc r11,r30
 1862               	.LVL158:
 1863               	.LBE64:
 153:main.c        **** 					uint16_t dataRead = gba_read_16bit_data(address);
 1864               		.loc 3 153 0 discriminator 2
 1865 0166 1811      		cpse r17,r8
 1866 0168 00C0      		rjmp .L92
 1867 016a F0E2      		ldi r31,32
 1868 016c CF0E      		add r12,r31
 1869 016e D11C      		adc r13,__zero_reg__
 1870 0170 E11C      		adc r14,__zero_reg__
 1871 0172 F11C      		adc r15,__zero_reg__
 1872               	.LVL159:
 1873               	.LBE63:
 163:main.c        **** 				receivedChar = USART_Receive();
 1874               		.loc 3 163 0
 1875 0174 9398      		cbi 0x12,3
 1876               		.loc 3 164 0
 1877 0176 00D0      		rcall USART_Receive
 1878               	.LVL160:
 1879 0178 00C0      		rjmp .L160
 1880               	.LVL161:
 1881               	.L89:
 165:main.c        **** 			}
 166:main.c        **** 		}
 167:main.c        **** 		
 168:main.c        **** 		
 169:main.c        **** 		// ---------- SRAM ----------
 170:main.c        **** 		// Read RAM from address (and increment) until anything but 1 is received
 171:main.c        **** 		else if (receivedChar == GBA_READ_SRAM) {
 1882               		.loc 3 171 0
 1883 017a 9D36      		cpi r25,lo8(109)
 1884 017c 01F4      		brne .L94
 172:main.c        **** 			gb_mode(); // Set GB mode as it uses 16 bit address with 8 bit data
 1885               		.loc 3 172 0
 1886 017e 00D0      		rcall gb_mode
 1887               	.LVL162:
 173:main.c        **** 			
 174:main.c        **** 			receivedChar = '1';
 1888               		.loc 3 174 0
 1889 0180 81E3      		ldi r24,lo8(49)
 1890               	.LVL163:
 1891               	.L161:
 175:main.c        **** 			while (receivedChar == '1') {
 176:main.c        **** 				PORTD |= (1<<ACTIVITY_LED);
 177:main.c        **** 				for (uint8_t x = 0; x < 64; x++) {
 178:main.c        **** 					USART_Transmit(gba_read_ram_8bit_data(address));
 179:main.c        **** 					address++;
 180:main.c        **** 				}
 181:main.c        **** 				
 182:main.c        **** 				PORTD &= ~(1<<ACTIVITY_LED);
 183:main.c        **** 				receivedChar = USART_Receive();
 1892               		.loc 3 183 0
 1893 0182 8093 0000 		sts receivedChar,r24
 1894               	.LVL164:
 175:main.c        **** 			while (receivedChar == '1') {
 1895               		.loc 3 175 0
 1896 0186 8091 0000 		lds r24,receivedChar
 1897 018a 8133      		cpi r24,lo8(49)
 1898 018c 01F0      		breq .+2
 1899 018e 00C0      		rjmp .L164
 176:main.c        **** 				for (uint8_t x = 0; x < 64; x++) {
 1900               		.loc 3 176 0
 1901 0190 939A      		sbi 0x12,3
 1902               	.LVL165:
 1903 0192 A12C      		mov r10,__zero_reg__
 1904 0194 B12C      		mov r11,__zero_reg__
 1905               	.LVL166:
 1906               	.L97:
 1907 0196 C501      		movw r24,r10
 1908 0198 8C0D      		add r24,r12
 1909 019a 9D1D      		adc r25,r13
 1910               	.LBB65:
 178:main.c        **** 					address++;
 1911               		.loc 3 178 0 discriminator 2
 1912 019c 00D0      		rcall gba_read_ram_8bit_data
 1913               	.LVL167:
 1914 019e 00D0      		rcall USART_Transmit
 1915               	.LVL168:
 1916 01a0 8FEF      		ldi r24,-1
 1917 01a2 A81A      		sub r10,r24
 1918 01a4 B80A      		sbc r11,r24
 1919               	.LVL169:
 177:main.c        **** 					USART_Transmit(gba_read_ram_8bit_data(address));
 1920               		.loc 3 177 0 discriminator 2
 1921 01a6 90E4      		ldi r25,64
 1922 01a8 A916      		cp r10,r25
 1923 01aa B104      		cpc r11,__zero_reg__
 1924 01ac 01F4      		brne .L97
 1925 01ae E0E4      		ldi r30,64
 1926 01b0 CE0E      		add r12,r30
 1927 01b2 D11C      		adc r13,__zero_reg__
 1928 01b4 E11C      		adc r14,__zero_reg__
 1929 01b6 F11C      		adc r15,__zero_reg__
 1930               	.LBE65:
 182:main.c        **** 				receivedChar = USART_Receive();
 1931               		.loc 3 182 0
 1932 01b8 9398      		cbi 0x12,3
 1933               		.loc 3 183 0
 1934 01ba 00D0      		rcall USART_Receive
 1935               	.LVL170:
 1936 01bc 00C0      		rjmp .L161
 1937               	.LVL171:
 1938               	.L94:
 184:main.c        **** 			}
 185:main.c        **** 			
 186:main.c        **** 			gba_mode(); // Set back
 187:main.c        **** 		}
 188:main.c        **** 		
 189:main.c        **** 		// Write to RAM on address (and increment) with 64 bytes of data
 190:main.c        **** 		else if (receivedChar == GBA_WRITE_SRAM) {
 1939               		.loc 3 190 0
 1940 01be 9737      		cpi r25,lo8(119)
 1941 01c0 01F4      		brne .L99
 191:main.c        **** 			gb_mode();
 1942               		.loc 3 191 0
 1943 01c2 00D0      		rcall gb_mode
 1944               	.LVL172:
 192:main.c        **** 			
 193:main.c        **** 			usart_read_bytes(64);
 1945               		.loc 3 193 0
 1946 01c4 80E4      		ldi r24,lo8(64)
 1947 01c6 00D0      		rcall usart_read_bytes
 1948               	.LVL173:
 194:main.c        **** 			
 195:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 1949               		.loc 3 195 0
 1950 01c8 939A      		sbi 0x12,3
 1951               	.LVL174:
 1952 01ca 00E0      		ldi r16,lo8(receivedBuffer)
 1953 01cc 10E0      		ldi r17,hi8(receivedBuffer)
 1954 01ce A12C      		mov r10,__zero_reg__
 1955 01d0 B12C      		mov r11,__zero_reg__
 1956               	.LVL175:
 1957               	.L101:
 1958               	.LBB66:
 196:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 197:main.c        **** 				gba_write_ram_8bit_data(address, receivedBuffer[x]);
 1959               		.loc 3 197 0 discriminator 2
 1960 01d2 F801      		movw r30,r16
 1961 01d4 6191      		ld r22,Z+
 1962 01d6 8F01      		movw r16,r30
 1963 01d8 C501      		movw r24,r10
 1964 01da 8C0D      		add r24,r12
 1965 01dc 9D1D      		adc r25,r13
 1966 01de 00D0      		rcall gba_write_ram_8bit_data
 1967               	.LVL176:
 1968 01e0 FFEF      		ldi r31,-1
 1969 01e2 AF1A      		sub r10,r31
 1970 01e4 BF0A      		sbc r11,r31
 1971               	.LVL177:
 196:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 1972               		.loc 3 196 0 discriminator 2
 1973 01e6 80E4      		ldi r24,64
 1974 01e8 A816      		cp r10,r24
 1975 01ea B104      		cpc r11,__zero_reg__
 1976 01ec 01F4      		brne .L101
 1977 01ee 00C0      		rjmp .L167
 1978               	.LVL178:
 1979               	.L99:
 1980               	.LBE66:
 198:main.c        **** 				address++;
 199:main.c        **** 			}
 200:main.c        **** 			USART_Transmit('1'); // Send back acknowledgement
 201:main.c        **** 			
 202:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 203:main.c        **** 			gba_mode(); // Set back
 204:main.c        **** 		}
 205:main.c        **** 		
 206:main.c        **** 		// 'o' - Write 1 byte to SRAM address
 207:main.c        **** 		else if (receivedChar == GBA_WRITE_ONE_BYTE_SRAM) {
 1981               		.loc 3 207 0
 1982 01f0 9F36      		cpi r25,lo8(111)
 1983 01f2 01F4      		brne .L102
 1984               	.LBB67:
 208:main.c        **** 			gb_mode();
 1985               		.loc 3 208 0
 1986 01f4 00D0      		rcall gb_mode
 1987               	.LVL179:
 209:main.c        **** 			
 210:main.c        **** 			uint8_t data = USART_Receive();
 1988               		.loc 3 210 0
 1989 01f6 00D0      		rcall USART_Receive
 1990               	.LVL180:
 211:main.c        **** 			gba_write_ram_8bit_data(address, data);
 1991               		.loc 3 211 0
 1992 01f8 682F      		mov r22,r24
 1993 01fa C601      		movw r24,r12
 1994               	.LVL181:
 1995 01fc 00D0      		rcall gba_write_ram_8bit_data
 1996               	.LVL182:
 1997 01fe 00C0      		rjmp .L169
 1998               	.LVL183:
 1999               	.L102:
 2000               	.LBE67:
 212:main.c        **** 			USART_Transmit('1'); // Send back acknowledgement
 213:main.c        **** 			
 214:main.c        **** 			gba_mode(); // Set back
 215:main.c        **** 		}
 216:main.c        **** 		
 217:main.c        **** 		
 218:main.c        **** 		// ---------- FLASH ----------
 219:main.c        **** 		// Read the Flash Manufacturer and Device ID
 220:main.c        **** 		else if (receivedChar == GBA_FLASH_READ_ID) {
 2001               		.loc 3 220 0
 2002 0200 9936      		cpi r25,lo8(105)
 2003 0202 01F4      		brne .L103
 221:main.c        **** 			gb_mode();
 2004               		.loc 3 221 0
 2005 0204 00D0      		rcall gb_mode
 2006               	.LVL184:
 222:main.c        **** 			
 223:main.c        **** 			flash_read_chip_id();
 2007               		.loc 3 223 0
 2008 0206 00D0      		rcall flash_read_chip_id
 2009               	.LVL185:
 224:main.c        **** 			USART_Transmit(flashChipIdBuffer[0]);
 2010               		.loc 3 224 0
 2011 0208 8091 0000 		lds r24,flashChipIdBuffer
 2012 020c 00D0      		rcall USART_Transmit
 2013               	.LVL186:
 225:main.c        **** 			USART_Transmit(flashChipIdBuffer[1]);
 2014               		.loc 3 225 0
 2015 020e 8091 0000 		lds r24,flashChipIdBuffer+1
 2016 0212 00C0      		rjmp .L168
 2017               	.LVL187:
 2018               	.L103:
 226:main.c        **** 			
 227:main.c        **** 			gba_mode(); // Set back
 228:main.c        **** 		}
 229:main.c        **** 		
 230:main.c        **** 		// Change bank
 231:main.c        **** 		else if (receivedChar == GBA_FLASH_SET_BANK) {
 2019               		.loc 3 231 0
 2020 0214 9B36      		cpi r25,lo8(107)
 2021 0216 01F4      		brne .L104
 2022               	.LBB68:
 232:main.c        **** 			usart_read_chars(); // Read data
 2023               		.loc 3 232 0
 2024 0218 00D0      		rcall usart_read_chars
 2025               	.LVL188:
 233:main.c        **** 			uint8_t bank = atoi(receivedBuffer); // Convert data string to dec
 2026               		.loc 3 233 0
 2027 021a 80E0      		ldi r24,lo8(receivedBuffer)
 2028 021c 90E0      		ldi r25,hi8(receivedBuffer)
 2029 021e 00D0      		rcall atoi
 2030               	.LVL189:
 234:main.c        **** 			
 235:main.c        **** 			gb_mode();
 2031               		.loc 3 235 0
 2032 0220 8983      		std Y+1,r24
 2033 0222 00D0      		rcall gb_mode
 2034               	.LVL190:
 236:main.c        **** 			flash_switch_bank(bank);
 2035               		.loc 3 236 0
 2036 0224 8981      		ldd r24,Y+1
 2037 0226 00D0      		rcall flash_switch_bank
 2038               	.LVL191:
 2039 0228 00C0      		rjmp .L164
 2040               	.LVL192:
 2041               	.L104:
 2042               	.LBE68:
 237:main.c        **** 			
 238:main.c        **** 			gba_mode(); // Set back
 239:main.c        **** 		}
 240:main.c        **** 		
 241:main.c        **** 		// Erase 4K sector on Flash (sector 0 to 15 for 512Kbit)
 242:main.c        **** 		else if (receivedChar == GBA_FLASH_4K_SECTOR_ERASE) {
 2043               		.loc 3 242 0
 2044 022a 9337      		cpi r25,lo8(115)
 2045 022c 01F4      		brne .L105
 2046               	.LBB69:
 243:main.c        **** 			gb_mode();
 2047               		.loc 3 243 0
 2048 022e 00D0      		rcall gb_mode
 2049               	.LVL193:
 244:main.c        **** 			
 245:main.c        **** 			usart_read_chars(); // Read sector
 2050               		.loc 3 245 0
 2051 0230 00D0      		rcall usart_read_chars
 2052               	.LVL194:
 246:main.c        **** 			uint8_t sectorAddress = strtol(receivedBuffer, NULL, 16); // Convert address string in hex to de
 2053               		.loc 3 246 0
 2054 0232 40E1      		ldi r20,lo8(16)
 2055 0234 50E0      		ldi r21,0
 2056 0236 60E0      		ldi r22,0
 2057 0238 70E0      		ldi r23,0
 2058 023a 80E0      		ldi r24,lo8(receivedBuffer)
 2059 023c 90E0      		ldi r25,hi8(receivedBuffer)
 2060 023e 00D0      		rcall strtol
 2061               	.LVL195:
 2062 0240 862F      		mov r24,r22
 2063               	.LVL196:
 247:main.c        **** 			
 248:main.c        **** 			flash_erase_4k_sector(sectorAddress);
 2064               		.loc 3 248 0
 2065 0242 00D0      		rcall flash_erase_4k_sector
 2066               	.LVL197:
 2067               	.L169:
 249:main.c        **** 			USART_Transmit('1'); // Send back acknowledgement
 2068               		.loc 3 249 0
 2069 0244 81E3      		ldi r24,lo8(49)
 2070               	.L168:
 2071 0246 00D0      		rcall USART_Transmit
 2072               	.LVL198:
 2073 0248 00C0      		rjmp .L164
 2074               	.LVL199:
 2075               	.L105:
 2076               	.LBE69:
 250:main.c        **** 			
 251:main.c        **** 			gba_mode(); // Set back
 252:main.c        **** 		}
 253:main.c        **** 		
 254:main.c        **** 		// Write 64 bytes to Flash address one byte write at a time (and increment)
 255:main.c        **** 		else if (receivedChar == GBA_FLASH_WRITE_BYTE) {
 2077               		.loc 3 255 0
 2078 024a 9236      		cpi r25,lo8(98)
 2079 024c 01F4      		brne .L106
 256:main.c        **** 			gb_mode();
 2080               		.loc 3 256 0
 2081 024e 00D0      		rcall gb_mode
 2082               	.LVL200:
 257:main.c        **** 			
 258:main.c        **** 			usart_read_bytes(64);
 2083               		.loc 3 258 0
 2084 0250 80E4      		ldi r24,lo8(64)
 2085 0252 00D0      		rcall usart_read_bytes
 2086               	.LVL201:
 259:main.c        **** 			
 260:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 2087               		.loc 3 260 0
 2088 0254 939A      		sbi 0x12,3
 2089               	.LVL202:
 2090 0256 00E0      		ldi r16,lo8(receivedBuffer)
 2091 0258 10E0      		ldi r17,hi8(receivedBuffer)
 2092 025a A12C      		mov r10,__zero_reg__
 2093 025c B12C      		mov r11,__zero_reg__
 2094               	.LVL203:
 2095               	.L108:
 2096               	.LBB70:
 261:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 262:main.c        **** 				flash_write_byte(address, receivedBuffer[x]);
 2097               		.loc 3 262 0 discriminator 2
 2098 025e F801      		movw r30,r16
 2099 0260 6191      		ld r22,Z+
 2100 0262 8F01      		movw r16,r30
 2101 0264 C501      		movw r24,r10
 2102 0266 8C0D      		add r24,r12
 2103 0268 9D1D      		adc r25,r13
 2104 026a 00D0      		rcall flash_write_byte
 2105               	.LVL204:
 2106 026c FFEF      		ldi r31,-1
 2107 026e AF1A      		sub r10,r31
 2108 0270 BF0A      		sbc r11,r31
 2109               	.LVL205:
 261:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 2110               		.loc 3 261 0 discriminator 2
 2111 0272 80E4      		ldi r24,64
 2112 0274 A816      		cp r10,r24
 2113 0276 B104      		cpc r11,__zero_reg__
 2114 0278 01F4      		brne .L108
 2115               	.LVL206:
 2116               	.L167:
 2117 027a 90E4      		ldi r25,64
 2118 027c C90E      		add r12,r25
 2119 027e D11C      		adc r13,__zero_reg__
 2120 0280 E11C      		adc r14,__zero_reg__
 2121 0282 F11C      		adc r15,__zero_reg__
 2122 0284 00C0      		rjmp .L163
 2123               	.LVL207:
 2124               	.L106:
 2125               	.LBE70:
 263:main.c        **** 				address++;
 264:main.c        **** 			}
 265:main.c        **** 			USART_Transmit('1'); // Send back acknowledgement
 266:main.c        **** 			
 267:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 268:main.c        **** 			gba_mode(); // Set back
 269:main.c        **** 		}
 270:main.c        **** 		
 271:main.c        **** 		// Write 128 bytes to flash sector for Atmel flash (and increment)
 272:main.c        **** 		else if (receivedChar == GBA_FLASH_WRITE_ATMEL) {
 2126               		.loc 3 272 0
 2127 0286 9136      		cpi r25,lo8(97)
 2128 0288 01F4      		brne .L76
 273:main.c        **** 			gb_mode();
 2129               		.loc 3 273 0
 2130 028a 00D0      		rcall gb_mode
 2131               	.LVL208:
 274:main.c        **** 			
 275:main.c        **** 			usart_read_bytes(128);
 2132               		.loc 3 275 0
 2133 028c 80E8      		ldi r24,lo8(-128)
 2134 028e 00D0      		rcall usart_read_bytes
 2135               	.LVL209:
 276:main.c        **** 			
 277:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 2136               		.loc 3 277 0
 2137 0290 939A      		sbi 0x12,3
 278:main.c        **** 			flash_write_sector(address); // Address used as sector number
 2138               		.loc 3 278 0
 2139 0292 C601      		movw r24,r12
 2140 0294 00D0      		rcall flash_write_sector
 2141               	.LVL210:
 279:main.c        **** 			address++;
 2142               		.loc 3 279 0
 2143 0296 EFEF      		ldi r30,-1
 2144 0298 CE1A      		sub r12,r30
 2145 029a DE0A      		sbc r13,r30
 2146 029c EE0A      		sbc r14,r30
 2147 029e FE0A      		sbc r15,r30
 2148               	.LVL211:
 2149               	.L163:
 280:main.c        **** 			USART_Transmit('1'); // Send back acknowledgement
 2150               		.loc 3 280 0
 2151 02a0 81E3      		ldi r24,lo8(49)
 2152 02a2 00D0      		rcall USART_Transmit
 2153               	.LVL212:
 281:main.c        **** 			
 282:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 2154               		.loc 3 282 0
 2155 02a4 9398      		cbi 0x12,3
 2156               	.L164:
 283:main.c        **** 			gba_mode(); // Set back
 2157               		.loc 3 283 0
 2158 02a6 00D0      		rcall gba_mode
 2159               	.LVL213:
 2160               	.L76:
 284:main.c        **** 		}
 285:main.c        **** 		
 286:main.c        **** 		
 287:main.c        **** 		// ---------- EEPROM ----------
 288:main.c        **** 		// Set EEPROM size
 289:main.c        **** 		if (receivedChar == GBA_SET_EEPROM_SIZE) {
 2161               		.loc 3 289 0
 2162 02a8 8091 0000 		lds r24,receivedChar
 2163 02ac 8335      		cpi r24,lo8(83)
 2164 02ae 01F4      		brne .L109
 290:main.c        **** 			usart_read_chars(); // Read size
 2165               		.loc 3 290 0
 2166 02b0 00D0      		rcall usart_read_chars
 2167               	.LVL214:
 291:main.c        **** 			eepromSize = strtol(receivedBuffer, NULL, 16); // Convert size to dec
 2168               		.loc 3 291 0
 2169 02b2 40E1      		ldi r20,lo8(16)
 2170 02b4 50E0      		ldi r21,0
 2171 02b6 60E0      		ldi r22,0
 2172 02b8 70E0      		ldi r23,0
 2173 02ba 80E0      		ldi r24,lo8(receivedBuffer)
 2174 02bc 90E0      		ldi r25,hi8(receivedBuffer)
 2175 02be 00D0      		rcall strtol
 2176               	.LVL215:
 2177 02c0 762E      		mov r7,r22
 2178               	.LVL216:
 2179 02c2 00C0      		rjmp .L71
 2180               	.L109:
 292:main.c        **** 		}
 293:main.c        **** 		
 294:main.c        **** 		// Read the EEPROM on address (and increment) until anything but 1 is received
 295:main.c        **** 		else if (receivedChar == GBA_READ_EEPROM) {
 2181               		.loc 3 295 0
 2182 02c4 8536      		cpi r24,lo8(101)
 2183 02c6 01F4      		brne .L111
 296:main.c        **** 			gba_eeprom_mode();
 2184               		.loc 3 296 0
 2185 02c8 00D0      		rcall gba_eeprom_mode
 2186               	.LVL217:
 297:main.c        **** 			
 298:main.c        **** 			receivedChar = '1';
 2187               		.loc 3 298 0
 2188 02ca 81E3      		ldi r24,lo8(49)
 2189               	.L165:
 299:main.c        **** 			while (receivedChar == '1') {
 300:main.c        **** 				PORTD |= (1<<ACTIVITY_LED);
 301:main.c        **** 				gba_eeprom_read(address, eepromSize);
 302:main.c        **** 				
 303:main.c        **** 				// Send back the 8 bytes of data
 304:main.c        **** 				for (uint8_t c = 0; c < 8; c++) {
 305:main.c        **** 					USART_Transmit(eepromBuffer[c]);
 306:main.c        **** 				}
 307:main.c        **** 				address++; // Increment to next 8 bytes
 308:main.c        **** 				
 309:main.c        **** 				PORTD &= ~(1<<ACTIVITY_LED);
 310:main.c        **** 				receivedChar = USART_Receive();
 2190               		.loc 3 310 0
 2191 02cc 8093 0000 		sts receivedChar,r24
 299:main.c        **** 			while (receivedChar == '1') {
 2192               		.loc 3 299 0
 2193 02d0 8091 0000 		lds r24,receivedChar
 2194 02d4 8133      		cpi r24,lo8(49)
 2195 02d6 01F4      		brne .L158
 300:main.c        **** 				gba_eeprom_read(address, eepromSize);
 2196               		.loc 3 300 0
 2197 02d8 939A      		sbi 0x12,3
 301:main.c        **** 				
 2198               		.loc 3 301 0
 2199 02da 672D      		mov r22,r7
 2200 02dc C601      		movw r24,r12
 2201 02de 00D0      		rcall gba_eeprom_read
 2202               	.LVL218:
 2203 02e0 00E0      		ldi r16,lo8(eepromBuffer)
 2204 02e2 10E0      		ldi r17,hi8(eepromBuffer)
 2205               	.LVL219:
 2206               	.L114:
 2207               	.LBB71:
 305:main.c        **** 				}
 2208               		.loc 3 305 0 discriminator 2
 2209 02e4 F801      		movw r30,r16
 2210 02e6 8191      		ld r24,Z+
 2211 02e8 8F01      		movw r16,r30
 2212               	.LVL220:
 2213 02ea 00D0      		rcall USART_Transmit
 2214               	.LVL221:
 304:main.c        **** 					USART_Transmit(eepromBuffer[c]);
 2215               		.loc 3 304 0 discriminator 2
 2216 02ec F0E0      		ldi r31,hi8(eepromBuffer+8)
 2217 02ee 0030      		cpi r16,lo8(eepromBuffer+8)
 2218 02f0 1F07      		cpc r17,r31
 2219 02f2 01F4      		brne .L114
 2220               	.LBE71:
 307:main.c        **** 				
 2221               		.loc 3 307 0
 2222 02f4 8FEF      		ldi r24,-1
 2223 02f6 C81A      		sub r12,r24
 2224 02f8 D80A      		sbc r13,r24
 2225 02fa E80A      		sbc r14,r24
 2226 02fc F80A      		sbc r15,r24
 2227               	.LVL222:
 309:main.c        **** 				receivedChar = USART_Receive();
 2228               		.loc 3 309 0
 2229 02fe 9398      		cbi 0x12,3
 2230               		.loc 3 310 0
 2231 0300 00D0      		rcall USART_Receive
 2232               	.LVL223:
 2233 0302 00C0      		rjmp .L165
 2234               	.LVL224:
 2235               	.L111:
 311:main.c        **** 			}
 312:main.c        **** 			
 313:main.c        **** 			gba_mode(); // Set back
 314:main.c        **** 		}
 315:main.c        **** 		
 316:main.c        **** 		// Write 8 bytes to the EEPROM address (and increment)
 317:main.c        **** 		else if (receivedChar == GBA_WRITE_EEPROM) {
 2236               		.loc 3 317 0
 2237 0304 8037      		cpi r24,lo8(112)
 2238 0306 01F4      		brne .L116
 318:main.c        **** 			gba_eeprom_mode();
 2239               		.loc 3 318 0
 2240 0308 00D0      		rcall gba_eeprom_mode
 2241               	.LVL225:
 2242 030a 00E0      		ldi r16,lo8(eepromBuffer)
 2243 030c 10E0      		ldi r17,hi8(eepromBuffer)
 2244               	.LVL226:
 2245               	.L118:
 2246               	.LBB72:
 319:main.c        **** 			
 320:main.c        **** 			// Read 8 bytes from USART and place in buffer
 321:main.c        **** 			for (uint8_t x = 0; x < 8; x++) {
 322:main.c        **** 				eepromBuffer[x] = USART_Receive();
 2247               		.loc 3 322 0 discriminator 2
 2248 030e 00D0      		rcall USART_Receive
 2249               	.LVL227:
 2250 0310 F801      		movw r30,r16
 2251 0312 8193      		st Z+,r24
 2252 0314 8F01      		movw r16,r30
 2253               	.LVL228:
 321:main.c        **** 				eepromBuffer[x] = USART_Receive();
 2254               		.loc 3 321 0 discriminator 2
 2255 0316 F0E0      		ldi r31,hi8(eepromBuffer+8)
 2256 0318 0030      		cpi r16,lo8(eepromBuffer+8)
 2257 031a 1F07      		cpc r17,r31
 2258 031c 01F4      		brne .L118
 2259               	.LBE72:
 323:main.c        **** 			}
 324:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 2260               		.loc 3 324 0
 2261 031e 939A      		sbi 0x12,3
 325:main.c        **** 			
 326:main.c        **** 			gba_eeprom_write(address, eepromSize);
 2262               		.loc 3 326 0
 2263 0320 672D      		mov r22,r7
 2264 0322 C601      		movw r24,r12
 2265 0324 00D0      		rcall gba_eeprom_write
 2266               	.LVL229:
 327:main.c        **** 			address++;
 2267               		.loc 3 327 0
 2268 0326 8FEF      		ldi r24,-1
 2269 0328 C81A      		sub r12,r24
 2270 032a D80A      		sbc r13,r24
 2271 032c E80A      		sbc r14,r24
 2272 032e F80A      		sbc r15,r24
 2273               	.LVL230:
 2274               	.LBB73:
 2275               	.LBB74:
 163:c:\winavr-20100110\avr\include\util\delay.h **** 
 2276               		.loc 2 163 0
 2277 0330 EFE7      		ldi r30,lo8(15999)
 2278 0332 FEE3      		ldi r31,hi8(15999)
 2279 0334 3197      		1: sbiw r30,1
 2280 0336 01F4      		brne 1b
 2281 0338 00C0      		rjmp .
 2282 033a 0000      		nop
 2283               	.LBE74:
 2284               	.LBE73:
 328:main.c        **** 			
 329:main.c        **** 			_delay_ms(8); // Wait for EEPROM to write data (8ms)
 330:main.c        **** 			USART_Transmit('1'); // Send back acknowledgement
 2285               		.loc 3 330 0
 2286 033c 81E3      		ldi r24,lo8(49)
 2287 033e 00D0      		rcall USART_Transmit
 2288               	.LVL231:
 331:main.c        **** 			
 332:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 2289               		.loc 3 332 0
 2290 0340 9398      		cbi 0x12,3
 2291               	.LVL232:
 2292               	.L158:
 333:main.c        **** 			gba_mode(); // Set back
 2293               		.loc 3 333 0
 2294 0342 00D0      		rcall gba_mode
 2295               	.LVL233:
 2296 0344 00C0      		rjmp .L71
 2297               	.L116:
 334:main.c        **** 		}
 335:main.c        **** 		
 336:main.c        **** 		
 337:main.c        **** 		// ---------- General commands ----------
 338:main.c        **** 		// Set any pin as input/output
 339:main.c        **** 		// Reads the DDR/PORT (e.g. DDRB/PORTB is 'B') and the hex value that represents pins to set to a
 340:main.c        **** 		else if (receivedChar == SET_INPUT || receivedChar == SET_OUTPUT) {
 2298               		.loc 3 340 0
 2299 0346 8934      		cpi r24,lo8(73)
 2300 0348 01F0      		breq .L119
 2301               		.loc 3 340 0 is_stmt 0 discriminator 1
 2302 034a 8F34      		cpi r24,lo8(79)
 2303 034c 01F0      		breq .+2
 2304 034e 00C0      		rjmp .L120
 2305               	.L119:
 2306               	.LBB75:
 341:main.c        **** 			char portChar = USART_Receive();
 2307               		.loc 3 341 0 is_stmt 1
 2308 0350 00D0      		rcall USART_Receive
 2309               	.LVL234:
 2310 0352 182F      		mov r17,r24
 2311               	.LVL235:
 342:main.c        **** 			usart_read_chars();
 2312               		.loc 3 342 0
 2313 0354 00D0      		rcall usart_read_chars
 2314               	.LVL236:
 343:main.c        **** 			uint8_t setValue = strtol(receivedBuffer, NULL, 16);
 2315               		.loc 3 343 0
 2316 0356 40E1      		ldi r20,lo8(16)
 2317 0358 50E0      		ldi r21,0
 2318 035a 60E0      		ldi r22,0
 2319 035c 70E0      		ldi r23,0
 2320 035e 80E0      		ldi r24,lo8(receivedBuffer)
 2321 0360 90E0      		ldi r25,hi8(receivedBuffer)
 2322 0362 00D0      		rcall strtol
 2323               	.LVL237:
 344:main.c        **** 			
 345:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 2324               		.loc 3 345 0
 2325 0364 939A      		sbi 0x12,3
 346:main.c        **** 			if (receivedChar == SET_INPUT) {
 2326               		.loc 3 346 0
 2327 0366 8091 0000 		lds r24,receivedChar
 2328 036a 8934      		cpi r24,lo8(73)
 2329 036c 01F4      		brne .L121
 347:main.c        **** 				if (portChar == 'A') {
 2330               		.loc 3 347 0
 2331 036e 1134      		cpi r17,lo8(65)
 2332 0370 01F4      		brne .L122
 348:main.c        **** 					DDRA &= ~(setValue);
 2333               		.loc 3 348 0
 2334 0372 8AB3      		in r24,0x1a
 2335 0374 6095      		com r22
 2336               	.LVL238:
 2337 0376 6823      		and r22,r24
 2338               	.LVL239:
 2339 0378 6ABB      		out 0x1a,r22
 2340 037a 00C0      		rjmp .L145
 2341               	.LVL240:
 2342               	.L122:
 349:main.c        **** 				}
 350:main.c        **** 				else if (portChar == 'B') {
 2343               		.loc 3 350 0
 2344 037c 1234      		cpi r17,lo8(66)
 2345 037e 01F4      		brne .L124
 351:main.c        **** 					DDRB &= ~(setValue);
 2346               		.loc 3 351 0
 2347 0380 87B3      		in r24,0x17
 2348 0382 6095      		com r22
 2349               	.LVL241:
 2350 0384 6823      		and r22,r24
 2351               	.LVL242:
 2352 0386 67BB      		out 0x17,r22
 2353 0388 00C0      		rjmp .L145
 2354               	.LVL243:
 2355               	.L124:
 352:main.c        **** 				}
 353:main.c        **** 				else if (portChar == 'C') {
 2356               		.loc 3 353 0
 2357 038a 1334      		cpi r17,lo8(67)
 2358 038c 01F4      		brne .L125
 354:main.c        **** 					DDRC &= ~(setValue);
 2359               		.loc 3 354 0
 2360 038e 84B3      		in r24,0x14
 2361 0390 6095      		com r22
 2362               	.LVL244:
 2363 0392 6823      		and r22,r24
 2364               	.LVL245:
 2365 0394 64BB      		out 0x14,r22
 2366 0396 00C0      		rjmp .L145
 2367               	.LVL246:
 2368               	.L125:
 355:main.c        **** 				}
 356:main.c        **** 				else if (portChar == 'D') {
 2369               		.loc 3 356 0
 2370 0398 1434      		cpi r17,lo8(68)
 2371 039a 01F4      		brne .L126
 357:main.c        **** 					DDRD &= ~(setValue);
 2372               		.loc 3 357 0
 2373 039c 81B3      		in r24,0x11
 2374 039e 6095      		com r22
 2375               	.LVL247:
 2376 03a0 6823      		and r22,r24
 2377               	.LVL248:
 2378 03a2 61BB      		out 0x11,r22
 2379 03a4 00C0      		rjmp .L145
 2380               	.LVL249:
 2381               	.L126:
 358:main.c        **** 				}
 359:main.c        **** 				else if (portChar == 'E') {
 2382               		.loc 3 359 0
 2383 03a6 1534      		cpi r17,lo8(69)
 2384 03a8 01F0      		breq .+2
 2385 03aa 00C0      		rjmp .L145
 360:main.c        **** 					DDRE &= ~(setValue);
 2386               		.loc 3 360 0
 2387 03ac 86B1      		in r24,0x6
 2388 03ae 6095      		com r22
 2389               	.LVL250:
 2390 03b0 6823      		and r22,r24
 2391               	.LVL251:
 2392 03b2 66B9      		out 0x6,r22
 2393 03b4 00C0      		rjmp .L145
 2394               	.LVL252:
 2395               	.L121:
 361:main.c        **** 				}
 362:main.c        **** 			}
 363:main.c        **** 			else if (receivedChar == SET_OUTPUT) {
 2396               		.loc 3 363 0
 2397 03b6 8F34      		cpi r24,lo8(79)
 2398 03b8 01F0      		breq .+2
 2399 03ba 00C0      		rjmp .L145
 364:main.c        **** 				if (portChar == 'A') {
 2400               		.loc 3 364 0
 2401 03bc 1134      		cpi r17,lo8(65)
 2402 03be 01F4      		brne .L127
 365:main.c        **** 					DDRA |= (setValue);
 2403               		.loc 3 365 0
 2404 03c0 8AB3      		in r24,0x1a
 2405 03c2 862B      		or r24,r22
 2406 03c4 8ABB      		out 0x1a,r24
 2407 03c6 00C0      		rjmp .L145
 2408               	.L127:
 366:main.c        **** 				}
 367:main.c        **** 				else if (portChar == 'B') {
 2409               		.loc 3 367 0
 2410 03c8 1234      		cpi r17,lo8(66)
 2411 03ca 01F4      		brne .L128
 368:main.c        **** 					DDRB |= (setValue);
 2412               		.loc 3 368 0
 2413 03cc 87B3      		in r24,0x17
 2414 03ce 862B      		or r24,r22
 2415 03d0 87BB      		out 0x17,r24
 2416 03d2 00C0      		rjmp .L145
 2417               	.L128:
 369:main.c        **** 				}
 370:main.c        **** 				else if (portChar == 'C') {
 2418               		.loc 3 370 0
 2419 03d4 1334      		cpi r17,lo8(67)
 2420 03d6 01F4      		brne .L129
 371:main.c        **** 					DDRC |= (setValue);
 2421               		.loc 3 371 0
 2422 03d8 84B3      		in r24,0x14
 2423 03da 862B      		or r24,r22
 2424 03dc 84BB      		out 0x14,r24
 2425 03de 00C0      		rjmp .L145
 2426               	.L129:
 372:main.c        **** 				}
 373:main.c        **** 				else if (portChar == 'D') {
 2427               		.loc 3 373 0
 2428 03e0 1434      		cpi r17,lo8(68)
 2429 03e2 01F4      		brne .L130
 374:main.c        **** 					DDRD |= (setValue);
 2430               		.loc 3 374 0
 2431 03e4 81B3      		in r24,0x11
 2432 03e6 862B      		or r24,r22
 2433 03e8 81BB      		out 0x11,r24
 2434 03ea 00C0      		rjmp .L145
 2435               	.L130:
 375:main.c        **** 				}
 376:main.c        **** 				else if (portChar == 'E') {
 2436               		.loc 3 376 0
 2437 03ec 1534      		cpi r17,lo8(69)
 2438 03ee 01F0      		breq .+2
 2439 03f0 00C0      		rjmp .L145
 377:main.c        **** 					DDRE |= (setValue);
 2440               		.loc 3 377 0
 2441 03f2 86B1      		in r24,0x6
 2442 03f4 862B      		or r24,r22
 2443 03f6 86B9      		out 0x6,r24
 2444 03f8 00C0      		rjmp .L145
 2445               	.LVL253:
 2446               	.L120:
 2447               	.LBE75:
 378:main.c        **** 				}
 379:main.c        **** 			}
 380:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 381:main.c        **** 		}
 382:main.c        **** 		
 383:main.c        **** 		// Set pin output as low
 384:main.c        **** 		else if (receivedChar == SET_OUTPUT_LOW) {
 2448               		.loc 3 384 0
 2449 03fa 8C34      		cpi r24,lo8(76)
 2450 03fc 01F4      		brne .L131
 2451               	.LBB76:
 385:main.c        **** 			char portChar = USART_Receive();			
 2452               		.loc 3 385 0
 2453 03fe 00D0      		rcall USART_Receive
 2454               	.LVL254:
 2455 0400 182F      		mov r17,r24
 2456               	.LVL255:
 386:main.c        **** 			usart_read_chars();
 2457               		.loc 3 386 0
 2458 0402 00D0      		rcall usart_read_chars
 2459               	.LVL256:
 387:main.c        **** 			uint8_t setValue = strtol(receivedBuffer, NULL, 16);
 2460               		.loc 3 387 0
 2461 0404 40E1      		ldi r20,lo8(16)
 2462 0406 50E0      		ldi r21,0
 2463 0408 60E0      		ldi r22,0
 2464 040a 70E0      		ldi r23,0
 2465 040c 80E0      		ldi r24,lo8(receivedBuffer)
 2466 040e 90E0      		ldi r25,hi8(receivedBuffer)
 2467 0410 00D0      		rcall strtol
 2468               	.LVL257:
 388:main.c        **** 			
 389:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 2469               		.loc 3 389 0
 2470 0412 939A      		sbi 0x12,3
 390:main.c        **** 			if (portChar == 'A') {
 2471               		.loc 3 390 0
 2472 0414 1134      		cpi r17,lo8(65)
 2473 0416 01F4      		brne .L132
 391:main.c        **** 				PORTA &= ~(setValue);
 2474               		.loc 3 391 0
 2475 0418 8BB3      		in r24,0x1b
 2476 041a 6095      		com r22
 2477               	.LVL258:
 2478 041c 6823      		and r22,r24
 2479               	.LVL259:
 2480 041e 6BBB      		out 0x1b,r22
 2481 0420 00C0      		rjmp .L145
 2482               	.LVL260:
 2483               	.L132:
 392:main.c        **** 			}
 393:main.c        **** 			else if (portChar == 'B') {
 2484               		.loc 3 393 0
 2485 0422 1234      		cpi r17,lo8(66)
 2486 0424 01F4      		brne .L134
 394:main.c        **** 				PORTB &= ~(setValue);
 2487               		.loc 3 394 0
 2488 0426 88B3      		in r24,0x18
 2489 0428 6095      		com r22
 2490               	.LVL261:
 2491 042a 6823      		and r22,r24
 2492               	.LVL262:
 2493 042c 68BB      		out 0x18,r22
 2494 042e 00C0      		rjmp .L145
 2495               	.LVL263:
 2496               	.L134:
 395:main.c        **** 			}
 396:main.c        **** 			else if (portChar == 'C') {
 2497               		.loc 3 396 0
 2498 0430 1334      		cpi r17,lo8(67)
 2499 0432 01F4      		brne .L135
 397:main.c        **** 				PORTC &= ~(setValue);
 2500               		.loc 3 397 0
 2501 0434 85B3      		in r24,0x15
 2502 0436 6095      		com r22
 2503               	.LVL264:
 2504 0438 6823      		and r22,r24
 2505               	.LVL265:
 2506 043a 65BB      		out 0x15,r22
 2507 043c 00C0      		rjmp .L145
 2508               	.LVL266:
 2509               	.L135:
 398:main.c        **** 			}
 399:main.c        **** 			else if (portChar == 'D') {
 2510               		.loc 3 399 0
 2511 043e 1434      		cpi r17,lo8(68)
 2512 0440 01F4      		brne .L136
 400:main.c        **** 				PORTD &= ~(setValue);
 2513               		.loc 3 400 0
 2514 0442 82B3      		in r24,0x12
 2515 0444 6095      		com r22
 2516               	.LVL267:
 2517 0446 6823      		and r22,r24
 2518               	.LVL268:
 2519 0448 62BB      		out 0x12,r22
 2520 044a 00C0      		rjmp .L145
 2521               	.LVL269:
 2522               	.L136:
 401:main.c        **** 			}
 402:main.c        **** 			else if (portChar == 'E') {
 2523               		.loc 3 402 0
 2524 044c 1534      		cpi r17,lo8(69)
 2525 044e 01F0      		breq .+2
 2526 0450 00C0      		rjmp .L145
 403:main.c        **** 				PORTE &= ~(setValue);
 2527               		.loc 3 403 0
 2528 0452 87B1      		in r24,0x7
 2529 0454 6095      		com r22
 2530               	.LVL270:
 2531 0456 6823      		and r22,r24
 2532               	.LVL271:
 2533 0458 67B9      		out 0x7,r22
 2534 045a 00C0      		rjmp .L145
 2535               	.LVL272:
 2536               	.L131:
 2537               	.LBE76:
 404:main.c        **** 			}
 405:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 406:main.c        **** 		}
 407:main.c        **** 		
 408:main.c        **** 		// Set pin output as high
 409:main.c        **** 		else if (receivedChar == SET_OUTPUT_HIGH) {
 2538               		.loc 3 409 0
 2539 045c 8834      		cpi r24,lo8(72)
 2540 045e 01F4      		brne .L137
 2541               	.LBB77:
 410:main.c        **** 			char portChar = USART_Receive();			
 2542               		.loc 3 410 0
 2543 0460 00D0      		rcall USART_Receive
 2544               	.LVL273:
 2545 0462 182F      		mov r17,r24
 2546               	.LVL274:
 411:main.c        **** 			usart_read_chars();
 2547               		.loc 3 411 0
 2548 0464 00D0      		rcall usart_read_chars
 2549               	.LVL275:
 412:main.c        **** 			uint8_t setValue = strtol(receivedBuffer, NULL, 16);
 2550               		.loc 3 412 0
 2551 0466 40E1      		ldi r20,lo8(16)
 2552 0468 50E0      		ldi r21,0
 2553 046a 60E0      		ldi r22,0
 2554 046c 70E0      		ldi r23,0
 2555 046e 80E0      		ldi r24,lo8(receivedBuffer)
 2556 0470 90E0      		ldi r25,hi8(receivedBuffer)
 2557 0472 00D0      		rcall strtol
 2558               	.LVL276:
 413:main.c        **** 			
 414:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 2559               		.loc 3 414 0
 2560 0474 939A      		sbi 0x12,3
 415:main.c        **** 			if (portChar == 'A') {
 2561               		.loc 3 415 0
 2562 0476 1134      		cpi r17,lo8(65)
 2563 0478 01F4      		brne .L138
 416:main.c        **** 				PORTA |= (setValue);
 2564               		.loc 3 416 0
 2565 047a 8BB3      		in r24,0x1b
 2566 047c 862B      		or r24,r22
 2567 047e 8BBB      		out 0x1b,r24
 2568 0480 00C0      		rjmp .L145
 2569               	.L138:
 417:main.c        **** 			}
 418:main.c        **** 			else if (portChar == 'B') {
 2570               		.loc 3 418 0
 2571 0482 1234      		cpi r17,lo8(66)
 2572 0484 01F4      		brne .L140
 419:main.c        **** 				PORTB |= (setValue);
 2573               		.loc 3 419 0
 2574 0486 88B3      		in r24,0x18
 2575 0488 862B      		or r24,r22
 2576 048a 88BB      		out 0x18,r24
 2577 048c 00C0      		rjmp .L145
 2578               	.L140:
 420:main.c        **** 			}
 421:main.c        **** 			else if (portChar == 'C') {
 2579               		.loc 3 421 0
 2580 048e 1334      		cpi r17,lo8(67)
 2581 0490 01F4      		brne .L141
 422:main.c        **** 				PORTC |= (setValue);
 2582               		.loc 3 422 0
 2583 0492 85B3      		in r24,0x15
 2584 0494 862B      		or r24,r22
 2585 0496 85BB      		out 0x15,r24
 2586 0498 00C0      		rjmp .L145
 2587               	.L141:
 423:main.c        **** 			}
 424:main.c        **** 			else if (portChar == 'D') {
 2588               		.loc 3 424 0
 2589 049a 1434      		cpi r17,lo8(68)
 2590 049c 01F4      		brne .L142
 425:main.c        **** 				PORTD |= (setValue);
 2591               		.loc 3 425 0
 2592 049e 82B3      		in r24,0x12
 2593 04a0 862B      		or r24,r22
 2594 04a2 82BB      		out 0x12,r24
 2595 04a4 00C0      		rjmp .L145
 2596               	.L142:
 426:main.c        **** 			}
 427:main.c        **** 			else if (portChar == 'E') {
 2597               		.loc 3 427 0
 2598 04a6 1534      		cpi r17,lo8(69)
 2599 04a8 01F4      		brne .L145
 428:main.c        **** 				PORTE |= (setValue);
 2600               		.loc 3 428 0
 2601 04aa 87B1      		in r24,0x7
 2602 04ac 862B      		or r24,r22
 2603 04ae 87B9      		out 0x7,r24
 2604 04b0 00C0      		rjmp .L145
 2605               	.LVL277:
 2606               	.L137:
 2607               	.LBE77:
 429:main.c        **** 			}
 430:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 431:main.c        **** 		}
 432:main.c        **** 		
 433:main.c        **** 		// Read all pins of a PORT and return the value
 434:main.c        **** 		else if (receivedChar == READ_INPUT) {
 2608               		.loc 3 434 0
 2609 04b2 8434      		cpi r24,lo8(68)
 2610 04b4 01F4      		brne .L143
 2611               	.LBB78:
 435:main.c        **** 			char portChar = USART_Receive();			
 2612               		.loc 3 435 0
 2613 04b6 00D0      		rcall USART_Receive
 2614               	.LVL278:
 436:main.c        **** 			
 437:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 2615               		.loc 3 437 0
 2616 04b8 939A      		sbi 0x12,3
 438:main.c        **** 			if (portChar == 'A') {
 2617               		.loc 3 438 0
 2618 04ba 8134      		cpi r24,lo8(65)
 2619 04bc 01F4      		brne .L144
 439:main.c        **** 				USART_Transmit(PINA);
 2620               		.loc 3 439 0
 2621 04be 89B3      		in r24,0x19
 2622               	.LVL279:
 2623 04c0 00C0      		rjmp .L166
 2624               	.LVL280:
 2625               	.L144:
 440:main.c        **** 			}
 441:main.c        **** 			else if (portChar == 'B') {
 2626               		.loc 3 441 0
 2627 04c2 8234      		cpi r24,lo8(66)
 2628 04c4 01F4      		brne .L146
 442:main.c        **** 				USART_Transmit(PINB);
 2629               		.loc 3 442 0
 2630 04c6 86B3      		in r24,0x16
 2631               	.LVL281:
 2632 04c8 00C0      		rjmp .L166
 2633               	.LVL282:
 2634               	.L146:
 443:main.c        **** 			}
 444:main.c        **** 			else if (portChar == 'C') {
 2635               		.loc 3 444 0
 2636 04ca 8334      		cpi r24,lo8(67)
 2637 04cc 01F4      		brne .L147
 445:main.c        **** 				USART_Transmit(PINC);
 2638               		.loc 3 445 0
 2639 04ce 83B3      		in r24,0x13
 2640               	.LVL283:
 2641 04d0 00C0      		rjmp .L166
 2642               	.LVL284:
 2643               	.L147:
 446:main.c        **** 			}
 447:main.c        **** 			else if (portChar == 'D') {
 2644               		.loc 3 447 0
 2645 04d2 8434      		cpi r24,lo8(68)
 2646 04d4 01F4      		brne .L148
 448:main.c        **** 				USART_Transmit(PIND);
 2647               		.loc 3 448 0
 2648 04d6 80B3      		in r24,0x10
 2649               	.LVL285:
 2650 04d8 00C0      		rjmp .L166
 2651               	.LVL286:
 2652               	.L148:
 449:main.c        **** 			}
 450:main.c        **** 			else if (portChar == 'E') {
 2653               		.loc 3 450 0
 2654 04da 8534      		cpi r24,lo8(69)
 2655 04dc 01F4      		brne .L145
 451:main.c        **** 				USART_Transmit(PINE);
 2656               		.loc 3 451 0
 2657 04de 85B1      		in r24,0x5
 2658               	.LVL287:
 2659               	.L166:
 2660 04e0 00D0      		rcall USART_Transmit
 2661               	.LVL288:
 2662               	.L145:
 452:main.c        **** 			}
 453:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 2663               		.loc 3 453 0 discriminator 1
 2664 04e2 9398      		cbi 0x12,3
 2665               	.LBE78:
 2666 04e4 00C0      		rjmp .L71
 2667               	.L143:
 454:main.c        **** 		}
 455:main.c        **** 		
 456:main.c        **** 		// Set the reset common lines variable on or off, useful if you are controlling all the pins dire
 457:main.c        **** 		else if (receivedChar == RESET_COMMON_LINES) {
 2668               		.loc 3 457 0
 2669 04e6 8D34      		cpi r24,lo8(77)
 2670 04e8 01F4      		brne .L149
 2671               	.LBB79:
 458:main.c        **** 			char commonChar = USART_Receive();
 2672               		.loc 3 458 0
 2673 04ea 00D0      		rcall USART_Receive
 2674               	.LVL289:
 459:main.c        **** 			if (commonChar == '1') {
 2675               		.loc 3 459 0
 2676 04ec 8133      		cpi r24,lo8(49)
 2677 04ee 01F4      		brne .L170
 460:main.c        **** 				resetCommonLines = 1;
 2678               		.loc 3 460 0
 2679 04f0 6624      		clr r6
 2680 04f2 6394      		inc r6
 2681 04f4 00C0      		rjmp .L156
 2682               	.L170:
 461:main.c        **** 			}
 462:main.c        **** 			else if (commonChar == '0') {
 2683               		.loc 3 462 0
 2684 04f6 8033      		cpi r24,lo8(48)
 2685 04f8 01F0      		breq .+2
 2686 04fa 00C0      		rjmp .L71
 463:main.c        **** 				resetCommonLines = 0;
 2687               		.loc 3 463 0
 2688 04fc 612C      		mov r6,__zero_reg__
 2689 04fe 00C0      		rjmp .L72
 2690               	.LVL290:
 2691               	.L149:
 2692               	.LBE79:
 464:main.c        **** 			}
 465:main.c        **** 		}
 466:main.c        **** 		
 467:main.c        **** 		// Send back the PCB version number
 468:main.c        **** 		else if (receivedChar == READ_PCB_VERSION) {
 2693               		.loc 3 468 0
 2694 0500 8836      		cpi r24,lo8(104)
 2695 0502 01F0      		breq .L157
 469:main.c        **** 			USART_Transmit(PCB_VERSION);
 470:main.c        **** 		}
 471:main.c        **** 		
 472:main.c        **** 		// Send back the firmware version number
 473:main.c        **** 		else if (receivedChar == READ_FIRMWARE_VERSION) {
 2696               		.loc 3 473 0
 2697 0504 8635      		cpi r24,lo8(86)
 2698 0506 01F0      		breq .+2
 2699 0508 00C0      		rjmp .L71
 2700               	.L157:
 474:main.c        **** 			USART_Transmit(FIRMWARE_VERSION);
 2701               		.loc 3 474 0
 2702 050a 82E0      		ldi r24,lo8(2)
 2703 050c 00D0      		rcall USART_Transmit
 2704               	.LVL291:
 2705 050e 00C0      		rjmp .L71
 2706               		.cfi_endproc
 2707               	.LFE35:
 2709               		.comm	flashChipIdBuffer,2,1
 2710               		.comm	eepromBuffer,8,1
 2711               		.comm	receivedChar,1,1
 2712               		.comm	receivedBuffer,129,1
 2713               		.text
 2714               	.Letext0:
 2715               		.file 4 "c:\\winavr-20100110\\avr\\include\\stdint.h"
 2716               		.file 5 "c:\\winavr-20100110\\avr\\include\\stdlib.h"
DEFINED SYMBOLS
                            *ABS*:00000000 main.c
C:\Users\Alex\AppData\Local\Temp\ccvd2Zzg.s:2      *ABS*:0000003e __SP_H__
C:\Users\Alex\AppData\Local\Temp\ccvd2Zzg.s:3      *ABS*:0000003d __SP_L__
C:\Users\Alex\AppData\Local\Temp\ccvd2Zzg.s:4      *ABS*:0000003f __SREG__
C:\Users\Alex\AppData\Local\Temp\ccvd2Zzg.s:5      *ABS*:00000000 __tmp_reg__
C:\Users\Alex\AppData\Local\Temp\ccvd2Zzg.s:6      *ABS*:00000001 __zero_reg__
C:\Users\Alex\AppData\Local\Temp\ccvd2Zzg.s:12     .text:00000000 USART_Receive
C:\Users\Alex\AppData\Local\Temp\ccvd2Zzg.s:34     .text:00000008 USART_Transmit
C:\Users\Alex\AppData\Local\Temp\ccvd2Zzg.s:55     .text:00000010 usart_read_bytes
                            *COM*:00000081 receivedBuffer
C:\Users\Alex\AppData\Local\Temp\ccvd2Zzg.s:121    .text:0000003c usart_read_chars
C:\Users\Alex\AppData\Local\Temp\ccvd2Zzg.s:165    .text:00000058 rd_wr_csmreq_cs2_reset
C:\Users\Alex\AppData\Local\Temp\ccvd2Zzg.s:187    .text:00000062 gb_mode
C:\Users\Alex\AppData\Local\Temp\ccvd2Zzg.s:214    .text:00000072 set_16bit_address
C:\Users\Alex\AppData\Local\Temp\ccvd2Zzg.s:233    .text:00000078 read_8bit_data
C:\Users\Alex\AppData\Local\Temp\ccvd2Zzg.s:273    .text:0000008a write_8bit_data
C:\Users\Alex\AppData\Local\Temp\ccvd2Zzg.s:347    .text:000000c4 gba_mode
C:\Users\Alex\AppData\Local\Temp\ccvd2Zzg.s:374    .text:000000d4 gba_set_24bit_address
C:\Users\Alex\AppData\Local\Temp\ccvd2Zzg.s:427    .text:00000100 gba_read_16bit_data
C:\Users\Alex\AppData\Local\Temp\ccvd2Zzg.s:475    .text:0000011e gba_read_ram_8bit_data
C:\Users\Alex\AppData\Local\Temp\ccvd2Zzg.s:515    .text:00000130 gba_write_ram_8bit_data
C:\Users\Alex\AppData\Local\Temp\ccvd2Zzg.s:582    .text:0000015e gba_eeprom_mode
C:\Users\Alex\AppData\Local\Temp\ccvd2Zzg.s:610    .text:00000170 gba_eeprom_set_address
C:\Users\Alex\AppData\Local\Temp\ccvd2Zzg.s:750    .text:000001d8 gba_eeprom_read
                            *COM*:00000008 eepromBuffer
C:\Users\Alex\AppData\Local\Temp\ccvd2Zzg.s:882    .text:00000232 gba_eeprom_write
C:\Users\Alex\AppData\Local\Temp\ccvd2Zzg.s:998    .text:00000284 flash_write_bus_cycle
C:\Users\Alex\AppData\Local\Temp\ccvd2Zzg.s:1057   .text:000002ac flash_read_chip_id
                            *COM*:00000002 flashChipIdBuffer
C:\Users\Alex\AppData\Local\Temp\ccvd2Zzg.s:1146   .text:0000030e flash_switch_bank
C:\Users\Alex\AppData\Local\Temp\ccvd2Zzg.s:1195   .text:00000334 flash_erase_4k_sector
C:\Users\Alex\AppData\Local\Temp\ccvd2Zzg.s:1269   .text:0000037c flash_write_byte
C:\Users\Alex\AppData\Local\Temp\ccvd2Zzg.s:1339   .text:000003b4 flash_write_sector
C:\Users\Alex\AppData\Local\Temp\ccvd2Zzg.s:1451   .text:00000420 setup
C:\Users\Alex\AppData\Local\Temp\ccvd2Zzg.s:1536   .text.startup:00000000 main
                            *COM*:00000001 receivedChar

UNDEFINED SYMBOLS
strtol
atoi
__do_clear_bss
