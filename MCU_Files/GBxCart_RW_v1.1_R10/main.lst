   1               		.file	"main.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               	.global	USART_Receive
  12               	USART_Receive:
  13               	.LFB12:
  14               		.file 1 "setup.c"
   1:setup.c       **** /*
   2:setup.c       ****  GBxCart RW
   3:setup.c       ****  PCB version: 1.1 or 1.2
   4:setup.c       ****  Firmware version: R10
   5:setup.c       ****  Author: Alex from insideGadgets (www.insidegadgets.com)
   6:setup.c       ****  Created: 7/11/2016
   7:setup.c       ****  Last Modified: 19/06/2018
   8:setup.c       ****  
   9:setup.c       ****  */
  10:setup.c       ****  
  11:setup.c       **** #ifndef cbi
  12:setup.c       **** #define cbi(sfr, bit) (_SFR_BYTE(sfr) &= ~_BV(bit))
  13:setup.c       **** #endif
  14:setup.c       **** #ifndef sbi
  15:setup.c       **** #define sbi(sfr, bit) (_SFR_BYTE(sfr) |= _BV(bit))
  16:setup.c       **** #endif
  17:setup.c       **** 
  18:setup.c       **** #ifndef NULL
  19:setup.c       **** #define NULL ((void *)0)
  20:setup.c       **** #endif
  21:setup.c       **** 
  22:setup.c       **** #define LOW 0
  23:setup.c       **** #define HIGH 1
  24:setup.c       **** #define false 0
  25:setup.c       **** #define true 1
  26:setup.c       **** 
  27:setup.c       **** #define SWITCH_DETECT PD2
  28:setup.c       **** #define ACTIVITY_LED PD3
  29:setup.c       **** #define LED_5V PD7
  30:setup.c       **** #define LED_3V PE0
  31:setup.c       **** 
  32:setup.c       **** #define WR_PIN PD6
  33:setup.c       **** #define RD_PIN PD5
  34:setup.c       **** #define CS_MREQ_PIN PD4
  35:setup.c       **** #define CS2_PIN PE2
  36:setup.c       **** #define AUDIO_PIN PE1
  37:setup.c       **** 
  38:setup.c       **** #define wrPin_high	PORTD |= (1<<WR_PIN);
  39:setup.c       **** #define wrPin_low		PORTD &= ~(1<<WR_PIN);
  40:setup.c       **** #define rdPin_high	PORTD |= (1<<RD_PIN);
  41:setup.c       **** #define rdPin_low		PORTD &= ~(1<<RD_PIN);
  42:setup.c       **** #define cs_mreqPin_high		PORTD |= (1<<CS_MREQ_PIN);
  43:setup.c       **** #define cs_mreqPin_low		PORTD &= ~(1<<CS_MREQ_PIN);
  44:setup.c       **** #define cs2Pin_high		PORTE |= (1<<CS2_PIN);
  45:setup.c       **** #define cs2Pin_low		PORTE &= ~(1<<CS2_PIN);
  46:setup.c       **** #define audioPin_high	PORTE |= (1<<AUDIO_PIN);
  47:setup.c       **** #define audioPin_low		PORTE &= ~(1<<AUDIO_PIN);
  48:setup.c       **** 
  49:setup.c       **** #define GB_MODE 1
  50:setup.c       **** #define GBA_MODE 2
  51:setup.c       **** 
  52:setup.c       **** // GB/GBC
  53:setup.c       **** #define PORT_ADDR7_0 PORTB
  54:setup.c       **** #define PORT_ADDR15_8 PORTA
  55:setup.c       **** #define PORT_DATA7_0 PORTC
  56:setup.c       **** 
  57:setup.c       **** #define DDR_ADDR7_0 DDRB
  58:setup.c       **** #define DDR_ADDR15_8 DDRA
  59:setup.c       **** #define DDR_DATA7_0 DDRC
  60:setup.c       **** 
  61:setup.c       **** #define PIN_ADDR7_0 PINB
  62:setup.c       **** #define PIN_ADDR15_8 PINA
  63:setup.c       **** #define PIN_DATA7_0 PINC
  64:setup.c       **** 
  65:setup.c       **** #define BANK_WRITE 0
  66:setup.c       **** #define MEMORY_WRITE 1
  67:setup.c       **** 
  68:setup.c       **** // GBA
  69:setup.c       **** #define EEPROM_WRITE 1
  70:setup.c       **** #define EEPROM_READ 0
  71:setup.c       **** 
  72:setup.c       **** #define EEPROM_NONE 0
  73:setup.c       **** #define EEPROM_4KBIT 1
  74:setup.c       **** #define EEPROM_64KBIT 2
  75:setup.c       **** 
  76:setup.c       **** #define AD0 PB0
  77:setup.c       **** #define ad0Pin_high		PORTB |= (1<<AD0);
  78:setup.c       **** #define ad0Pin_low		PORTB &= ~(1<<AD0);
  79:setup.c       **** 
  80:setup.c       **** #define A23 PC7
  81:setup.c       **** #define a23Pin_high		PORTC |= (1<<A23);
  82:setup.c       **** #define a23Pin_low		PORTC &= ~(1<<A23);
  83:setup.c       **** 
  84:setup.c       **** #define GBA_DDR_ROM_ADDR7_0 DDRB
  85:setup.c       **** #define GBA_DDR_ROM_ADDR15_8 DDRA
  86:setup.c       **** #define GBA_DDR_ROM_ADDR23_16 DDRC
  87:setup.c       **** #define GBA_DDR_ROM_DATA7_0 DDRB
  88:setup.c       **** #define GBA_DDR_ROM_DATA15_8 DDRA
  89:setup.c       **** #define GBA_DDR_RAM_DATA7_0 DDRC
  90:setup.c       **** #define GBA_DDR_EEPROM_DATA7_0 DDRB
  91:setup.c       **** 
  92:setup.c       **** #define GBA_PORT_ROM_ADDR7_0 PORTB
  93:setup.c       **** #define GBA_PORT_ROM_ADDR15_8 PORTA
  94:setup.c       **** #define GBA_PORT_ROM_ADDR23_16 PORTC
  95:setup.c       **** #define GBA_PORT_ROM_DATA7_0 PORTB
  96:setup.c       **** #define GBA_PORT_ROM_DATA15_8 PORTA
  97:setup.c       **** #define GBA_PORT_RAM_DATA7_0 PORTC
  98:setup.c       **** #define GBA_PORT_EEPROM_DATA7_0 PORTB
  99:setup.c       **** 
 100:setup.c       **** #define GBA_PIN_ROM_DATA7_0 PINB
 101:setup.c       **** #define GBA_PIN_ROM_DATA15_8 PINA
 102:setup.c       **** #define GBA_PIN_RAM_DATA7_0 PINC
 103:setup.c       **** #define GBA_PIN_EEPROM_DATA7_0 PINB
 104:setup.c       **** 
 105:setup.c       **** // GB/GBC commands
 106:setup.c       **** #define SET_START_ADDRESS 'A'
 107:setup.c       **** #define READ_ROM_RAM 'R'
 108:setup.c       **** #define WRITE_RAM 'W'
 109:setup.c       **** #define SET_BANK 'B'
 110:setup.c       **** #define GB_CART_MODE 'G'
 111:setup.c       **** 
 112:setup.c       **** // GBA commands
 113:setup.c       **** #define GBA_READ_ROM 'r'
 114:setup.c       **** #define GBA_READ_ROM_256BYTE 'j'
 115:setup.c       **** #define GBA_READ_SRAM 'm'
 116:setup.c       **** #define GBA_WRITE_SRAM 'w'
 117:setup.c       **** #define GBA_WRITE_ONE_BYTE_SRAM 'o'
 118:setup.c       **** #define GBA_CART_MODE 'g'
 119:setup.c       **** 
 120:setup.c       **** #define GBA_FLASH_READ_ID 'i'
 121:setup.c       **** #define GBA_FLASH_SET_BANK 'k'
 122:setup.c       **** #define GBA_FLASH_4K_SECTOR_ERASE 's'
 123:setup.c       **** #define GBA_FLASH_WRITE_BYTE 'b'
 124:setup.c       **** #define GBA_FLASH_WRITE_ATMEL 'a'
 125:setup.c       **** 
 126:setup.c       **** #define GBA_SET_EEPROM_SIZE 'S'
 127:setup.c       **** #define GBA_READ_EEPROM 'e'
 128:setup.c       **** #define GBA_WRITE_EEPROM 'p'
 129:setup.c       **** 
 130:setup.c       **** // Flash Cart commands
 131:setup.c       **** #define GB_FLASH_WE_PIN 'P'
 132:setup.c       **** 	#define WE_AS_AUDIO_PIN 'A'
 133:setup.c       **** 	#define WE_AS_WR_PIN 'W'
 134:setup.c       **** 
 135:setup.c       **** #define GB_FLASH_PROGRAM_METHOD 'E'
 136:setup.c       **** 	#define GB_FLASH_PROGRAM_555 0
 137:setup.c       **** 	#define GB_FLASH_PROGRAM_AAA 1
 138:setup.c       **** 	#define GB_FLASH_PROGRAM_555_BIT01_SWAPPED 2
 139:setup.c       **** 	#define GB_FLASH_PROGRAM_AAA_BIT01_SWAPPED 3
 140:setup.c       **** 	#define GB_FLASH_PROGRAM_5555 4
 141:setup.c       **** 
 142:setup.c       **** #define GB_FLASH_WRITE_BYTE 'F'
 143:setup.c       **** #define GB_FLASH_WRITE_64BYTE 'T'
 144:setup.c       **** 
 145:setup.c       **** #define GBA_FLASH_CART_WRITE_BYTE 'n'
 146:setup.c       **** #define GBA_FLASH_WRITE_64BYTE 'q'
 147:setup.c       **** #define GBA_FLASH_WRITE_256BYTE 't'
 148:setup.c       **** #define GBA_FLASH_WRITE_INTEL_64BYTE 'l'
 149:setup.c       **** 
 150:setup.c       **** // General commands
 151:setup.c       **** #define SEND_ACK '1'
 152:setup.c       **** #define CART_MODE 'C'
 153:setup.c       **** #define SET_INPUT 'I'
 154:setup.c       **** #define SET_OUTPUT 'O'
 155:setup.c       **** #define SET_OUTPUT_LOW 'L'
 156:setup.c       **** #define SET_OUTPUT_HIGH 'H'
 157:setup.c       **** #define READ_INPUT 'D'
 158:setup.c       **** #define RESET_COMMON_LINES 'M'
 159:setup.c       **** #define READ_FIRMWARE_VERSION 'V'
 160:setup.c       **** #define READ_PCB_VERSION 'h'
 161:setup.c       **** 
 162:setup.c       **** #define RESET_AVR '*'
 163:setup.c       **** #define RESET_VALUE 0x7E5E1
 164:setup.c       **** 
 165:setup.c       **** 
 166:setup.c       **** char receivedBuffer[256];
 167:setup.c       **** char receivedChar;
 168:setup.c       **** uint8_t eepromBuffer[8];
 169:setup.c       **** uint8_t flashChipIdBuffer[2];
 170:setup.c       **** 
 171:setup.c       **** char flashWriteWePin;
 172:setup.c       **** uint16_t flashWriteCycle[3][2];
 173:setup.c       **** 
 174:setup.c       **** 
 175:setup.c       **** // Receive USART data
 176:setup.c       **** uint8_t USART_Receive(void) {
  15               		.loc 1 176 0
  16               		.cfi_startproc
  17               	/* prologue: function */
  18               	/* frame size = 0 */
  19               	/* stack size = 0 */
  20               	.L__stack_usage = 0
  21               	.L2:
 177:setup.c       **** 	while ( !(UCSRA & (1<<RXC)) ); // Wait for data to be received
  22               		.loc 1 177 0 discriminator 1
  23 0000 5F9B      		sbis 0xb,7
  24 0002 00C0      		rjmp .L2
 178:setup.c       **** 	return UDR; // Get and return received data from buffer
  25               		.loc 1 178 0
  26 0004 8CB1      		in r24,0xc
 179:setup.c       **** }
  27               		.loc 1 179 0
  28 0006 0895      		ret
  29               		.cfi_endproc
  30               	.LFE12:
  32               	.global	USART_Transmit
  34               	USART_Transmit:
  35               	.LFB13:
 180:setup.c       **** 
 181:setup.c       **** // Transmit USART data
 182:setup.c       **** void USART_Transmit(unsigned char data) {
  36               		.loc 1 182 0
  37               		.cfi_startproc
  38               	/* prologue: function */
  39               	/* frame size = 0 */
  40               	/* stack size = 0 */
  41               	.L__stack_usage = 0
  42               	.LVL0:
  43               	.L6:
 183:setup.c       **** 	while ( !( UCSRA & (1<<UDRE)) ); // Wait for empty transmit buffer
  44               		.loc 1 183 0 discriminator 1
  45 0008 5D9B      		sbis 0xb,5
  46 000a 00C0      		rjmp .L6
 184:setup.c       **** 	UDR = data;
  47               		.loc 1 184 0
  48 000c 8CB9      		out 0xc,r24
  49 000e 0895      		ret
  50               		.cfi_endproc
  51               	.LFE13:
  53               	.global	usart_read_bytes
  55               	usart_read_bytes:
  56               	.LFB14:
 185:setup.c       **** }
 186:setup.c       **** 
 187:setup.c       **** // Read 1-256 bytes from the USART 
 188:setup.c       **** void usart_read_bytes(int count) {
  57               		.loc 1 188 0
  58               		.cfi_startproc
  59               	.LVL1:
  60 0010 0F93      		push r16
  61               	.LCFI0:
  62               		.cfi_def_cfa_offset 3
  63               		.cfi_offset 16, -2
  64 0012 1F93      		push r17
  65               	.LCFI1:
  66               		.cfi_def_cfa_offset 4
  67               		.cfi_offset 17, -3
  68 0014 CF93      		push r28
  69               	.LCFI2:
  70               		.cfi_def_cfa_offset 5
  71               		.cfi_offset 28, -4
  72 0016 DF93      		push r29
  73               	.LCFI3:
  74               		.cfi_def_cfa_offset 6
  75               		.cfi_offset 29, -5
  76               	/* prologue: function */
  77               	/* frame size = 0 */
  78               	/* stack size = 4 */
  79               	.L__stack_usage = 4
  80 0018 8C01      		movw r16,r24
  81               	.LVL2:
  82               	.LBB67:
 189:setup.c       **** 	for (int x = 0; x < count; x++) {
  83               		.loc 1 189 0
  84 001a C0E0      		ldi r28,lo8(receivedBuffer)
  85 001c D0E0      		ldi r29,hi8(receivedBuffer)
  86               	.LVL3:
  87               	.L10:
  88               		.loc 1 189 0 is_stmt 0 discriminator 1
  89 001e CE01      		movw r24,r28
  90 0020 8050      		subi r24,lo8(receivedBuffer)
  91 0022 9040      		sbci r25,hi8(receivedBuffer)
  92               	.LVL4:
  93 0024 8017      		cp r24,r16
  94 0026 9107      		cpc r25,r17
  95 0028 04F4      		brge .L12
 190:setup.c       **** 		receivedBuffer[x] = USART_Receive();
  96               		.loc 1 190 0 is_stmt 1 discriminator 3
  97 002a 00D0      		rcall USART_Receive
  98               	.LVL5:
  99 002c 8993      		st Y+,r24
 100               	.LVL6:
 101 002e 00C0      		rjmp .L10
 102               	.LVL7:
 103               	.L12:
 104               	/* epilogue start */
 105               	.LBE67:
 191:setup.c       **** 	}
 192:setup.c       **** }
 106               		.loc 1 192 0
 107 0030 DF91      		pop r29
 108 0032 CF91      		pop r28
 109 0034 1F91      		pop r17
 110 0036 0F91      		pop r16
 111               	.LVL8:
 112 0038 0895      		ret
 113               		.cfi_endproc
 114               	.LFE14:
 116               	.global	usart_read_chars
 118               	usart_read_chars:
 119               	.LFB15:
 193:setup.c       **** 
 194:setup.c       **** // Read the USART until a 0 (string terminator byte) is received
 195:setup.c       **** void usart_read_chars(void) {
 120               		.loc 1 195 0
 121               		.cfi_startproc
 122 003a CF93      		push r28
 123               	.LCFI4:
 124               		.cfi_def_cfa_offset 3
 125               		.cfi_offset 28, -2
 126 003c DF93      		push r29
 127               	.LCFI5:
 128               		.cfi_def_cfa_offset 4
 129               		.cfi_offset 29, -3
 130               	/* prologue: function */
 131               	/* frame size = 0 */
 132               	/* stack size = 2 */
 133               	.L__stack_usage = 2
 134               	.LVL9:
 135 003e C0E0      		ldi r28,lo8(receivedBuffer)
 136 0040 D0E0      		ldi r29,hi8(receivedBuffer)
 137               	.LVL10:
 138               	.L14:
 196:setup.c       **** 	int x = 0;
 197:setup.c       **** 	while (1) {
 198:setup.c       **** 		receivedBuffer[x] = USART_Receive();
 139               		.loc 1 198 0
 140 0042 00D0      		rcall USART_Receive
 141               	.LVL11:
 142 0044 8993      		st Y+,r24
 143               	.LVL12:
 199:setup.c       **** 		if (receivedBuffer[x] == 0) {
 144               		.loc 1 199 0
 145 0046 8111      		cpse r24,__zero_reg__
 146 0048 00C0      		rjmp .L14
 147               	/* epilogue start */
 200:setup.c       **** 			break;
 201:setup.c       **** 		}
 202:setup.c       **** 		x++;
 203:setup.c       **** 	}
 204:setup.c       **** }
 148               		.loc 1 204 0
 149 004a DF91      		pop r29
 150 004c CF91      		pop r28
 151               	.LVL13:
 152 004e 0895      		ret
 153               		.cfi_endproc
 154               	.LFE15:
 156               	.global	rd_wr_csmreq_cs2_reset
 158               	rd_wr_csmreq_cs2_reset:
 159               	.LFB16:
 205:setup.c       **** 
 206:setup.c       **** // Turn RD, WR, CS/MREQ and CS2 to high so they are deselected (reset state)
 207:setup.c       **** void rd_wr_csmreq_cs2_reset(void) {
 160               		.loc 1 207 0
 161               		.cfi_startproc
 162               	/* prologue: function */
 163               	/* frame size = 0 */
 164               	/* stack size = 0 */
 165               	.L__stack_usage = 0
 208:setup.c       **** 	cs2Pin_high; // CS2 off
 166               		.loc 1 208 0
 167 0050 3A9A      		sbi 0x7,2
 209:setup.c       **** 	cs_mreqPin_high; // CS/MREQ off
 168               		.loc 1 209 0
 169 0052 949A      		sbi 0x12,4
 210:setup.c       **** 	rdPin_high; // RD off
 170               		.loc 1 210 0
 171 0054 959A      		sbi 0x12,5
 211:setup.c       **** 	wrPin_high; // WR off
 172               		.loc 1 211 0
 173 0056 969A      		sbi 0x12,6
 174 0058 0895      		ret
 175               		.cfi_endproc
 176               	.LFE16:
 178               	.global	gb_mode
 180               	gb_mode:
 181               	.LFB17:
 212:setup.c       **** }
 213:setup.c       **** 
 214:setup.c       **** 
 215:setup.c       **** 
 216:setup.c       **** // ****** Gameboy / Gameboy Colour functions ******
 217:setup.c       **** 
 218:setup.c       **** // Set Gameboy mode
 219:setup.c       **** void gb_mode(void) {
 182               		.loc 1 219 0
 183               		.cfi_startproc
 184               	/* prologue: function */
 185               	/* frame size = 0 */
 186               	/* stack size = 0 */
 187               	.L__stack_usage = 0
 220:setup.c       **** 	// Set inputs
 221:setup.c       **** 	PORT_DATA7_0 = 0;
 188               		.loc 1 221 0
 189 005a 15BA      		out 0x15,__zero_reg__
 222:setup.c       **** 	DDR_DATA7_0 = 0;
 190               		.loc 1 222 0
 191 005c 14BA      		out 0x14,__zero_reg__
 223:setup.c       **** 	
 224:setup.c       **** 	// Set outputs
 225:setup.c       **** 	PORT_ADDR7_0 = 0;
 192               		.loc 1 225 0
 193 005e 18BA      		out 0x18,__zero_reg__
 226:setup.c       **** 	PORT_ADDR15_8 = 0;
 194               		.loc 1 226 0
 195 0060 1BBA      		out 0x1b,__zero_reg__
 227:setup.c       **** 	DDR_ADDR7_0 = 0xFF;
 196               		.loc 1 227 0
 197 0062 8FEF      		ldi r24,lo8(-1)
 198 0064 87BB      		out 0x17,r24
 228:setup.c       **** 	DDR_ADDR15_8 = 0xFF;
 199               		.loc 1 228 0
 200 0066 8ABB      		out 0x1a,r24
 201 0068 0895      		ret
 202               		.cfi_endproc
 203               	.LFE17:
 205               	.global	set_16bit_address
 207               	set_16bit_address:
 208               	.LFB18:
 229:setup.c       **** }
 230:setup.c       **** 
 231:setup.c       **** // Set the 16 bit address on A15-0
 232:setup.c       **** void set_16bit_address(uint16_t address) {
 209               		.loc 1 232 0
 210               		.cfi_startproc
 211               	.LVL14:
 212               	/* prologue: function */
 213               	/* frame size = 0 */
 214               	/* stack size = 0 */
 215               	.L__stack_usage = 0
 233:setup.c       **** 	PORT_ADDR15_8 = (address >> 8);
 216               		.loc 1 233 0
 217 006a 9BBB      		out 0x1b,r25
 234:setup.c       **** 	PORT_ADDR7_0 = (address & 0xFF);
 218               		.loc 1 234 0
 219 006c 88BB      		out 0x18,r24
 220 006e 0895      		ret
 221               		.cfi_endproc
 222               	.LFE18:
 224               	.global	read_8bit_data
 226               	read_8bit_data:
 227               	.LFB19:
 235:setup.c       **** }
 236:setup.c       **** 
 237:setup.c       **** // Set the address and read a byte from the 8 bit data line
 238:setup.c       **** uint8_t read_8bit_data(uint16_t address) {
 228               		.loc 1 238 0
 229               		.cfi_startproc
 230               	.LVL15:
 231               	/* prologue: function */
 232               	/* frame size = 0 */
 233               	/* stack size = 0 */
 234               	.L__stack_usage = 0
 239:setup.c       **** 	set_16bit_address(address);
 235               		.loc 1 239 0
 236 0070 00D0      		rcall set_16bit_address
 237               	.LVL16:
 240:setup.c       **** 	
 241:setup.c       **** 	cs_mreqPin_low;
 238               		.loc 1 241 0
 239 0072 9498      		cbi 0x12,4
 242:setup.c       **** 	rdPin_low;
 240               		.loc 1 242 0
 241 0074 9598      		cbi 0x12,5
 243:setup.c       **** 	
 244:setup.c       **** 	asm volatile("nop"); // Delay a little (minimum needed is 1 nops, 2 nops for GB camera)
 242               		.loc 1 244 0
 243               	/* #APP */
 244               	 ;  244 "setup.c" 1
 245 0076 0000      		nop
 246               	 ;  0 "" 2
 245:setup.c       **** 	asm volatile("nop");
 247               		.loc 1 245 0
 248               	 ;  245 "setup.c" 1
 249 0078 0000      		nop
 250               	 ;  0 "" 2
 246:setup.c       **** 	uint8_t data = PIN_DATA7_0; // Read data
 251               		.loc 1 246 0
 252               	/* #NOAPP */
 253 007a 83B3      		in r24,0x13
 254               	.LVL17:
 247:setup.c       **** 	
 248:setup.c       **** 	rdPin_high;
 255               		.loc 1 248 0
 256 007c 959A      		sbi 0x12,5
 249:setup.c       **** 	cs_mreqPin_high;
 257               		.loc 1 249 0
 258 007e 949A      		sbi 0x12,4
 250:setup.c       **** 	
 251:setup.c       **** 	return data;
 252:setup.c       **** }
 259               		.loc 1 252 0
 260 0080 0895      		ret
 261               		.cfi_endproc
 262               	.LFE19:
 264               	.global	write_8bit_data
 266               	write_8bit_data:
 267               	.LFB20:
 253:setup.c       **** 
 254:setup.c       **** // Set the address and write a byte to the 8 bit data line and pulse cs/mREQ if writing to RAM
 255:setup.c       **** void write_8bit_data(uint16_t address, uint8_t data, uint8_t type) {
 268               		.loc 1 255 0
 269               		.cfi_startproc
 270               	.LVL18:
 271 0082 CF93      		push r28
 272               	.LCFI6:
 273               		.cfi_def_cfa_offset 3
 274               		.cfi_offset 28, -2
 275 0084 DF93      		push r29
 276               	.LCFI7:
 277               		.cfi_def_cfa_offset 4
 278               		.cfi_offset 29, -3
 279               	/* prologue: function */
 280               	/* frame size = 0 */
 281               	/* stack size = 2 */
 282               	.L__stack_usage = 2
 283 0086 D62F      		mov r29,r22
 284 0088 C42F      		mov r28,r20
 256:setup.c       **** 	set_16bit_address(address);
 285               		.loc 1 256 0
 286 008a 00D0      		rcall set_16bit_address
 287               	.LVL19:
 257:setup.c       **** 	
 258:setup.c       **** 	DDR_DATA7_0 = 0xFF; // Set data pins as outputs
 288               		.loc 1 258 0
 289 008c 8FEF      		ldi r24,lo8(-1)
 290 008e 84BB      		out 0x14,r24
 259:setup.c       **** 	PORT_DATA7_0 = data; // Set data
 291               		.loc 1 259 0
 292 0090 D5BB      		out 0x15,r29
 260:setup.c       **** 	
 261:setup.c       **** 	// Pulse WR and mREQ if the type matches
 262:setup.c       **** 	wrPin_low;
 293               		.loc 1 262 0
 294 0092 9698      		cbi 0x12,6
 263:setup.c       **** 	if (type == MEMORY_WRITE) {
 295               		.loc 1 263 0
 296 0094 C130      		cpi r28,lo8(1)
 297 0096 01F4      		brne .L21
 264:setup.c       **** 		cs_mreqPin_low;
 298               		.loc 1 264 0
 299 0098 9498      		cbi 0x12,4
 300               	.L21:
 265:setup.c       **** 	}
 266:setup.c       **** 	
 267:setup.c       **** 	asm volatile("nop");
 301               		.loc 1 267 0
 302               	/* #APP */
 303               	 ;  267 "setup.c" 1
 304 009a 0000      		nop
 305               	 ;  0 "" 2
 268:setup.c       **** 	
 269:setup.c       **** 	if (type == MEMORY_WRITE) {
 306               		.loc 1 269 0
 307               	/* #NOAPP */
 308 009c C130      		cpi r28,lo8(1)
 309 009e 01F4      		brne .L22
 270:setup.c       **** 		cs_mreqPin_high;
 310               		.loc 1 270 0
 311 00a0 949A      		sbi 0x12,4
 312               	.L22:
 271:setup.c       **** 	}
 272:setup.c       **** 	wrPin_high;
 313               		.loc 1 272 0
 314 00a2 969A      		sbi 0x12,6
 273:setup.c       **** 	
 274:setup.c       **** 	// Clear data outputs and set data pins as inputs
 275:setup.c       **** 	PORT_DATA7_0 = 0;
 315               		.loc 1 275 0
 316 00a4 15BA      		out 0x15,__zero_reg__
 276:setup.c       **** 	DDR_DATA7_0 = 0;
 317               		.loc 1 276 0
 318 00a6 14BA      		out 0x14,__zero_reg__
 319               	/* epilogue start */
 277:setup.c       **** }
 320               		.loc 1 277 0
 321 00a8 DF91      		pop r29
 322               	.LVL20:
 323 00aa CF91      		pop r28
 324               	.LVL21:
 325 00ac 0895      		ret
 326               		.cfi_endproc
 327               	.LFE20:
 329               	.global	gba_mode
 331               	gba_mode:
 332               	.LFB21:
 278:setup.c       **** 
 279:setup.c       **** 
 280:setup.c       **** 
 281:setup.c       **** // ****** Gameboy Advance functions ****** 
 282:setup.c       **** 
 283:setup.c       **** // Set GBA mode
 284:setup.c       **** void gba_mode(void) {
 333               		.loc 1 284 0
 334               		.cfi_startproc
 335               	/* prologue: function */
 336               	/* frame size = 0 */
 337               	/* stack size = 0 */
 338               	.L__stack_usage = 0
 285:setup.c       **** 	// Set outputs for reading ROM addresses as default
 286:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = 0;
 339               		.loc 1 286 0
 340 00ae 18BA      		out 0x18,__zero_reg__
 287:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = 0;
 341               		.loc 1 287 0
 342 00b0 1BBA      		out 0x1b,__zero_reg__
 288:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = 0;
 343               		.loc 1 288 0
 344 00b2 15BA      		out 0x15,__zero_reg__
 289:setup.c       **** 	GBA_DDR_ROM_ADDR7_0 = 0xFF;
 345               		.loc 1 289 0
 346 00b4 8FEF      		ldi r24,lo8(-1)
 347 00b6 87BB      		out 0x17,r24
 290:setup.c       **** 	GBA_DDR_ROM_ADDR15_8 = 0xFF;
 348               		.loc 1 290 0
 349 00b8 8ABB      		out 0x1a,r24
 291:setup.c       **** 	GBA_DDR_ROM_ADDR23_16 = 0xFF;
 350               		.loc 1 291 0
 351 00ba 84BB      		out 0x14,r24
 352 00bc 0895      		ret
 353               		.cfi_endproc
 354               	.LFE21:
 356               	.global	gba_set_24bit_address
 358               	gba_set_24bit_address:
 359               	.LFB22:
 292:setup.c       **** }
 293:setup.c       **** 
 294:setup.c       **** // Set the 24 bit address on A23-0
 295:setup.c       **** void gba_set_24bit_address(uint32_t address) {	
 360               		.loc 1 295 0
 361               		.cfi_startproc
 362               	.LVL22:
 363 00be 0F93      		push r16
 364               	.LCFI8:
 365               		.cfi_def_cfa_offset 3
 366               		.cfi_offset 16, -2
 367 00c0 1F93      		push r17
 368               	.LCFI9:
 369               		.cfi_def_cfa_offset 4
 370               		.cfi_offset 17, -3
 371               	/* prologue: function */
 372               	/* frame size = 0 */
 373               	/* stack size = 2 */
 374               	.L__stack_usage = 2
 296:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = 0; // Set 0-23 address lines low and set as outputs
 375               		.loc 1 296 0
 376 00c2 15BA      		out 0x15,__zero_reg__
 297:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = 0;
 377               		.loc 1 297 0
 378 00c4 1BBA      		out 0x1b,__zero_reg__
 298:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = 0;
 379               		.loc 1 298 0
 380 00c6 18BA      		out 0x18,__zero_reg__
 299:setup.c       **** 	GBA_DDR_ROM_ADDR23_16 = 0xFF;
 381               		.loc 1 299 0
 382 00c8 2FEF      		ldi r18,lo8(-1)
 383 00ca 24BB      		out 0x14,r18
 300:setup.c       **** 	GBA_DDR_ROM_ADDR15_8 = 0xFF;
 384               		.loc 1 300 0
 385 00cc 2ABB      		out 0x1a,r18
 301:setup.c       **** 	GBA_DDR_ROM_ADDR7_0 = 0xFF;
 386               		.loc 1 301 0
 387 00ce 27BB      		out 0x17,r18
 302:setup.c       **** 	
 303:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = (address >> 16);
 388               		.loc 1 303 0
 389 00d0 8C01      		movw r16,r24
 390 00d2 2227      		clr r18
 391 00d4 3327      		clr r19
 392 00d6 05BB      		out 0x15,r16
 304:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = (address >> 8);
 393               		.loc 1 304 0
 394 00d8 072F      		mov r16,r23
 395 00da 182F      		mov r17,r24
 396 00dc 292F      		mov r18,r25
 397 00de 3327      		clr r19
 398 00e0 0BBB      		out 0x1b,r16
 305:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = (address & 0xFF);
 399               		.loc 1 305 0
 400 00e2 68BB      		out 0x18,r22
 401               	/* epilogue start */
 306:setup.c       **** }
 402               		.loc 1 306 0
 403 00e4 1F91      		pop r17
 404 00e6 0F91      		pop r16
 405 00e8 0895      		ret
 406               		.cfi_endproc
 407               	.LFE22:
 409               	.global	gba_read_16bit_data
 411               	gba_read_16bit_data:
 412               	.LFB23:
 307:setup.c       **** 
 308:setup.c       **** 
 309:setup.c       **** 
 310:setup.c       **** // ---------- ROM/SRAM ----------
 311:setup.c       **** 
 312:setup.c       **** // Read a byte from the 16 bit data line non-sequentially
 313:setup.c       **** uint16_t gba_read_16bit_data(uint32_t address) {
 413               		.loc 1 313 0
 414               		.cfi_startproc
 415               	.LVL23:
 416               	/* prologue: function */
 417               	/* frame size = 0 */
 418               	/* stack size = 0 */
 419               	.L__stack_usage = 0
 314:setup.c       **** 	gba_set_24bit_address(address);
 420               		.loc 1 314 0
 421 00ea 00D0      		rcall gba_set_24bit_address
 422               	.LVL24:
 315:setup.c       **** 	
 316:setup.c       **** 	cs_mreqPin_low;
 423               		.loc 1 316 0
 424 00ec 9498      		cbi 0x12,4
 317:setup.c       **** 	
 318:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = 0; // Set A16-A0 address lines low and set as inputs for the data to be re
 425               		.loc 1 318 0
 426 00ee 1BBA      		out 0x1b,__zero_reg__
 319:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = 0;
 427               		.loc 1 319 0
 428 00f0 18BA      		out 0x18,__zero_reg__
 320:setup.c       **** 	GBA_DDR_ROM_ADDR15_8 = 0;
 429               		.loc 1 320 0
 430 00f2 1ABA      		out 0x1a,__zero_reg__
 321:setup.c       **** 	GBA_DDR_ROM_ADDR7_0 = 0;
 431               		.loc 1 321 0
 432 00f4 17BA      		out 0x17,__zero_reg__
 322:setup.c       **** 	
 323:setup.c       **** 	rdPin_low;
 433               		.loc 1 323 0
 434 00f6 9598      		cbi 0x12,5
 324:setup.c       **** 	asm volatile("nop");
 435               		.loc 1 324 0
 436               	/* #APP */
 437               	 ;  324 "setup.c" 1
 438 00f8 0000      		nop
 439               	 ;  0 "" 2
 325:setup.c       **** 	
 326:setup.c       **** 	uint16_t data = (GBA_PIN_ROM_DATA15_8 << 8) | GBA_PIN_ROM_DATA7_0; // Read data
 440               		.loc 1 326 0
 441               	/* #NOAPP */
 442 00fa 29B3      		in r18,0x19
 443 00fc 86B3      		in r24,0x16
 444               	.LVL25:
 327:setup.c       **** 	
 328:setup.c       **** 	rdPin_high;
 445               		.loc 1 328 0
 446 00fe 959A      		sbi 0x12,5
 329:setup.c       **** 	cs_mreqPin_high;
 447               		.loc 1 329 0
 448 0100 949A      		sbi 0x12,4
 330:setup.c       **** 	
 331:setup.c       **** 	return data;
 449               		.loc 1 331 0
 450 0102 90E0      		ldi r25,0
 332:setup.c       **** }
 451               		.loc 1 332 0
 452 0104 922B      		or r25,r18
 453 0106 0895      		ret
 454               		.cfi_endproc
 455               	.LFE23:
 457               	.global	gba_read_ram_8bit_data
 459               	gba_read_ram_8bit_data:
 460               	.LFB24:
 333:setup.c       **** 
 334:setup.c       **** // Set the address and read a byte from the 8 bit data line
 335:setup.c       **** uint8_t gba_read_ram_8bit_data(uint16_t address) {
 461               		.loc 1 335 0
 462               		.cfi_startproc
 463               	.LVL26:
 464               	/* prologue: function */
 465               	/* frame size = 0 */
 466               	/* stack size = 0 */
 467               	.L__stack_usage = 0
 336:setup.c       **** 	set_16bit_address(address);
 468               		.loc 1 336 0
 469 0108 00D0      		rcall set_16bit_address
 470               	.LVL27:
 337:setup.c       **** 	
 338:setup.c       **** 	rdPin_low;
 471               		.loc 1 338 0
 472 010a 9598      		cbi 0x12,5
 339:setup.c       **** 	cs2Pin_low; // CS2 pin low for SRAM/Flash select
 473               		.loc 1 339 0
 474 010c 3A98      		cbi 0x7,2
 340:setup.c       **** 	
 341:setup.c       **** 	asm volatile("nop"); // Delay a little (minimum needed is 2)
 475               		.loc 1 341 0
 476               	/* #APP */
 477               	 ;  341 "setup.c" 1
 478 010e 0000      		nop
 479               	 ;  0 "" 2
 342:setup.c       **** 	asm volatile("nop");
 480               		.loc 1 342 0
 481               	 ;  342 "setup.c" 1
 482 0110 0000      		nop
 483               	 ;  0 "" 2
 343:setup.c       **** 	
 344:setup.c       **** 	uint8_t data = GBA_PIN_RAM_DATA7_0; // Read data
 484               		.loc 1 344 0
 485               	/* #NOAPP */
 486 0112 83B3      		in r24,0x13
 487               	.LVL28:
 345:setup.c       **** 	
 346:setup.c       **** 	cs2Pin_high;
 488               		.loc 1 346 0
 489 0114 3A9A      		sbi 0x7,2
 347:setup.c       **** 	rdPin_high;
 490               		.loc 1 347 0
 491 0116 959A      		sbi 0x12,5
 348:setup.c       **** 	
 349:setup.c       **** 	return data;
 350:setup.c       **** }
 492               		.loc 1 350 0
 493 0118 0895      		ret
 494               		.cfi_endproc
 495               	.LFE24:
 497               	.global	gba_write_ram_8bit_data
 499               	gba_write_ram_8bit_data:
 500               	.LFB25:
 351:setup.c       **** 
 352:setup.c       **** // Set the address and write a byte to the 8 bit data line 
 353:setup.c       **** void gba_write_ram_8bit_data(uint16_t address, uint8_t data) {
 501               		.loc 1 353 0
 502               		.cfi_startproc
 503               	.LVL29:
 504 011a CF93      		push r28
 505               	.LCFI10:
 506               		.cfi_def_cfa_offset 3
 507               		.cfi_offset 28, -2
 508               	/* prologue: function */
 509               	/* frame size = 0 */
 510               	/* stack size = 1 */
 511               	.L__stack_usage = 1
 512 011c C62F      		mov r28,r22
 354:setup.c       **** 	set_16bit_address(address);
 513               		.loc 1 354 0
 514 011e 00D0      		rcall set_16bit_address
 515               	.LVL30:
 355:setup.c       **** 	
 356:setup.c       **** 	GBA_DDR_RAM_DATA7_0 = 0xFF; // Set data pins as outputs
 516               		.loc 1 356 0
 517 0120 8FEF      		ldi r24,lo8(-1)
 518 0122 84BB      		out 0x14,r24
 357:setup.c       **** 	GBA_PORT_RAM_DATA7_0 = data; // Set data
 519               		.loc 1 357 0
 520 0124 C5BB      		out 0x15,r28
 358:setup.c       **** 	
 359:setup.c       **** 	// Pulse WR
 360:setup.c       **** 	wrPin_low;
 521               		.loc 1 360 0
 522 0126 9698      		cbi 0x12,6
 361:setup.c       **** 	cs2Pin_low; // CS2 pin low for SRAM/Flash select
 523               		.loc 1 361 0
 524 0128 3A98      		cbi 0x7,2
 362:setup.c       **** 	
 363:setup.c       **** 	asm volatile("nop");
 525               		.loc 1 363 0
 526               	/* #APP */
 527               	 ;  363 "setup.c" 1
 528 012a 0000      		nop
 529               	 ;  0 "" 2
 364:setup.c       **** 	asm volatile("nop");
 530               		.loc 1 364 0
 531               	 ;  364 "setup.c" 1
 532 012c 0000      		nop
 533               	 ;  0 "" 2
 365:setup.c       **** 	
 366:setup.c       **** 	cs2Pin_high;
 534               		.loc 1 366 0
 535               	/* #NOAPP */
 536 012e 3A9A      		sbi 0x7,2
 367:setup.c       **** 	wrPin_high;
 537               		.loc 1 367 0
 538 0130 969A      		sbi 0x12,6
 368:setup.c       **** 	
 369:setup.c       **** 	// Clear data outputs and set data pins as inputs
 370:setup.c       **** 	GBA_PORT_RAM_DATA7_0 = 0;
 539               		.loc 1 370 0
 540 0132 15BA      		out 0x15,__zero_reg__
 371:setup.c       **** 	GBA_DDR_RAM_DATA7_0 = 0;
 541               		.loc 1 371 0
 542 0134 14BA      		out 0x14,__zero_reg__
 543               	/* epilogue start */
 372:setup.c       **** }
 544               		.loc 1 372 0
 545 0136 CF91      		pop r28
 546               	.LVL31:
 547 0138 0895      		ret
 548               		.cfi_endproc
 549               	.LFE25:
 551               	.global	gba_eeprom_mode
 553               	gba_eeprom_mode:
 554               	.LFB26:
 373:setup.c       **** 
 374:setup.c       **** 
 375:setup.c       **** 
 376:setup.c       **** // ---------- EEPROM ----------
 377:setup.c       **** 
 378:setup.c       **** // Set address/data all high (includes AD0/A23)
 379:setup.c       **** void gba_eeprom_mode (void) {
 555               		.loc 1 379 0
 556               		.cfi_startproc
 557               	/* prologue: function */
 558               	/* frame size = 0 */
 559               	/* stack size = 0 */
 560               	.L__stack_usage = 0
 380:setup.c       **** 	GBA_DDR_ROM_ADDR7_0 = 0xFF;
 561               		.loc 1 380 0
 562 013a 8FEF      		ldi r24,lo8(-1)
 563 013c 87BB      		out 0x17,r24
 381:setup.c       **** 	GBA_DDR_ROM_ADDR15_8 = 0xFF;
 564               		.loc 1 381 0
 565 013e 8ABB      		out 0x1a,r24
 382:setup.c       **** 	GBA_DDR_ROM_ADDR23_16 = 0xFF;
 566               		.loc 1 382 0
 567 0140 84BB      		out 0x14,r24
 383:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = 0x80;
 568               		.loc 1 383 0
 569 0142 90E8      		ldi r25,lo8(-128)
 570 0144 98BB      		out 0x18,r25
 384:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = 0xFF;
 571               		.loc 1 384 0
 572 0146 8BBB      		out 0x1b,r24
 385:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = 0xFF;
 573               		.loc 1 385 0
 574 0148 85BB      		out 0x15,r24
 575 014a 0895      		ret
 576               		.cfi_endproc
 577               	.LFE26:
 579               	.global	gba_eeprom_set_address
 581               	gba_eeprom_set_address:
 582               	.LFB27:
 386:setup.c       **** }
 387:setup.c       **** 
 388:setup.c       **** // Send out EEPROM address serially (WR clock, AD0 data out)
 389:setup.c       **** void gba_eeprom_set_address(uint16_t address, uint8_t eepromSize, uint8_t command) {
 583               		.loc 1 389 0
 584               		.cfi_startproc
 585               	.LVL32:
 586               	/* prologue: function */
 587               	/* frame size = 0 */
 588               	/* stack size = 0 */
 589               	.L__stack_usage = 0
 390:setup.c       **** 	cs_mreqPin_low;
 590               		.loc 1 390 0
 591 014c 9498      		cbi 0x12,4
 592               	.LVL33:
 391:setup.c       **** 	
 392:setup.c       **** 	int8_t x = 0;
 393:setup.c       **** 	if (eepromSize == EEPROM_64KBIT) {
 593               		.loc 1 393 0
 594 014e 6230      		cpi r22,lo8(2)
 595 0150 01F4      		brne .L30
 394:setup.c       **** 		if (command == EEPROM_READ) {
 596               		.loc 1 394 0
 597 0152 4111      		cpse r20,__zero_reg__
 598 0154 00C0      		rjmp .L31
 395:setup.c       **** 			address |= (1<<15) | (1<<14); // Set upper 2 bits high for read request
 599               		.loc 1 395 0
 600 0156 906C      		ori r25,192
 601               	.LVL34:
 602               	.L40:
 396:setup.c       **** 		}
 397:setup.c       **** 		else {
 398:setup.c       **** 			address |= (1<<15); // Set upper 1 bit high for write request
 399:setup.c       **** 		}
 400:setup.c       **** 		x = 15;
 603               		.loc 1 400 0
 604 0158 2FE0      		ldi r18,lo8(15)
 605               	.L33:
 606               	.LVL35:
 401:setup.c       **** 	}
 402:setup.c       **** 	else {
 403:setup.c       **** 		if (command == EEPROM_READ) {
 404:setup.c       **** 			address |= (1<<7) | (1<<6);
 405:setup.c       **** 		}
 406:setup.c       **** 		else {
 407:setup.c       **** 			address |= (1<<7);
 408:setup.c       **** 		}
 409:setup.c       **** 		x = 7;
 410:setup.c       **** 	}
 411:setup.c       **** 	
 412:setup.c       **** 	// Loop through address, 8 or 16 bits depending on EEPROM (includes the 2 bits for request type)
 413:setup.c       **** 	while (x >= 0) {
 414:setup.c       **** 		if (address & (1<<x)) {
 607               		.loc 1 414 0
 608 015a E1E0      		ldi r30,lo8(1)
 609 015c F0E0      		ldi r31,0
 610 015e 00C0      		rjmp .L32
 611               	.LVL36:
 612               	.L31:
 398:setup.c       **** 		}
 613               		.loc 1 398 0
 614 0160 9068      		ori r25,128
 615               	.LVL37:
 616 0162 00C0      		rjmp .L40
 617               	.L30:
 403:setup.c       **** 			address |= (1<<7) | (1<<6);
 618               		.loc 1 403 0
 619 0164 4111      		cpse r20,__zero_reg__
 620 0166 00C0      		rjmp .L34
 404:setup.c       **** 		}
 621               		.loc 1 404 0
 622 0168 806C      		ori r24,192
 623               	.LVL38:
 624 016a 00C0      		rjmp .L39
 625               	.L34:
 407:setup.c       **** 		}
 626               		.loc 1 407 0
 627 016c 8068      		ori r24,128
 628               	.LVL39:
 629               	.L39:
 409:setup.c       **** 	}
 630               		.loc 1 409 0
 631 016e 27E0      		ldi r18,lo8(7)
 632 0170 00C0      		rjmp .L33
 633               	.LVL40:
 634               	.L35:
 415:setup.c       **** 			ad0Pin_high;
 416:setup.c       **** 		}
 417:setup.c       **** 		else {
 418:setup.c       **** 			ad0Pin_low;
 635               		.loc 1 418 0
 636 0172 C098      		cbi 0x18,0
 637               	.L36:
 419:setup.c       **** 		}
 420:setup.c       **** 		
 421:setup.c       **** 		wrPin_low; // CLK
 638               		.loc 1 421 0
 639 0174 9698      		cbi 0x12,6
 422:setup.c       **** 		asm ("nop");
 640               		.loc 1 422 0
 641               	/* #APP */
 642               	 ;  422 "setup.c" 1
 643 0176 0000      		nop
 644               	 ;  0 "" 2
 423:setup.c       **** 		asm ("nop");
 645               		.loc 1 423 0
 646               	 ;  423 "setup.c" 1
 647 0178 0000      		nop
 648               	 ;  0 "" 2
 424:setup.c       **** 		wrPin_high; 
 649               		.loc 1 424 0
 650               	/* #NOAPP */
 651 017a 969A      		sbi 0x12,6
 425:setup.c       **** 		asm ("nop");
 652               		.loc 1 425 0
 653               	/* #APP */
 654               	 ;  425 "setup.c" 1
 655 017c 0000      		nop
 656               	 ;  0 "" 2
 426:setup.c       **** 		asm ("nop");
 657               		.loc 1 426 0
 658               	 ;  426 "setup.c" 1
 659 017e 0000      		nop
 660               	 ;  0 "" 2
 661               	/* #NOAPP */
 662 0180 2150      		subi r18,lo8(-(-1))
 663               	.LVL41:
 413:setup.c       **** 		if (address & (1<<x)) {
 664               		.loc 1 413 0
 665 0182 27FD      		sbrc r18,7
 666 0184 00C0      		rjmp .L41
 667               	.L32:
 414:setup.c       **** 			ad0Pin_high;
 668               		.loc 1 414 0
 669 0186 BF01      		movw r22,r30
 670 0188 022E      		mov r0,r18
 671 018a 00C0      		rjmp 2f
 672               		1:
 673 018c 660F      		lsl r22
 674 018e 771F      		rol r23
 675               		2:
 676 0190 0A94      		dec r0
 677 0192 02F4      		brpl 1b
 678 0194 6823      		and r22,r24
 679 0196 7923      		and r23,r25
 680 0198 672B      		or r22,r23
 681 019a 01F0      		breq .L35
 415:setup.c       **** 		}
 682               		.loc 1 415 0
 683 019c C09A      		sbi 0x18,0
 684 019e 00C0      		rjmp .L36
 685               	.L41:
 427:setup.c       **** 		
 428:setup.c       **** 		x--;
 429:setup.c       **** 	}
 430:setup.c       **** 	
 431:setup.c       **** 	// Only send stop bit (0) and WR/CS high if reading, as writing is done in 1 continuous chunk
 432:setup.c       **** 	if (command == EEPROM_READ) {  
 686               		.loc 1 432 0
 687 01a0 4111      		cpse r20,__zero_reg__
 688 01a2 00C0      		rjmp .L29
 433:setup.c       **** 		ad0Pin_low;
 689               		.loc 1 433 0
 690 01a4 C098      		cbi 0x18,0
 434:setup.c       **** 		asm ("nop");
 691               		.loc 1 434 0
 692               	/* #APP */
 693               	 ;  434 "setup.c" 1
 694 01a6 0000      		nop
 695               	 ;  0 "" 2
 435:setup.c       **** 		wrPin_low;
 696               		.loc 1 435 0
 697               	/* #NOAPP */
 698 01a8 9698      		cbi 0x12,6
 436:setup.c       **** 		asm ("nop");
 699               		.loc 1 436 0
 700               	/* #APP */
 701               	 ;  436 "setup.c" 1
 702 01aa 0000      		nop
 703               	 ;  0 "" 2
 437:setup.c       **** 		asm ("nop");
 704               		.loc 1 437 0
 705               	 ;  437 "setup.c" 1
 706 01ac 0000      		nop
 707               	 ;  0 "" 2
 438:setup.c       **** 		
 439:setup.c       **** 		wrPin_high;
 708               		.loc 1 439 0
 709               	/* #NOAPP */
 710 01ae 969A      		sbi 0x12,6
 440:setup.c       **** 		cs_mreqPin_high;
 711               		.loc 1 440 0
 712 01b0 949A      		sbi 0x12,4
 713               	.L29:
 714 01b2 0895      		ret
 715               		.cfi_endproc
 716               	.LFE27:
 718               	.global	gba_eeprom_read
 720               	gba_eeprom_read:
 721               	.LFB28:
 441:setup.c       **** 	}
 442:setup.c       **** }
 443:setup.c       **** 
 444:setup.c       **** // Read 8 bytes from the EEPROM address, data is valid on rising edge
 445:setup.c       **** void gba_eeprom_read(uint16_t address, uint8_t eepromSize) {
 722               		.loc 1 445 0
 723               		.cfi_startproc
 724               	.LVL42:
 725               	/* prologue: function */
 726               	/* frame size = 0 */
 727               	/* stack size = 0 */
 728               	.L__stack_usage = 0
 446:setup.c       **** 	gba_eeprom_set_address(address, eepromSize, EEPROM_READ);
 729               		.loc 1 446 0
 730 01b4 40E0      		ldi r20,0
 731 01b6 00D0      		rcall gba_eeprom_set_address
 732               	.LVL43:
 447:setup.c       **** 	
 448:setup.c       **** 	// Set AD0 pin as input
 449:setup.c       **** 	GBA_PORT_EEPROM_DATA7_0 &= ~(1<<AD0);
 733               		.loc 1 449 0
 734 01b8 C098      		cbi 0x18,0
 450:setup.c       **** 	GBA_DDR_EEPROM_DATA7_0 &= ~(1<<AD0);
 735               		.loc 1 450 0
 736 01ba B898      		cbi 0x17,0
 451:setup.c       **** 	
 452:setup.c       **** 	cs_mreqPin_low;
 737               		.loc 1 452 0
 738 01bc 9498      		cbi 0x12,4
 739               	.LVL44:
 740 01be 84E0      		ldi r24,lo8(4)
 741               	.LVL45:
 742               	.L43:
 743               	.LBB68:
 453:setup.c       **** 	
 454:setup.c       **** 	// Ignore first 4 bits
 455:setup.c       **** 	for (int8_t x = 0; x < 4; x++) {
 456:setup.c       **** 		rdPin_low; // CLK
 744               		.loc 1 456 0 discriminator 3
 745 01c0 9598      		cbi 0x12,5
 457:setup.c       **** 		asm ("nop");
 746               		.loc 1 457 0 discriminator 3
 747               	/* #APP */
 748               	 ;  457 "setup.c" 1
 749 01c2 0000      		nop
 750               	 ;  0 "" 2
 458:setup.c       **** 		asm ("nop");
 751               		.loc 1 458 0 discriminator 3
 752               	 ;  458 "setup.c" 1
 753 01c4 0000      		nop
 754               	 ;  0 "" 2
 459:setup.c       **** 		rdPin_high; 
 755               		.loc 1 459 0 discriminator 3
 756               	/* #NOAPP */
 757 01c6 959A      		sbi 0x12,5
 460:setup.c       **** 		asm ("nop");
 758               		.loc 1 460 0 discriminator 3
 759               	/* #APP */
 760               	 ;  460 "setup.c" 1
 761 01c8 0000      		nop
 762               	 ;  0 "" 2
 461:setup.c       **** 		asm ("nop");
 763               		.loc 1 461 0 discriminator 3
 764               	 ;  461 "setup.c" 1
 765 01ca 0000      		nop
 766               	 ;  0 "" 2
 767               	.LVL46:
 768               	/* #NOAPP */
 769 01cc 8150      		subi r24,lo8(-(-1))
 770               	.LVL47:
 455:setup.c       **** 		rdPin_low; // CLK
 771               		.loc 1 455 0 discriminator 3
 772 01ce 01F4      		brne .L43
 773 01d0 E0E0      		ldi r30,lo8(eepromBuffer)
 774 01d2 F0E0      		ldi r31,hi8(eepromBuffer)
 775               	.LBE68:
 776               	.LBB69:
 777               	.LBB70:
 778               	.LBB71:
 462:setup.c       **** 	}
 463:setup.c       **** 	
 464:setup.c       **** 	// Read out 64 bits
 465:setup.c       **** 	for (uint8_t c = 0; c < 8; c++) {
 466:setup.c       **** 		uint8_t data = 0;
 467:setup.c       **** 		for (int8_t x = 7; x >= 0; x--) {
 468:setup.c       **** 			rdPin_low; // CLK
 469:setup.c       **** 			asm ("nop");
 470:setup.c       **** 			asm ("nop");
 471:setup.c       **** 			rdPin_high;
 472:setup.c       **** 			
 473:setup.c       **** 			if (GBA_PIN_EEPROM_DATA7_0 & (1<<AD0)) {
 474:setup.c       **** 				data |= (1<<x);
 779               		.loc 1 474 0
 780 01d4 41E0      		ldi r20,lo8(1)
 781 01d6 50E0      		ldi r21,0
 782               	.LVL48:
 783               	.L44:
 784               	.LBE71:
 785               	.LBE70:
 786               	.LBE69:
 452:setup.c       **** 	
 787               		.loc 1 452 0
 788 01d8 87E0      		ldi r24,lo8(7)
 789 01da 90E0      		ldi r25,0
 790 01dc 20E0      		ldi r18,0
 791               	.LVL49:
 792               	.L46:
 793               	.LBB74:
 794               	.LBB73:
 795               	.LBB72:
 468:setup.c       **** 			asm ("nop");
 796               		.loc 1 468 0
 797 01de 9598      		cbi 0x12,5
 469:setup.c       **** 			asm ("nop");
 798               		.loc 1 469 0
 799               	/* #APP */
 800               	 ;  469 "setup.c" 1
 801 01e0 0000      		nop
 802               	 ;  0 "" 2
 470:setup.c       **** 			rdPin_high;
 803               		.loc 1 470 0
 804               	 ;  470 "setup.c" 1
 805 01e2 0000      		nop
 806               	 ;  0 "" 2
 471:setup.c       **** 			
 807               		.loc 1 471 0
 808               	/* #NOAPP */
 809 01e4 959A      		sbi 0x12,5
 473:setup.c       **** 				data |= (1<<x);
 810               		.loc 1 473 0
 811 01e6 B09B      		sbis 0x16,0
 812 01e8 00C0      		rjmp .L45
 813               		.loc 1 474 0
 814 01ea BA01      		movw r22,r20
 815 01ec 082E      		mov r0,r24
 816 01ee 00C0      		rjmp 2f
 817               		1:
 818 01f0 660F      		lsl r22
 819               		2:
 820 01f2 0A94      		dec r0
 821 01f4 02F4      		brpl 1b
 822 01f6 262B      		or r18,r22
 823               	.LVL50:
 824               	.L45:
 825               	.LVL51:
 826 01f8 0197      		sbiw r24,1
 827 01fa 00F4      		brcc .L46
 828               	.LBE72:
 475:setup.c       **** 			}
 476:setup.c       **** 		}
 477:setup.c       **** 		eepromBuffer[c] = data;
 829               		.loc 1 477 0 discriminator 2
 830 01fc 2193      		st Z+,r18
 831               	.LVL52:
 832               	.LBE73:
 465:setup.c       **** 		uint8_t data = 0;
 833               		.loc 1 465 0 discriminator 2
 834 01fe 80E0      		ldi r24,hi8(eepromBuffer+8)
 835 0200 E030      		cpi r30,lo8(eepromBuffer+8)
 836 0202 F807      		cpc r31,r24
 837               	.LVL53:
 838 0204 01F4      		brne .L44
 839               	.LBE74:
 478:setup.c       **** 	}
 479:setup.c       **** 	
 480:setup.c       **** 	cs_mreqPin_high;
 840               		.loc 1 480 0
 841 0206 949A      		sbi 0x12,4
 481:setup.c       **** 	
 482:setup.c       **** 	// Set AD0 pin as output
 483:setup.c       **** 	GBA_PORT_EEPROM_DATA7_0 |= (1<<AD0);
 842               		.loc 1 483 0
 843 0208 C09A      		sbi 0x18,0
 484:setup.c       **** 	GBA_DDR_EEPROM_DATA7_0 |= (1<<AD0);
 844               		.loc 1 484 0
 845 020a B89A      		sbi 0x17,0
 846 020c 0895      		ret
 847               		.cfi_endproc
 848               	.LFE28:
 850               	.global	gba_eeprom_write
 852               	gba_eeprom_write:
 853               	.LFB29:
 485:setup.c       **** }
 486:setup.c       **** 
 487:setup.c       **** // Write 8 bytes to the EEPROM address
 488:setup.c       **** void gba_eeprom_write(uint16_t address, uint8_t eepromSize) {
 854               		.loc 1 488 0
 855               		.cfi_startproc
 856               	.LVL54:
 857               	/* prologue: function */
 858               	/* frame size = 0 */
 859               	/* stack size = 0 */
 860               	.L__stack_usage = 0
 489:setup.c       **** 	gba_eeprom_set_address(address, eepromSize, EEPROM_WRITE);
 861               		.loc 1 489 0
 862 020e 41E0      		ldi r20,lo8(1)
 863 0210 00D0      		rcall gba_eeprom_set_address
 864               	.LVL55:
 865 0212 E0E0      		ldi r30,lo8(eepromBuffer)
 866 0214 F0E0      		ldi r31,hi8(eepromBuffer)
 867 0216 48E0      		ldi r20,lo8(8)
 868               	.LVL56:
 869               	.L54:
 488:setup.c       **** 	gba_eeprom_set_address(address, eepromSize, EEPROM_WRITE);
 870               		.loc 1 488 0
 871 0218 27E0      		ldi r18,lo8(7)
 872 021a 30E0      		ldi r19,0
 873               	.LVL57:
 874               	.L57:
 875               	.LBB75:
 876               	.LBB76:
 490:setup.c       **** 	
 491:setup.c       **** 	// Write 64 bits
 492:setup.c       **** 	for (uint8_t c = 0; c < 8; c++) {
 493:setup.c       **** 		for (int8_t x = 7; x >= 0; x--) {
 494:setup.c       **** 			if (eepromBuffer[c] & (1<<x)) {
 877               		.loc 1 494 0
 878 021c 8081      		ld r24,Z
 879 021e 90E0      		ldi r25,0
 880 0220 022E      		mov r0,r18
 881 0222 00C0      		rjmp 2f
 882               		1:
 883 0224 9595      		asr r25
 884 0226 8795      		ror r24
 885               		2:
 886 0228 0A94      		dec r0
 887 022a 02F4      		brpl 1b
 888 022c 80FF      		sbrs r24,0
 889 022e 00C0      		rjmp .L55
 495:setup.c       **** 				ad0Pin_high;
 890               		.loc 1 495 0
 891 0230 C09A      		sbi 0x18,0
 892 0232 00C0      		rjmp .L56
 893               	.L55:
 496:setup.c       **** 			}
 497:setup.c       **** 			else {
 498:setup.c       **** 				ad0Pin_low;
 894               		.loc 1 498 0
 895 0234 C098      		cbi 0x18,0
 896               	.L56:
 499:setup.c       **** 			}
 500:setup.c       **** 			
 501:setup.c       **** 			wrPin_low; // CLK
 897               		.loc 1 501 0 discriminator 2
 898 0236 9698      		cbi 0x12,6
 502:setup.c       **** 			asm ("nop");
 899               		.loc 1 502 0 discriminator 2
 900               	/* #APP */
 901               	 ;  502 "setup.c" 1
 902 0238 0000      		nop
 903               	 ;  0 "" 2
 503:setup.c       **** 			asm ("nop");
 904               		.loc 1 503 0 discriminator 2
 905               	 ;  503 "setup.c" 1
 906 023a 0000      		nop
 907               	 ;  0 "" 2
 504:setup.c       **** 			wrPin_high; 
 908               		.loc 1 504 0 discriminator 2
 909               	/* #NOAPP */
 910 023c 969A      		sbi 0x12,6
 505:setup.c       **** 			asm ("nop");
 911               		.loc 1 505 0 discriminator 2
 912               	/* #APP */
 913               	 ;  505 "setup.c" 1
 914 023e 0000      		nop
 915               	 ;  0 "" 2
 506:setup.c       **** 			asm ("nop");
 916               		.loc 1 506 0 discriminator 2
 917               	 ;  506 "setup.c" 1
 918 0240 0000      		nop
 919               	 ;  0 "" 2
 920               	.LVL58:
 921               	/* #NOAPP */
 922               	.LVL59:
 923 0242 2150      		subi r18,1
 924 0244 3109      		sbc r19,__zero_reg__
 925 0246 00F4      		brcc .L57
 926 0248 4150      		subi r20,lo8(-(-1))
 927 024a 3196      		adiw r30,1
 928               	.LVL60:
 929               	.LBE76:
 492:setup.c       **** 		for (int8_t x = 7; x >= 0; x--) {
 930               		.loc 1 492 0 discriminator 2
 931 024c 4111      		cpse r20,__zero_reg__
 932 024e 00C0      		rjmp .L54
 933               	.LBE75:
 507:setup.c       **** 		}
 508:setup.c       **** 	}
 509:setup.c       **** 	
 510:setup.c       **** 	// Last bit low
 511:setup.c       **** 	ad0Pin_low;
 934               		.loc 1 511 0
 935 0250 C098      		cbi 0x18,0
 512:setup.c       **** 	wrPin_low; // CLK
 936               		.loc 1 512 0
 937 0252 9698      		cbi 0x12,6
 513:setup.c       **** 	asm ("nop");
 938               		.loc 1 513 0
 939               	/* #APP */
 940               	 ;  513 "setup.c" 1
 941 0254 0000      		nop
 942               	 ;  0 "" 2
 514:setup.c       **** 	asm ("nop");
 943               		.loc 1 514 0
 944               	 ;  514 "setup.c" 1
 945 0256 0000      		nop
 946               	 ;  0 "" 2
 515:setup.c       **** 	wrPin_high; 
 947               		.loc 1 515 0
 948               	/* #NOAPP */
 949 0258 969A      		sbi 0x12,6
 516:setup.c       **** 	asm ("nop");
 950               		.loc 1 516 0
 951               	/* #APP */
 952               	 ;  516 "setup.c" 1
 953 025a 0000      		nop
 954               	 ;  0 "" 2
 517:setup.c       **** 	asm ("nop");
 955               		.loc 1 517 0
 956               	 ;  517 "setup.c" 1
 957 025c 0000      		nop
 958               	 ;  0 "" 2
 518:setup.c       **** 	
 519:setup.c       **** 	cs_mreqPin_high;
 959               		.loc 1 519 0
 960               	/* #NOAPP */
 961 025e 949A      		sbi 0x12,4
 962 0260 0895      		ret
 963               		.cfi_endproc
 964               	.LFE29:
 966               	.global	flash_write_bus_cycle
 968               	flash_write_bus_cycle:
 969               	.LFB30:
 520:setup.c       **** }
 521:setup.c       **** 
 522:setup.c       **** 
 523:setup.c       **** 
 524:setup.c       **** // ---------- FLASH ----------
 525:setup.c       **** 
 526:setup.c       **** // Set the address and data for the write byte cycle to the flash
 527:setup.c       **** void flash_write_bus_cycle(uint16_t address, uint8_t data) {
 970               		.loc 1 527 0
 971               		.cfi_startproc
 972               	.LVL61:
 973 0262 CF93      		push r28
 974               	.LCFI11:
 975               		.cfi_def_cfa_offset 3
 976               		.cfi_offset 28, -2
 977               	/* prologue: function */
 978               	/* frame size = 0 */
 979               	/* stack size = 1 */
 980               	.L__stack_usage = 1
 981 0264 C62F      		mov r28,r22
 528:setup.c       **** 	GBA_DDR_RAM_DATA7_0 = 0xFF; // Set data pins as outputs
 982               		.loc 1 528 0
 983 0266 2FEF      		ldi r18,lo8(-1)
 984 0268 24BB      		out 0x14,r18
 529:setup.c       **** 	set_16bit_address(address);
 985               		.loc 1 529 0
 986 026a 00D0      		rcall set_16bit_address
 987               	.LVL62:
 530:setup.c       **** 	GBA_PORT_RAM_DATA7_0 = data;
 988               		.loc 1 530 0
 989 026c C5BB      		out 0x15,r28
 531:setup.c       **** 	
 532:setup.c       **** 	wrPin_low;
 990               		.loc 1 532 0
 991 026e 9698      		cbi 0x12,6
 533:setup.c       **** 	cs2Pin_low;
 992               		.loc 1 533 0
 993 0270 3A98      		cbi 0x7,2
 534:setup.c       **** 	asm volatile("nop");
 994               		.loc 1 534 0
 995               	/* #APP */
 996               	 ;  534 "setup.c" 1
 997 0272 0000      		nop
 998               	 ;  0 "" 2
 535:setup.c       **** 	wrPin_high;
 999               		.loc 1 535 0
 1000               	/* #NOAPP */
 1001 0274 969A      		sbi 0x12,6
 536:setup.c       **** 	cs2Pin_high;
 1002               		.loc 1 536 0
 1003 0276 3A9A      		sbi 0x7,2
 1004               	/* epilogue start */
 537:setup.c       **** }
 1005               		.loc 1 537 0
 1006 0278 CF91      		pop r28
 1007               	.LVL63:
 1008 027a 0895      		ret
 1009               		.cfi_endproc
 1010               	.LFE30:
 1012               	.global	flash_read_chip_id
 1014               	flash_read_chip_id:
 1015               	.LFB31:
 538:setup.c       **** 
 539:setup.c       **** // Read the flash manufacturer and device ID (Software ID)
 540:setup.c       **** void flash_read_chip_id(void) {
 1016               		.loc 1 540 0
 1017               		.cfi_startproc
 1018 027c CF93      		push r28
 1019               	.LCFI12:
 1020               		.cfi_def_cfa_offset 3
 1021               		.cfi_offset 28, -2
 1022 027e DF93      		push r29
 1023               	.LCFI13:
 1024               		.cfi_def_cfa_offset 4
 1025               		.cfi_offset 29, -3
 1026               	/* prologue: function */
 1027               	/* frame size = 0 */
 1028               	/* stack size = 2 */
 1029               	.L__stack_usage = 2
 541:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xAA);
 1030               		.loc 1 541 0
 1031 0280 6AEA      		ldi r22,lo8(-86)
 1032 0282 85E5      		ldi r24,lo8(85)
 1033 0284 95E5      		ldi r25,lo8(85)
 1034 0286 00D0      		rcall flash_write_bus_cycle
 1035               	.LVL64:
 542:setup.c       **** 	flash_write_bus_cycle(0x2AAA, 0x55);
 1036               		.loc 1 542 0
 1037 0288 65E5      		ldi r22,lo8(85)
 1038 028a 8AEA      		ldi r24,lo8(-86)
 1039 028c 9AE2      		ldi r25,lo8(42)
 1040 028e 00D0      		rcall flash_write_bus_cycle
 1041               	.LVL65:
 543:setup.c       **** 	flash_write_bus_cycle(0x5555, 0x90); // Software ID entry
 1042               		.loc 1 543 0
 1043 0290 60E9      		ldi r22,lo8(-112)
 1044 0292 85E5      		ldi r24,lo8(85)
 1045 0294 95E5      		ldi r25,lo8(85)
 1046 0296 00D0      		rcall flash_write_bus_cycle
 1047               	.LVL66:
 1048               	.LBB77:
 1049               	.LBB78:
 1050               		.file 2 "c:\\winavr-20100110\\avr\\include\\util\\delay.h"
   1:c:\winavr-20100110\avr\include\util\delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:c:\winavr-20100110\avr\include\util\delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:c:\winavr-20100110\avr\include\util\delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:c:\winavr-20100110\avr\include\util\delay.h ****    All rights reserved.
   5:c:\winavr-20100110\avr\include\util\delay.h **** 
   6:c:\winavr-20100110\avr\include\util\delay.h ****    Redistribution and use in source and binary forms, with or without
   7:c:\winavr-20100110\avr\include\util\delay.h ****    modification, are permitted provided that the following conditions are met:
   8:c:\winavr-20100110\avr\include\util\delay.h **** 
   9:c:\winavr-20100110\avr\include\util\delay.h ****    * Redistributions of source code must retain the above copyright
  10:c:\winavr-20100110\avr\include\util\delay.h ****      notice, this list of conditions and the following disclaimer.
  11:c:\winavr-20100110\avr\include\util\delay.h **** 
  12:c:\winavr-20100110\avr\include\util\delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:c:\winavr-20100110\avr\include\util\delay.h ****      notice, this list of conditions and the following disclaimer in
  14:c:\winavr-20100110\avr\include\util\delay.h ****      the documentation and/or other materials provided with the
  15:c:\winavr-20100110\avr\include\util\delay.h ****      distribution.
  16:c:\winavr-20100110\avr\include\util\delay.h **** 
  17:c:\winavr-20100110\avr\include\util\delay.h ****    * Neither the name of the copyright holders nor the names of
  18:c:\winavr-20100110\avr\include\util\delay.h ****      contributors may be used to endorse or promote products derived
  19:c:\winavr-20100110\avr\include\util\delay.h ****      from this software without specific prior written permission.
  20:c:\winavr-20100110\avr\include\util\delay.h **** 
  21:c:\winavr-20100110\avr\include\util\delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:c:\winavr-20100110\avr\include\util\delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:c:\winavr-20100110\avr\include\util\delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:c:\winavr-20100110\avr\include\util\delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:c:\winavr-20100110\avr\include\util\delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:c:\winavr-20100110\avr\include\util\delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:c:\winavr-20100110\avr\include\util\delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:c:\winavr-20100110\avr\include\util\delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:c:\winavr-20100110\avr\include\util\delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:c:\winavr-20100110\avr\include\util\delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:c:\winavr-20100110\avr\include\util\delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:c:\winavr-20100110\avr\include\util\delay.h **** 
  33:c:\winavr-20100110\avr\include\util\delay.h **** /* $Id$ */
  34:c:\winavr-20100110\avr\include\util\delay.h **** 
  35:c:\winavr-20100110\avr\include\util\delay.h **** #ifndef _UTIL_DELAY_H_
  36:c:\winavr-20100110\avr\include\util\delay.h **** #define _UTIL_DELAY_H_ 1
  37:c:\winavr-20100110\avr\include\util\delay.h **** 
  38:c:\winavr-20100110\avr\include\util\delay.h **** #ifndef __DOXYGEN__
  39:c:\winavr-20100110\avr\include\util\delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:c:\winavr-20100110\avr\include\util\delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:c:\winavr-20100110\avr\include\util\delay.h **** #  endif
  42:c:\winavr-20100110\avr\include\util\delay.h **** #endif  /* __DOXYGEN__ */
  43:c:\winavr-20100110\avr\include\util\delay.h **** 
  44:c:\winavr-20100110\avr\include\util\delay.h **** #include <inttypes.h>
  45:c:\winavr-20100110\avr\include\util\delay.h **** #include <util/delay_basic.h>
  46:c:\winavr-20100110\avr\include\util\delay.h **** #include <math.h>
  47:c:\winavr-20100110\avr\include\util\delay.h **** 
  48:c:\winavr-20100110\avr\include\util\delay.h **** /** \file */
  49:c:\winavr-20100110\avr\include\util\delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:c:\winavr-20100110\avr\include\util\delay.h ****     \code
  51:c:\winavr-20100110\avr\include\util\delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:c:\winavr-20100110\avr\include\util\delay.h ****     //#define F_CPU 14.7456E6
  53:c:\winavr-20100110\avr\include\util\delay.h ****     #include <util/delay.h>
  54:c:\winavr-20100110\avr\include\util\delay.h ****     \endcode
  55:c:\winavr-20100110\avr\include\util\delay.h **** 
  56:c:\winavr-20100110\avr\include\util\delay.h ****     \note As an alternative method, it is possible to pass the
  57:c:\winavr-20100110\avr\include\util\delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:c:\winavr-20100110\avr\include\util\delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:c:\winavr-20100110\avr\include\util\delay.h ****     used.
  60:c:\winavr-20100110\avr\include\util\delay.h **** 
  61:c:\winavr-20100110\avr\include\util\delay.h ****     The functions in this header file are wrappers around the basic
  62:c:\winavr-20100110\avr\include\util\delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:c:\winavr-20100110\avr\include\util\delay.h ****     convenience functions where actual time values can be specified
  64:c:\winavr-20100110\avr\include\util\delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:c:\winavr-20100110\avr\include\util\delay.h ****     that compile-time constant expressions will be eliminated by
  66:c:\winavr-20100110\avr\include\util\delay.h ****     compiler optimization so floating-point expressions can be used
  67:c:\winavr-20100110\avr\include\util\delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:c:\winavr-20100110\avr\include\util\delay.h ****     frequency passed by the macro F_CPU.
  69:c:\winavr-20100110\avr\include\util\delay.h **** 
  70:c:\winavr-20100110\avr\include\util\delay.h ****     \note In order for these functions to work as intended, compiler
  71:c:\winavr-20100110\avr\include\util\delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:c:\winavr-20100110\avr\include\util\delay.h ****     <em>must</em> be an expression that is a known constant at
  73:c:\winavr-20100110\avr\include\util\delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:c:\winavr-20100110\avr\include\util\delay.h ****     delay will be much longer (and basically unpredictable), and
  75:c:\winavr-20100110\avr\include\util\delay.h ****     applications that otherwise do not use floating-point calculations
  76:c:\winavr-20100110\avr\include\util\delay.h ****     will experience severe code bloat by the floating-point library
  77:c:\winavr-20100110\avr\include\util\delay.h ****     routines linked into the application.
  78:c:\winavr-20100110\avr\include\util\delay.h **** 
  79:c:\winavr-20100110\avr\include\util\delay.h ****     The functions available allow the specification of microsecond, and
  80:c:\winavr-20100110\avr\include\util\delay.h ****     millisecond delays directly, using the application-supplied macro
  81:c:\winavr-20100110\avr\include\util\delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:c:\winavr-20100110\avr\include\util\delay.h **** 
  83:c:\winavr-20100110\avr\include\util\delay.h **** */
  84:c:\winavr-20100110\avr\include\util\delay.h **** 
  85:c:\winavr-20100110\avr\include\util\delay.h **** #if !defined(__DOXYGEN__)
  86:c:\winavr-20100110\avr\include\util\delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:c:\winavr-20100110\avr\include\util\delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:c:\winavr-20100110\avr\include\util\delay.h **** #endif
  89:c:\winavr-20100110\avr\include\util\delay.h **** 
  90:c:\winavr-20100110\avr\include\util\delay.h **** #ifndef F_CPU
  91:c:\winavr-20100110\avr\include\util\delay.h **** /* prevent compiler error by supplying a default */
  92:c:\winavr-20100110\avr\include\util\delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:c:\winavr-20100110\avr\include\util\delay.h **** /** \ingroup util_delay
  94:c:\winavr-20100110\avr\include\util\delay.h ****     \def F_CPU
  95:c:\winavr-20100110\avr\include\util\delay.h ****     \brief CPU frequency in Hz
  96:c:\winavr-20100110\avr\include\util\delay.h **** 
  97:c:\winavr-20100110\avr\include\util\delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:c:\winavr-20100110\avr\include\util\delay.h ****     the delay macros.  This macro is normally supplied by the
  99:c:\winavr-20100110\avr\include\util\delay.h ****     environment (e.g. from within a project header, or the project's
 100:c:\winavr-20100110\avr\include\util\delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:c:\winavr-20100110\avr\include\util\delay.h ****     fallback if no such user-provided definition could be found.
 102:c:\winavr-20100110\avr\include\util\delay.h **** 
 103:c:\winavr-20100110\avr\include\util\delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:c:\winavr-20100110\avr\include\util\delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:c:\winavr-20100110\avr\include\util\delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:c:\winavr-20100110\avr\include\util\delay.h ****     integer value.
 107:c:\winavr-20100110\avr\include\util\delay.h ****  */
 108:c:\winavr-20100110\avr\include\util\delay.h **** # define F_CPU 1000000UL
 109:c:\winavr-20100110\avr\include\util\delay.h **** #endif
 110:c:\winavr-20100110\avr\include\util\delay.h **** 
 111:c:\winavr-20100110\avr\include\util\delay.h **** #ifndef __OPTIMIZE__
 112:c:\winavr-20100110\avr\include\util\delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:c:\winavr-20100110\avr\include\util\delay.h **** #endif
 114:c:\winavr-20100110\avr\include\util\delay.h **** 
 115:c:\winavr-20100110\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:c:\winavr-20100110\avr\include\util\delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:c:\winavr-20100110\avr\include\util\delay.h ****   __STDC_HOSTED__
 118:c:\winavr-20100110\avr\include\util\delay.h **** #  include <math.h>
 119:c:\winavr-20100110\avr\include\util\delay.h **** #endif
 120:c:\winavr-20100110\avr\include\util\delay.h **** 
 121:c:\winavr-20100110\avr\include\util\delay.h **** /**
 122:c:\winavr-20100110\avr\include\util\delay.h ****    \ingroup util_delay
 123:c:\winavr-20100110\avr\include\util\delay.h **** 
 124:c:\winavr-20100110\avr\include\util\delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:c:\winavr-20100110\avr\include\util\delay.h **** 
 126:c:\winavr-20100110\avr\include\util\delay.h ****    The macro F_CPU is supposed to be defined to a
 127:c:\winavr-20100110\avr\include\util\delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:c:\winavr-20100110\avr\include\util\delay.h **** 
 129:c:\winavr-20100110\avr\include\util\delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:c:\winavr-20100110\avr\include\util\delay.h **** 
 131:c:\winavr-20100110\avr\include\util\delay.h ****    When the user request delay which exceed the maximum possible one,
 132:c:\winavr-20100110\avr\include\util\delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:c:\winavr-20100110\avr\include\util\delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:c:\winavr-20100110\avr\include\util\delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:c:\winavr-20100110\avr\include\util\delay.h ****    user will not be informed about decreased resolution.
 136:c:\winavr-20100110\avr\include\util\delay.h **** 
 137:c:\winavr-20100110\avr\include\util\delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:c:\winavr-20100110\avr\include\util\delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:c:\winavr-20100110\avr\include\util\delay.h ****    values greater than the maximal possible delay, overflows results in
 140:c:\winavr-20100110\avr\include\util\delay.h ****    no delay i.e., 0ms.
 141:c:\winavr-20100110\avr\include\util\delay.h **** 
 142:c:\winavr-20100110\avr\include\util\delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:c:\winavr-20100110\avr\include\util\delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:c:\winavr-20100110\avr\include\util\delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:c:\winavr-20100110\avr\include\util\delay.h ****    microseconds of delay.
 146:c:\winavr-20100110\avr\include\util\delay.h **** 
 147:c:\winavr-20100110\avr\include\util\delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:c:\winavr-20100110\avr\include\util\delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:c:\winavr-20100110\avr\include\util\delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:c:\winavr-20100110\avr\include\util\delay.h ****    respectively.
 151:c:\winavr-20100110\avr\include\util\delay.h **** 
 152:c:\winavr-20100110\avr\include\util\delay.h ****    \note
 153:c:\winavr-20100110\avr\include\util\delay.h **** 
 154:c:\winavr-20100110\avr\include\util\delay.h ****    The implementation of _delay_ms() based on
 155:c:\winavr-20100110\avr\include\util\delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:c:\winavr-20100110\avr\include\util\delay.h ****    implementations.  In order to get functionality backward compatible
 157:c:\winavr-20100110\avr\include\util\delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:c:\winavr-20100110\avr\include\util\delay.h ****    must be defined before including this header file. Also, the
 159:c:\winavr-20100110\avr\include\util\delay.h ****    backward compatible algorithm will be chosen if the code is
 160:c:\winavr-20100110\avr\include\util\delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:c:\winavr-20100110\avr\include\util\delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:c:\winavr-20100110\avr\include\util\delay.h ****    not available to the compiler then.
 163:c:\winavr-20100110\avr\include\util\delay.h **** 
 164:c:\winavr-20100110\avr\include\util\delay.h ****  */
 165:c:\winavr-20100110\avr\include\util\delay.h **** void
 166:c:\winavr-20100110\avr\include\util\delay.h **** _delay_ms(double __ms)
 167:c:\winavr-20100110\avr\include\util\delay.h **** {
 168:c:\winavr-20100110\avr\include\util\delay.h **** 	double __tmp ;
 169:c:\winavr-20100110\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:c:\winavr-20100110\avr\include\util\delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:c:\winavr-20100110\avr\include\util\delay.h ****   __STDC_HOSTED__
 172:c:\winavr-20100110\avr\include\util\delay.h **** 	uint32_t __ticks_dc;
 173:c:\winavr-20100110\avr\include\util\delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 174:c:\winavr-20100110\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 175:c:\winavr-20100110\avr\include\util\delay.h **** 
 176:c:\winavr-20100110\avr\include\util\delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:c:\winavr-20100110\avr\include\util\delay.h **** 
 179:c:\winavr-20100110\avr\include\util\delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:c:\winavr-20100110\avr\include\util\delay.h **** 
 182:c:\winavr-20100110\avr\include\util\delay.h **** 	#else
 183:c:\winavr-20100110\avr\include\util\delay.h **** 		//round up by default
 184:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 185:c:\winavr-20100110\avr\include\util\delay.h **** 	#endif
 186:c:\winavr-20100110\avr\include\util\delay.h **** 
 187:c:\winavr-20100110\avr\include\util\delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 1051               		.loc 2 187 0
 1052 0298 8FE3      		ldi r24,lo8(-25537)
 1053 029a 9CE9      		ldi r25,hi8(-25537)
 1054 029c 0197      	1:	sbiw r24,1
 1055 029e 01F4      		brne 1b
 1056 02a0 00C0      		rjmp .
 1057 02a2 0000      		nop
 1058               	.LVL67:
 1059               	.LBE78:
 1060               	.LBE77:
 544:setup.c       **** 	_delay_ms(20); // Wait a little (for Atmel chip)
 545:setup.c       **** 	
 546:setup.c       **** 	// Set data as inputs
 547:setup.c       **** 	GBA_PORT_RAM_DATA7_0 = 0;
 1061               		.loc 1 547 0
 1062 02a4 15BA      		out 0x15,__zero_reg__
 548:setup.c       **** 	GBA_DDR_RAM_DATA7_0 = 0;
 1063               		.loc 1 548 0
 1064 02a6 14BA      		out 0x14,__zero_reg__
 549:setup.c       **** 	
 550:setup.c       **** 	// Read and transmit the 2 bytes
 551:setup.c       **** 	flashChipIdBuffer[0] = gba_read_ram_8bit_data(0x0000);
 1065               		.loc 1 551 0
 1066 02a8 80E0      		ldi r24,0
 1067 02aa 90E0      		ldi r25,0
 1068 02ac 00D0      		rcall gba_read_ram_8bit_data
 1069               	.LVL68:
 1070 02ae C0E0      		ldi r28,lo8(flashChipIdBuffer)
 1071 02b0 D0E0      		ldi r29,hi8(flashChipIdBuffer)
 1072 02b2 8883      		st Y,r24
 552:setup.c       **** 	flashChipIdBuffer[1] = gba_read_ram_8bit_data(0x0001);
 1073               		.loc 1 552 0
 1074 02b4 81E0      		ldi r24,lo8(1)
 1075 02b6 90E0      		ldi r25,0
 1076 02b8 00D0      		rcall gba_read_ram_8bit_data
 1077               	.LVL69:
 1078 02ba 8983      		std Y+1,r24
 553:setup.c       **** 	
 554:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xAA);
 1079               		.loc 1 554 0
 1080 02bc 6AEA      		ldi r22,lo8(-86)
 1081 02be 85E5      		ldi r24,lo8(85)
 1082 02c0 95E5      		ldi r25,lo8(85)
 1083 02c2 00D0      		rcall flash_write_bus_cycle
 1084               	.LVL70:
 555:setup.c       **** 	flash_write_bus_cycle(0x2AAA, 0x55);
 1085               		.loc 1 555 0
 1086 02c4 65E5      		ldi r22,lo8(85)
 1087 02c6 8AEA      		ldi r24,lo8(-86)
 1088 02c8 9AE2      		ldi r25,lo8(42)
 1089 02ca 00D0      		rcall flash_write_bus_cycle
 1090               	.LVL71:
 556:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xF0); // Software ID exit
 1091               		.loc 1 556 0
 1092 02cc 60EF      		ldi r22,lo8(-16)
 1093 02ce 85E5      		ldi r24,lo8(85)
 1094 02d0 95E5      		ldi r25,lo8(85)
 1095 02d2 00D0      		rcall flash_write_bus_cycle
 1096               	.LVL72:
 1097               	.LBB79:
 1098               	.LBB80:
 1099               		.loc 2 187 0
 1100 02d4 8FE3      		ldi r24,lo8(-25537)
 1101 02d6 9CE9      		ldi r25,hi8(-25537)
 1102 02d8 0197      	1:	sbiw r24,1
 1103 02da 01F4      		brne 1b
 1104 02dc 00C0      		rjmp .
 1105 02de 0000      		nop
 1106               	.LVL73:
 1107               	/* epilogue start */
 1108               	.LBE80:
 1109               	.LBE79:
 557:setup.c       **** 	_delay_ms(20); // Wait a little (for Atmel chip)
 558:setup.c       **** }
 1110               		.loc 1 558 0
 1111 02e0 DF91      		pop r29
 1112 02e2 CF91      		pop r28
 1113 02e4 0895      		ret
 1114               		.cfi_endproc
 1115               	.LFE31:
 1117               	.global	flash_switch_bank
 1119               	flash_switch_bank:
 1120               	.LFB32:
 559:setup.c       **** 
 560:setup.c       **** // Switch banks on the Flash
 561:setup.c       **** void flash_switch_bank(uint8_t bank) {
 1121               		.loc 1 561 0
 1122               		.cfi_startproc
 1123               	.LVL74:
 1124 02e6 CF93      		push r28
 1125               	.LCFI14:
 1126               		.cfi_def_cfa_offset 3
 1127               		.cfi_offset 28, -2
 1128               	/* prologue: function */
 1129               	/* frame size = 0 */
 1130               	/* stack size = 1 */
 1131               	.L__stack_usage = 1
 1132 02e8 C82F      		mov r28,r24
 562:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xAA);
 1133               		.loc 1 562 0
 1134 02ea 6AEA      		ldi r22,lo8(-86)
 1135 02ec 85E5      		ldi r24,lo8(85)
 1136 02ee 95E5      		ldi r25,lo8(85)
 1137               	.LVL75:
 1138 02f0 00D0      		rcall flash_write_bus_cycle
 1139               	.LVL76:
 563:setup.c       **** 	flash_write_bus_cycle(0x2AAA, 0x55);
 1140               		.loc 1 563 0
 1141 02f2 65E5      		ldi r22,lo8(85)
 1142 02f4 8AEA      		ldi r24,lo8(-86)
 1143 02f6 9AE2      		ldi r25,lo8(42)
 1144 02f8 00D0      		rcall flash_write_bus_cycle
 1145               	.LVL77:
 564:setup.c       **** 	
 565:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xB0);
 1146               		.loc 1 565 0
 1147 02fa 60EB      		ldi r22,lo8(-80)
 1148 02fc 85E5      		ldi r24,lo8(85)
 1149 02fe 95E5      		ldi r25,lo8(85)
 1150 0300 00D0      		rcall flash_write_bus_cycle
 1151               	.LVL78:
 566:setup.c       **** 	flash_write_bus_cycle(0x0000, bank);
 1152               		.loc 1 566 0
 1153 0302 6C2F      		mov r22,r28
 1154 0304 80E0      		ldi r24,0
 1155 0306 90E0      		ldi r25,0
 1156               	/* epilogue start */
 567:setup.c       **** }
 1157               		.loc 1 567 0
 1158 0308 CF91      		pop r28
 1159               	.LVL79:
 566:setup.c       **** 	flash_write_bus_cycle(0x0000, bank);
 1160               		.loc 1 566 0
 1161 030a 00C0      		rjmp flash_write_bus_cycle
 1162               	.LVL80:
 1163               		.cfi_endproc
 1164               	.LFE32:
 1166               	.global	flash_erase_4k_sector
 1168               	flash_erase_4k_sector:
 1169               	.LFB33:
 568:setup.c       **** 
 569:setup.c       **** // Erase 4K sector on Flash, expects first sector to start at 0, left shifts by 12 (A15-A12 to sele
 570:setup.c       **** // Takes 25ms after last command to erase sector
 571:setup.c       **** void flash_erase_4k_sector(uint8_t sector) {
 1170               		.loc 1 571 0
 1171               		.cfi_startproc
 1172               	.LVL81:
 1173 030c CF93      		push r28
 1174               	.LCFI15:
 1175               		.cfi_def_cfa_offset 3
 1176               		.cfi_offset 28, -2
 1177               	/* prologue: function */
 1178               	/* frame size = 0 */
 1179               	/* stack size = 1 */
 1180               	.L__stack_usage = 1
 1181 030e C82F      		mov r28,r24
 572:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xAA);
 1182               		.loc 1 572 0
 1183 0310 6AEA      		ldi r22,lo8(-86)
 1184 0312 85E5      		ldi r24,lo8(85)
 1185 0314 95E5      		ldi r25,lo8(85)
 1186               	.LVL82:
 1187 0316 00D0      		rcall flash_write_bus_cycle
 1188               	.LVL83:
 573:setup.c       **** 	flash_write_bus_cycle(0x2AAA, 0x55);
 1189               		.loc 1 573 0
 1190 0318 65E5      		ldi r22,lo8(85)
 1191 031a 8AEA      		ldi r24,lo8(-86)
 1192 031c 9AE2      		ldi r25,lo8(42)
 1193 031e 00D0      		rcall flash_write_bus_cycle
 1194               	.LVL84:
 574:setup.c       **** 	flash_write_bus_cycle(0x5555, 0x80);
 1195               		.loc 1 574 0
 1196 0320 60E8      		ldi r22,lo8(-128)
 1197 0322 85E5      		ldi r24,lo8(85)
 1198 0324 95E5      		ldi r25,lo8(85)
 1199 0326 00D0      		rcall flash_write_bus_cycle
 1200               	.LVL85:
 575:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xAA);
 1201               		.loc 1 575 0
 1202 0328 6AEA      		ldi r22,lo8(-86)
 1203 032a 85E5      		ldi r24,lo8(85)
 1204 032c 95E5      		ldi r25,lo8(85)
 1205 032e 00D0      		rcall flash_write_bus_cycle
 1206               	.LVL86:
 576:setup.c       **** 	flash_write_bus_cycle(0x2AAA, 0x55);
 1207               		.loc 1 576 0
 1208 0330 65E5      		ldi r22,lo8(85)
 1209 0332 8AEA      		ldi r24,lo8(-86)
 1210 0334 9AE2      		ldi r25,lo8(42)
 1211 0336 00D0      		rcall flash_write_bus_cycle
 1212               	.LVL87:
 577:setup.c       **** 	
 578:setup.c       **** 	flash_write_bus_cycle((uint16_t) sector << 12, 0x30);
 1213               		.loc 1 578 0
 1214 0338 60E3      		ldi r22,lo8(48)
 1215 033a 80E0      		ldi r24,0
 1216 033c 9C2F      		mov r25,r28
 1217 033e 9295      		swap r25
 1218 0340 907F      		andi r25,lo8(-16)
 1219 0342 00D0      		rcall flash_write_bus_cycle
 1220               	.LVL88:
 1221               	.LBB81:
 1222               	.LBB82:
 1223               		.loc 2 187 0
 1224 0344 8FE4      		ldi r24,lo8(-15537)
 1225 0346 93EC      		ldi r25,hi8(-15537)
 1226 0348 0197      	1:	sbiw r24,1
 1227 034a 01F4      		brne 1b
 1228 034c 00C0      		rjmp .
 1229 034e 0000      		nop
 1230               	.LVL89:
 1231               	/* epilogue start */
 1232               	.LBE82:
 1233               	.LBE81:
 579:setup.c       **** 	_delay_ms(25); // Wait 25ms for sector erase
 580:setup.c       **** }
 1234               		.loc 1 580 0
 1235 0350 CF91      		pop r28
 1236               	.LVL90:
 1237 0352 0895      		ret
 1238               		.cfi_endproc
 1239               	.LFE33:
 1241               	.global	flash_write_byte
 1243               	flash_write_byte:
 1244               	.LFB34:
 581:setup.c       **** 
 582:setup.c       **** // Write a single byte to the Flash address
 583:setup.c       **** // Takes 20us to program Flash
 584:setup.c       **** void flash_write_byte(uint16_t address, uint8_t data) {
 1245               		.loc 1 584 0
 1246               		.cfi_startproc
 1247               	.LVL91:
 1248 0354 1F93      		push r17
 1249               	.LCFI16:
 1250               		.cfi_def_cfa_offset 3
 1251               		.cfi_offset 17, -2
 1252 0356 CF93      		push r28
 1253               	.LCFI17:
 1254               		.cfi_def_cfa_offset 4
 1255               		.cfi_offset 28, -3
 1256 0358 DF93      		push r29
 1257               	.LCFI18:
 1258               		.cfi_def_cfa_offset 5
 1259               		.cfi_offset 29, -4
 1260               	/* prologue: function */
 1261               	/* frame size = 0 */
 1262               	/* stack size = 3 */
 1263               	.L__stack_usage = 3
 1264 035a EC01      		movw r28,r24
 1265 035c 162F      		mov r17,r22
 585:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xAA);
 1266               		.loc 1 585 0
 1267 035e 6AEA      		ldi r22,lo8(-86)
 1268               	.LVL92:
 1269 0360 85E5      		ldi r24,lo8(85)
 1270 0362 95E5      		ldi r25,lo8(85)
 1271               	.LVL93:
 1272 0364 00D0      		rcall flash_write_bus_cycle
 1273               	.LVL94:
 586:setup.c       **** 	flash_write_bus_cycle(0x2AAA, 0x55);
 1274               		.loc 1 586 0
 1275 0366 65E5      		ldi r22,lo8(85)
 1276 0368 8AEA      		ldi r24,lo8(-86)
 1277 036a 9AE2      		ldi r25,lo8(42)
 1278 036c 00D0      		rcall flash_write_bus_cycle
 1279               	.LVL95:
 587:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xA0);
 1280               		.loc 1 587 0
 1281 036e 60EA      		ldi r22,lo8(-96)
 1282 0370 85E5      		ldi r24,lo8(85)
 1283 0372 95E5      		ldi r25,lo8(85)
 1284 0374 00D0      		rcall flash_write_bus_cycle
 1285               	.LVL96:
 588:setup.c       **** 	
 589:setup.c       **** 	flash_write_bus_cycle(address, data);
 1286               		.loc 1 589 0
 1287 0376 612F      		mov r22,r17
 1288 0378 CE01      		movw r24,r28
 1289 037a 00D0      		rcall flash_write_bus_cycle
 1290               	.LVL97:
 1291               	.LBB83:
 1292               	.LBB84:
 188:c:\winavr-20100110\avr\include\util\delay.h **** 
 189:c:\winavr-20100110\avr\include\util\delay.h **** #else
 190:c:\winavr-20100110\avr\include\util\delay.h **** 	uint16_t __ticks;
 191:c:\winavr-20100110\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 4e3) * __ms;
 192:c:\winavr-20100110\avr\include\util\delay.h **** 	if (__tmp < 1.0)
 193:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks = 1;
 194:c:\winavr-20100110\avr\include\util\delay.h **** 	else if (__tmp > 65535)
 195:c:\winavr-20100110\avr\include\util\delay.h **** 	{
 196:c:\winavr-20100110\avr\include\util\delay.h **** 		//	__ticks = requested delay in 1/10 ms
 197:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 198:c:\winavr-20100110\avr\include\util\delay.h **** 		while(__ticks)
 199:c:\winavr-20100110\avr\include\util\delay.h **** 		{
 200:c:\winavr-20100110\avr\include\util\delay.h **** 			// wait 1/10 ms
 201:c:\winavr-20100110\avr\include\util\delay.h **** 			_delay_loop_2(((F_CPU) / 4e3) / 10);
 202:c:\winavr-20100110\avr\include\util\delay.h **** 			__ticks --;
 203:c:\winavr-20100110\avr\include\util\delay.h **** 		}
 204:c:\winavr-20100110\avr\include\util\delay.h **** 		return;
 205:c:\winavr-20100110\avr\include\util\delay.h **** 	}
 206:c:\winavr-20100110\avr\include\util\delay.h **** 	else
 207:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks = (uint16_t)__tmp;
 208:c:\winavr-20100110\avr\include\util\delay.h **** 	_delay_loop_2(__ticks);
 209:c:\winavr-20100110\avr\include\util\delay.h **** #endif
 210:c:\winavr-20100110\avr\include\util\delay.h **** }
 211:c:\winavr-20100110\avr\include\util\delay.h **** 
 212:c:\winavr-20100110\avr\include\util\delay.h **** /**
 213:c:\winavr-20100110\avr\include\util\delay.h ****    \ingroup util_delay
 214:c:\winavr-20100110\avr\include\util\delay.h **** 
 215:c:\winavr-20100110\avr\include\util\delay.h ****    Perform a delay of \c __us microseconds, using _delay_loop_1().
 216:c:\winavr-20100110\avr\include\util\delay.h **** 
 217:c:\winavr-20100110\avr\include\util\delay.h ****    The macro F_CPU is supposed to be defined to a
 218:c:\winavr-20100110\avr\include\util\delay.h ****    constant defining the CPU clock frequency (in Hertz).
 219:c:\winavr-20100110\avr\include\util\delay.h **** 
 220:c:\winavr-20100110\avr\include\util\delay.h ****    The maximal possible delay is 768 us / F_CPU in MHz.
 221:c:\winavr-20100110\avr\include\util\delay.h **** 
 222:c:\winavr-20100110\avr\include\util\delay.h ****    If the user requests a delay greater than the maximal possible one,
 223:c:\winavr-20100110\avr\include\util\delay.h ****    _delay_us() will automatically call _delay_ms() instead.  The user
 224:c:\winavr-20100110\avr\include\util\delay.h ****    will not be informed about this case.
 225:c:\winavr-20100110\avr\include\util\delay.h **** 
 226:c:\winavr-20100110\avr\include\util\delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 227:c:\winavr-20100110\avr\include\util\delay.h ****    support, maximal possible delay is 4294967.295 us/ F_CPU in MHz. For
 228:c:\winavr-20100110\avr\include\util\delay.h ****    values greater than the maximal possible delay, overflow results in
 229:c:\winavr-20100110\avr\include\util\delay.h ****    no delay i.e., 0us.
 230:c:\winavr-20100110\avr\include\util\delay.h **** 
 231:c:\winavr-20100110\avr\include\util\delay.h ****    Conversion of \c __us into clock cycles may not always result in
 232:c:\winavr-20100110\avr\include\util\delay.h ****    integer.  By default, the clock cycles rounded up to next
 233:c:\winavr-20100110\avr\include\util\delay.h ****    integer. This ensures that the user gets at least \c __us
 234:c:\winavr-20100110\avr\include\util\delay.h ****    microseconds of delay.
 235:c:\winavr-20100110\avr\include\util\delay.h **** 
 236:c:\winavr-20100110\avr\include\util\delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 237:c:\winavr-20100110\avr\include\util\delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 238:c:\winavr-20100110\avr\include\util\delay.h ****    algorithm can be made to round down, or round to closest integer,
 239:c:\winavr-20100110\avr\include\util\delay.h ****    respectively.
 240:c:\winavr-20100110\avr\include\util\delay.h **** 
 241:c:\winavr-20100110\avr\include\util\delay.h ****    \note
 242:c:\winavr-20100110\avr\include\util\delay.h **** 
 243:c:\winavr-20100110\avr\include\util\delay.h ****    The implementation of _delay_ms() based on
 244:c:\winavr-20100110\avr\include\util\delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 245:c:\winavr-20100110\avr\include\util\delay.h ****    implementations.  In order to get functionality backward compatible
 246:c:\winavr-20100110\avr\include\util\delay.h ****    with previous versions, the macro \c __DELAY_BACKWARD_COMPATIBLE__
 247:c:\winavr-20100110\avr\include\util\delay.h ****    must be defined before including this header file. Also, the
 248:c:\winavr-20100110\avr\include\util\delay.h ****    backward compatible algorithm will be chosen if the code is
 249:c:\winavr-20100110\avr\include\util\delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 250:c:\winavr-20100110\avr\include\util\delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 251:c:\winavr-20100110\avr\include\util\delay.h ****    not available to the compiler then.
 252:c:\winavr-20100110\avr\include\util\delay.h **** 
 253:c:\winavr-20100110\avr\include\util\delay.h ****  */
 254:c:\winavr-20100110\avr\include\util\delay.h **** void
 255:c:\winavr-20100110\avr\include\util\delay.h **** _delay_us(double __us)
 256:c:\winavr-20100110\avr\include\util\delay.h **** {
 257:c:\winavr-20100110\avr\include\util\delay.h **** 	double __tmp ;
 258:c:\winavr-20100110\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 259:c:\winavr-20100110\avr\include\util\delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 260:c:\winavr-20100110\avr\include\util\delay.h ****   __STDC_HOSTED__
 261:c:\winavr-20100110\avr\include\util\delay.h **** 	uint32_t __ticks_dc;
 262:c:\winavr-20100110\avr\include\util\delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 263:c:\winavr-20100110\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 264:c:\winavr-20100110\avr\include\util\delay.h **** 
 265:c:\winavr-20100110\avr\include\util\delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 266:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 267:c:\winavr-20100110\avr\include\util\delay.h **** 
 268:c:\winavr-20100110\avr\include\util\delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 269:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 270:c:\winavr-20100110\avr\include\util\delay.h **** 
 271:c:\winavr-20100110\avr\include\util\delay.h **** 	#else
 272:c:\winavr-20100110\avr\include\util\delay.h **** 		//round up by default
 273:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 274:c:\winavr-20100110\avr\include\util\delay.h **** 	#endif
 275:c:\winavr-20100110\avr\include\util\delay.h **** 
 276:c:\winavr-20100110\avr\include\util\delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 1293               		.loc 2 276 0
 1294 037c 85E3      		ldi r24,lo8(53)
 1295 037e 8A95      	1:	dec r24
 1296 0380 01F4      		brne 1b
 1297 0382 0000      		nop
 1298               	.LVL98:
 1299               	/* epilogue start */
 1300               	.LBE84:
 1301               	.LBE83:
 590:setup.c       **** 	_delay_us(20); // Wait byte program time
 591:setup.c       **** }
 1302               		.loc 1 591 0
 1303 0384 DF91      		pop r29
 1304 0386 CF91      		pop r28
 1305               	.LVL99:
 1306 0388 1F91      		pop r17
 1307               	.LVL100:
 1308 038a 0895      		ret
 1309               		.cfi_endproc
 1310               	.LFE34:
 1312               	.global	flash_write_sector
 1314               	flash_write_sector:
 1315               	.LFB35:
 592:setup.c       **** 
 593:setup.c       **** // Write a sector (128 bytes) to the Atmel flash
 594:setup.c       **** // Takes 20ms for write cycle
 595:setup.c       **** void flash_write_sector(uint16_t sector) {
 1316               		.loc 1 595 0
 1317               		.cfi_startproc
 1318               	.LVL101:
 1319 038c EF92      		push r14
 1320               	.LCFI19:
 1321               		.cfi_def_cfa_offset 3
 1322               		.cfi_offset 14, -2
 1323 038e FF92      		push r15
 1324               	.LCFI20:
 1325               		.cfi_def_cfa_offset 4
 1326               		.cfi_offset 15, -3
 1327 0390 0F93      		push r16
 1328               	.LCFI21:
 1329               		.cfi_def_cfa_offset 5
 1330               		.cfi_offset 16, -4
 1331 0392 1F93      		push r17
 1332               	.LCFI22:
 1333               		.cfi_def_cfa_offset 6
 1334               		.cfi_offset 17, -5
 1335 0394 CF93      		push r28
 1336               	.LCFI23:
 1337               		.cfi_def_cfa_offset 7
 1338               		.cfi_offset 28, -6
 1339 0396 DF93      		push r29
 1340               	.LCFI24:
 1341               		.cfi_def_cfa_offset 8
 1342               		.cfi_offset 29, -7
 1343               	/* prologue: function */
 1344               	/* frame size = 0 */
 1345               	/* stack size = 6 */
 1346               	.L__stack_usage = 6
 1347 0398 8C01      		movw r16,r24
 596:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xAA);
 1348               		.loc 1 596 0
 1349 039a 6AEA      		ldi r22,lo8(-86)
 1350 039c 85E5      		ldi r24,lo8(85)
 1351 039e 95E5      		ldi r25,lo8(85)
 1352               	.LVL102:
 1353 03a0 00D0      		rcall flash_write_bus_cycle
 1354               	.LVL103:
 597:setup.c       **** 	flash_write_bus_cycle(0x2AAA, 0x55);
 1355               		.loc 1 597 0
 1356 03a2 65E5      		ldi r22,lo8(85)
 1357 03a4 8AEA      		ldi r24,lo8(-86)
 1358 03a6 9AE2      		ldi r25,lo8(42)
 1359 03a8 00D0      		rcall flash_write_bus_cycle
 1360               	.LVL104:
 598:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xA0);
 1361               		.loc 1 598 0
 1362 03aa 60EA      		ldi r22,lo8(-96)
 1363 03ac 85E5      		ldi r24,lo8(85)
 1364 03ae 95E5      		ldi r25,lo8(85)
 1365 03b0 00D0      		rcall flash_write_bus_cycle
 1366               	.LVL105:
 1367               	.LBB85:
 599:setup.c       **** 	
 600:setup.c       **** 	// Write the bytes (A0-A6 byte address, A7-A15 sector address)
 601:setup.c       **** 	for (uint8_t x = 0; x < 128; x++) {
 602:setup.c       **** 		flash_write_bus_cycle((uint16_t) (sector << 7) | (uint16_t) x, receivedBuffer[x]);
 1368               		.loc 1 602 0
 1369 03b2 1695      		lsr r17
 1370 03b4 102F      		mov r17,r16
 1371 03b6 0027      		clr r16
 1372 03b8 1795      		ror r17
 1373 03ba 0795      		ror r16
 1374               	.LVL106:
 1375 03bc 90E0      		ldi r25,lo8(receivedBuffer)
 1376 03be E92E      		mov r14,r25
 1377 03c0 90E0      		ldi r25,hi8(receivedBuffer)
 1378 03c2 F92E      		mov r15,r25
 1379 03c4 C0E0      		ldi r28,0
 1380 03c6 D0E0      		ldi r29,0
 1381               	.LVL107:
 1382               	.L66:
 1383               		.loc 1 602 0 is_stmt 0 discriminator 3
 1384 03c8 F701      		movw r30,r14
 1385 03ca 6191      		ld r22,Z+
 1386 03cc 7F01      		movw r14,r30
 1387 03ce CE01      		movw r24,r28
 1388 03d0 802B      		or r24,r16
 1389 03d2 912B      		or r25,r17
 1390 03d4 00D0      		rcall flash_write_bus_cycle
 1391               	.LVL108:
 1392 03d6 2196      		adiw r28,1
 1393               	.LVL109:
 601:setup.c       **** 		flash_write_bus_cycle((uint16_t) (sector << 7) | (uint16_t) x, receivedBuffer[x]);
 1394               		.loc 1 601 0 is_stmt 1 discriminator 3
 1395 03d8 C038      		cpi r28,-128
 1396 03da D105      		cpc r29,__zero_reg__
 1397 03dc 01F4      		brne .L66
 1398               	.LVL110:
 1399               	.LBE85:
 1400               	.LBB86:
 1401               	.LBB87:
 187:c:\winavr-20100110\avr\include\util\delay.h **** 
 1402               		.loc 2 187 0
 1403 03de 8FE3      		ldi r24,lo8(-25537)
 1404 03e0 9CE9      		ldi r25,hi8(-25537)
 1405 03e2 0197      	1:	sbiw r24,1
 1406 03e4 01F4      		brne 1b
 1407 03e6 00C0      		rjmp .
 1408 03e8 0000      		nop
 1409               	.LVL111:
 1410               	/* epilogue start */
 1411               	.LBE87:
 1412               	.LBE86:
 603:setup.c       **** 	}
 604:setup.c       **** 	_delay_ms(20); // Wait sector program time
 605:setup.c       **** }
 1413               		.loc 1 605 0
 1414 03ea DF91      		pop r29
 1415 03ec CF91      		pop r28
 1416               	.LVL112:
 1417 03ee 1F91      		pop r17
 1418 03f0 0F91      		pop r16
 1419 03f2 FF90      		pop r15
 1420 03f4 EF90      		pop r14
 1421 03f6 0895      		ret
 1422               		.cfi_endproc
 1423               	.LFE35:
 1425               	.global	gb_flash_read_byte
 1427               	gb_flash_read_byte:
 1428               	.LFB36:
 606:setup.c       **** 
 607:setup.c       **** 
 608:setup.c       **** 
 609:setup.c       **** // ---------- GB FLASH CARTS ----------
 610:setup.c       **** 
 611:setup.c       **** // Read a byte from the flash (No CS pin pulse)
 612:setup.c       **** uint8_t gb_flash_read_byte(uint16_t address) {
 1429               		.loc 1 612 0
 1430               		.cfi_startproc
 1431               	.LVL113:
 1432               	/* prologue: function */
 1433               	/* frame size = 0 */
 1434               	/* stack size = 0 */
 1435               	.L__stack_usage = 0
 613:setup.c       **** 	PORT_DATA7_0 = 0;
 1436               		.loc 1 613 0
 1437 03f8 15BA      		out 0x15,__zero_reg__
 614:setup.c       **** 	DDR_DATA7_0 = 0;
 1438               		.loc 1 614 0
 1439 03fa 14BA      		out 0x14,__zero_reg__
 615:setup.c       **** 	
 616:setup.c       **** 	set_16bit_address(address);
 1440               		.loc 1 616 0
 1441 03fc 00D0      		rcall set_16bit_address
 1442               	.LVL114:
 617:setup.c       **** 	
 618:setup.c       **** 	rdPin_low;
 1443               		.loc 1 618 0
 1444 03fe 9598      		cbi 0x12,5
 619:setup.c       **** 	asm volatile("nop"); // Delay a little
 1445               		.loc 1 619 0
 1446               	/* #APP */
 1447               	 ;  619 "setup.c" 1
 1448 0400 0000      		nop
 1449               	 ;  0 "" 2
 620:setup.c       **** 	asm volatile("nop");
 1450               		.loc 1 620 0
 1451               	 ;  620 "setup.c" 1
 1452 0402 0000      		nop
 1453               	 ;  0 "" 2
 621:setup.c       **** 	uint8_t data = PIN_DATA7_0; // Read data
 1454               		.loc 1 621 0
 1455               	/* #NOAPP */
 1456 0404 83B3      		in r24,0x13
 1457               	.LVL115:
 622:setup.c       **** 	rdPin_high;
 1458               		.loc 1 622 0
 1459 0406 959A      		sbi 0x12,5
 623:setup.c       **** 	
 624:setup.c       **** 	return data;
 625:setup.c       **** }
 1460               		.loc 1 625 0
 1461 0408 0895      		ret
 1462               		.cfi_endproc
 1463               	.LFE36:
 1465               	.global	gb_flash_write_bus_cycle
 1467               	gb_flash_write_bus_cycle:
 1468               	.LFB37:
 626:setup.c       **** 
 627:setup.c       **** // Set the address and data for the write byte cycle to the flash
 628:setup.c       **** void gb_flash_write_bus_cycle(uint16_t address, uint8_t data) {
 1469               		.loc 1 628 0
 1470               		.cfi_startproc
 1471               	.LVL116:
 1472 040a CF93      		push r28
 1473               	.LCFI25:
 1474               		.cfi_def_cfa_offset 3
 1475               		.cfi_offset 28, -2
 1476               	/* prologue: function */
 1477               	/* frame size = 0 */
 1478               	/* stack size = 1 */
 1479               	.L__stack_usage = 1
 1480 040c C62F      		mov r28,r22
 629:setup.c       **** 	DDR_DATA7_0 = 0xFF; // Set data pins as outputs
 1481               		.loc 1 629 0
 1482 040e 2FEF      		ldi r18,lo8(-1)
 1483 0410 24BB      		out 0x14,r18
 630:setup.c       **** 	set_16bit_address(address);
 1484               		.loc 1 630 0
 1485 0412 00D0      		rcall set_16bit_address
 1486               	.LVL117:
 631:setup.c       **** 	PORT_DATA7_0 = data;
 1487               		.loc 1 631 0
 1488 0414 C5BB      		out 0x15,r28
 632:setup.c       **** 	
 633:setup.c       **** 	if (flashWriteWePin == WE_AS_AUDIO_PIN) { // Audio pin
 1489               		.loc 1 633 0
 1490 0416 8091 0000 		lds r24,flashWriteWePin
 1491 041a 8134      		cpi r24,lo8(65)
 1492 041c 01F4      		brne .L70
 1493               	.LVL118:
 1494               	.LBB90:
 1495               	.LBB91:
 634:setup.c       **** 		audioPin_low; // WE low
 1496               		.loc 1 634 0
 1497 041e 3998      		cbi 0x7,1
 635:setup.c       **** 		asm volatile("nop");
 1498               		.loc 1 635 0
 1499               	/* #APP */
 1500               	 ;  635 "setup.c" 1
 1501 0420 0000      		nop
 1502               	 ;  0 "" 2
 636:setup.c       **** 		asm volatile("nop");
 1503               		.loc 1 636 0
 1504               	 ;  636 "setup.c" 1
 1505 0422 0000      		nop
 1506               	 ;  0 "" 2
 637:setup.c       **** 		asm volatile("nop");
 1507               		.loc 1 637 0
 1508               	 ;  637 "setup.c" 1
 1509 0424 0000      		nop
 1510               	 ;  0 "" 2
 638:setup.c       **** 		audioPin_high; // WE high
 1511               		.loc 1 638 0
 1512               	/* #NOAPP */
 1513 0426 399A      		sbi 0x7,1
 1514 0428 00C0      		rjmp .L69
 1515               	.LVL119:
 1516               	.L70:
 1517               	.LBE91:
 1518               	.LBE90:
 639:setup.c       **** 	}
 640:setup.c       **** 	else { // WR pin
 641:setup.c       **** 		wrPin_low; // WE low
 1519               		.loc 1 641 0
 1520 042a 9698      		cbi 0x12,6
 642:setup.c       **** 		asm volatile("nop");
 1521               		.loc 1 642 0
 1522               	/* #APP */
 1523               	 ;  642 "setup.c" 1
 1524 042c 0000      		nop
 1525               	 ;  0 "" 2
 643:setup.c       **** 		asm volatile("nop");
 1526               		.loc 1 643 0
 1527               	 ;  643 "setup.c" 1
 1528 042e 0000      		nop
 1529               	 ;  0 "" 2
 644:setup.c       **** 		asm volatile("nop");
 1530               		.loc 1 644 0
 1531               	 ;  644 "setup.c" 1
 1532 0430 0000      		nop
 1533               	 ;  0 "" 2
 645:setup.c       **** 		wrPin_high; // WE high
 1534               		.loc 1 645 0
 1535               	/* #NOAPP */
 1536 0432 969A      		sbi 0x12,6
 1537               	.L69:
 1538               	/* epilogue start */
 646:setup.c       **** 	}
 647:setup.c       **** }
 1539               		.loc 1 647 0
 1540 0434 CF91      		pop r28
 1541               	.LVL120:
 1542 0436 0895      		ret
 1543               		.cfi_endproc
 1544               	.LFE37:
 1546               	.global	gb_flash_write_byte
 1548               	gb_flash_write_byte:
 1549               	.LFB38:
 648:setup.c       **** 
 649:setup.c       **** // Write a single byte to the Flash address. Takes 10-50us to program each byte.
 650:setup.c       **** void gb_flash_write_byte(uint16_t address, uint8_t data) {
 1550               		.loc 1 650 0
 1551               		.cfi_startproc
 1552               	.LVL121:
 1553 0438 1F93      		push r17
 1554               	.LCFI26:
 1555               		.cfi_def_cfa_offset 3
 1556               		.cfi_offset 17, -2
 1557 043a CF93      		push r28
 1558               	.LCFI27:
 1559               		.cfi_def_cfa_offset 4
 1560               		.cfi_offset 28, -3
 1561 043c DF93      		push r29
 1562               	.LCFI28:
 1563               		.cfi_def_cfa_offset 5
 1564               		.cfi_offset 29, -4
 1565               	/* prologue: function */
 1566               	/* frame size = 0 */
 1567               	/* stack size = 3 */
 1568               	.L__stack_usage = 3
 1569 043e EC01      		movw r28,r24
 1570 0440 162F      		mov r17,r22
 651:setup.c       **** 	gb_flash_write_bus_cycle(flashWriteCycle[0][0], flashWriteCycle[0][1]);
 1571               		.loc 1 651 0
 1572 0442 6091 0000 		lds r22,flashWriteCycle+2
 1573               	.LVL122:
 1574 0446 8091 0000 		lds r24,flashWriteCycle
 1575 044a 9091 0000 		lds r25,flashWriteCycle+1
 1576               	.LVL123:
 1577 044e 00D0      		rcall gb_flash_write_bus_cycle
 1578               	.LVL124:
 652:setup.c       **** 	gb_flash_write_bus_cycle(flashWriteCycle[1][0], flashWriteCycle[1][1]);
 1579               		.loc 1 652 0
 1580 0450 6091 0000 		lds r22,flashWriteCycle+6
 1581 0454 8091 0000 		lds r24,flashWriteCycle+4
 1582 0458 9091 0000 		lds r25,flashWriteCycle+4+1
 1583 045c 00D0      		rcall gb_flash_write_bus_cycle
 1584               	.LVL125:
 653:setup.c       **** 	gb_flash_write_bus_cycle(flashWriteCycle[2][0], flashWriteCycle[2][1]);
 1585               		.loc 1 653 0
 1586 045e 6091 0000 		lds r22,flashWriteCycle+10
 1587 0462 8091 0000 		lds r24,flashWriteCycle+8
 1588 0466 9091 0000 		lds r25,flashWriteCycle+8+1
 1589 046a 00D0      		rcall gb_flash_write_bus_cycle
 1590               	.LVL126:
 654:setup.c       **** 	gb_flash_write_bus_cycle(address, data);
 1591               		.loc 1 654 0
 1592 046c 612F      		mov r22,r17
 1593 046e CE01      		movw r24,r28
 1594 0470 00D0      		rcall gb_flash_write_bus_cycle
 1595               	.LVL127:
 1596               	.LBB92:
 1597               	.LBB93:
 1598               		.loc 2 276 0
 1599 0472 8AE1      		ldi r24,lo8(26)
 1600 0474 8A95      	1:	dec r24
 1601 0476 01F4      		brne 1b
 1602 0478 00C0      		rjmp .
 1603               	.LVL128:
 1604               	.LBE93:
 1605               	.LBE92:
 655:setup.c       **** 	_delay_us(10); // Wait byte program time
 656:setup.c       **** 	
 657:setup.c       **** 	// Set data pins inputs
 658:setup.c       **** 	PORT_DATA7_0 = 0;
 1606               		.loc 1 658 0
 1607 047a 15BA      		out 0x15,__zero_reg__
 659:setup.c       **** 	DDR_DATA7_0 = 0;
 1608               		.loc 1 659 0
 1609 047c 14BA      		out 0x14,__zero_reg__
 660:setup.c       **** 	
 661:setup.c       **** 	// Verify data
 662:setup.c       **** 	uint8_t dataVerify = gb_flash_read_byte(address);
 1610               		.loc 1 662 0
 1611 047e CE01      		movw r24,r28
 1612 0480 00D0      		rcall gb_flash_read_byte
 1613               	.LVL129:
 1614               	.L73:
 663:setup.c       **** 	while (data != dataVerify) {
 1615               		.loc 1 663 0
 1616 0482 8117      		cp r24,r17
 1617 0484 01F0      		breq .L75
 664:setup.c       **** 		dataVerify = gb_flash_read_byte(address);
 1618               		.loc 1 664 0
 1619 0486 CE01      		movw r24,r28
 1620               	.LVL130:
 1621 0488 00D0      		rcall gb_flash_read_byte
 1622               	.LVL131:
 1623               	.LBB94:
 1624               	.LBB95:
 1625               		.loc 2 276 0
 1626 048a 9DE0      		ldi r25,lo8(13)
 1627 048c 9A95      	1:	dec r25
 1628 048e 01F4      		brne 1b
 1629 0490 0000      		nop
 1630 0492 00C0      		rjmp .L73
 1631               	.LVL132:
 1632               	.L75:
 1633               	/* epilogue start */
 1634               	.LBE95:
 1635               	.LBE94:
 665:setup.c       **** 		_delay_us(5);
 666:setup.c       **** 	}
 667:setup.c       **** }
 1636               		.loc 1 667 0
 1637 0494 DF91      		pop r29
 1638 0496 CF91      		pop r28
 1639               	.LVL133:
 1640 0498 1F91      		pop r17
 1641               	.LVL134:
 1642 049a 0895      		ret
 1643               		.cfi_endproc
 1644               	.LFE38:
 1646               	.global	gba_flash_write_bus_cycle
 1648               	gba_flash_write_bus_cycle:
 1649               	.LFB39:
 668:setup.c       **** 
 669:setup.c       **** 
 670:setup.c       **** 
 671:setup.c       **** // ---------- GBA FLASH CARTS ----------
 672:setup.c       **** 
 673:setup.c       **** // Set the 24 bit address and 16 bit data for the write byte cycle to the flash (pulse WR pin)
 674:setup.c       **** void gba_flash_write_bus_cycle(uint32_t address, uint16_t data) {
 1650               		.loc 1 674 0
 1651               		.cfi_startproc
 1652               	.LVL135:
 1653 049c 0F93      		push r16
 1654               	.LCFI29:
 1655               		.cfi_def_cfa_offset 3
 1656               		.cfi_offset 16, -2
 1657 049e 1F93      		push r17
 1658               	.LCFI30:
 1659               		.cfi_def_cfa_offset 4
 1660               		.cfi_offset 17, -3
 1661               	/* prologue: function */
 1662               	/* frame size = 0 */
 1663               	/* stack size = 2 */
 1664               	.L__stack_usage = 2
 675:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = (address >> 16);
 1665               		.loc 1 675 0
 1666 04a0 8C01      		movw r16,r24
 1667 04a2 2227      		clr r18
 1668 04a4 3327      		clr r19
 1669 04a6 05BB      		out 0x15,r16
 676:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = (address >> 8);
 1670               		.loc 1 676 0
 1671 04a8 072F      		mov r16,r23
 1672 04aa 182F      		mov r17,r24
 1673 04ac 292F      		mov r18,r25
 1674 04ae 3327      		clr r19
 1675 04b0 0BBB      		out 0x1b,r16
 677:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = (address & 0xFF);
 1676               		.loc 1 677 0
 1677 04b2 68BB      		out 0x18,r22
 678:setup.c       **** 	
 679:setup.c       **** 	cs_mreqPin_low;
 1678               		.loc 1 679 0
 1679 04b4 9498      		cbi 0x12,4
 680:setup.c       **** 	
 681:setup.c       **** 	GBA_PORT_ROM_DATA15_8 = data >> 8; // Set data
 1680               		.loc 1 681 0
 1681 04b6 5BBB      		out 0x1b,r21
 682:setup.c       **** 	GBA_PORT_ROM_DATA7_0 = data & 0xFF;
 1682               		.loc 1 682 0
 1683 04b8 48BB      		out 0x18,r20
 683:setup.c       **** 	
 684:setup.c       **** 	wrPin_low;
 1684               		.loc 1 684 0
 1685 04ba 9698      		cbi 0x12,6
 685:setup.c       **** 	asm volatile("nop");
 1686               		.loc 1 685 0
 1687               	/* #APP */
 1688               	 ;  685 "setup.c" 1
 1689 04bc 0000      		nop
 1690               	 ;  0 "" 2
 686:setup.c       **** 	asm volatile("nop");
 1691               		.loc 1 686 0
 1692               	 ;  686 "setup.c" 1
 1693 04be 0000      		nop
 1694               	 ;  0 "" 2
 687:setup.c       **** 	asm volatile("nop");
 1695               		.loc 1 687 0
 1696               	 ;  687 "setup.c" 1
 1697 04c0 0000      		nop
 1698               	 ;  0 "" 2
 688:setup.c       **** 	wrPin_high;
 1699               		.loc 1 688 0
 1700               	/* #NOAPP */
 1701 04c2 969A      		sbi 0x12,6
 689:setup.c       **** 	cs_mreqPin_high;
 1702               		.loc 1 689 0
 1703 04c4 949A      		sbi 0x12,4
 1704               	/* epilogue start */
 690:setup.c       **** }
 1705               		.loc 1 690 0
 1706 04c6 1F91      		pop r17
 1707 04c8 0F91      		pop r16
 1708 04ca 0895      		ret
 1709               		.cfi_endproc
 1710               	.LFE39:
 1712               	.global	gba_flash_write_cycle_start
 1714               	gba_flash_write_cycle_start:
 1715               	.LFB40:
 691:setup.c       **** 
 692:setup.c       **** // Send the first 3 write cycles to the flash
 693:setup.c       **** void gba_flash_write_cycle_start(void) {
 1716               		.loc 1 693 0
 1717               		.cfi_startproc
 1718               	/* prologue: function */
 1719               	/* frame size = 0 */
 1720               	/* stack size = 0 */
 1721               	.L__stack_usage = 0
 694:setup.c       **** 	// Set outputs
 695:setup.c       **** 	GBA_DDR_ROM_ADDR23_16 = 0xFF;
 1722               		.loc 1 695 0
 1723 04cc 8FEF      		ldi r24,lo8(-1)
 1724 04ce 84BB      		out 0x14,r24
 696:setup.c       **** 	GBA_DDR_ROM_ADDR15_8 = 0xFF;
 1725               		.loc 1 696 0
 1726 04d0 8ABB      		out 0x1a,r24
 697:setup.c       **** 	GBA_DDR_ROM_ADDR7_0 = 0xFF;
 1727               		.loc 1 697 0
 1728 04d2 87BB      		out 0x17,r24
 698:setup.c       **** 	
 699:setup.c       **** 	// 0x555, 0xA9
 700:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = 0;
 1729               		.loc 1 700 0
 1730 04d4 15BA      		out 0x15,__zero_reg__
 701:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = 0x05;
 1731               		.loc 1 701 0
 1732 04d6 95E0      		ldi r25,lo8(5)
 1733 04d8 9BBB      		out 0x1b,r25
 702:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = 0x55;
 1734               		.loc 1 702 0
 1735 04da 85E5      		ldi r24,lo8(85)
 1736 04dc 88BB      		out 0x18,r24
 703:setup.c       **** 	cs_mreqPin_low;
 1737               		.loc 1 703 0
 1738 04de 9498      		cbi 0x12,4
 704:setup.c       **** 	GBA_PORT_ROM_DATA15_8 = 0; // Set data
 1739               		.loc 1 704 0
 1740 04e0 1BBA      		out 0x1b,__zero_reg__
 705:setup.c       **** 	GBA_PORT_ROM_DATA7_0 = 0xA9;
 1741               		.loc 1 705 0
 1742 04e2 29EA      		ldi r18,lo8(-87)
 1743 04e4 28BB      		out 0x18,r18
 706:setup.c       **** 	wrPin_low;
 1744               		.loc 1 706 0
 1745 04e6 9698      		cbi 0x12,6
 707:setup.c       **** 	asm volatile("nop");
 1746               		.loc 1 707 0
 1747               	/* #APP */
 1748               	 ;  707 "setup.c" 1
 1749 04e8 0000      		nop
 1750               	 ;  0 "" 2
 708:setup.c       **** 	asm volatile("nop");
 1751               		.loc 1 708 0
 1752               	 ;  708 "setup.c" 1
 1753 04ea 0000      		nop
 1754               	 ;  0 "" 2
 709:setup.c       **** 	asm volatile("nop");
 1755               		.loc 1 709 0
 1756               	 ;  709 "setup.c" 1
 1757 04ec 0000      		nop
 1758               	 ;  0 "" 2
 710:setup.c       **** 	wrPin_high;
 1759               		.loc 1 710 0
 1760               	/* #NOAPP */
 1761 04ee 969A      		sbi 0x12,6
 711:setup.c       **** 	cs_mreqPin_high;
 1762               		.loc 1 711 0
 1763 04f0 949A      		sbi 0x12,4
 712:setup.c       **** 	
 713:setup.c       **** 	// 0x2AA, 0x56
 714:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = 0;
 1764               		.loc 1 714 0
 1765 04f2 15BA      		out 0x15,__zero_reg__
 715:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = 0x02;
 1766               		.loc 1 715 0
 1767 04f4 22E0      		ldi r18,lo8(2)
 1768 04f6 2BBB      		out 0x1b,r18
 716:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = 0xAA;
 1769               		.loc 1 716 0
 1770 04f8 2AEA      		ldi r18,lo8(-86)
 1771 04fa 28BB      		out 0x18,r18
 717:setup.c       **** 	cs_mreqPin_low;
 1772               		.loc 1 717 0
 1773 04fc 9498      		cbi 0x12,4
 718:setup.c       **** 	GBA_PORT_ROM_DATA15_8 = 0; // Set data
 1774               		.loc 1 718 0
 1775 04fe 1BBA      		out 0x1b,__zero_reg__
 719:setup.c       **** 	GBA_PORT_ROM_DATA7_0 = 0x56;
 1776               		.loc 1 719 0
 1777 0500 26E5      		ldi r18,lo8(86)
 1778 0502 28BB      		out 0x18,r18
 720:setup.c       **** 	wrPin_low;
 1779               		.loc 1 720 0
 1780 0504 9698      		cbi 0x12,6
 721:setup.c       **** 	asm volatile("nop");
 1781               		.loc 1 721 0
 1782               	/* #APP */
 1783               	 ;  721 "setup.c" 1
 1784 0506 0000      		nop
 1785               	 ;  0 "" 2
 722:setup.c       **** 	asm volatile("nop");
 1786               		.loc 1 722 0
 1787               	 ;  722 "setup.c" 1
 1788 0508 0000      		nop
 1789               	 ;  0 "" 2
 723:setup.c       **** 	asm volatile("nop");
 1790               		.loc 1 723 0
 1791               	 ;  723 "setup.c" 1
 1792 050a 0000      		nop
 1793               	 ;  0 "" 2
 724:setup.c       **** 	wrPin_high;
 1794               		.loc 1 724 0
 1795               	/* #NOAPP */
 1796 050c 969A      		sbi 0x12,6
 725:setup.c       **** 	cs_mreqPin_high;
 1797               		.loc 1 725 0
 1798 050e 949A      		sbi 0x12,4
 726:setup.c       **** 	
 727:setup.c       **** 	// 0x555, 0xA0;
 728:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = 0;
 1799               		.loc 1 728 0
 1800 0510 15BA      		out 0x15,__zero_reg__
 729:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = 0x05;
 1801               		.loc 1 729 0
 1802 0512 9BBB      		out 0x1b,r25
 730:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = 0x55;
 1803               		.loc 1 730 0
 1804 0514 88BB      		out 0x18,r24
 731:setup.c       **** 	cs_mreqPin_low;
 1805               		.loc 1 731 0
 1806 0516 9498      		cbi 0x12,4
 732:setup.c       **** 	GBA_PORT_ROM_DATA15_8 = 0; // Set data
 1807               		.loc 1 732 0
 1808 0518 1BBA      		out 0x1b,__zero_reg__
 733:setup.c       **** 	GBA_PORT_ROM_DATA7_0 = 0xA0;
 1809               		.loc 1 733 0
 1810 051a 80EA      		ldi r24,lo8(-96)
 1811 051c 88BB      		out 0x18,r24
 734:setup.c       **** 	wrPin_low;
 1812               		.loc 1 734 0
 1813 051e 9698      		cbi 0x12,6
 735:setup.c       **** 	asm volatile("nop");
 1814               		.loc 1 735 0
 1815               	/* #APP */
 1816               	 ;  735 "setup.c" 1
 1817 0520 0000      		nop
 1818               	 ;  0 "" 2
 736:setup.c       **** 	asm volatile("nop");
 1819               		.loc 1 736 0
 1820               	 ;  736 "setup.c" 1
 1821 0522 0000      		nop
 1822               	 ;  0 "" 2
 737:setup.c       **** 	asm volatile("nop");
 1823               		.loc 1 737 0
 1824               	 ;  737 "setup.c" 1
 1825 0524 0000      		nop
 1826               	 ;  0 "" 2
 738:setup.c       **** 	wrPin_high;
 1827               		.loc 1 738 0
 1828               	/* #NOAPP */
 1829 0526 969A      		sbi 0x12,6
 739:setup.c       **** 	cs_mreqPin_high;
 1830               		.loc 1 739 0
 1831 0528 949A      		sbi 0x12,4
 1832 052a 0895      		ret
 1833               		.cfi_endproc
 1834               	.LFE40:
 1836               	.global	gba_flash_write_byte_swapped
 1838               	gba_flash_write_byte_swapped:
 1839               	.LFB41:
 740:setup.c       **** }	
 741:setup.c       **** 
 742:setup.c       **** 
 743:setup.c       **** // Write 2 bytes to the Flash address. Time to wait depends on Flash, we will query it to verify th
 744:setup.c       **** // Address is divided by 2 as we are in GBA mode. 
 745:setup.c       **** // Data byte's bit 0 & 1 are swapped for chip commands as D0 & D1 lines are swapped
 746:setup.c       **** void gba_flash_write_byte_swapped(uint32_t address, uint16_t data) {
 1840               		.loc 1 746 0
 1841               		.cfi_startproc
 1842               	.LVL136:
 1843 052c CF92      		push r12
 1844               	.LCFI31:
 1845               		.cfi_def_cfa_offset 3
 1846               		.cfi_offset 12, -2
 1847 052e DF92      		push r13
 1848               	.LCFI32:
 1849               		.cfi_def_cfa_offset 4
 1850               		.cfi_offset 13, -3
 1851 0530 EF92      		push r14
 1852               	.LCFI33:
 1853               		.cfi_def_cfa_offset 5
 1854               		.cfi_offset 14, -4
 1855 0532 FF92      		push r15
 1856               	.LCFI34:
 1857               		.cfi_def_cfa_offset 6
 1858               		.cfi_offset 15, -5
 1859 0534 CF93      		push r28
 1860               	.LCFI35:
 1861               		.cfi_def_cfa_offset 7
 1862               		.cfi_offset 28, -6
 1863 0536 DF93      		push r29
 1864               	.LCFI36:
 1865               		.cfi_def_cfa_offset 8
 1866               		.cfi_offset 29, -7
 1867               	/* prologue: function */
 1868               	/* frame size = 0 */
 1869               	/* stack size = 6 */
 1870               	.L__stack_usage = 6
 1871 0538 6B01      		movw r12,r22
 1872 053a 7C01      		movw r14,r24
 1873 053c EA01      		movw r28,r20
 747:setup.c       **** 	gba_flash_write_cycle_start();
 1874               		.loc 1 747 0
 1875 053e 00D0      		rcall gba_flash_write_cycle_start
 1876               	.LVL137:
 748:setup.c       **** 	gba_flash_write_bus_cycle(address, data);
 1877               		.loc 1 748 0
 1878 0540 AE01      		movw r20,r28
 1879 0542 C701      		movw r24,r14
 1880 0544 B601      		movw r22,r12
 1881 0546 00D0      		rcall gba_flash_write_bus_cycle
 1882               	.LVL138:
 1883               	.LBB96:
 1884               	.LBB97:
 1885               		.loc 2 276 0
 1886 0548 25E0      		ldi r18,lo8(5)
 1887 054a 2A95      	1:	dec r18
 1888 054c 01F4      		brne 1b
 1889 054e 0000      		nop
 1890               	.LVL139:
 1891               	.LBE97:
 1892               	.LBE96:
 749:setup.c       **** 	_delay_us(2); // Wait byte program time
 750:setup.c       **** 	
 751:setup.c       **** 	// Verify data
 752:setup.c       **** 	uint16_t dataVerify = gba_read_16bit_data(address);
 1893               		.loc 1 752 0
 1894 0550 C701      		movw r24,r14
 1895 0552 B601      		movw r22,r12
 1896 0554 00D0      		rcall gba_read_16bit_data
 1897               	.LVL140:
 1898               	.L79:
 753:setup.c       **** 	while (data != dataVerify) {
 1899               		.loc 1 753 0
 1900 0556 8C17      		cp r24,r28
 1901 0558 9D07      		cpc r25,r29
 1902 055a 01F0      		breq .L81
 754:setup.c       **** 		dataVerify = gba_read_16bit_data(address);
 1903               		.loc 1 754 0
 1904 055c C701      		movw r24,r14
 1905 055e B601      		movw r22,r12
 1906 0560 00D0      		rcall gba_read_16bit_data
 1907               	.LVL141:
 1908               	.LBB98:
 1909               	.LBB99:
 1910               		.loc 2 276 0
 1911 0562 25E0      		ldi r18,lo8(5)
 1912 0564 2A95      	1:	dec r18
 1913 0566 01F4      		brne 1b
 1914 0568 0000      		nop
 1915 056a 00C0      		rjmp .L79
 1916               	.LVL142:
 1917               	.L81:
 1918               	/* epilogue start */
 1919               	.LBE99:
 1920               	.LBE98:
 755:setup.c       **** 		_delay_us(2);
 756:setup.c       **** 	}
 757:setup.c       **** }
 1921               		.loc 1 757 0
 1922 056c DF91      		pop r29
 1923 056e CF91      		pop r28
 1924               	.LVL143:
 1925 0570 FF90      		pop r15
 1926 0572 EF90      		pop r14
 1927 0574 DF90      		pop r13
 1928 0576 CF90      		pop r12
 1929               	.LVL144:
 1930 0578 0895      		ret
 1931               		.cfi_endproc
 1932               	.LFE41:
 1934               	.global	setup
 1936               	setup:
 1937               	.LFB42:
 758:setup.c       **** 
 759:setup.c       **** 
 760:setup.c       **** // Setup
 761:setup.c       **** void setup(void) {
 1938               		.loc 1 761 0
 1939               		.cfi_startproc
 1940               	/* prologue: function */
 1941               	/* frame size = 0 */
 1942               	/* stack size = 0 */
 1943               	.L__stack_usage = 0
 762:setup.c       **** 	// Turn off watchdog
 763:setup.c       **** 	MCUCSR &= ~(1<<WDRF);
 1944               		.loc 1 763 0
 1945 057a 84B7      		in r24,0x34
 1946 057c 877F      		andi r24,lo8(-9)
 1947 057e 84BF      		out 0x34,r24
 764:setup.c       **** 	WDTCR = (1<<WDCE) | (1<<WDE);
 1948               		.loc 1 764 0
 1949 0580 88E1      		ldi r24,lo8(24)
 1950 0582 81BD      		out 0x21,r24
 765:setup.c       **** 	WDTCR = 0;
 1951               		.loc 1 765 0
 1952 0584 11BC      		out 0x21,__zero_reg__
 766:setup.c       **** 	
 767:setup.c       **** 	// Reset common lines
 768:setup.c       **** 	rd_wr_csmreq_cs2_reset();
 1953               		.loc 1 768 0
 1954 0586 00D0      		rcall rd_wr_csmreq_cs2_reset
 1955               	.LVL145:
 769:setup.c       **** 	
 770:setup.c       **** 	// Set outputs
 771:setup.c       **** 	DDRD |= (1<<ACTIVITY_LED) | (1<<WR_PIN) | (1<<RD_PIN) | (1<<CS_MREQ_PIN) | (1<<LED_5V);
 1956               		.loc 1 771 0
 1957 0588 81B3      		in r24,0x11
 1958 058a 886F      		ori r24,lo8(-8)
 1959 058c 81BB      		out 0x11,r24
 772:setup.c       **** 	DDRE |= (1<<CS2_PIN) | (1<<LED_3V);
 1960               		.loc 1 772 0
 1961 058e 86B1      		in r24,0x6
 1962 0590 8560      		ori r24,lo8(5)
 1963 0592 86B9      		out 0x6,r24
 773:setup.c       **** 	
 774:setup.c       **** 	// Set all pins as inputs
 775:setup.c       **** 	PORT_DATA7_0 = 0;
 1964               		.loc 1 775 0
 1965 0594 15BA      		out 0x15,__zero_reg__
 776:setup.c       **** 	DDR_DATA7_0 = 0;
 1966               		.loc 1 776 0
 1967 0596 14BA      		out 0x14,__zero_reg__
 777:setup.c       **** 	PORT_ADDR7_0 = 0;
 1968               		.loc 1 777 0
 1969 0598 18BA      		out 0x18,__zero_reg__
 778:setup.c       **** 	DDR_ADDR7_0 = 0;
 1970               		.loc 1 778 0
 1971 059a 17BA      		out 0x17,__zero_reg__
 779:setup.c       **** 	PORT_ADDR15_8 = 0;
 1972               		.loc 1 779 0
 1973 059c 1BBA      		out 0x1b,__zero_reg__
 780:setup.c       **** 	DDR_ADDR15_8 = 0;
 1974               		.loc 1 780 0
 1975 059e 1ABA      		out 0x1a,__zero_reg__
 781:setup.c       **** 	
 782:setup.c       **** 	// Light up 3.3V or 5V
 783:setup.c       **** 	if (PIND & (1<<SWITCH_DETECT)) {
 1976               		.loc 1 783 0
 1977 05a0 829B      		sbis 0x10,2
 1978 05a2 00C0      		rjmp .L83
 784:setup.c       **** 		PORTD |= (1<<LED_5V);
 1979               		.loc 1 784 0
 1980 05a4 979A      		sbi 0x12,7
 785:setup.c       **** 		PORTE &= ~(1<<LED_3V);
 1981               		.loc 1 785 0
 1982 05a6 3898      		cbi 0x7,0
 1983 05a8 00C0      		rjmp .L84
 1984               	.L83:
 786:setup.c       **** 	}
 787:setup.c       **** 	else {
 788:setup.c       **** 		PORTE |= (1<<LED_3V);
 1985               		.loc 1 788 0
 1986 05aa 389A      		sbi 0x7,0
 789:setup.c       **** 		PORTD &= ~(1<<LED_5V);
 1987               		.loc 1 789 0
 1988 05ac 9798      		cbi 0x12,7
 1989               	.L84:
 790:setup.c       **** 	}
 791:setup.c       **** 	
 792:setup.c       **** 	// Light LED
 793:setup.c       **** 	PORTD |= (1<<ACTIVITY_LED);
 1990               		.loc 1 793 0
 1991 05ae 939A      		sbi 0x12,3
 1992               	.LVL146:
 1993               	.LBB100:
 1994               	.LBB101:
 187:c:\winavr-20100110\avr\include\util\delay.h **** 
 1995               		.loc 2 187 0
 1996 05b0 2FEF      		ldi r18,lo8(799999)
 1997 05b2 84E3      		ldi r24,hi8(799999)
 1998 05b4 9CE0      		ldi r25,hlo8(799999)
 1999 05b6 2150      	1:	subi r18,1
 2000 05b8 8040      		sbci r24,0
 2001 05ba 9040      		sbci r25,0
 2002 05bc 01F4      		brne 1b
 2003 05be 00C0      		rjmp .
 2004 05c0 0000      		nop
 2005               	.LVL147:
 2006               	.LBE101:
 2007               	.LBE100:
 794:setup.c       **** 	_delay_ms(500);
 795:setup.c       **** 	PORTD &= ~(1<<ACTIVITY_LED);
 2008               		.loc 1 795 0
 2009 05c2 9398      		cbi 0x12,3
 796:setup.c       **** 	
 797:setup.c       **** 	// Setup USART
 798:setup.c       **** 	UBRRL = 0; // 1Mbps Baud rate
 2010               		.loc 1 798 0
 2011 05c4 19B8      		out 0x9,__zero_reg__
 799:setup.c       **** 	sbi(UCSRA, U2X); // Double rate
 2012               		.loc 1 799 0
 2013 05c6 599A      		sbi 0xb,1
 800:setup.c       **** 	sbi(UCSRB, TXEN); // Transmitter enable
 2014               		.loc 1 800 0
 2015 05c8 539A      		sbi 0xa,3
 801:setup.c       **** 	sbi(UCSRB, RXEN); // Receiver enable
 2016               		.loc 1 801 0
 2017 05ca 549A      		sbi 0xa,4
 802:setup.c       **** 	
 803:setup.c       **** 	// Turn on interrupts
 804:setup.c       **** 	sei();
 2018               		.loc 1 804 0
 2019               	/* #APP */
 2020               	 ;  804 "setup.c" 1
 2021 05cc 7894      		sei
 2022               	 ;  0 "" 2
 2023               	/* #NOAPP */
 2024 05ce 0895      		ret
 2025               		.cfi_endproc
 2026               	.LFE42:
 2028               		.section	.text.startup,"ax",@progbits
 2029               	.global	main
 2031               	main:
 2032               	.LFB43:
 2033               		.file 3 "main.c"
   1:main.c        **** /*
   2:main.c        ****  GBxCart RW
   3:main.c        ****  PCB version: 1.1 or 1.2
   4:main.c        ****  Firmware version: R10
   5:main.c        ****  Author: Alex from insideGadgets (www.insidegadgets.com)
   6:main.c        ****  Created: 7/11/2016
   7:main.c        ****  Last Modified: 19/06/2018
   8:main.c        ****  
   9:main.c        ****  GBxCart RW allows you to dump your Gameboy/Gameboy Colour/Gameboy Advance games ROM, save the RAM,
  10:main.c        ****  write to certain Gameboy/Gameboy Advance flash carts.
  11:main.c        ****  
  12:main.c        ****  The ATmega8515L talks to the cartridge and interfaces with the CH340G serial to USB converter with
  13:main.c        ****  
  14:main.c        ****  
  15:main.c        ****  Set fuse bits: External 8MHz crystal, divide clock by 8 is off, boot loader is on (512 bytes), BOD
  16:main.c        ****  avrdude -p atmega8515 -c usbasp -U lfuse:w:0xaf:m -U hfuse:w:0xda:m
  17:main.c        ****  
  18:main.c        ****  Program the TinySafeBoot boot loader (modified ASM code, watchdog reset will act as a hardware res
  19:main.c        ****  avrdude -p atmega8515 -c usbasp -U flash:w:GBxCart_RW_v1.1_Rx\tsb\tsb_m8515_d0d1_resetwdt.hex
  20:main.c        ****  
  21:main.c        ****  Program GBxCart RW through TinySafeBoot
  22:main.c        ****  tsb com16:57600 fw GBxCart_RW_v1.1_Rx\main.hex
  23:main.c        ****  
  24:main.c        ****  Set TinySafeBoot delay time to 25 (T 25), gives ~0.5s in bootloader
  25:main.c        ****  tsb com16:9600 T 25
  26:main.c        ****  
  27:main.c        ****  
  28:main.c        ****  Programming shortcuts (if added in Programmers Notepad):
  29:main.c        ****  Alt + W - Program fuse
  30:main.c        ****  Alt + B - Burn bootloader
  31:main.c        ****  
  32:main.c        ****  Plug in USB then
  33:main.c        ****  Alt + T - Program
  34:main.c        ****  Alt + N - Program delay settings
  35:main.c        ****  
  36:main.c        ****  
  37:main.c        ****  */
  38:main.c        **** 
  39:main.c        **** // ATmega8515L Pin Map
  40:main.c        **** //
  41:main.c        **** // VCC (5)			GND (6)			XTAL (7 ,8)		Activity LED PD3 (9)				Switch sense PD2 (8)
  42:main.c        **** // SCK PB7 (3)		MOSI PB5 (1)	MISO PB6 (2)	RST (4)		RXD PD0 (5)			TXD PD1 (7)
  43:main.c        **** // 
  44:main.c        **** // Gameboy / Gameboy Colour
  45:main.c        **** // A0-A7 PB0-7 (40-44, 1-3) 		A8-A15 PA0-7 (37-30)			D0-D7 PC0-7 (18-25)		Audio PE1 (27)
  46:main.c        **** // 
  47:main.c        **** // Gameboy Advance
  48:main.c        **** // AD0-AD7 PB0-7 (40-44, 1-3) 	AD8-AD15 PA0-7 (37-30)		A16-23 / D0-D7 PC0-7 (19-26)
  49:main.c        **** // *WR PD6 (13)						*RD PD5 (14)					*MREQ/CS PD4 (15)			CS2/RST PE2 (16)
  50:main.c        **** 
  51:main.c        **** #define F_CPU 8000000 // 8 MHz
  52:main.c        **** #define PCB_VERSION 2
  53:main.c        **** #define FIRMWARE_VERSION 10
  54:main.c        **** 
  55:main.c        **** #include <avr/io.h>
  56:main.c        **** #include <avr/wdt.h>
  57:main.c        **** #include <avr/eeprom.h>
  58:main.c        **** #include <avr/interrupt.h>
  59:main.c        **** #include <avr/sleep.h>
  60:main.c        **** #include <util/delay.h>
  61:main.c        **** #include <stdlib.h>
  62:main.c        **** #include <string.h>
  63:main.c        **** #include "setup.c" // See defines, variables, constants, functions here
  64:main.c        **** 
  65:main.c        **** 
  66:main.c        **** int main(void) {
 2034               		.loc 3 66 0
 2035               		.cfi_startproc
 2036 0000 CF93      		push r28
 2037               	.LCFI37:
 2038               		.cfi_def_cfa_offset 3
 2039               		.cfi_offset 28, -2
 2040 0002 DF93      		push r29
 2041               	.LCFI38:
 2042               		.cfi_def_cfa_offset 4
 2043               		.cfi_offset 29, -3
 2044 0004 00D0      		rcall .
 2045               	.LCFI39:
 2046               		.cfi_def_cfa_offset 6
 2047 0006 CDB7      		in r28,__SP_L__
 2048 0008 DEB7      		in r29,__SP_H__
 2049               	.LCFI40:
 2050               		.cfi_def_cfa_register 28
 2051               	/* prologue: function */
 2052               	/* frame size = 2 */
 2053               	/* stack size = 4 */
 2054               	.L__stack_usage = 4
  67:main.c        **** 	setup();
 2055               		.loc 3 67 0
 2056 000a 00D0      		rcall setup
 2057               	.LVL148:
  68:main.c        **** 	
  69:main.c        **** 	uint32_t address = 0;
  70:main.c        **** 	uint8_t eepromSize = EEPROM_4KBIT;
  71:main.c        **** 	uint8_t cartMode = GB_MODE;
  72:main.c        **** 	uint8_t resetCommonLines = 1;
 2058               		.loc 3 72 0
 2059 000c 21E0      		ldi r18,lo8(1)
 2060 000e 2A83      		std Y+2,r18
  70:main.c        **** 	uint8_t cartMode = GB_MODE;
 2061               		.loc 3 70 0
 2062 0010 81E0      		ldi r24,lo8(1)
 2063 0012 8983      		std Y+1,r24
  69:main.c        **** 	uint8_t eepromSize = EEPROM_4KBIT;
 2064               		.loc 3 69 0
 2065 0014 C12C      		mov r12,__zero_reg__
 2066 0016 D12C      		mov r13,__zero_reg__
 2067 0018 7601      		movw r14,r12
 2068 001a E0E0      		ldi r30,lo8(eepromBuffer+8)
 2069 001c 2E2E      		mov r2,r30
 2070 001e E0E0      		ldi r30,hi8(eepromBuffer+8)
 2071 0020 3E2E      		mov r3,r30
 2072               	.LVL149:
 2073               	.L86:
  73:main.c        **** 	
  74:main.c        **** 	while(1) {
  75:main.c        **** 		if (resetCommonLines == 1) {
 2074               		.loc 3 75 0
 2075 0022 EA81      		ldd r30,Y+2
 2076 0024 E130      		cpi r30,lo8(1)
 2077 0026 01F4      		brne .L87
 2078               	.LVL150:
 2079               	.L202:
  76:main.c        **** 			rd_wr_csmreq_cs2_reset();
 2080               		.loc 3 76 0
 2081 0028 00D0      		rcall rd_wr_csmreq_cs2_reset
 2082               	.LVL151:
 2083               	.L87:
  77:main.c        **** 		}
  78:main.c        **** 		receivedChar = USART_Receive(); // Wait for 1 byte of data
 2084               		.loc 3 78 0
 2085 002a 00D0      		rcall USART_Receive
 2086               	.LVL152:
 2087 002c 8093 0000 		sts receivedChar,r24
  79:main.c        **** 		
  80:main.c        **** 		// Read the pin to find out which mode we are in, if it reads high, we are powered by 5V
  81:main.c        **** 		if (PIND & (1<<SWITCH_DETECT)) {
 2088               		.loc 3 81 0
 2089 0030 829B      		sbis 0x10,2
 2090 0032 00C0      		rjmp .L88
 2091               	.LVL153:
  82:main.c        **** 			cartMode = GB_MODE;
  83:main.c        **** 			PORTD |= (1<<LED_5V);
 2092               		.loc 3 83 0
 2093 0034 979A      		sbi 0x12,7
  84:main.c        **** 			PORTE &= ~(1<<LED_3V);
 2094               		.loc 3 84 0
 2095 0036 3898      		cbi 0x7,0
  82:main.c        **** 			cartMode = GB_MODE;
 2096               		.loc 3 82 0
 2097 0038 81E0      		ldi r24,lo8(1)
 2098 003a 00C0      		rjmp .L89
 2099               	.LVL154:
 2100               	.L88:
  85:main.c        **** 		}
  86:main.c        **** 		else {
  87:main.c        **** 			cartMode = GBA_MODE;
  88:main.c        **** 			PORTE |= (1<<LED_3V);
 2101               		.loc 3 88 0
 2102 003c 389A      		sbi 0x7,0
  89:main.c        **** 			PORTD &= ~(1<<LED_5V);
 2103               		.loc 3 89 0
 2104 003e 9798      		cbi 0x12,7
  87:main.c        **** 			PORTE |= (1<<LED_3V);
 2105               		.loc 3 87 0
 2106 0040 82E0      		ldi r24,lo8(2)
 2107               	.LVL155:
 2108               	.L89:
  90:main.c        **** 		}
  91:main.c        **** 		
  92:main.c        **** 		// Return the cart mode in use
  93:main.c        **** 		if (receivedChar == CART_MODE) {
 2109               		.loc 3 93 0
 2110 0042 9091 0000 		lds r25,receivedChar
 2111 0046 9334      		cpi r25,lo8(67)
 2112 0048 01F4      		brne .+2
 2113 004a 00C0      		rjmp .L203
  94:main.c        **** 			USART_Transmit(cartMode);
  95:main.c        **** 		}
  96:main.c        **** 		
  97:main.c        **** 		// Change to GB mode or GBA mode if requested
  98:main.c        **** 		else if (receivedChar == GB_CART_MODE) {
 2114               		.loc 3 98 0
 2115 004c 9734      		cpi r25,lo8(71)
 2116 004e 01F4      		brne .L92
  99:main.c        **** 			gb_mode();
 2117               		.loc 3 99 0
 2118 0050 00D0      		rcall gb_mode
 2119               	.LVL156:
 2120 0052 00C0      		rjmp .L86
 2121               	.LVL157:
 2122               	.L92:
 100:main.c        **** 		}
 101:main.c        **** 		else if (receivedChar == GBA_CART_MODE) {
 2123               		.loc 3 101 0
 2124 0054 9736      		cpi r25,lo8(103)
 2125 0056 01F4      		brne .+2
 2126 0058 00C0      		rjmp .L205
 102:main.c        **** 			gba_mode();
 103:main.c        **** 		}
 104:main.c        **** 		
 105:main.c        **** 		// Set address
 106:main.c        **** 		else if (receivedChar == SET_START_ADDRESS) {
 2127               		.loc 3 106 0
 2128 005a 9134      		cpi r25,lo8(65)
 2129 005c 01F4      		brne .L94
 107:main.c        **** 			usart_read_chars(); // Read start address
 2130               		.loc 3 107 0
 2131 005e 00D0      		rcall usart_read_chars
 2132               	.LVL158:
 108:main.c        **** 			address = strtol(receivedBuffer, NULL, 16); // Convert address string in hex to dec
 2133               		.loc 3 108 0
 2134 0060 40E1      		ldi r20,lo8(16)
 2135 0062 50E0      		ldi r21,0
 2136 0064 60E0      		ldi r22,0
 2137 0066 70E0      		ldi r23,0
 2138 0068 80E0      		ldi r24,lo8(receivedBuffer)
 2139 006a 90E0      		ldi r25,hi8(receivedBuffer)
 2140 006c 00D0      		rcall strtol
 2141               	.LVL159:
 2142 006e 6B01      		movw r12,r22
 2143 0070 7C01      		movw r14,r24
 2144               	.LVL160:
 2145 0072 00C0      		rjmp .L86
 2146               	.LVL161:
 2147               	.L94:
 109:main.c        **** 		}
 110:main.c        **** 		
 111:main.c        **** 		
 112:main.c        **** 		// ****** Gameboy / Gameboy Colour ******
 113:main.c        **** 		
 114:main.c        **** 		// Read 64 bytes of ROM/RAM from address (and increment) until anything but 1 is received
 115:main.c        **** 		else if (receivedChar == READ_ROM_RAM) {
 2148               		.loc 3 115 0
 2149 0074 9235      		cpi r25,lo8(82)
 2150 0076 01F4      		brne .L95
 116:main.c        **** 			gb_mode();
 2151               		.loc 3 116 0
 2152 0078 00D0      		rcall gb_mode
 2153               	.LVL162:
 117:main.c        **** 			receivedChar = '1';
 2154               		.loc 3 117 0
 2155 007a F1E3      		ldi r31,lo8(49)
 2156 007c F093 0000 		sts receivedChar,r31
 2157               	.LVL163:
 2158               	.L96:
 118:main.c        **** 			while (receivedChar == '1') {
 2159               		.loc 3 118 0
 2160 0080 8091 0000 		lds r24,receivedChar
 2161 0084 8133      		cpi r24,lo8(49)
 2162 0086 01F4      		brne .L86
 119:main.c        **** 				PORTD |= (1<<ACTIVITY_LED);
 2163               		.loc 3 119 0
 2164 0088 939A      		sbi 0x12,3
 2165               	.LVL164:
 2166 008a 00E0      		ldi r16,0
 2167 008c 10E0      		ldi r17,0
 2168               	.LVL165:
 2169               	.L97:
 2170               	.LBB102:
 120:main.c        **** 				for (uint8_t x = 0; x < 64; x++) {
 121:main.c        **** 					USART_Transmit(read_8bit_data(address));
 2171               		.loc 3 121 0 discriminator 3
 2172 008e C801      		movw r24,r16
 2173 0090 8C0D      		add r24,r12
 2174 0092 9D1D      		adc r25,r13
 2175 0094 00D0      		rcall read_8bit_data
 2176               	.LVL166:
 2177 0096 00D0      		rcall USART_Transmit
 2178               	.LVL167:
 2179 0098 0F5F      		subi r16,-1
 2180 009a 1F4F      		sbci r17,-1
 2181               	.LVL168:
 120:main.c        **** 				for (uint8_t x = 0; x < 64; x++) {
 2182               		.loc 3 120 0 discriminator 3
 2183 009c 0034      		cpi r16,64
 2184 009e 1105      		cpc r17,__zero_reg__
 2185 00a0 01F4      		brne .L97
 2186 00a2 20E4      		ldi r18,64
 2187 00a4 C20E      		add r12,r18
 2188 00a6 D11C      		adc r13,__zero_reg__
 2189 00a8 E11C      		adc r14,__zero_reg__
 2190 00aa F11C      		adc r15,__zero_reg__
 2191               	.LBE102:
 122:main.c        **** 					address++;
 123:main.c        **** 				}
 124:main.c        **** 				
 125:main.c        **** 				PORTD &= ~(1<<ACTIVITY_LED);
 2192               		.loc 3 125 0
 2193 00ac 9398      		cbi 0x12,3
 126:main.c        **** 				receivedChar = USART_Receive();
 2194               		.loc 3 126 0
 2195 00ae 00D0      		rcall USART_Receive
 2196               	.LVL169:
 2197 00b0 8093 0000 		sts receivedChar,r24
 2198 00b4 00C0      		rjmp .L96
 2199               	.LVL170:
 2200               	.L95:
 127:main.c        **** 			}
 128:main.c        **** 		}
 129:main.c        **** 		
 130:main.c        **** 		// Write 64 bytes to RAM on address (and increment)
 131:main.c        **** 		else if (receivedChar == WRITE_RAM) {
 2201               		.loc 3 131 0
 2202 00b6 9735      		cpi r25,lo8(87)
 2203 00b8 01F4      		brne .L99
 132:main.c        **** 			gb_mode();
 2204               		.loc 3 132 0
 2205 00ba 00D0      		rcall gb_mode
 2206               	.LVL171:
 133:main.c        **** 			
 134:main.c        **** 			// Read 64 bytes first as CH340G sends them all at once
 135:main.c        **** 			usart_read_bytes(64);
 2207               		.loc 3 135 0
 2208 00bc 80E4      		ldi r24,lo8(64)
 2209 00be 90E0      		ldi r25,0
 2210 00c0 00D0      		rcall usart_read_bytes
 2211               	.LVL172:
 136:main.c        **** 			
 137:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 2212               		.loc 3 137 0
 2213 00c2 939A      		sbi 0x12,3
 2214               	.LVL173:
 2215 00c4 70E0      		ldi r23,lo8(receivedBuffer)
 2216 00c6 A72E      		mov r10,r23
 2217 00c8 70E0      		ldi r23,hi8(receivedBuffer)
 2218 00ca B72E      		mov r11,r23
 2219 00cc 00E0      		ldi r16,0
 2220 00ce 10E0      		ldi r17,0
 2221               	.LVL174:
 2222               	.L100:
 2223               	.LBB103:
 138:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 139:main.c        **** 				write_8bit_data(address, receivedBuffer[x], MEMORY_WRITE);
 2224               		.loc 3 139 0 discriminator 3
 2225 00d0 F501      		movw r30,r10
 2226 00d2 6191      		ld r22,Z+
 2227 00d4 5F01      		movw r10,r30
 2228 00d6 C801      		movw r24,r16
 2229 00d8 8C0D      		add r24,r12
 2230 00da 9D1D      		adc r25,r13
 2231 00dc 41E0      		ldi r20,lo8(1)
 2232 00de 00D0      		rcall write_8bit_data
 2233               	.LVL175:
 2234 00e0 0F5F      		subi r16,-1
 2235 00e2 1F4F      		sbci r17,-1
 2236               	.LVL176:
 138:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 2237               		.loc 3 138 0 discriminator 3
 2238 00e4 0034      		cpi r16,64
 2239 00e6 1105      		cpc r17,__zero_reg__
 2240 00e8 01F4      		brne .L100
 2241 00ea F0E4      		ldi r31,64
 2242 00ec CF0E      		add r12,r31
 2243 00ee D11C      		adc r13,__zero_reg__
 2244 00f0 E11C      		adc r14,__zero_reg__
 2245 00f2 F11C      		adc r15,__zero_reg__
 2246 00f4 00C0      		rjmp .L223
 2247               	.LVL177:
 2248               	.L99:
 2249               	.LBE103:
 140:main.c        **** 				address++;
 141:main.c        **** 			}
 142:main.c        **** 			
 143:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 144:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 145:main.c        **** 		}
 146:main.c        **** 		
 147:main.c        **** 		// Set bank address and write a byte
 148:main.c        **** 		else if (receivedChar == SET_BANK) {
 2250               		.loc 3 148 0
 2251 00f6 9234      		cpi r25,lo8(66)
 2252 00f8 01F4      		brne .L101
 2253               	.LBB104:
 149:main.c        **** 			gb_mode();
 2254               		.loc 3 149 0
 2255 00fa 00D0      		rcall gb_mode
 2256               	.LVL178:
 150:main.c        **** 			
 151:main.c        **** 			usart_read_chars(); // Read start address
 2257               		.loc 3 151 0
 2258 00fc 00D0      		rcall usart_read_chars
 2259               	.LVL179:
 152:main.c        **** 			uint16_t bankaddress = strtol(receivedBuffer, NULL, 16); // Convert address string in hex to dec
 2260               		.loc 3 152 0
 2261 00fe 40E1      		ldi r20,lo8(16)
 2262 0100 50E0      		ldi r21,0
 2263 0102 60E0      		ldi r22,0
 2264 0104 70E0      		ldi r23,0
 2265 0106 80E0      		ldi r24,lo8(receivedBuffer)
 2266 0108 90E0      		ldi r25,hi8(receivedBuffer)
 2267 010a 00D0      		rcall strtol
 2268               	.LVL180:
 2269 010c 4B01      		movw r8,r22
 2270 010e 5C01      		movw r10,r24
 2271               	.LVL181:
 153:main.c        **** 			
 154:main.c        **** 			receivedChar = USART_Receive(); // Wait for bank number
 2272               		.loc 3 154 0
 2273 0110 00D0      		rcall USART_Receive
 2274               	.LVL182:
 2275 0112 8093 0000 		sts receivedChar,r24
 155:main.c        **** 			if (receivedChar == 'B') {
 2276               		.loc 3 155 0
 2277 0116 8234      		cpi r24,lo8(66)
 2278 0118 01F0      		breq .+2
 2279 011a 00C0      		rjmp .L86
 2280               	.LBB105:
 156:main.c        **** 				usart_read_chars(); // Read data
 2281               		.loc 3 156 0
 2282 011c 00D0      		rcall usart_read_chars
 2283               	.LVL183:
 157:main.c        **** 				uint8_t data = atoi(receivedBuffer); // Convert data string to dec
 2284               		.loc 3 157 0
 2285 011e 80E0      		ldi r24,lo8(receivedBuffer)
 2286 0120 90E0      		ldi r25,hi8(receivedBuffer)
 2287 0122 00D0      		rcall atoi
 2288               	.LVL184:
 158:main.c        **** 				
 159:main.c        **** 				write_8bit_data(bankaddress, data, BANK_WRITE);
 2289               		.loc 3 159 0
 2290 0124 40E0      		ldi r20,0
 2291 0126 682F      		mov r22,r24
 2292 0128 C401      		movw r24,r8
 2293               	.LVL185:
 2294 012a 00D0      		rcall write_8bit_data
 2295               	.LVL186:
 2296 012c 00C0      		rjmp .L86
 2297               	.LVL187:
 2298               	.L101:
 2299               	.LBE105:
 2300               	.LBE104:
 160:main.c        **** 			}
 161:main.c        **** 		}
 162:main.c        **** 		
 163:main.c        **** 		
 164:main.c        **** 		// ****** Gameboy Advance ******
 165:main.c        **** 		
 166:main.c        **** 		// ---------- ROM ----------
 167:main.c        **** 		// Read one 16bit byte from ROM using address (and increment) until anything but 1 is received
 168:main.c        **** 		else if (receivedChar == GBA_READ_ROM || receivedChar == GBA_READ_ROM_256BYTE) {
 2301               		.loc 3 168 0
 2302 012e 9237      		cpi r25,lo8(114)
 2303 0130 01F0      		breq .L102
 2304               		.loc 3 168 0 is_stmt 0 discriminator 1
 2305 0132 9A36      		cpi r25,lo8(106)
 2306 0134 01F4      		brne .L103
 2307               	.L102:
 2308               	.LBB106:
 169:main.c        **** 			gba_mode();
 2309               		.loc 3 169 0 is_stmt 1
 2310 0136 00D0      		rcall gba_mode
 2311               	.LVL188:
 170:main.c        **** 			
 171:main.c        **** 			uint8_t readEnd = 32;
 172:main.c        **** 			if (receivedChar == GBA_READ_ROM_256BYTE) {
 2312               		.loc 3 172 0
 2313 0138 8091 0000 		lds r24,receivedChar
 2314 013c 8A36      		cpi r24,lo8(106)
 2315 013e 01F4      		brne .L178
 173:main.c        **** 				readEnd = 128;
 2316               		.loc 3 173 0
 2317 0140 00E8      		ldi r16,lo8(-128)
 2318 0142 00C0      		rjmp .L104
 2319               	.L178:
 171:main.c        **** 			if (receivedChar == GBA_READ_ROM_256BYTE) {
 2320               		.loc 3 171 0
 2321 0144 00E2      		ldi r16,lo8(32)
 2322               	.L104:
 2323               	.LVL189:
 174:main.c        **** 			}
 175:main.c        **** 			
 176:main.c        **** 			receivedChar = '1';
 2324               		.loc 3 176 0
 2325 0146 21E3      		ldi r18,lo8(49)
 2326 0148 2093 0000 		sts receivedChar,r18
 2327 014c 8824      		clr r8
 2328 014e 8A94      		dec r8
 2329 0150 800E      		add r8,r16
 2330 0152 912C      		mov r9,__zero_reg__
 2331 0154 A12C      		mov r10,__zero_reg__
 2332 0156 B12C      		mov r11,__zero_reg__
 2333 0158 8FEF      		ldi r24,-1
 2334 015a 881A      		sub r8,r24
 2335 015c 980A      		sbc r9,r24
 2336 015e A80A      		sbc r10,r24
 2337 0160 B80A      		sbc r11,r24
 2338               	.LVL190:
 2339               	.L105:
 177:main.c        **** 			while (receivedChar == '1') {
 2340               		.loc 3 177 0
 2341 0162 8091 0000 		lds r24,receivedChar
 2342 0166 8133      		cpi r24,lo8(49)
 2343 0168 01F0      		breq .+2
 2344 016a 00C0      		rjmp .L86
 178:main.c        **** 				PORTD |= (1<<ACTIVITY_LED);
 2345               		.loc 3 178 0
 2346 016c 939A      		sbi 0x12,3
 2347               	.LVL191:
 2348 016e 2601      		movw r4,r12
 2349 0170 3701      		movw r6,r14
 2350               	.LVL192:
 2351               	.L106:
 2352               	.LBB107:
 2353               	.LBB108:
 179:main.c        **** 				
 180:main.c        **** 				for (uint8_t x = 0; x < readEnd; x++) {
 181:main.c        **** 					uint16_t dataRead = gba_read_16bit_data(address);
 2354               		.loc 3 181 0 discriminator 3
 2355 0172 C301      		movw r24,r6
 2356 0174 B201      		movw r22,r4
 2357 0176 00D0      		rcall gba_read_16bit_data
 2358               	.LVL193:
 2359 0178 192F      		mov r17,r25
 2360               	.LVL194:
 182:main.c        **** 					
 183:main.c        **** 					// Low byte & High byte
 184:main.c        **** 					USART_Transmit(dataRead & 0xFF);
 2361               		.loc 3 184 0 discriminator 3
 2362 017a 00D0      		rcall USART_Transmit
 2363               	.LVL195:
 185:main.c        **** 					USART_Transmit(dataRead >> 8);
 2364               		.loc 3 185 0 discriminator 3
 2365 017c 812F      		mov r24,r17
 2366 017e 00D0      		rcall USART_Transmit
 2367               	.LVL196:
 186:main.c        **** 					
 187:main.c        **** 					address++;
 2368               		.loc 3 187 0 discriminator 3
 2369 0180 9FEF      		ldi r25,-1
 2370 0182 491A      		sub r4,r25
 2371 0184 590A      		sbc r5,r25
 2372 0186 690A      		sbc r6,r25
 2373 0188 790A      		sbc r7,r25
 2374               	.LVL197:
 2375               	.LBE108:
 180:main.c        **** 					uint16_t dataRead = gba_read_16bit_data(address);
 2376               		.loc 3 180 0 discriminator 3
 2377 018a 842D      		mov r24,r4
 2378 018c 8C19      		sub r24,r12
 2379 018e 8017      		cp r24,r16
 2380 0190 00F0      		brlo .L106
 2381 0192 C80C      		add r12,r8
 2382 0194 D91C      		adc r13,r9
 2383 0196 EA1C      		adc r14,r10
 2384 0198 FB1C      		adc r15,r11
 2385               	.LVL198:
 2386               	.LBE107:
 188:main.c        **** 				}
 189:main.c        **** 				
 190:main.c        **** 				PORTD &= ~(1<<ACTIVITY_LED);
 2387               		.loc 3 190 0
 2388 019a 9398      		cbi 0x12,3
 191:main.c        **** 				receivedChar = USART_Receive();
 2389               		.loc 3 191 0
 2390 019c 00D0      		rcall USART_Receive
 2391               	.LVL199:
 2392 019e 8093 0000 		sts receivedChar,r24
 2393 01a2 00C0      		rjmp .L105
 2394               	.LVL200:
 2395               	.L103:
 2396               	.LBE106:
 192:main.c        **** 			}
 193:main.c        **** 		}
 194:main.c        **** 		
 195:main.c        **** 		// ---------- SRAM ----------
 196:main.c        **** 		// Read RAM from address (and increment) until anything but 1 is received
 197:main.c        **** 		else if (receivedChar == GBA_READ_SRAM) {
 2397               		.loc 3 197 0
 2398 01a4 9D36      		cpi r25,lo8(109)
 2399 01a6 01F4      		brne .L108
 198:main.c        **** 			gb_mode(); // Set GB mode as it uses 16 bit address with 8 bit data
 2400               		.loc 3 198 0
 2401 01a8 00D0      		rcall gb_mode
 2402               	.LVL201:
 199:main.c        **** 			
 200:main.c        **** 			receivedChar = '1';
 2403               		.loc 3 200 0
 2404 01aa E1E3      		ldi r30,lo8(49)
 2405 01ac E093 0000 		sts receivedChar,r30
 2406               	.LVL202:
 2407               	.L109:
 201:main.c        **** 			while (receivedChar == '1') {
 2408               		.loc 3 201 0
 2409 01b0 8091 0000 		lds r24,receivedChar
 2410 01b4 8133      		cpi r24,lo8(49)
 2411 01b6 01F4      		brne .L205
 202:main.c        **** 				PORTD |= (1<<ACTIVITY_LED);
 2412               		.loc 3 202 0
 2413 01b8 939A      		sbi 0x12,3
 2414               	.LVL203:
 2415 01ba 00E0      		ldi r16,0
 2416 01bc 10E0      		ldi r17,0
 2417               	.LVL204:
 2418               	.L110:
 2419               	.LBB109:
 203:main.c        **** 				for (uint8_t x = 0; x < 64; x++) {
 204:main.c        **** 					USART_Transmit(gba_read_ram_8bit_data(address));
 2420               		.loc 3 204 0 discriminator 3
 2421 01be C801      		movw r24,r16
 2422 01c0 8C0D      		add r24,r12
 2423 01c2 9D1D      		adc r25,r13
 2424 01c4 00D0      		rcall gba_read_ram_8bit_data
 2425               	.LVL205:
 2426 01c6 00D0      		rcall USART_Transmit
 2427               	.LVL206:
 2428 01c8 0F5F      		subi r16,-1
 2429 01ca 1F4F      		sbci r17,-1
 2430               	.LVL207:
 203:main.c        **** 				for (uint8_t x = 0; x < 64; x++) {
 2431               		.loc 3 203 0 discriminator 3
 2432 01cc 0034      		cpi r16,64
 2433 01ce 1105      		cpc r17,__zero_reg__
 2434 01d0 01F4      		brne .L110
 2435 01d2 F0E4      		ldi r31,64
 2436 01d4 CF0E      		add r12,r31
 2437 01d6 D11C      		adc r13,__zero_reg__
 2438 01d8 E11C      		adc r14,__zero_reg__
 2439 01da F11C      		adc r15,__zero_reg__
 2440               	.LBE109:
 205:main.c        **** 					address++;
 206:main.c        **** 				}
 207:main.c        **** 				
 208:main.c        **** 				PORTD &= ~(1<<ACTIVITY_LED);
 2441               		.loc 3 208 0
 2442 01dc 9398      		cbi 0x12,3
 209:main.c        **** 				receivedChar = USART_Receive();
 2443               		.loc 3 209 0
 2444 01de 00D0      		rcall USART_Receive
 2445               	.LVL208:
 2446 01e0 8093 0000 		sts receivedChar,r24
 2447 01e4 00C0      		rjmp .L109
 2448               	.LVL209:
 2449               	.L108:
 210:main.c        **** 			}
 211:main.c        **** 			
 212:main.c        **** 			gba_mode(); // Set back
 213:main.c        **** 		}
 214:main.c        **** 		
 215:main.c        **** 		// Write to RAM on address (and increment) with 64 bytes of data
 216:main.c        **** 		else if (receivedChar == GBA_WRITE_SRAM) {
 2450               		.loc 3 216 0
 2451 01e6 9737      		cpi r25,lo8(119)
 2452 01e8 01F4      		brne .L112
 217:main.c        **** 			gb_mode();
 2453               		.loc 3 217 0
 2454 01ea 00D0      		rcall gb_mode
 2455               	.LVL210:
 218:main.c        **** 			
 219:main.c        **** 			usart_read_bytes(64);
 2456               		.loc 3 219 0
 2457 01ec 80E4      		ldi r24,lo8(64)
 2458 01ee 90E0      		ldi r25,0
 2459 01f0 00D0      		rcall usart_read_bytes
 2460               	.LVL211:
 220:main.c        **** 			
 221:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 2461               		.loc 3 221 0
 2462 01f2 939A      		sbi 0x12,3
 2463               	.LVL212:
 2464 01f4 60E0      		ldi r22,lo8(receivedBuffer)
 2465 01f6 A62E      		mov r10,r22
 2466 01f8 60E0      		ldi r22,hi8(receivedBuffer)
 2467 01fa B62E      		mov r11,r22
 2468 01fc 00E0      		ldi r16,0
 2469 01fe 10E0      		ldi r17,0
 2470               	.LVL213:
 2471               	.L113:
 2472               	.LBB110:
 222:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 223:main.c        **** 				gba_write_ram_8bit_data(address, receivedBuffer[x]);
 2473               		.loc 3 223 0 discriminator 3
 2474 0200 F501      		movw r30,r10
 2475 0202 6191      		ld r22,Z+
 2476 0204 5F01      		movw r10,r30
 2477 0206 C801      		movw r24,r16
 2478 0208 8C0D      		add r24,r12
 2479 020a 9D1D      		adc r25,r13
 2480 020c 00D0      		rcall gba_write_ram_8bit_data
 2481               	.LVL214:
 2482 020e 0F5F      		subi r16,-1
 2483 0210 1F4F      		sbci r17,-1
 2484               	.LVL215:
 222:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 2485               		.loc 3 222 0 discriminator 3
 2486 0212 0034      		cpi r16,64
 2487 0214 1105      		cpc r17,__zero_reg__
 2488 0216 01F4      		brne .L113
 2489               	.LVL216:
 2490               	.L208:
 2491 0218 F0E4      		ldi r31,64
 2492 021a CF0E      		add r12,r31
 2493 021c D11C      		adc r13,__zero_reg__
 2494 021e E11C      		adc r14,__zero_reg__
 2495 0220 F11C      		adc r15,__zero_reg__
 2496               	.L207:
 2497               	.LBE110:
 224:main.c        **** 				address++;
 225:main.c        **** 			}
 226:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 2498               		.loc 3 226 0
 2499 0222 81E3      		ldi r24,lo8(49)
 2500 0224 00D0      		rcall USART_Transmit
 2501               	.LVL217:
 227:main.c        **** 			
 228:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 2502               		.loc 3 228 0
 2503 0226 9398      		cbi 0x12,3
 2504               	.L205:
 229:main.c        **** 			gba_mode(); // Set back
 2505               		.loc 3 229 0
 2506 0228 00D0      		rcall gba_mode
 2507               	.LVL218:
 2508 022a 00C0      		rjmp .L86
 2509               	.LVL219:
 2510               	.L112:
 230:main.c        **** 		}
 231:main.c        **** 		
 232:main.c        **** 		// Write 1 byte to SRAM address
 233:main.c        **** 		else if (receivedChar == GBA_WRITE_ONE_BYTE_SRAM) {
 2511               		.loc 3 233 0
 2512 022c 9F36      		cpi r25,lo8(111)
 2513 022e 01F4      		brne .L114
 2514               	.LBB111:
 234:main.c        **** 			gb_mode();
 2515               		.loc 3 234 0
 2516 0230 00D0      		rcall gb_mode
 2517               	.LVL220:
 235:main.c        **** 			
 236:main.c        **** 			uint8_t data = USART_Receive();
 2518               		.loc 3 236 0
 2519 0232 00D0      		rcall USART_Receive
 2520               	.LVL221:
 237:main.c        **** 			gba_write_ram_8bit_data(address, data);
 2521               		.loc 3 237 0
 2522 0234 682F      		mov r22,r24
 2523 0236 C601      		movw r24,r12
 2524               	.LVL222:
 2525 0238 00D0      		rcall gba_write_ram_8bit_data
 2526               	.LVL223:
 2527 023a 00C0      		rjmp .L210
 2528               	.LVL224:
 2529               	.L114:
 2530               	.LBE111:
 238:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 239:main.c        **** 			
 240:main.c        **** 			gba_mode(); // Set back
 241:main.c        **** 		}
 242:main.c        **** 		
 243:main.c        **** 		
 244:main.c        **** 		// ---------- FLASH ----------
 245:main.c        **** 		// Read the Flash Manufacturer and Device ID
 246:main.c        **** 		else if (receivedChar == GBA_FLASH_READ_ID) {
 2531               		.loc 3 246 0
 2532 023c 9936      		cpi r25,lo8(105)
 2533 023e 01F4      		brne .L115
 247:main.c        **** 			gb_mode();
 2534               		.loc 3 247 0
 2535 0240 00D0      		rcall gb_mode
 2536               	.LVL225:
 248:main.c        **** 			
 249:main.c        **** 			flash_read_chip_id();
 2537               		.loc 3 249 0
 2538 0242 00D0      		rcall flash_read_chip_id
 2539               	.LVL226:
 250:main.c        **** 			USART_Transmit(flashChipIdBuffer[0]);
 2540               		.loc 3 250 0
 2541 0244 8091 0000 		lds r24,flashChipIdBuffer
 2542 0248 00D0      		rcall USART_Transmit
 2543               	.LVL227:
 251:main.c        **** 			USART_Transmit(flashChipIdBuffer[1]);
 2544               		.loc 3 251 0
 2545 024a 8091 0000 		lds r24,flashChipIdBuffer+1
 2546               	.L209:
 2547 024e 00D0      		rcall USART_Transmit
 2548               	.LVL228:
 2549 0250 00C0      		rjmp .L205
 2550               	.LVL229:
 2551               	.L115:
 252:main.c        **** 			
 253:main.c        **** 			gba_mode(); // Set back
 254:main.c        **** 		}
 255:main.c        **** 		
 256:main.c        **** 		// Change bank
 257:main.c        **** 		else if (receivedChar == GBA_FLASH_SET_BANK) {
 2552               		.loc 3 257 0
 2553 0252 9B36      		cpi r25,lo8(107)
 2554 0254 01F4      		brne .L116
 2555               	.LBB112:
 258:main.c        **** 			usart_read_chars(); // Read data
 2556               		.loc 3 258 0
 2557 0256 00D0      		rcall usart_read_chars
 2558               	.LVL230:
 259:main.c        **** 			uint8_t bank = atoi(receivedBuffer); // Convert data string to dec
 2559               		.loc 3 259 0
 2560 0258 80E0      		ldi r24,lo8(receivedBuffer)
 2561 025a 90E0      		ldi r25,hi8(receivedBuffer)
 2562 025c 00D0      		rcall atoi
 2563               	.LVL231:
 2564 025e 182F      		mov r17,r24
 2565               	.LVL232:
 260:main.c        **** 			
 261:main.c        **** 			gb_mode();
 2566               		.loc 3 261 0
 2567 0260 00D0      		rcall gb_mode
 2568               	.LVL233:
 262:main.c        **** 			flash_switch_bank(bank);
 2569               		.loc 3 262 0
 2570 0262 812F      		mov r24,r17
 2571 0264 00D0      		rcall flash_switch_bank
 2572               	.LVL234:
 2573 0266 00C0      		rjmp .L205
 2574               	.LVL235:
 2575               	.L116:
 2576               	.LBE112:
 263:main.c        **** 			
 264:main.c        **** 			gba_mode(); // Set back
 265:main.c        **** 		}
 266:main.c        **** 		
 267:main.c        **** 		// Erase 4K sector on Flash (sector 0 to 15 for 512Kbit)
 268:main.c        **** 		else if (receivedChar == GBA_FLASH_4K_SECTOR_ERASE) {
 2577               		.loc 3 268 0
 2578 0268 9337      		cpi r25,lo8(115)
 2579 026a 01F4      		brne .L117
 2580               	.LBB113:
 269:main.c        **** 			gb_mode();
 2581               		.loc 3 269 0
 2582 026c 00D0      		rcall gb_mode
 2583               	.LVL236:
 270:main.c        **** 			
 271:main.c        **** 			usart_read_chars(); // Read sector
 2584               		.loc 3 271 0
 2585 026e 00D0      		rcall usart_read_chars
 2586               	.LVL237:
 272:main.c        **** 			uint8_t sectorAddress = strtol(receivedBuffer, NULL, 16); // Convert address string in hex to de
 2587               		.loc 3 272 0
 2588 0270 40E1      		ldi r20,lo8(16)
 2589 0272 50E0      		ldi r21,0
 2590 0274 60E0      		ldi r22,0
 2591 0276 70E0      		ldi r23,0
 2592 0278 80E0      		ldi r24,lo8(receivedBuffer)
 2593 027a 90E0      		ldi r25,hi8(receivedBuffer)
 2594 027c 00D0      		rcall strtol
 2595               	.LVL238:
 2596 027e 862F      		mov r24,r22
 2597               	.LVL239:
 273:main.c        **** 			
 274:main.c        **** 			flash_erase_4k_sector(sectorAddress);
 2598               		.loc 3 274 0
 2599 0280 00D0      		rcall flash_erase_4k_sector
 2600               	.LVL240:
 2601               	.L210:
 275:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 2602               		.loc 3 275 0
 2603 0282 81E3      		ldi r24,lo8(49)
 2604 0284 00C0      		rjmp .L209
 2605               	.LVL241:
 2606               	.L117:
 2607               	.LBE113:
 276:main.c        **** 			
 277:main.c        **** 			gba_mode(); // Set back
 278:main.c        **** 		}
 279:main.c        **** 		
 280:main.c        **** 		// Write 64 bytes to Flash address one byte write at a time (and increment)
 281:main.c        **** 		else if (receivedChar == GBA_FLASH_WRITE_BYTE) {
 2608               		.loc 3 281 0
 2609 0286 9236      		cpi r25,lo8(98)
 2610 0288 01F4      		brne .L118
 282:main.c        **** 			gb_mode();
 2611               		.loc 3 282 0
 2612 028a 00D0      		rcall gb_mode
 2613               	.LVL242:
 283:main.c        **** 			
 284:main.c        **** 			usart_read_bytes(64);
 2614               		.loc 3 284 0
 2615 028c 80E4      		ldi r24,lo8(64)
 2616 028e 90E0      		ldi r25,0
 2617 0290 00D0      		rcall usart_read_bytes
 2618               	.LVL243:
 285:main.c        **** 			
 286:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 2619               		.loc 3 286 0
 2620 0292 939A      		sbi 0x12,3
 2621               	.LVL244:
 2622 0294 50E0      		ldi r21,lo8(receivedBuffer)
 2623 0296 A52E      		mov r10,r21
 2624 0298 50E0      		ldi r21,hi8(receivedBuffer)
 2625 029a B52E      		mov r11,r21
 2626 029c 00E0      		ldi r16,0
 2627 029e 10E0      		ldi r17,0
 2628               	.LVL245:
 2629               	.L119:
 2630               	.LBB114:
 287:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 288:main.c        **** 				flash_write_byte(address, receivedBuffer[x]);
 2631               		.loc 3 288 0 discriminator 3
 2632 02a0 F501      		movw r30,r10
 2633 02a2 6191      		ld r22,Z+
 2634 02a4 5F01      		movw r10,r30
 2635 02a6 C801      		movw r24,r16
 2636 02a8 8C0D      		add r24,r12
 2637 02aa 9D1D      		adc r25,r13
 2638 02ac 00D0      		rcall flash_write_byte
 2639               	.LVL246:
 2640 02ae 0F5F      		subi r16,-1
 2641 02b0 1F4F      		sbci r17,-1
 2642               	.LVL247:
 287:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 2643               		.loc 3 287 0 discriminator 3
 2644 02b2 0034      		cpi r16,64
 2645 02b4 1105      		cpc r17,__zero_reg__
 2646 02b6 01F4      		brne .L119
 2647 02b8 00C0      		rjmp .L208
 2648               	.LVL248:
 2649               	.L118:
 2650               	.LBE114:
 289:main.c        **** 				address++;
 290:main.c        **** 			}
 291:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 292:main.c        **** 			
 293:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 294:main.c        **** 			gba_mode(); // Set back
 295:main.c        **** 		}
 296:main.c        **** 		
 297:main.c        **** 		// Write 128 bytes to flash sector for Atmel flash (and increment)
 298:main.c        **** 		else if (receivedChar == GBA_FLASH_WRITE_ATMEL) {
 2651               		.loc 3 298 0
 2652 02ba 9136      		cpi r25,lo8(97)
 2653 02bc 01F4      		brne .L120
 299:main.c        **** 			gb_mode();
 2654               		.loc 3 299 0
 2655 02be 00D0      		rcall gb_mode
 2656               	.LVL249:
 300:main.c        **** 			
 301:main.c        **** 			usart_read_bytes(128);
 2657               		.loc 3 301 0
 2658 02c0 80E8      		ldi r24,lo8(-128)
 2659 02c2 90E0      		ldi r25,0
 2660 02c4 00D0      		rcall usart_read_bytes
 2661               	.LVL250:
 302:main.c        **** 			
 303:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 2662               		.loc 3 303 0
 2663 02c6 939A      		sbi 0x12,3
 304:main.c        **** 			flash_write_sector(address); // Address used as sector number
 2664               		.loc 3 304 0
 2665 02c8 C601      		movw r24,r12
 2666 02ca 00D0      		rcall flash_write_sector
 2667               	.LVL251:
 305:main.c        **** 			address++;
 2668               		.loc 3 305 0
 2669 02cc 2FEF      		ldi r18,-1
 2670 02ce C21A      		sub r12,r18
 2671 02d0 D20A      		sbc r13,r18
 2672 02d2 E20A      		sbc r14,r18
 2673 02d4 F20A      		sbc r15,r18
 2674               	.LVL252:
 2675 02d6 00C0      		rjmp .L207
 2676               	.LVL253:
 2677               	.L120:
 306:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 307:main.c        **** 			
 308:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 309:main.c        **** 			gba_mode(); // Set back
 310:main.c        **** 		}
 311:main.c        **** 		
 312:main.c        **** 		
 313:main.c        **** 		// ---------- EEPROM ----------
 314:main.c        **** 		// Set EEPROM size
 315:main.c        **** 		else if (receivedChar == GBA_SET_EEPROM_SIZE) {
 2678               		.loc 3 315 0
 2679 02d8 9335      		cpi r25,lo8(83)
 2680 02da 01F4      		brne .L121
 316:main.c        **** 			usart_read_chars(); // Read size
 2681               		.loc 3 316 0
 2682 02dc 00D0      		rcall usart_read_chars
 2683               	.LVL254:
 317:main.c        **** 			eepromSize = strtol(receivedBuffer, NULL, 16); // Convert size to dec
 2684               		.loc 3 317 0
 2685 02de 40E1      		ldi r20,lo8(16)
 2686 02e0 50E0      		ldi r21,0
 2687 02e2 60E0      		ldi r22,0
 2688 02e4 70E0      		ldi r23,0
 2689 02e6 80E0      		ldi r24,lo8(receivedBuffer)
 2690 02e8 90E0      		ldi r25,hi8(receivedBuffer)
 2691 02ea 00D0      		rcall strtol
 2692               	.LVL255:
 2693 02ec 6983      		std Y+1,r22
 2694               	.LVL256:
 2695 02ee 00C0      		rjmp .L86
 2696               	.LVL257:
 2697               	.L121:
 318:main.c        **** 		}
 319:main.c        **** 		
 320:main.c        **** 		// Read the EEPROM on address (and increment) until anything but 1 is received
 321:main.c        **** 		else if (receivedChar == GBA_READ_EEPROM) {
 2698               		.loc 3 321 0
 2699 02f0 9536      		cpi r25,lo8(101)
 2700 02f2 01F4      		brne .L122
 322:main.c        **** 			gba_eeprom_mode();
 2701               		.loc 3 322 0
 2702 02f4 00D0      		rcall gba_eeprom_mode
 2703               	.LVL258:
 323:main.c        **** 			
 324:main.c        **** 			receivedChar = '1';
 2704               		.loc 3 324 0
 2705 02f6 81E3      		ldi r24,lo8(49)
 2706               	.L211:
 325:main.c        **** 			while (receivedChar == '1') {
 326:main.c        **** 				PORTD |= (1<<ACTIVITY_LED);
 327:main.c        **** 				gba_eeprom_read(address, eepromSize);
 328:main.c        **** 				
 329:main.c        **** 				// Send back the 8 bytes of data
 330:main.c        **** 				for (uint8_t c = 0; c < 8; c++) {
 331:main.c        **** 					USART_Transmit(eepromBuffer[c]);
 332:main.c        **** 				}
 333:main.c        **** 				address++; // Increment to next 8 bytes
 334:main.c        **** 				
 335:main.c        **** 				PORTD &= ~(1<<ACTIVITY_LED);
 336:main.c        **** 				receivedChar = USART_Receive();
 2707               		.loc 3 336 0
 2708 02f8 8093 0000 		sts receivedChar,r24
 325:main.c        **** 			while (receivedChar == '1') {
 2709               		.loc 3 325 0
 2710 02fc 8091 0000 		lds r24,receivedChar
 2711 0300 8133      		cpi r24,lo8(49)
 2712 0302 01F0      		breq .+2
 2713 0304 00C0      		rjmp .L205
 326:main.c        **** 				gba_eeprom_read(address, eepromSize);
 2714               		.loc 3 326 0
 2715 0306 939A      		sbi 0x12,3
 327:main.c        **** 				
 2716               		.loc 3 327 0
 2717 0308 6981      		ldd r22,Y+1
 2718 030a C601      		movw r24,r12
 2719 030c 00D0      		rcall gba_eeprom_read
 2720               	.LVL259:
 2721 030e 00E0      		ldi r16,lo8(eepromBuffer)
 2722 0310 10E0      		ldi r17,hi8(eepromBuffer)
 2723               	.LVL260:
 2724               	.L124:
 2725               	.LBB115:
 331:main.c        **** 				}
 2726               		.loc 3 331 0 discriminator 3
 2727 0312 F801      		movw r30,r16
 2728 0314 8191      		ld r24,Z+
 2729 0316 8F01      		movw r16,r30
 2730               	.LVL261:
 2731 0318 00D0      		rcall USART_Transmit
 2732               	.LVL262:
 330:main.c        **** 					USART_Transmit(eepromBuffer[c]);
 2733               		.loc 3 330 0 discriminator 3
 2734 031a 2016      		cp r2,r16
 2735 031c 3106      		cpc r3,r17
 2736 031e 01F4      		brne .L124
 2737               	.LBE115:
 333:main.c        **** 				
 2738               		.loc 3 333 0
 2739 0320 FFEF      		ldi r31,-1
 2740 0322 CF1A      		sub r12,r31
 2741 0324 DF0A      		sbc r13,r31
 2742 0326 EF0A      		sbc r14,r31
 2743 0328 FF0A      		sbc r15,r31
 2744               	.LVL263:
 335:main.c        **** 				receivedChar = USART_Receive();
 2745               		.loc 3 335 0
 2746 032a 9398      		cbi 0x12,3
 2747               		.loc 3 336 0
 2748 032c 00D0      		rcall USART_Receive
 2749               	.LVL264:
 2750 032e 00C0      		rjmp .L211
 2751               	.LVL265:
 2752               	.L122:
 337:main.c        **** 			}
 338:main.c        **** 			
 339:main.c        **** 			gba_mode(); // Set back
 340:main.c        **** 		}
 341:main.c        **** 		
 342:main.c        **** 		// Write 8 bytes to the EEPROM address (and increment)
 343:main.c        **** 		else if (receivedChar == GBA_WRITE_EEPROM) {
 2753               		.loc 3 343 0
 2754 0330 9037      		cpi r25,lo8(112)
 2755 0332 01F4      		brne .L126
 344:main.c        **** 			gba_eeprom_mode();
 2756               		.loc 3 344 0
 2757 0334 00D0      		rcall gba_eeprom_mode
 2758               	.LVL266:
 2759 0336 00E0      		ldi r16,lo8(eepromBuffer)
 2760 0338 10E0      		ldi r17,hi8(eepromBuffer)
 2761               	.LVL267:
 2762               	.L127:
 2763               	.LBB116:
 345:main.c        **** 			
 346:main.c        **** 			// Read 8 bytes from USART and place in buffer
 347:main.c        **** 			for (uint8_t x = 0; x < 8; x++) {
 348:main.c        **** 				eepromBuffer[x] = USART_Receive();
 2764               		.loc 3 348 0 discriminator 3
 2765 033a 00D0      		rcall USART_Receive
 2766               	.LVL268:
 2767 033c F801      		movw r30,r16
 2768 033e 8193      		st Z+,r24
 2769 0340 8F01      		movw r16,r30
 2770               	.LVL269:
 347:main.c        **** 				eepromBuffer[x] = USART_Receive();
 2771               		.loc 3 347 0 discriminator 3
 2772 0342 2E16      		cp r2,r30
 2773 0344 3F06      		cpc r3,r31
 2774 0346 01F4      		brne .L127
 2775               	.LBE116:
 349:main.c        **** 			}
 350:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 2776               		.loc 3 350 0
 2777 0348 939A      		sbi 0x12,3
 351:main.c        **** 			
 352:main.c        **** 			gba_eeprom_write(address, eepromSize);
 2778               		.loc 3 352 0
 2779 034a 6981      		ldd r22,Y+1
 2780 034c C601      		movw r24,r12
 2781 034e 00D0      		rcall gba_eeprom_write
 2782               	.LVL270:
 353:main.c        **** 			address++;
 2783               		.loc 3 353 0
 2784 0350 FFEF      		ldi r31,-1
 2785 0352 CF1A      		sub r12,r31
 2786 0354 DF0A      		sbc r13,r31
 2787 0356 EF0A      		sbc r14,r31
 2788 0358 FF0A      		sbc r15,r31
 2789               	.LVL271:
 2790               	.LBB117:
 2791               	.LBB118:
 187:c:\winavr-20100110\avr\include\util\delay.h **** 
 2792               		.loc 2 187 0
 2793 035a 8FE7      		ldi r24,lo8(15999)
 2794 035c 9EE3      		ldi r25,hi8(15999)
 2795 035e 0197      	1:	sbiw r24,1
 2796 0360 01F4      		brne 1b
 2797 0362 00C0      		rjmp .
 2798 0364 0000      		nop
 2799               	.LVL272:
 2800 0366 00C0      		rjmp .L207
 2801               	.LVL273:
 2802               	.L126:
 2803               	.LBE118:
 2804               	.LBE117:
 354:main.c        **** 			
 355:main.c        **** 			_delay_ms(8); // Wait for EEPROM to write data (8ms)
 356:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 357:main.c        **** 			
 358:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 359:main.c        **** 			gba_mode(); // Set back
 360:main.c        **** 		}
 361:main.c        **** 		
 362:main.c        **** 		
 363:main.c        **** 		// ---------- GB FLASH CARTS ----------
 364:main.c        **** 		// Select which pin need to pulse as WE (Audio or WR)
 365:main.c        **** 		else if (receivedChar == GB_FLASH_WE_PIN) {
 2805               		.loc 3 365 0
 2806 0368 9035      		cpi r25,lo8(80)
 2807 036a 01F4      		brne .L128
 366:main.c        **** 			flashWriteWePin = USART_Receive();
 2808               		.loc 3 366 0
 2809 036c 00D0      		rcall USART_Receive
 2810               	.LVL274:
 2811 036e 8093 0000 		sts flashWriteWePin,r24
 367:main.c        **** 			
 368:main.c        **** 			if (flashWriteWePin == WE_AS_AUDIO_PIN) {
 2812               		.loc 3 368 0
 2813 0372 8134      		cpi r24,lo8(65)
 2814 0374 01F0      		breq .+2
 2815 0376 00C0      		rjmp .L86
 369:main.c        **** 				DDRE |= (1<<AUDIO_PIN);
 2816               		.loc 3 369 0
 2817 0378 319A      		sbi 0x6,1
 370:main.c        **** 				audioPin_high;
 2818               		.loc 3 370 0
 2819 037a 399A      		sbi 0x7,1
 2820 037c 00C0      		rjmp .L86
 2821               	.LVL275:
 2822               	.L128:
 371:main.c        **** 			}
 372:main.c        **** 		}
 373:main.c        **** 		
 374:main.c        **** 		// Load the program method to use
 375:main.c        **** 		else if (receivedChar == GB_FLASH_PROGRAM_METHOD) {
 2823               		.loc 3 375 0
 2824 037e 9534      		cpi r25,lo8(69)
 2825 0380 01F4      		brne .L129
 2826 0382 00E0      		ldi r16,lo8(flashWriteCycle)
 2827 0384 10E0      		ldi r17,hi8(flashWriteCycle)
 2828               	.LVL276:
 2829               	.L130:
 2830               	.LBB119:
 376:main.c        **** 			for (uint8_t x = 0; x < 3; x++) {
 377:main.c        **** 				usart_read_chars(); // Address
 2831               		.loc 3 377 0 discriminator 3
 2832 0386 00D0      		rcall usart_read_chars
 2833               	.LVL277:
 378:main.c        **** 				flashWriteCycle[x][0] = strtol(receivedBuffer, NULL, 16);
 2834               		.loc 3 378 0 discriminator 3
 2835 0388 40E1      		ldi r20,lo8(16)
 2836 038a 50E0      		ldi r21,0
 2837 038c 60E0      		ldi r22,0
 2838 038e 70E0      		ldi r23,0
 2839 0390 80E0      		ldi r24,lo8(receivedBuffer)
 2840 0392 90E0      		ldi r25,hi8(receivedBuffer)
 2841 0394 00D0      		rcall strtol
 2842               	.LVL278:
 2843 0396 F801      		movw r30,r16
 2844 0398 7183      		std Z+1,r23
 2845 039a 6083      		st Z,r22
 379:main.c        **** 				USART_Transmit(SEND_ACK);
 2846               		.loc 3 379 0 discriminator 3
 2847 039c 81E3      		ldi r24,lo8(49)
 2848 039e 00D0      		rcall USART_Transmit
 2849               	.LVL279:
 380:main.c        **** 				
 381:main.c        **** 				usart_read_chars(); // Data
 2850               		.loc 3 381 0 discriminator 3
 2851 03a0 00D0      		rcall usart_read_chars
 2852               	.LVL280:
 382:main.c        **** 				flashWriteCycle[x][1] = strtol(receivedBuffer, NULL, 16);
 2853               		.loc 3 382 0 discriminator 3
 2854 03a2 40E1      		ldi r20,lo8(16)
 2855 03a4 50E0      		ldi r21,0
 2856 03a6 60E0      		ldi r22,0
 2857 03a8 70E0      		ldi r23,0
 2858 03aa 80E0      		ldi r24,lo8(receivedBuffer)
 2859 03ac 90E0      		ldi r25,hi8(receivedBuffer)
 2860 03ae 00D0      		rcall strtol
 2861               	.LVL281:
 2862 03b0 F801      		movw r30,r16
 2863 03b2 7383      		std Z+3,r23
 2864 03b4 6283      		std Z+2,r22
 383:main.c        **** 				USART_Transmit(SEND_ACK);
 2865               		.loc 3 383 0 discriminator 3
 2866 03b6 81E3      		ldi r24,lo8(49)
 2867 03b8 00D0      		rcall USART_Transmit
 2868               	.LVL282:
 2869 03ba 0C5F      		subi r16,-4
 2870 03bc 1F4F      		sbci r17,-1
 376:main.c        **** 				usart_read_chars(); // Address
 2871               		.loc 3 376 0 discriminator 3
 2872 03be F0E0      		ldi r31,hi8(flashWriteCycle+12)
 2873 03c0 0030      		cpi r16,lo8(flashWriteCycle+12)
 2874 03c2 1F07      		cpc r17,r31
 2875 03c4 01F4      		brne .L130
 2876 03c6 00C0      		rjmp .L86
 2877               	.LVL283:
 2878               	.L129:
 2879               	.LBE119:
 384:main.c        **** 			}
 385:main.c        **** 		}
 386:main.c        **** 		
 387:main.c        **** 		// Write address and one byte to Flash, pulse a pin
 388:main.c        **** 		else if (receivedChar == GB_FLASH_WRITE_BYTE) {
 2880               		.loc 3 388 0
 2881 03c8 9634      		cpi r25,lo8(70)
 2882 03ca 01F4      		brne .L131
 2883               	.LBB120:
 389:main.c        **** 			usart_read_chars(); // Read address
 2884               		.loc 3 389 0
 2885 03cc 00D0      		rcall usart_read_chars
 2886               	.LVL284:
 390:main.c        **** 			uint16_t flashAddress = strtol(receivedBuffer, NULL, 16);
 2887               		.loc 3 390 0
 2888 03ce 40E1      		ldi r20,lo8(16)
 2889 03d0 50E0      		ldi r21,0
 2890 03d2 60E0      		ldi r22,0
 2891 03d4 70E0      		ldi r23,0
 2892 03d6 80E0      		ldi r24,lo8(receivedBuffer)
 2893 03d8 90E0      		ldi r25,hi8(receivedBuffer)
 2894 03da 00D0      		rcall strtol
 2895               	.LVL285:
 2896 03dc 4B01      		movw r8,r22
 2897 03de 5C01      		movw r10,r24
 2898               	.LVL286:
 391:main.c        **** 			
 392:main.c        **** 			usart_read_chars(); // Read data byte
 2899               		.loc 3 392 0
 2900 03e0 00D0      		rcall usart_read_chars
 2901               	.LVL287:
 393:main.c        **** 			uint8_t flashByte = strtol(receivedBuffer, NULL, 16);
 2902               		.loc 3 393 0
 2903 03e2 40E1      		ldi r20,lo8(16)
 2904 03e4 50E0      		ldi r21,0
 2905 03e6 60E0      		ldi r22,0
 2906 03e8 70E0      		ldi r23,0
 2907 03ea 80E0      		ldi r24,lo8(receivedBuffer)
 2908 03ec 90E0      		ldi r25,hi8(receivedBuffer)
 2909 03ee 00D0      		rcall strtol
 2910               	.LVL288:
 394:main.c        **** 			
 395:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 2911               		.loc 3 395 0
 2912 03f0 939A      		sbi 0x12,3
 396:main.c        **** 			gb_flash_write_bus_cycle(flashAddress, flashByte);
 2913               		.loc 3 396 0
 2914 03f2 C401      		movw r24,r8
 2915 03f4 00D0      		rcall gb_flash_write_bus_cycle
 2916               	.LVL289:
 2917 03f6 00C0      		rjmp .L223
 2918               	.LVL290:
 2919               	.L131:
 2920               	.LBE120:
 397:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 398:main.c        **** 			
 399:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 400:main.c        **** 		}
 401:main.c        **** 		
 402:main.c        **** 		// Write 64 bytes to Flash address one byte write at a time (and increment), pulse a pin
 403:main.c        **** 		else if (receivedChar == GB_FLASH_WRITE_64BYTE) {
 2921               		.loc 3 403 0
 2922 03f8 9435      		cpi r25,lo8(84)
 2923 03fa 01F4      		brne .L132
 404:main.c        **** 			usart_read_bytes(64);
 2924               		.loc 3 404 0
 2925 03fc 80E4      		ldi r24,lo8(64)
 2926 03fe 90E0      		ldi r25,0
 2927               	.LVL291:
 2928 0400 00D0      		rcall usart_read_bytes
 2929               	.LVL292:
 405:main.c        **** 			
 406:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 2930               		.loc 3 406 0
 2931 0402 939A      		sbi 0x12,3
 2932               	.LVL293:
 2933 0404 40E0      		ldi r20,lo8(receivedBuffer)
 2934 0406 A42E      		mov r10,r20
 2935 0408 40E0      		ldi r20,hi8(receivedBuffer)
 2936 040a B42E      		mov r11,r20
 2937 040c 00E0      		ldi r16,0
 2938 040e 10E0      		ldi r17,0
 2939               	.LVL294:
 2940               	.L133:
 2941               	.LBB121:
 407:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 408:main.c        **** 				gb_flash_write_byte(address, receivedBuffer[x]);
 2942               		.loc 3 408 0 discriminator 3
 2943 0410 F501      		movw r30,r10
 2944 0412 6191      		ld r22,Z+
 2945 0414 5F01      		movw r10,r30
 2946 0416 C801      		movw r24,r16
 2947 0418 8C0D      		add r24,r12
 2948 041a 9D1D      		adc r25,r13
 2949 041c 00D0      		rcall gb_flash_write_byte
 2950               	.LVL295:
 2951 041e 0F5F      		subi r16,-1
 2952 0420 1F4F      		sbci r17,-1
 2953               	.LVL296:
 407:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 2954               		.loc 3 407 0 discriminator 3
 2955 0422 0034      		cpi r16,64
 2956 0424 1105      		cpc r17,__zero_reg__
 2957 0426 01F4      		brne .L133
 2958 0428 F0E4      		ldi r31,64
 2959 042a CF0E      		add r12,r31
 2960 042c D11C      		adc r13,__zero_reg__
 2961 042e E11C      		adc r14,__zero_reg__
 2962 0430 F11C      		adc r15,__zero_reg__
 2963 0432 00C0      		rjmp .L212
 2964               	.LVL297:
 2965               	.L132:
 2966               	.LBE121:
 409:main.c        **** 				address++;
 410:main.c        **** 			}
 411:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 412:main.c        **** 			
 413:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 414:main.c        **** 		}
 415:main.c        **** 		
 416:main.c        **** 		
 417:main.c        **** 		// ---------- GBA FLASH CARTS ----------
 418:main.c        **** 		// Write 24 bit address, 16 bit data and pulse a pin
 419:main.c        **** 		else if (receivedChar == GBA_FLASH_CART_WRITE_BYTE) {
 2967               		.loc 3 419 0
 2968 0434 9E36      		cpi r25,lo8(110)
 2969 0436 01F4      		brne .L134
 2970               	.LBB122:
 420:main.c        **** 			usart_read_chars(); // Read address
 2971               		.loc 3 420 0
 2972 0438 00D0      		rcall usart_read_chars
 2973               	.LVL298:
 421:main.c        **** 			uint32_t flashAddress = strtol(receivedBuffer, NULL, 16); // Convert address string in hex to de
 2974               		.loc 3 421 0
 2975 043a 40E1      		ldi r20,lo8(16)
 2976 043c 50E0      		ldi r21,0
 2977 043e 60E0      		ldi r22,0
 2978 0440 70E0      		ldi r23,0
 2979 0442 80E0      		ldi r24,lo8(receivedBuffer)
 2980 0444 90E0      		ldi r25,hi8(receivedBuffer)
 2981 0446 00D0      		rcall strtol
 2982               	.LVL299:
 2983 0448 4B01      		movw r8,r22
 2984 044a 5C01      		movw r10,r24
 2985               	.LVL300:
 422:main.c        **** 			
 423:main.c        **** 			receivedChar = USART_Receive(); // Wait for byte
 2986               		.loc 3 423 0
 2987 044c 00D0      		rcall USART_Receive
 2988               	.LVL301:
 2989 044e 8093 0000 		sts receivedChar,r24
 424:main.c        **** 			if (receivedChar == GBA_FLASH_CART_WRITE_BYTE) {
 2990               		.loc 3 424 0
 2991 0452 8E36      		cpi r24,lo8(110)
 2992 0454 01F0      		breq .+2
 2993 0456 00C0      		rjmp .L86
 2994               	.LBB123:
 425:main.c        **** 				usart_read_chars(); // Read data
 2995               		.loc 3 425 0
 2996 0458 00D0      		rcall usart_read_chars
 2997               	.LVL302:
 426:main.c        **** 				uint16_t flashByte = strtol(receivedBuffer, NULL, 16); // Convert data byte in hex to dec
 2998               		.loc 3 426 0
 2999 045a 40E1      		ldi r20,lo8(16)
 3000 045c 50E0      		ldi r21,0
 3001 045e 60E0      		ldi r22,0
 3002 0460 70E0      		ldi r23,0
 3003 0462 80E0      		ldi r24,lo8(receivedBuffer)
 3004 0464 90E0      		ldi r25,hi8(receivedBuffer)
 3005 0466 00D0      		rcall strtol
 3006               	.LVL303:
 427:main.c        **** 				
 428:main.c        **** 				PORTD |= (1<<ACTIVITY_LED);
 3007               		.loc 3 428 0
 3008 0468 939A      		sbi 0x12,3
 429:main.c        **** 				GBA_DDR_ROM_ADDR23_16 = 0xFF;
 3009               		.loc 3 429 0
 3010 046a 2FEF      		ldi r18,lo8(-1)
 3011 046c 24BB      		out 0x14,r18
 430:main.c        **** 				GBA_DDR_ROM_ADDR15_8 = 0xFF;
 3012               		.loc 3 430 0
 3013 046e 2ABB      		out 0x1a,r18
 431:main.c        **** 				GBA_DDR_ROM_ADDR7_0 = 0xFF;
 3014               		.loc 3 431 0
 3015 0470 27BB      		out 0x17,r18
 432:main.c        **** 				gba_flash_write_bus_cycle(flashAddress, flashByte);
 3016               		.loc 3 432 0
 3017 0472 AB01      		movw r20,r22
 3018 0474 C501      		movw r24,r10
 3019 0476 B401      		movw r22,r8
 3020               	.LVL304:
 3021 0478 00D0      		rcall gba_flash_write_bus_cycle
 3022               	.LVL305:
 3023               	.L223:
 433:main.c        **** 				PORTD &= ~(1<<ACTIVITY_LED);
 3024               		.loc 3 433 0
 3025 047a 9398      		cbi 0x12,3
 434:main.c        **** 				
 435:main.c        **** 				USART_Transmit(SEND_ACK); // Send back acknowledgement
 3026               		.loc 3 435 0
 3027 047c 81E3      		ldi r24,lo8(49)
 3028 047e 00C0      		rjmp .L203
 3029               	.LVL306:
 3030               	.L134:
 3031               	.LBE123:
 3032               	.LBE122:
 436:main.c        **** 			}
 437:main.c        **** 		}
 438:main.c        **** 		
 439:main.c        **** 		// Write 64 or 256 bytes to Flash address, combine 2 bytes and write one at a time (and increment
 440:main.c        **** 		else if (receivedChar == GBA_FLASH_WRITE_64BYTE || receivedChar == GBA_FLASH_WRITE_256BYTE) {
 3033               		.loc 3 440 0
 3034 0480 9137      		cpi r25,lo8(113)
 3035 0482 01F0      		breq .L135
 3036               		.loc 3 440 0 is_stmt 0 discriminator 1
 3037 0484 9437      		cpi r25,lo8(116)
 3038 0486 01F4      		brne .L136
 3039               	.L135:
 3040               	.LBB124:
 441:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 3041               		.loc 3 441 0 is_stmt 1
 3042 0488 939A      		sbi 0x12,3
 3043               	.LVL307:
 442:main.c        **** 			
 443:main.c        **** 			int readLength = 64;
 444:main.c        **** 			if (receivedChar == GBA_FLASH_WRITE_256BYTE) {
 3044               		.loc 3 444 0
 3045 048a 8091 0000 		lds r24,receivedChar
 3046               	.LVL308:
 3047 048e 8437      		cpi r24,lo8(116)
 3048 0490 01F4      		brne .L179
 445:main.c        **** 				readLength = 256;
 3049               		.loc 3 445 0
 3050 0492 00E0      		ldi r16,0
 3051 0494 11E0      		ldi r17,lo8(1)
 3052 0496 00C0      		rjmp .L137
 3053               	.L179:
 443:main.c        **** 			if (receivedChar == GBA_FLASH_WRITE_256BYTE) {
 3054               		.loc 3 443 0
 3055 0498 00E4      		ldi r16,lo8(64)
 3056 049a 10E0      		ldi r17,0
 3057               	.L137:
 3058               	.LVL309:
 446:main.c        **** 			}
 447:main.c        **** 			usart_read_bytes(readLength);
 3059               		.loc 3 447 0
 3060 049c C801      		movw r24,r16
 3061 049e 00D0      		rcall usart_read_bytes
 3062               	.LVL310:
 3063 04a0 30E0      		ldi r19,lo8(receivedBuffer)
 3064 04a2 A32E      		mov r10,r19
 3065 04a4 30E0      		ldi r19,hi8(receivedBuffer)
 3066 04a6 B32E      		mov r11,r19
 3067 04a8 2601      		movw r4,r12
 3068 04aa 3701      		movw r6,r14
 3069               	.LVL311:
 3070               	.L138:
 3071               	.LBB125:
 3072               	.LBB126:
 448:main.c        **** 			
 449:main.c        **** 			for (int x = 0; x < readLength; x += 2) {
 450:main.c        **** 				uint16_t combinedBytes = (uint16_t) receivedBuffer[x+1] << 8 | (uint16_t) receivedBuffer[x];
 451:main.c        **** 				gba_flash_write_byte_swapped(address, combinedBytes);
 3073               		.loc 3 451 0 discriminator 3
 3074 04ac F501      		movw r30,r10
 3075 04ae 4181      		ldd r20,Z+1
 3076 04b0 50E0      		ldi r21,0
 3077 04b2 542F      		mov r21,r20
 3078 04b4 4427      		clr r20
 3079 04b6 8081      		ld r24,Z
 3080 04b8 482B      		or r20,r24
 3081 04ba C301      		movw r24,r6
 3082 04bc B201      		movw r22,r4
 3083 04be 00D0      		rcall gba_flash_write_byte_swapped
 3084               	.LVL312:
 452:main.c        **** 				address++;
 3085               		.loc 3 452 0 discriminator 3
 3086 04c0 FFEF      		ldi r31,-1
 3087 04c2 4F1A      		sub r4,r31
 3088 04c4 5F0A      		sbc r5,r31
 3089 04c6 6F0A      		sbc r6,r31
 3090 04c8 7F0A      		sbc r7,r31
 3091               	.LVL313:
 3092 04ca 22E0      		ldi r18,2
 3093 04cc A20E      		add r10,r18
 3094 04ce B11C      		adc r11,__zero_reg__
 3095               	.LVL314:
 3096               	.LBE126:
 449:main.c        **** 				uint16_t combinedBytes = (uint16_t) receivedBuffer[x+1] << 8 | (uint16_t) receivedBuffer[x];
 3097               		.loc 3 449 0 discriminator 3
 3098 04d0 C501      		movw r24,r10
 3099 04d2 8050      		subi r24,lo8(receivedBuffer)
 3100 04d4 9040      		sbci r25,hi8(receivedBuffer)
 3101 04d6 8017      		cp r24,r16
 3102 04d8 9107      		cpc r25,r17
 3103 04da 04F0      		brlt .L138
 3104 04dc 8FEF      		ldi r24,-1
 3105 04de C81A      		sub r12,r24
 3106 04e0 D80A      		sbc r13,r24
 3107 04e2 E80A      		sbc r14,r24
 3108 04e4 F80A      		sbc r15,r24
 3109 04e6 0150      		subi r16,1
 3110 04e8 1109      		sbc r17,__zero_reg__
 3111               	.LVL315:
 3112 04ea 1695      		lsr r17
 3113 04ec 0795      		ror r16
 3114               	.LVL316:
 3115 04ee C00E      		add r12,r16
 3116 04f0 D11E      		adc r13,r17
 3117 04f2 E11C      		adc r14,__zero_reg__
 3118 04f4 F11C      		adc r15,__zero_reg__
 3119 04f6 00C0      		rjmp .L212
 3120               	.LVL317:
 3121               	.L136:
 3122               	.LBE125:
 3123               	.LBE124:
 453:main.c        **** 			}
 454:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 455:main.c        **** 			
 456:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 457:main.c        **** 		}
 458:main.c        **** 		
 459:main.c        **** 		// Intel flash command based chips
 460:main.c        **** 		// Write 64 bytes to Flash address, combine 2 bytes and write one at a time (and increment addres
 461:main.c        **** 		else if (receivedChar == GBA_FLASH_WRITE_INTEL_64BYTE) {
 3124               		.loc 3 461 0
 3125 04f8 9C36      		cpi r25,lo8(108)
 3126 04fa 01F0      		breq .+2
 3127 04fc 00C0      		rjmp .L139
 3128               	.LBB127:
 462:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 3129               		.loc 3 462 0
 3130 04fe 939A      		sbi 0x12,3
 463:main.c        **** 			usart_read_bytes(64);
 3131               		.loc 3 463 0
 3132 0500 80E4      		ldi r24,lo8(64)
 3133 0502 90E0      		ldi r25,0
 3134               	.LVL318:
 3135 0504 00D0      		rcall usart_read_bytes
 3136               	.LVL319:
 464:main.c        **** 			
 465:main.c        **** 			// Set address lines as outputs
 466:main.c        **** 			GBA_DDR_ROM_ADDR23_16 = 0xFF;
 3137               		.loc 3 466 0
 3138 0506 9FEF      		ldi r25,lo8(-1)
 3139 0508 94BB      		out 0x14,r25
 467:main.c        **** 			GBA_DDR_ROM_ADDR15_8 = 0xFF;
 3140               		.loc 3 467 0
 3141 050a 9ABB      		out 0x1a,r25
 468:main.c        **** 			GBA_DDR_ROM_ADDR7_0 = 0xFF;
 3142               		.loc 3 468 0
 3143 050c 97BB      		out 0x17,r25
 469:main.c        **** 			
 470:main.c        **** 			// Unlock
 471:main.c        **** 			gba_flash_write_bus_cycle(address, 0x60);
 3144               		.loc 3 471 0
 3145 050e 40E6      		ldi r20,lo8(96)
 3146 0510 50E0      		ldi r21,0
 3147 0512 C701      		movw r24,r14
 3148 0514 B601      		movw r22,r12
 3149 0516 00D0      		rcall gba_flash_write_bus_cycle
 3150               	.LVL320:
 472:main.c        **** 			gba_flash_write_bus_cycle(address, 0xD0);
 3151               		.loc 3 472 0
 3152 0518 40ED      		ldi r20,lo8(-48)
 3153 051a 50E0      		ldi r21,0
 3154 051c C701      		movw r24,r14
 3155 051e B601      		movw r22,r12
 3156 0520 00D0      		rcall gba_flash_write_bus_cycle
 3157               	.LVL321:
 473:main.c        **** 			
 474:main.c        **** 			// Buffered write command
 475:main.c        **** 			gba_flash_write_bus_cycle(address, 0xE8);
 3158               		.loc 3 475 0
 3159 0522 48EE      		ldi r20,lo8(-24)
 3160 0524 50E0      		ldi r21,0
 3161 0526 C701      		movw r24,r14
 3162 0528 B601      		movw r22,r12
 3163 052a 00D0      		rcall gba_flash_write_bus_cycle
 3164               	.LVL322:
 3165               	.LBB128:
 3166               	.LBB129:
 3167               		.loc 2 276 0
 3168 052c E5E8      		ldi r30,lo8(-123)
 3169 052e EA95      	1:	dec r30
 3170 0530 01F4      		brne 1b
 3171 0532 0000      		nop
 3172               	.LVL323:
 3173               	.LBE129:
 3174               	.LBE128:
 476:main.c        **** 			_delay_us(50);
 477:main.c        **** 			
 478:main.c        **** 			// Wait for first 2 bytes to be 0x80, 0x00
 479:main.c        **** 			uint16_t dataVerify = gba_read_16bit_data(address);
 3175               		.loc 3 479 0
 3176 0534 C701      		movw r24,r14
 3177 0536 B601      		movw r22,r12
 3178 0538 00D0      		rcall gba_read_16bit_data
 3179               	.LVL324:
 3180               	.L140:
 480:main.c        **** 			while (dataVerify != 0x0080) {
 3181               		.loc 3 480 0
 3182 053a 8038      		cpi r24,-128
 3183 053c 9105      		cpc r25,__zero_reg__
 3184 053e 01F0      		breq .L224
 481:main.c        **** 				dataVerify = gba_read_16bit_data(address);
 3185               		.loc 3 481 0
 3186 0540 C701      		movw r24,r14
 3187 0542 B601      		movw r22,r12
 3188 0544 00D0      		rcall gba_read_16bit_data
 3189               	.LVL325:
 3190               	.LBB130:
 3191               	.LBB131:
 3192               		.loc 2 276 0
 3193 0546 F5E8      		ldi r31,lo8(-123)
 3194 0548 FA95      	1:	dec r31
 3195 054a 01F4      		brne 1b
 3196 054c 0000      		nop
 3197 054e 00C0      		rjmp .L140
 3198               	.LVL326:
 3199               	.L224:
 3200               	.LBE131:
 3201               	.LBE130:
 482:main.c        **** 				_delay_us(50);
 483:main.c        **** 			}
 484:main.c        **** 			
 485:main.c        **** 			
 486:main.c        **** 			// Set address lines as outputs
 487:main.c        **** 			GBA_DDR_ROM_ADDR23_16 = 0xFF;
 3202               		.loc 3 487 0
 3203 0550 2FEF      		ldi r18,lo8(-1)
 3204 0552 24BB      		out 0x14,r18
 488:main.c        **** 			GBA_DDR_ROM_ADDR15_8 = 0xFF;
 3205               		.loc 3 488 0
 3206 0554 2ABB      		out 0x1a,r18
 489:main.c        **** 			GBA_DDR_ROM_ADDR7_0 = 0xFF;
 3207               		.loc 3 489 0
 3208 0556 27BB      		out 0x17,r18
 490:main.c        **** 			
 491:main.c        **** 			// Set length
 492:main.c        **** 			gba_flash_write_bus_cycle(address, 0x1F);
 3209               		.loc 3 492 0
 3210 0558 4FE1      		ldi r20,lo8(31)
 3211 055a 50E0      		ldi r21,0
 3212 055c C701      		movw r24,r14
 3213 055e B601      		movw r22,r12
 3214 0560 00D0      		rcall gba_flash_write_bus_cycle
 3215               	.LVL327:
 3216 0562 00E0      		ldi r16,lo8(receivedBuffer)
 3217 0564 10E0      		ldi r17,hi8(receivedBuffer)
 3218 0566 4601      		movw r8,r12
 3219 0568 5701      		movw r10,r14
 3220               	.LVL328:
 3221               	.L142:
 3222               	.LBB132:
 3223               	.LBB133:
 493:main.c        **** 			
 494:main.c        **** 			// Write data
 495:main.c        **** 			for (int x = 0; x < 64; x += 2) {
 496:main.c        **** 				uint16_t combinedBytes = (uint16_t) receivedBuffer[x+1] << 8 | (uint16_t) receivedBuffer[x];
 497:main.c        **** 				gba_flash_write_bus_cycle(address, combinedBytes);
 3224               		.loc 3 497 0 discriminator 3
 3225 056a F801      		movw r30,r16
 3226 056c 4181      		ldd r20,Z+1
 3227 056e 50E0      		ldi r21,0
 3228 0570 542F      		mov r21,r20
 3229 0572 4427      		clr r20
 3230 0574 8081      		ld r24,Z
 3231 0576 482B      		or r20,r24
 3232 0578 C501      		movw r24,r10
 3233 057a B401      		movw r22,r8
 3234 057c 00D0      		rcall gba_flash_write_bus_cycle
 3235               	.LVL329:
 498:main.c        **** 				address++;
 3236               		.loc 3 498 0 discriminator 3
 3237 057e FFEF      		ldi r31,-1
 3238 0580 8F1A      		sub r8,r31
 3239 0582 9F0A      		sbc r9,r31
 3240 0584 AF0A      		sbc r10,r31
 3241 0586 BF0A      		sbc r11,r31
 3242               	.LVL330:
 3243 0588 0E5F      		subi r16,-2
 3244 058a 1F4F      		sbci r17,-1
 3245               	.LVL331:
 3246               	.LBE133:
 495:main.c        **** 				uint16_t combinedBytes = (uint16_t) receivedBuffer[x+1] << 8 | (uint16_t) receivedBuffer[x];
 3247               		.loc 3 495 0 discriminator 3
 3248 058c 20E0      		ldi r18,hi8(receivedBuffer+64)
 3249 058e 0030      		cpi r16,lo8(receivedBuffer+64)
 3250 0590 1207      		cpc r17,r18
 3251 0592 01F4      		brne .L142
 3252 0594 80E2      		ldi r24,32
 3253 0596 C80E      		add r12,r24
 3254 0598 D11C      		adc r13,__zero_reg__
 3255 059a E11C      		adc r14,__zero_reg__
 3256 059c F11C      		adc r15,__zero_reg__
 3257               	.LBE132:
 499:main.c        **** 			}
 500:main.c        **** 			
 501:main.c        **** 			// Write buffer to flash
 502:main.c        **** 			gba_flash_write_bus_cycle(address, 0xD0);
 3258               		.loc 3 502 0
 3259 059e 40ED      		ldi r20,lo8(-48)
 3260 05a0 50E0      		ldi r21,0
 3261 05a2 C701      		movw r24,r14
 3262 05a4 B601      		movw r22,r12
 3263 05a6 00D0      		rcall gba_flash_write_bus_cycle
 3264               	.LVL332:
 3265               	.LBB134:
 3266               	.LBB135:
 3267               		.loc 2 276 0
 3268 05a8 EFE6      		ldi r30,lo8(879)
 3269 05aa F3E0      		ldi r31,hi8(879)
 3270 05ac 3197      	1:	sbiw r30,1
 3271 05ae 01F4      		brne 1b
 3272 05b0 00C0      		rjmp .
 3273 05b2 0000      		nop
 3274               	.LVL333:
 3275               	.LBE135:
 3276               	.LBE134:
 503:main.c        **** 			_delay_us(440);
 504:main.c        **** 			
 505:main.c        **** 			// Wait for first 2 bytes to be 0x80, 0x00
 506:main.c        **** 			dataVerify = gba_read_16bit_data(address);
 3277               		.loc 3 506 0
 3278 05b4 C701      		movw r24,r14
 3279 05b6 B601      		movw r22,r12
 3280 05b8 00D0      		rcall gba_read_16bit_data
 3281               	.LVL334:
 3282               	.L143:
 507:main.c        **** 			while (dataVerify != 0x0080) {
 3283               		.loc 3 507 0
 3284 05ba 8038      		cpi r24,-128
 3285 05bc 9105      		cpc r25,__zero_reg__
 3286 05be 01F0      		breq .L225
 508:main.c        **** 				dataVerify = gba_read_16bit_data(address);
 3287               		.loc 3 508 0
 3288 05c0 C701      		movw r24,r14
 3289 05c2 B601      		movw r22,r12
 3290 05c4 00D0      		rcall gba_read_16bit_data
 3291               	.LVL335:
 3292               	.LBB136:
 3293               	.LBB137:
 3294               		.loc 2 276 0
 3295 05c6 F5E8      		ldi r31,lo8(-123)
 3296 05c8 FA95      	1:	dec r31
 3297 05ca 01F4      		brne 1b
 3298 05cc 0000      		nop
 3299 05ce 00C0      		rjmp .L143
 3300               	.LVL336:
 3301               	.L225:
 3302               	.LBE137:
 3303               	.LBE136:
 509:main.c        **** 				_delay_us(50);
 510:main.c        **** 			}
 511:main.c        **** 			
 512:main.c        **** 			
 513:main.c        **** 			// Set address lines as outputs
 514:main.c        **** 			GBA_DDR_ROM_ADDR23_16 = 0xFF;
 3304               		.loc 3 514 0
 3305 05d0 2FEF      		ldi r18,lo8(-1)
 3306 05d2 24BB      		out 0x14,r18
 515:main.c        **** 			GBA_DDR_ROM_ADDR15_8 = 0xFF;
 3307               		.loc 3 515 0
 3308 05d4 2ABB      		out 0x1a,r18
 516:main.c        **** 			GBA_DDR_ROM_ADDR7_0 = 0xFF;
 3309               		.loc 3 516 0
 3310 05d6 27BB      		out 0x17,r18
 517:main.c        **** 			
 518:main.c        **** 			// Back to reading mode
 519:main.c        **** 			gba_flash_write_bus_cycle(address, 0xFF);
 3311               		.loc 3 519 0
 3312 05d8 4FEF      		ldi r20,lo8(-1)
 3313 05da 50E0      		ldi r21,0
 3314 05dc C701      		movw r24,r14
 3315 05de B601      		movw r22,r12
 3316 05e0 00D0      		rcall gba_flash_write_bus_cycle
 3317               	.LVL337:
 3318               	.L212:
 520:main.c        **** 			
 521:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 3319               		.loc 3 521 0
 3320 05e2 81E3      		ldi r24,lo8(49)
 3321 05e4 00C0      		rjmp .L206
 3322               	.LVL338:
 3323               	.L139:
 3324               	.LBE127:
 522:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 523:main.c        **** 		}
 524:main.c        **** 		
 525:main.c        **** 		
 526:main.c        **** 		// ---------- General commands ----------
 527:main.c        **** 		// Set any pin as input/output
 528:main.c        **** 		// Reads the DDR/PORT (e.g. DDRB/PORTB is 'B') and the hex value that represents pins to set to a
 529:main.c        **** 		else if (receivedChar == SET_INPUT || receivedChar == SET_OUTPUT) {
 3325               		.loc 3 529 0
 3326 05e6 9934      		cpi r25,lo8(73)
 3327 05e8 01F0      		breq .L145
 3328               		.loc 3 529 0 is_stmt 0 discriminator 1
 3329 05ea 9F34      		cpi r25,lo8(79)
 3330 05ec 01F0      		breq .+2
 3331 05ee 00C0      		rjmp .L146
 3332               	.L145:
 3333               	.LBB138:
 530:main.c        **** 			char portChar = USART_Receive();
 3334               		.loc 3 530 0 is_stmt 1
 3335 05f0 00D0      		rcall USART_Receive
 3336               	.LVL339:
 3337 05f2 182F      		mov r17,r24
 3338               	.LVL340:
 531:main.c        **** 			usart_read_chars();
 3339               		.loc 3 531 0
 3340 05f4 00D0      		rcall usart_read_chars
 3341               	.LVL341:
 532:main.c        **** 			uint8_t setValue = strtol(receivedBuffer, NULL, 16);
 3342               		.loc 3 532 0
 3343 05f6 40E1      		ldi r20,lo8(16)
 3344 05f8 50E0      		ldi r21,0
 3345 05fa 60E0      		ldi r22,0
 3346 05fc 70E0      		ldi r23,0
 3347 05fe 80E0      		ldi r24,lo8(receivedBuffer)
 3348 0600 90E0      		ldi r25,hi8(receivedBuffer)
 3349 0602 00D0      		rcall strtol
 3350               	.LVL342:
 533:main.c        **** 			
 534:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 3351               		.loc 3 534 0
 3352 0604 939A      		sbi 0x12,3
 535:main.c        **** 			if (receivedChar == SET_INPUT) {
 3353               		.loc 3 535 0
 3354 0606 8091 0000 		lds r24,receivedChar
 3355 060a 8934      		cpi r24,lo8(73)
 3356 060c 01F4      		brne .L147
 536:main.c        **** 				if (portChar == 'A') {
 3357               		.loc 3 536 0
 3358 060e 1134      		cpi r17,lo8(65)
 3359 0610 01F4      		brne .L148
 537:main.c        **** 					DDRA &= ~(setValue);
 3360               		.loc 3 537 0
 3361 0612 8AB3      		in r24,0x1a
 3362 0614 6095      		com r22
 3363               	.LVL343:
 3364 0616 6823      		and r22,r24
 3365               	.LVL344:
 3366 0618 00C0      		rjmp .L214
 3367               	.LVL345:
 3368               	.L148:
 538:main.c        **** 				}
 539:main.c        **** 				else if (portChar == 'B') {
 3369               		.loc 3 539 0
 3370 061a 1234      		cpi r17,lo8(66)
 3371 061c 01F4      		brne .L150
 540:main.c        **** 					DDRB &= ~(setValue);
 3372               		.loc 3 540 0
 3373 061e 87B3      		in r24,0x17
 3374 0620 6095      		com r22
 3375               	.LVL346:
 3376 0622 6823      		and r22,r24
 3377               	.LVL347:
 3378 0624 00C0      		rjmp .L215
 3379               	.LVL348:
 3380               	.L150:
 541:main.c        **** 				}
 542:main.c        **** 				else if (portChar == 'C') {
 3381               		.loc 3 542 0
 3382 0626 1334      		cpi r17,lo8(67)
 3383 0628 01F4      		brne .L151
 543:main.c        **** 					DDRC &= ~(setValue);
 3384               		.loc 3 543 0
 3385 062a 84B3      		in r24,0x14
 3386 062c 6095      		com r22
 3387               	.LVL349:
 3388 062e 6823      		and r22,r24
 3389               	.LVL350:
 3390 0630 00C0      		rjmp .L220
 3391               	.LVL351:
 3392               	.L151:
 544:main.c        **** 				}
 545:main.c        **** 				else if (portChar == 'D') {
 3393               		.loc 3 545 0
 3394 0632 1434      		cpi r17,lo8(68)
 3395 0634 01F4      		brne .L152
 546:main.c        **** 					DDRD &= ~(setValue);
 3396               		.loc 3 546 0
 3397 0636 81B3      		in r24,0x11
 3398 0638 6095      		com r22
 3399               	.LVL352:
 3400 063a 6823      		and r22,r24
 3401               	.LVL353:
 3402 063c 00C0      		rjmp .L221
 3403               	.LVL354:
 3404               	.L152:
 547:main.c        **** 				}
 548:main.c        **** 				else if (portChar == 'E') {
 3405               		.loc 3 548 0
 3406 063e 1534      		cpi r17,lo8(69)
 3407 0640 01F0      		breq .+2
 3408 0642 00C0      		rjmp .L171
 549:main.c        **** 					DDRE &= ~(setValue);
 3409               		.loc 3 549 0
 3410 0644 86B1      		in r24,0x6
 3411 0646 6095      		com r22
 3412               	.LVL355:
 3413 0648 6823      		and r22,r24
 3414               	.LVL356:
 3415 064a 00C0      		rjmp .L222
 3416               	.LVL357:
 3417               	.L147:
 550:main.c        **** 				}
 551:main.c        **** 			}
 552:main.c        **** 			else if (receivedChar == SET_OUTPUT) {
 3418               		.loc 3 552 0
 3419 064c 8F34      		cpi r24,lo8(79)
 3420 064e 01F0      		breq .+2
 3421 0650 00C0      		rjmp .L171
 553:main.c        **** 				if (portChar == 'A') {
 3422               		.loc 3 553 0
 3423 0652 1134      		cpi r17,lo8(65)
 3424 0654 01F4      		brne .L153
 554:main.c        **** 					DDRA |= (setValue);
 3425               		.loc 3 554 0
 3426 0656 8AB3      		in r24,0x1a
 3427 0658 682B      		or r22,r24
 3428               	.LVL358:
 3429               	.L214:
 3430 065a 6ABB      		out 0x1a,r22
 3431 065c 00C0      		rjmp .L171
 3432               	.LVL359:
 3433               	.L153:
 555:main.c        **** 				}
 556:main.c        **** 				else if (portChar == 'B') {
 3434               		.loc 3 556 0
 3435 065e 1234      		cpi r17,lo8(66)
 3436 0660 01F4      		brne .L154
 557:main.c        **** 					DDRB |= (setValue);
 3437               		.loc 3 557 0
 3438 0662 87B3      		in r24,0x17
 3439 0664 682B      		or r22,r24
 3440               	.LVL360:
 3441               	.L215:
 3442 0666 67BB      		out 0x17,r22
 3443 0668 00C0      		rjmp .L171
 3444               	.LVL361:
 3445               	.L154:
 558:main.c        **** 				}
 559:main.c        **** 				else if (portChar == 'C') {
 3446               		.loc 3 559 0
 3447 066a 1334      		cpi r17,lo8(67)
 3448 066c 01F4      		brne .L155
 560:main.c        **** 					DDRC |= (setValue);
 3449               		.loc 3 560 0
 3450 066e 84B3      		in r24,0x14
 3451 0670 682B      		or r22,r24
 3452               	.LVL362:
 3453               	.L220:
 3454 0672 64BB      		out 0x14,r22
 3455 0674 00C0      		rjmp .L171
 3456               	.LVL363:
 3457               	.L155:
 561:main.c        **** 				}
 562:main.c        **** 				else if (portChar == 'D') {
 3458               		.loc 3 562 0
 3459 0676 1434      		cpi r17,lo8(68)
 3460 0678 01F4      		brne .L156
 563:main.c        **** 					DDRD |= (setValue);
 3461               		.loc 3 563 0
 3462 067a 81B3      		in r24,0x11
 3463 067c 682B      		or r22,r24
 3464               	.LVL364:
 3465               	.L221:
 3466 067e 61BB      		out 0x11,r22
 3467 0680 00C0      		rjmp .L171
 3468               	.LVL365:
 3469               	.L156:
 564:main.c        **** 				}
 565:main.c        **** 				else if (portChar == 'E') {
 3470               		.loc 3 565 0
 3471 0682 1534      		cpi r17,lo8(69)
 3472 0684 01F0      		breq .+2
 3473 0686 00C0      		rjmp .L171
 566:main.c        **** 					DDRE |= (setValue);
 3474               		.loc 3 566 0
 3475 0688 86B1      		in r24,0x6
 3476 068a 682B      		or r22,r24
 3477               	.LVL366:
 3478               	.L222:
 3479 068c 66B9      		out 0x6,r22
 3480 068e 00C0      		rjmp .L171
 3481               	.LVL367:
 3482               	.L146:
 3483               	.LBE138:
 567:main.c        **** 				}
 568:main.c        **** 			}
 569:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 570:main.c        **** 		}
 571:main.c        **** 		
 572:main.c        **** 		// Set pin output as low
 573:main.c        **** 		else if (receivedChar == SET_OUTPUT_LOW) {
 3484               		.loc 3 573 0
 3485 0690 9C34      		cpi r25,lo8(76)
 3486 0692 01F4      		brne .L157
 3487               	.LBB139:
 574:main.c        **** 			char portChar = USART_Receive();			
 3488               		.loc 3 574 0
 3489 0694 00D0      		rcall USART_Receive
 3490               	.LVL368:
 3491 0696 182F      		mov r17,r24
 3492               	.LVL369:
 575:main.c        **** 			usart_read_chars();
 3493               		.loc 3 575 0
 3494 0698 00D0      		rcall usart_read_chars
 3495               	.LVL370:
 576:main.c        **** 			uint8_t setValue = strtol(receivedBuffer, NULL, 16);
 3496               		.loc 3 576 0
 3497 069a 40E1      		ldi r20,lo8(16)
 3498 069c 50E0      		ldi r21,0
 3499 069e 60E0      		ldi r22,0
 3500 06a0 70E0      		ldi r23,0
 3501 06a2 80E0      		ldi r24,lo8(receivedBuffer)
 3502 06a4 90E0      		ldi r25,hi8(receivedBuffer)
 3503 06a6 00D0      		rcall strtol
 3504               	.LVL371:
 577:main.c        **** 			
 578:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 3505               		.loc 3 578 0
 3506 06a8 939A      		sbi 0x12,3
 579:main.c        **** 			if (portChar == 'A') {
 3507               		.loc 3 579 0
 3508 06aa 1134      		cpi r17,lo8(65)
 3509 06ac 01F4      		brne .L158
 580:main.c        **** 				PORTA &= ~(setValue);
 3510               		.loc 3 580 0
 3511 06ae 8BB3      		in r24,0x1b
 3512 06b0 6095      		com r22
 3513               	.LVL372:
 3514 06b2 6823      		and r22,r24
 3515               	.LVL373:
 3516 06b4 00C0      		rjmp .L219
 3517               	.LVL374:
 3518               	.L158:
 581:main.c        **** 			}
 582:main.c        **** 			else if (portChar == 'B') {
 3519               		.loc 3 582 0
 3520 06b6 1234      		cpi r17,lo8(66)
 3521 06b8 01F4      		brne .L160
 583:main.c        **** 				PORTB &= ~(setValue);
 3522               		.loc 3 583 0
 3523 06ba 88B3      		in r24,0x18
 3524 06bc 6095      		com r22
 3525               	.LVL375:
 3526 06be 6823      		and r22,r24
 3527               	.LVL376:
 3528 06c0 00C0      		rjmp .L218
 3529               	.LVL377:
 3530               	.L160:
 584:main.c        **** 			}
 585:main.c        **** 			else if (portChar == 'C') {
 3531               		.loc 3 585 0
 3532 06c2 1334      		cpi r17,lo8(67)
 3533 06c4 01F4      		brne .L161
 586:main.c        **** 				PORTC &= ~(setValue);
 3534               		.loc 3 586 0
 3535 06c6 85B3      		in r24,0x15
 3536 06c8 6095      		com r22
 3537               	.LVL378:
 3538 06ca 6823      		and r22,r24
 3539               	.LVL379:
 3540 06cc 00C0      		rjmp .L217
 3541               	.LVL380:
 3542               	.L161:
 587:main.c        **** 			}
 588:main.c        **** 			else if (portChar == 'D') {
 3543               		.loc 3 588 0
 3544 06ce 1434      		cpi r17,lo8(68)
 3545 06d0 01F4      		brne .L162
 589:main.c        **** 				PORTD &= ~(setValue);
 3546               		.loc 3 589 0
 3547 06d2 82B3      		in r24,0x12
 3548 06d4 6095      		com r22
 3549               	.LVL381:
 3550 06d6 6823      		and r22,r24
 3551               	.LVL382:
 3552 06d8 00C0      		rjmp .L216
 3553               	.LVL383:
 3554               	.L162:
 590:main.c        **** 			}
 591:main.c        **** 			else if (portChar == 'E') {
 3555               		.loc 3 591 0
 3556 06da 1534      		cpi r17,lo8(69)
 3557 06dc 01F0      		breq .+2
 3558 06de 00C0      		rjmp .L171
 592:main.c        **** 				PORTE &= ~(setValue);
 3559               		.loc 3 592 0
 3560 06e0 87B1      		in r24,0x7
 3561 06e2 6095      		com r22
 3562               	.LVL384:
 3563 06e4 6823      		and r22,r24
 3564               	.LVL385:
 3565 06e6 00C0      		rjmp .L213
 3566               	.LVL386:
 3567               	.L157:
 3568               	.LBE139:
 593:main.c        **** 			}
 594:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 595:main.c        **** 		}
 596:main.c        **** 		
 597:main.c        **** 		// Set pin output as high
 598:main.c        **** 		else if (receivedChar == SET_OUTPUT_HIGH) {
 3569               		.loc 3 598 0
 3570 06e8 9834      		cpi r25,lo8(72)
 3571 06ea 01F4      		brne .L163
 3572               	.LBB140:
 599:main.c        **** 			char portChar = USART_Receive();			
 3573               		.loc 3 599 0
 3574 06ec 00D0      		rcall USART_Receive
 3575               	.LVL387:
 3576 06ee 182F      		mov r17,r24
 3577               	.LVL388:
 600:main.c        **** 			usart_read_chars();
 3578               		.loc 3 600 0
 3579 06f0 00D0      		rcall usart_read_chars
 3580               	.LVL389:
 601:main.c        **** 			uint8_t setValue = strtol(receivedBuffer, NULL, 16);
 3581               		.loc 3 601 0
 3582 06f2 40E1      		ldi r20,lo8(16)
 3583 06f4 50E0      		ldi r21,0
 3584 06f6 60E0      		ldi r22,0
 3585 06f8 70E0      		ldi r23,0
 3586 06fa 80E0      		ldi r24,lo8(receivedBuffer)
 3587 06fc 90E0      		ldi r25,hi8(receivedBuffer)
 3588 06fe 00D0      		rcall strtol
 3589               	.LVL390:
 602:main.c        **** 			
 603:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 3590               		.loc 3 603 0
 3591 0700 939A      		sbi 0x12,3
 604:main.c        **** 			if (portChar == 'A') {
 3592               		.loc 3 604 0
 3593 0702 1134      		cpi r17,lo8(65)
 3594 0704 01F4      		brne .L164
 605:main.c        **** 				PORTA |= (setValue);
 3595               		.loc 3 605 0
 3596 0706 8BB3      		in r24,0x1b
 3597 0708 682B      		or r22,r24
 3598               	.LVL391:
 3599               	.L219:
 3600 070a 6BBB      		out 0x1b,r22
 3601 070c 00C0      		rjmp .L171
 3602               	.LVL392:
 3603               	.L164:
 606:main.c        **** 			}
 607:main.c        **** 			else if (portChar == 'B') {
 3604               		.loc 3 607 0
 3605 070e 1234      		cpi r17,lo8(66)
 3606 0710 01F4      		brne .L166
 608:main.c        **** 				PORTB |= (setValue);
 3607               		.loc 3 608 0
 3608 0712 88B3      		in r24,0x18
 3609 0714 682B      		or r22,r24
 3610               	.LVL393:
 3611               	.L218:
 3612 0716 68BB      		out 0x18,r22
 3613 0718 00C0      		rjmp .L171
 3614               	.LVL394:
 3615               	.L166:
 609:main.c        **** 			}
 610:main.c        **** 			else if (portChar == 'C') {
 3616               		.loc 3 610 0
 3617 071a 1334      		cpi r17,lo8(67)
 3618 071c 01F4      		brne .L167
 611:main.c        **** 				PORTC |= (setValue);
 3619               		.loc 3 611 0
 3620 071e 85B3      		in r24,0x15
 3621 0720 682B      		or r22,r24
 3622               	.LVL395:
 3623               	.L217:
 3624 0722 65BB      		out 0x15,r22
 3625 0724 00C0      		rjmp .L171
 3626               	.LVL396:
 3627               	.L167:
 612:main.c        **** 			}
 613:main.c        **** 			else if (portChar == 'D') {
 3628               		.loc 3 613 0
 3629 0726 1434      		cpi r17,lo8(68)
 3630 0728 01F4      		brne .L168
 614:main.c        **** 				PORTD |= (setValue);
 3631               		.loc 3 614 0
 3632 072a 82B3      		in r24,0x12
 3633 072c 682B      		or r22,r24
 3634               	.LVL397:
 3635               	.L216:
 3636 072e 62BB      		out 0x12,r22
 3637 0730 00C0      		rjmp .L171
 3638               	.LVL398:
 3639               	.L168:
 615:main.c        **** 			}
 616:main.c        **** 			else if (portChar == 'E') {
 3640               		.loc 3 616 0
 3641 0732 1534      		cpi r17,lo8(69)
 3642 0734 01F4      		brne .L171
 617:main.c        **** 				PORTE |= (setValue);
 3643               		.loc 3 617 0
 3644 0736 87B1      		in r24,0x7
 3645 0738 682B      		or r22,r24
 3646               	.LVL399:
 3647               	.L213:
 3648 073a 67B9      		out 0x7,r22
 3649 073c 00C0      		rjmp .L171
 3650               	.LVL400:
 3651               	.L163:
 3652               	.LBE140:
 618:main.c        **** 			}
 619:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 620:main.c        **** 		}
 621:main.c        **** 		
 622:main.c        **** 		// Read all pins of a PORT and return the value
 623:main.c        **** 		else if (receivedChar == READ_INPUT) {
 3653               		.loc 3 623 0
 3654 073e 9434      		cpi r25,lo8(68)
 3655 0740 01F4      		brne .L169
 3656               	.LBB141:
 624:main.c        **** 			char portChar = USART_Receive();			
 3657               		.loc 3 624 0
 3658 0742 00D0      		rcall USART_Receive
 3659               	.LVL401:
 625:main.c        **** 			
 626:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 3660               		.loc 3 626 0
 3661 0744 939A      		sbi 0x12,3
 627:main.c        **** 			if (portChar == 'A') {
 3662               		.loc 3 627 0
 3663 0746 8134      		cpi r24,lo8(65)
 3664 0748 01F4      		brne .L170
 628:main.c        **** 				USART_Transmit(PINA);
 3665               		.loc 3 628 0
 3666 074a 89B3      		in r24,0x19
 3667               	.LVL402:
 3668 074c 00C0      		rjmp .L206
 3669               	.LVL403:
 3670               	.L170:
 629:main.c        **** 			}
 630:main.c        **** 			else if (portChar == 'B') {
 3671               		.loc 3 630 0
 3672 074e 8234      		cpi r24,lo8(66)
 3673 0750 01F4      		brne .L172
 631:main.c        **** 				USART_Transmit(PINB);
 3674               		.loc 3 631 0
 3675 0752 86B3      		in r24,0x16
 3676               	.LVL404:
 3677 0754 00C0      		rjmp .L206
 3678               	.LVL405:
 3679               	.L172:
 632:main.c        **** 			}
 633:main.c        **** 			else if (portChar == 'C') {
 3680               		.loc 3 633 0
 3681 0756 8334      		cpi r24,lo8(67)
 3682 0758 01F4      		brne .L173
 634:main.c        **** 				USART_Transmit(PINC);
 3683               		.loc 3 634 0
 3684 075a 83B3      		in r24,0x13
 3685               	.LVL406:
 3686 075c 00C0      		rjmp .L206
 3687               	.LVL407:
 3688               	.L173:
 635:main.c        **** 			}
 636:main.c        **** 			else if (portChar == 'D') {
 3689               		.loc 3 636 0
 3690 075e 8434      		cpi r24,lo8(68)
 3691 0760 01F4      		brne .L174
 637:main.c        **** 				USART_Transmit(PIND);
 3692               		.loc 3 637 0
 3693 0762 80B3      		in r24,0x10
 3694               	.LVL408:
 3695 0764 00C0      		rjmp .L206
 3696               	.LVL409:
 3697               	.L174:
 638:main.c        **** 			}
 639:main.c        **** 			else if (portChar == 'E') {
 3698               		.loc 3 639 0
 3699 0766 8534      		cpi r24,lo8(69)
 3700 0768 01F4      		brne .L171
 640:main.c        **** 				USART_Transmit(PINE);
 3701               		.loc 3 640 0
 3702 076a 85B1      		in r24,0x5
 3703               	.LVL410:
 3704               	.L206:
 3705 076c 00D0      		rcall USART_Transmit
 3706               	.LVL411:
 3707               	.L171:
 641:main.c        **** 			}
 642:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 3708               		.loc 3 642 0
 3709 076e 9398      		cbi 0x12,3
 3710               	.LBE141:
 3711 0770 00C0      		rjmp .L86
 3712               	.LVL412:
 3713               	.L169:
 643:main.c        **** 		}
 644:main.c        **** 		
 645:main.c        **** 		// Set the reset common lines variable on or off, useful if you are controlling all the pins dire
 646:main.c        **** 		else if (receivedChar == RESET_COMMON_LINES) {
 3714               		.loc 3 646 0
 3715 0772 9D34      		cpi r25,lo8(77)
 3716 0774 01F4      		brne .L175
 3717               	.LBB142:
 647:main.c        **** 			char commonChar = USART_Receive();
 3718               		.loc 3 647 0
 3719 0776 00D0      		rcall USART_Receive
 3720               	.LVL413:
 648:main.c        **** 			if (commonChar == '1') {
 3721               		.loc 3 648 0
 3722 0778 8133      		cpi r24,lo8(49)
 3723 077a 01F4      		brne .L226
 649:main.c        **** 				resetCommonLines = 1;
 3724               		.loc 3 649 0
 3725 077c 91E0      		ldi r25,lo8(1)
 3726 077e 9A83      		std Y+2,r25
 3727 0780 00C0      		rjmp .L202
 3728               	.L226:
 650:main.c        **** 			}
 651:main.c        **** 			else if (commonChar == '0') {
 3729               		.loc 3 651 0
 3730 0782 8033      		cpi r24,lo8(48)
 3731 0784 01F0      		breq .+2
 3732 0786 00C0      		rjmp .L86
 652:main.c        **** 				resetCommonLines = 0;
 3733               		.loc 3 652 0
 3734 0788 1A82      		std Y+2,__zero_reg__
 3735 078a 00C0      		rjmp .L87
 3736               	.LVL414:
 3737               	.L175:
 3738               	.LBE142:
 653:main.c        **** 			}
 654:main.c        **** 		}
 655:main.c        **** 		
 656:main.c        **** 		// Send back the PCB version number
 657:main.c        **** 		else if (receivedChar == READ_PCB_VERSION) {
 3739               		.loc 3 657 0
 3740 078c 9836      		cpi r25,lo8(104)
 3741 078e 01F4      		brne .L176
 658:main.c        **** 			USART_Transmit(PCB_VERSION);
 3742               		.loc 3 658 0
 3743 0790 82E0      		ldi r24,lo8(2)
 3744               	.LVL415:
 3745 0792 00C0      		rjmp .L203
 3746               	.LVL416:
 3747               	.L176:
 659:main.c        **** 		}
 660:main.c        **** 		
 661:main.c        **** 		// Send back the firmware version number
 662:main.c        **** 		else if (receivedChar == READ_FIRMWARE_VERSION) {
 3748               		.loc 3 662 0
 3749 0794 9635      		cpi r25,lo8(86)
 3750 0796 01F4      		brne .L177
 663:main.c        **** 			USART_Transmit(FIRMWARE_VERSION);
 3751               		.loc 3 663 0
 3752 0798 8AE0      		ldi r24,lo8(10)
 3753               	.LVL417:
 3754               	.L203:
 3755 079a 00D0      		rcall USART_Transmit
 3756               	.LVL418:
 3757 079c 00C0      		rjmp .L86
 3758               	.LVL419:
 3759               	.L177:
 664:main.c        **** 		}
 665:main.c        **** 		
 666:main.c        **** 		// Reset the AVR if it matches the number
 667:main.c        **** 		else if (receivedChar == RESET_AVR) {
 3760               		.loc 3 667 0
 3761 079e 9A32      		cpi r25,lo8(42)
 3762 07a0 01F0      		breq .+2
 3763 07a2 00C0      		rjmp .L86
 3764               	.LBB143:
 668:main.c        **** 			usart_read_chars();
 3765               		.loc 3 668 0
 3766 07a4 00D0      		rcall usart_read_chars
 3767               	.LVL420:
 669:main.c        **** 			uint32_t resetValue = strtol(receivedBuffer, NULL, 16);
 3768               		.loc 3 669 0
 3769 07a6 40E1      		ldi r20,lo8(16)
 3770 07a8 50E0      		ldi r21,0
 3771 07aa 60E0      		ldi r22,0
 3772 07ac 70E0      		ldi r23,0
 3773 07ae 80E0      		ldi r24,lo8(receivedBuffer)
 3774 07b0 90E0      		ldi r25,hi8(receivedBuffer)
 3775 07b2 00D0      		rcall strtol
 3776               	.LVL421:
 670:main.c        **** 			if (resetValue == RESET_VALUE) {
 3777               		.loc 3 670 0
 3778 07b4 613E      		cpi r22,-31
 3779 07b6 754E      		sbci r23,-27
 3780 07b8 8740      		sbci r24,7
 3781 07ba 9105      		cpc r25,__zero_reg__
 3782 07bc 01F0      		breq .+2
 3783 07be 00C0      		rjmp .L86
 671:main.c        **** 				// Clear watchdog flag
 672:main.c        **** 				MCUCSR &= ~(1<<WDRF);
 3784               		.loc 3 672 0
 3785 07c0 84B7      		in r24,0x34
 3786 07c2 877F      		andi r24,lo8(-9)
 3787 07c4 84BF      		out 0x34,r24
 673:main.c        **** 				
 674:main.c        **** 				// Start timed sequence
 675:main.c        **** 				WDTCR = (1<<WDCE) | (1<<WDE);
 3788               		.loc 3 675 0
 3789 07c6 F8E1      		ldi r31,lo8(24)
 3790 07c8 F1BD      		out 0x21,r31
 676:main.c        **** 				
 677:main.c        **** 				// Reset in 250 ms
 678:main.c        **** 				WDTCR = (1<<WDP2) | (1<<WDE);
 3791               		.loc 3 678 0
 3792 07ca 2CE0      		ldi r18,lo8(12)
 3793 07cc 21BD      		out 0x21,r18
 3794               	.LVL422:
 3795               	.LBB144:
 3796               	.LBB145:
 3797               		.file 4 "c:\\winavr-20100110\\avr\\include\\util\\delay_basic.h"
   1:c:\winavr-20100110\avr\include\util\delay_basic.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:c:\winavr-20100110\avr\include\util\delay_basic.h ****    Copyright (c) 2007 Joerg Wunsch
   3:c:\winavr-20100110\avr\include\util\delay_basic.h ****    All rights reserved.
   4:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
   5:c:\winavr-20100110\avr\include\util\delay_basic.h ****    Redistribution and use in source and binary forms, with or without
   6:c:\winavr-20100110\avr\include\util\delay_basic.h ****    modification, are permitted provided that the following conditions are met:
   7:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
   8:c:\winavr-20100110\avr\include\util\delay_basic.h ****    * Redistributions of source code must retain the above copyright
   9:c:\winavr-20100110\avr\include\util\delay_basic.h ****      notice, this list of conditions and the following disclaimer.
  10:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  11:c:\winavr-20100110\avr\include\util\delay_basic.h ****    * Redistributions in binary form must reproduce the above copyright
  12:c:\winavr-20100110\avr\include\util\delay_basic.h ****      notice, this list of conditions and the following disclaimer in
  13:c:\winavr-20100110\avr\include\util\delay_basic.h ****      the documentation and/or other materials provided with the
  14:c:\winavr-20100110\avr\include\util\delay_basic.h ****      distribution.
  15:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  16:c:\winavr-20100110\avr\include\util\delay_basic.h ****    * Neither the name of the copyright holders nor the names of
  17:c:\winavr-20100110\avr\include\util\delay_basic.h ****      contributors may be used to endorse or promote products derived
  18:c:\winavr-20100110\avr\include\util\delay_basic.h ****      from this software without specific prior written permission.
  19:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  20:c:\winavr-20100110\avr\include\util\delay_basic.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  21:c:\winavr-20100110\avr\include\util\delay_basic.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  22:c:\winavr-20100110\avr\include\util\delay_basic.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  23:c:\winavr-20100110\avr\include\util\delay_basic.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  24:c:\winavr-20100110\avr\include\util\delay_basic.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  25:c:\winavr-20100110\avr\include\util\delay_basic.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  26:c:\winavr-20100110\avr\include\util\delay_basic.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  27:c:\winavr-20100110\avr\include\util\delay_basic.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  28:c:\winavr-20100110\avr\include\util\delay_basic.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  29:c:\winavr-20100110\avr\include\util\delay_basic.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  30:c:\winavr-20100110\avr\include\util\delay_basic.h ****   POSSIBILITY OF SUCH DAMAGE. */
  31:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  32:c:\winavr-20100110\avr\include\util\delay_basic.h **** /* $Id$ */
  33:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  34:c:\winavr-20100110\avr\include\util\delay_basic.h **** #ifndef _UTIL_DELAY_BASIC_H_
  35:c:\winavr-20100110\avr\include\util\delay_basic.h **** #define _UTIL_DELAY_BASIC_H_ 1
  36:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  37:c:\winavr-20100110\avr\include\util\delay_basic.h **** #include <inttypes.h>
  38:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  39:c:\winavr-20100110\avr\include\util\delay_basic.h **** #if !defined(__DOXYGEN__)
  40:c:\winavr-20100110\avr\include\util\delay_basic.h **** static __inline__ void _delay_loop_1(uint8_t __count) __attribute__((__always_inline__));
  41:c:\winavr-20100110\avr\include\util\delay_basic.h **** static __inline__ void _delay_loop_2(uint16_t __count) __attribute__((__always_inline__));
  42:c:\winavr-20100110\avr\include\util\delay_basic.h **** #endif
  43:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  44:c:\winavr-20100110\avr\include\util\delay_basic.h **** /** \file */
  45:c:\winavr-20100110\avr\include\util\delay_basic.h **** /** \defgroup util_delay_basic <util/delay_basic.h>: Basic busy-wait delay loops
  46:c:\winavr-20100110\avr\include\util\delay_basic.h ****     \code
  47:c:\winavr-20100110\avr\include\util\delay_basic.h ****     #include <util/delay_basic.h>
  48:c:\winavr-20100110\avr\include\util\delay_basic.h ****     \endcode
  49:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  50:c:\winavr-20100110\avr\include\util\delay_basic.h ****     The functions in this header file implement simple delay loops
  51:c:\winavr-20100110\avr\include\util\delay_basic.h ****     that perform a busy-waiting.  They are typically used to
  52:c:\winavr-20100110\avr\include\util\delay_basic.h ****     facilitate short delays in the program execution.  They are
  53:c:\winavr-20100110\avr\include\util\delay_basic.h ****     implemented as count-down loops with a well-known CPU cycle
  54:c:\winavr-20100110\avr\include\util\delay_basic.h ****     count per loop iteration.  As such, no other processing can
  55:c:\winavr-20100110\avr\include\util\delay_basic.h ****     occur simultaneously.  It should be kept in mind that the
  56:c:\winavr-20100110\avr\include\util\delay_basic.h ****     functions described here do not disable interrupts.
  57:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  58:c:\winavr-20100110\avr\include\util\delay_basic.h ****     In general, for long delays, the use of hardware timers is
  59:c:\winavr-20100110\avr\include\util\delay_basic.h ****     much preferrable, as they free the CPU, and allow for
  60:c:\winavr-20100110\avr\include\util\delay_basic.h ****     concurrent processing of other events while the timer is
  61:c:\winavr-20100110\avr\include\util\delay_basic.h ****     running.  However, in particular for very short delays, the
  62:c:\winavr-20100110\avr\include\util\delay_basic.h ****     overhead of setting up a hardware timer is too much compared
  63:c:\winavr-20100110\avr\include\util\delay_basic.h ****     to the overall delay time.
  64:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  65:c:\winavr-20100110\avr\include\util\delay_basic.h ****     Two inline functions are provided for the actual delay algorithms.
  66:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  67:c:\winavr-20100110\avr\include\util\delay_basic.h **** */
  68:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  69:c:\winavr-20100110\avr\include\util\delay_basic.h **** /** \ingroup util_delay_basic
  70:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  71:c:\winavr-20100110\avr\include\util\delay_basic.h ****     Delay loop using an 8-bit counter \c __count, so up to 256
  72:c:\winavr-20100110\avr\include\util\delay_basic.h ****     iterations are possible.  (The value 256 would have to be passed
  73:c:\winavr-20100110\avr\include\util\delay_basic.h ****     as 0.)  The loop executes three CPU cycles per iteration, not
  74:c:\winavr-20100110\avr\include\util\delay_basic.h ****     including the overhead the compiler needs to setup the counter
  75:c:\winavr-20100110\avr\include\util\delay_basic.h ****     register.
  76:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  77:c:\winavr-20100110\avr\include\util\delay_basic.h ****     Thus, at a CPU speed of 1 MHz, delays of up to 768 microseconds
  78:c:\winavr-20100110\avr\include\util\delay_basic.h ****     can be achieved.
  79:c:\winavr-20100110\avr\include\util\delay_basic.h **** */
  80:c:\winavr-20100110\avr\include\util\delay_basic.h **** void
  81:c:\winavr-20100110\avr\include\util\delay_basic.h **** _delay_loop_1(uint8_t __count)
  82:c:\winavr-20100110\avr\include\util\delay_basic.h **** {
  83:c:\winavr-20100110\avr\include\util\delay_basic.h **** 	__asm__ volatile (
  84:c:\winavr-20100110\avr\include\util\delay_basic.h **** 		"1: dec %0" "\n\t"
  85:c:\winavr-20100110\avr\include\util\delay_basic.h **** 		"brne 1b"
  86:c:\winavr-20100110\avr\include\util\delay_basic.h **** 		: "=r" (__count)
  87:c:\winavr-20100110\avr\include\util\delay_basic.h **** 		: "0" (__count)
  88:c:\winavr-20100110\avr\include\util\delay_basic.h **** 	);
  89:c:\winavr-20100110\avr\include\util\delay_basic.h **** }
  90:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  91:c:\winavr-20100110\avr\include\util\delay_basic.h **** /** \ingroup util_delay_basic
  92:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  93:c:\winavr-20100110\avr\include\util\delay_basic.h ****     Delay loop using a 16-bit counter \c __count, so up to 65536
  94:c:\winavr-20100110\avr\include\util\delay_basic.h ****     iterations are possible.  (The value 65536 would have to be
  95:c:\winavr-20100110\avr\include\util\delay_basic.h ****     passed as 0.)  The loop executes four CPU cycles per iteration,
  96:c:\winavr-20100110\avr\include\util\delay_basic.h ****     not including the overhead the compiler requires to setup the
  97:c:\winavr-20100110\avr\include\util\delay_basic.h ****     counter register pair.
  98:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  99:c:\winavr-20100110\avr\include\util\delay_basic.h ****     Thus, at a CPU speed of 1 MHz, delays of up to about 262.1
 100:c:\winavr-20100110\avr\include\util\delay_basic.h ****     milliseconds can be achieved.
 101:c:\winavr-20100110\avr\include\util\delay_basic.h ****  */
 102:c:\winavr-20100110\avr\include\util\delay_basic.h **** void
 103:c:\winavr-20100110\avr\include\util\delay_basic.h **** _delay_loop_2(uint16_t __count)
 104:c:\winavr-20100110\avr\include\util\delay_basic.h **** {
 105:c:\winavr-20100110\avr\include\util\delay_basic.h **** 	__asm__ volatile (
 3798               		.loc 4 105 0
 3799 07ce 8FEF      		ldi r24,lo8(-1)
 3800 07d0 9FEF      		ldi r25,lo8(-1)
 3801               	/* #APP */
 3802               	 ;  105 "c:\winavr-20100110\avr\include\util\delay_basic.h" 1
 3803 07d2 0197      		1: sbiw r24,1
 3804 07d4 01F4      		brne 1b
 3805               	 ;  0 "" 2
 3806               	.LVL423:
 3807               	/* #NOAPP */
 3808 07d6 00C0      		rjmp .L86
 3809               	.LBE145:
 3810               	.LBE144:
 3811               	.LBE143:
 3812               		.cfi_endproc
 3813               	.LFE43:
 3815               		.comm	flashWriteCycle,12,1
 3816               		.comm	flashWriteWePin,1,1
 3817               		.comm	flashChipIdBuffer,2,1
 3818               		.comm	eepromBuffer,8,1
 3819               		.comm	receivedChar,1,1
 3820               		.comm	receivedBuffer,256,1
 3821               		.text
 3822               	.Letext0:
 3823               		.file 5 "c:\\winavr-20100110\\avr\\include\\stdint.h"
 3824               		.file 6 "c:\\winavr-20100110\\avr\\include\\stdlib.h"
DEFINED SYMBOLS
                            *ABS*:00000000 main.c
C:\Users\Alex\AppData\Local\Temp\cc5cfT8c.s:2      *ABS*:0000003e __SP_H__
C:\Users\Alex\AppData\Local\Temp\cc5cfT8c.s:3      *ABS*:0000003d __SP_L__
C:\Users\Alex\AppData\Local\Temp\cc5cfT8c.s:4      *ABS*:0000003f __SREG__
C:\Users\Alex\AppData\Local\Temp\cc5cfT8c.s:5      *ABS*:00000000 __tmp_reg__
C:\Users\Alex\AppData\Local\Temp\cc5cfT8c.s:6      *ABS*:00000001 __zero_reg__
C:\Users\Alex\AppData\Local\Temp\cc5cfT8c.s:12     .text:00000000 USART_Receive
C:\Users\Alex\AppData\Local\Temp\cc5cfT8c.s:34     .text:00000008 USART_Transmit
C:\Users\Alex\AppData\Local\Temp\cc5cfT8c.s:55     .text:00000010 usart_read_bytes
                            *COM*:00000100 receivedBuffer
C:\Users\Alex\AppData\Local\Temp\cc5cfT8c.s:118    .text:0000003a usart_read_chars
C:\Users\Alex\AppData\Local\Temp\cc5cfT8c.s:158    .text:00000050 rd_wr_csmreq_cs2_reset
C:\Users\Alex\AppData\Local\Temp\cc5cfT8c.s:180    .text:0000005a gb_mode
C:\Users\Alex\AppData\Local\Temp\cc5cfT8c.s:207    .text:0000006a set_16bit_address
C:\Users\Alex\AppData\Local\Temp\cc5cfT8c.s:226    .text:00000070 read_8bit_data
C:\Users\Alex\AppData\Local\Temp\cc5cfT8c.s:266    .text:00000082 write_8bit_data
C:\Users\Alex\AppData\Local\Temp\cc5cfT8c.s:331    .text:000000ae gba_mode
C:\Users\Alex\AppData\Local\Temp\cc5cfT8c.s:358    .text:000000be gba_set_24bit_address
C:\Users\Alex\AppData\Local\Temp\cc5cfT8c.s:411    .text:000000ea gba_read_16bit_data
C:\Users\Alex\AppData\Local\Temp\cc5cfT8c.s:459    .text:00000108 gba_read_ram_8bit_data
C:\Users\Alex\AppData\Local\Temp\cc5cfT8c.s:499    .text:0000011a gba_write_ram_8bit_data
C:\Users\Alex\AppData\Local\Temp\cc5cfT8c.s:553    .text:0000013a gba_eeprom_mode
C:\Users\Alex\AppData\Local\Temp\cc5cfT8c.s:581    .text:0000014c gba_eeprom_set_address
C:\Users\Alex\AppData\Local\Temp\cc5cfT8c.s:720    .text:000001b4 gba_eeprom_read
                            *COM*:00000008 eepromBuffer
C:\Users\Alex\AppData\Local\Temp\cc5cfT8c.s:852    .text:0000020e gba_eeprom_write
C:\Users\Alex\AppData\Local\Temp\cc5cfT8c.s:968    .text:00000262 flash_write_bus_cycle
C:\Users\Alex\AppData\Local\Temp\cc5cfT8c.s:1014   .text:0000027c flash_read_chip_id
                            *COM*:00000002 flashChipIdBuffer
C:\Users\Alex\AppData\Local\Temp\cc5cfT8c.s:1119   .text:000002e6 flash_switch_bank
C:\Users\Alex\AppData\Local\Temp\cc5cfT8c.s:1168   .text:0000030c flash_erase_4k_sector
C:\Users\Alex\AppData\Local\Temp\cc5cfT8c.s:1243   .text:00000354 flash_write_byte
C:\Users\Alex\AppData\Local\Temp\cc5cfT8c.s:1314   .text:0000038c flash_write_sector
C:\Users\Alex\AppData\Local\Temp\cc5cfT8c.s:1427   .text:000003f8 gb_flash_read_byte
C:\Users\Alex\AppData\Local\Temp\cc5cfT8c.s:1467   .text:0000040a gb_flash_write_bus_cycle
                            *COM*:00000001 flashWriteWePin
C:\Users\Alex\AppData\Local\Temp\cc5cfT8c.s:1548   .text:00000438 gb_flash_write_byte
                            *COM*:0000000c flashWriteCycle
C:\Users\Alex\AppData\Local\Temp\cc5cfT8c.s:1648   .text:0000049c gba_flash_write_bus_cycle
C:\Users\Alex\AppData\Local\Temp\cc5cfT8c.s:1714   .text:000004cc gba_flash_write_cycle_start
C:\Users\Alex\AppData\Local\Temp\cc5cfT8c.s:1838   .text:0000052c gba_flash_write_byte_swapped
C:\Users\Alex\AppData\Local\Temp\cc5cfT8c.s:1936   .text:0000057a setup
C:\Users\Alex\AppData\Local\Temp\cc5cfT8c.s:2031   .text.startup:00000000 main
                            *COM*:00000001 receivedChar

UNDEFINED SYMBOLS
strtol
atoi
__do_clear_bss
