   1               		.file	"main.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               	.global	USART_Receive
  12               	USART_Receive:
  13               	.LFB12:
  14               		.file 1 "setup.c"
   1:setup.c       **** /*
   2:setup.c       ****  GBxCart RW
   3:setup.c       ****  PCB version: 1.1
   4:setup.c       ****  Firmware version: R3
   5:setup.c       ****  Author: Alex from insideGadgets (www.insidegadgets.com)
   6:setup.c       ****  Created: 7/11/2016
   7:setup.c       ****  Last Modified: 26/08/2017
   8:setup.c       ****  
   9:setup.c       ****  */
  10:setup.c       ****  
  11:setup.c       **** #ifndef cbi
  12:setup.c       **** #define cbi(sfr, bit) (_SFR_BYTE(sfr) &= ~_BV(bit))
  13:setup.c       **** #endif
  14:setup.c       **** #ifndef sbi
  15:setup.c       **** #define sbi(sfr, bit) (_SFR_BYTE(sfr) |= _BV(bit))
  16:setup.c       **** #endif
  17:setup.c       **** 
  18:setup.c       **** #ifndef NULL
  19:setup.c       **** #define NULL ((void *)0)
  20:setup.c       **** #endif
  21:setup.c       **** 
  22:setup.c       **** #define LOW 0
  23:setup.c       **** #define HIGH 1
  24:setup.c       **** #define false 0
  25:setup.c       **** #define true 1
  26:setup.c       **** 
  27:setup.c       **** #define SWITCH_DETECT PD2
  28:setup.c       **** #define ACTIVITY_LED PD3
  29:setup.c       **** #define LED_5V PD7
  30:setup.c       **** #define LED_3V PE0
  31:setup.c       **** 
  32:setup.c       **** #define WR_PIN PD6
  33:setup.c       **** #define RD_PIN PD5
  34:setup.c       **** #define CS_MREQ_PIN PD4
  35:setup.c       **** #define CS2_PIN PE2
  36:setup.c       **** #define AUDIO_PIN PE1
  37:setup.c       **** 
  38:setup.c       **** #define wrPin_high	PORTD |= (1<<WR_PIN);
  39:setup.c       **** #define wrPin_low		PORTD &= ~(1<<WR_PIN);
  40:setup.c       **** #define rdPin_high	PORTD |= (1<<RD_PIN);
  41:setup.c       **** #define rdPin_low		PORTD &= ~(1<<RD_PIN);
  42:setup.c       **** #define cs_mreqPin_high		PORTD |= (1<<CS_MREQ_PIN);
  43:setup.c       **** #define cs_mreqPin_low		PORTD &= ~(1<<CS_MREQ_PIN);
  44:setup.c       **** #define cs2Pin_high		PORTE |= (1<<CS2_PIN);
  45:setup.c       **** #define cs2Pin_low		PORTE &= ~(1<<CS2_PIN);
  46:setup.c       **** #define audioPin_high		PORTE |= (1<<AUDIO_PIN);
  47:setup.c       **** #define audioPin_low		PORTE &= ~(1<<AUDIO_PIN);
  48:setup.c       **** 
  49:setup.c       **** #define GB_MODE 1
  50:setup.c       **** #define GBA_MODE 2
  51:setup.c       **** 
  52:setup.c       **** // GB/GBC
  53:setup.c       **** #define PORT_ADDR7_0 PORTB
  54:setup.c       **** #define PORT_ADDR15_8 PORTA
  55:setup.c       **** #define PORT_DATA7_0 PORTC
  56:setup.c       **** 
  57:setup.c       **** #define DDR_ADDR7_0 DDRB
  58:setup.c       **** #define DDR_ADDR15_8 DDRA
  59:setup.c       **** #define DDR_DATA7_0 DDRC
  60:setup.c       **** 
  61:setup.c       **** #define PIN_ADDR7_0 PINB
  62:setup.c       **** #define PIN_ADDR15_8 PINA
  63:setup.c       **** #define PIN_DATA7_0 PINC
  64:setup.c       **** 
  65:setup.c       **** #define BANK_WRITE 0
  66:setup.c       **** #define MEMORY_WRITE 1
  67:setup.c       **** 
  68:setup.c       **** // GBA
  69:setup.c       **** #define EEPROM_WRITE 1
  70:setup.c       **** #define EEPROM_READ 0
  71:setup.c       **** 
  72:setup.c       **** #define EEPROM_NONE 0
  73:setup.c       **** #define EEPROM_4KBIT 1
  74:setup.c       **** #define EEPROM_64KBIT 2
  75:setup.c       **** 
  76:setup.c       **** #define AD0 PB0
  77:setup.c       **** #define ad0Pin_high		PORTB |= (1<<AD0);
  78:setup.c       **** #define ad0Pin_low		PORTB &= ~(1<<AD0);
  79:setup.c       **** 
  80:setup.c       **** #define A23 PC7
  81:setup.c       **** #define a23Pin_high		PORTC |= (1<<A23);
  82:setup.c       **** #define a23Pin_low		PORTC &= ~(1<<A23);
  83:setup.c       **** 
  84:setup.c       **** #define GBA_DDR_ROM_ADDR7_0 DDRB
  85:setup.c       **** #define GBA_DDR_ROM_ADDR15_8 DDRA
  86:setup.c       **** #define GBA_DDR_ROM_ADDR23_16 DDRC
  87:setup.c       **** #define GBA_DDR_ROM_DATA7_0 DDRB
  88:setup.c       **** #define GBA_DDR_ROM_DATA15_8 DDRA
  89:setup.c       **** #define GBA_DDR_RAM_DATA7_0 DDRC
  90:setup.c       **** #define GBA_DDR_EEPROM_DATA7_0 DDRB
  91:setup.c       **** 
  92:setup.c       **** #define GBA_PORT_ROM_ADDR7_0 PORTB
  93:setup.c       **** #define GBA_PORT_ROM_ADDR15_8 PORTA
  94:setup.c       **** #define GBA_PORT_ROM_ADDR23_16 PORTC
  95:setup.c       **** #define GBA_PORT_ROM_DATA7_0 PORTB
  96:setup.c       **** #define GBA_PORT_ROM_DATA15_8 PORTA
  97:setup.c       **** #define GBA_PORT_RAM_DATA7_0 PORTC
  98:setup.c       **** #define GBA_PORT_EEPROM_DATA7_0 PORTB
  99:setup.c       **** 
 100:setup.c       **** #define GBA_PIN_ROM_DATA7_0 PINB
 101:setup.c       **** #define GBA_PIN_ROM_DATA15_8 PINA
 102:setup.c       **** #define GBA_PIN_RAM_DATA7_0 PINC
 103:setup.c       **** #define GBA_PIN_EEPROM_DATA7_0 PINB
 104:setup.c       **** 
 105:setup.c       **** // GB/GBC commands
 106:setup.c       **** #define SET_START_ADDRESS 'A'
 107:setup.c       **** #define READ_ROM_RAM 'R'
 108:setup.c       **** #define WRITE_RAM 'W'
 109:setup.c       **** #define SET_BANK 'B'
 110:setup.c       **** #define GB_CART_MODE 'G'
 111:setup.c       **** 
 112:setup.c       **** // GBA commands
 113:setup.c       **** #define GBA_READ_ROM 'r'
 114:setup.c       **** #define GBA_READ_SRAM 'm'
 115:setup.c       **** #define GBA_WRITE_SRAM 'w'
 116:setup.c       **** #define GBA_WRITE_ONE_BYTE_SRAM 'o'
 117:setup.c       **** #define GBA_CART_MODE 'g'
 118:setup.c       **** 
 119:setup.c       **** #define GBA_FLASH_READ_ID 'i'
 120:setup.c       **** #define GBA_FLASH_SET_BANK 'k'
 121:setup.c       **** #define GBA_FLASH_4K_SECTOR_ERASE 's'
 122:setup.c       **** #define GBA_FLASH_WRITE_BYTE 'b'
 123:setup.c       **** #define GBA_FLASH_WRITE_ATMEL 'a'
 124:setup.c       **** 
 125:setup.c       **** #define GBA_SET_EEPROM_SIZE 'S'
 126:setup.c       **** #define GBA_READ_EEPROM 'e'
 127:setup.c       **** #define GBA_WRITE_EEPROM 'p'
 128:setup.c       **** 
 129:setup.c       **** // General commands
 130:setup.c       **** #define CART_MODE 'C'
 131:setup.c       **** #define SET_INPUT 'I'
 132:setup.c       **** #define SET_OUTPUT 'O'
 133:setup.c       **** #define SET_OUTPUT_LOW 'L'
 134:setup.c       **** #define SET_OUTPUT_HIGH 'H'
 135:setup.c       **** #define READ_INPUT 'D'
 136:setup.c       **** #define RESET_COMMON_LINES 'M'
 137:setup.c       **** #define READ_FIRMWARE_VERSION 'V'
 138:setup.c       **** #define READ_PCB_VERSION 'h'
 139:setup.c       **** 
 140:setup.c       **** #define GB_FLASH_WRITE_BYTE_AUDIO 'F'
 141:setup.c       **** #define GB_FLASH_WRITE_64BYTE_AUDIO 'U'
 142:setup.c       **** 
 143:setup.c       **** #define RESET_AVR '*'
 144:setup.c       **** #define RESET_VALUE 0x7E5E1
 145:setup.c       **** 
 146:setup.c       **** 
 147:setup.c       **** char receivedBuffer[129];
 148:setup.c       **** char receivedChar;
 149:setup.c       **** uint8_t eepromBuffer[8];
 150:setup.c       **** uint8_t flashChipIdBuffer[2];
 151:setup.c       **** 
 152:setup.c       **** // Receive USART data
 153:setup.c       **** uint8_t USART_Receive(void) {
  15               		.loc 1 153 0
  16               		.cfi_startproc
  17               	/* prologue: function */
  18               	/* frame size = 0 */
  19               	/* stack size = 0 */
  20               	.L__stack_usage = 0
  21               	.L2:
 154:setup.c       **** 	while ( !(UCSRA & (1<<RXC)) ); // Wait for data to be received
  22               		.loc 1 154 0 discriminator 1
  23 0000 5F9B      		sbis 0xb,7
  24 0002 00C0      		rjmp .L2
 155:setup.c       **** 	return UDR; // Get and return received data from buffer
  25               		.loc 1 155 0
  26 0004 8CB1      		in r24,0xc
 156:setup.c       **** }
  27               		.loc 1 156 0
  28 0006 0895      		ret
  29               		.cfi_endproc
  30               	.LFE12:
  32               	.global	USART_Transmit
  34               	USART_Transmit:
  35               	.LFB13:
 157:setup.c       **** 
 158:setup.c       **** // Transmit USART data
 159:setup.c       **** void USART_Transmit(unsigned char data) {
  36               		.loc 1 159 0
  37               		.cfi_startproc
  38               	/* prologue: function */
  39               	/* frame size = 0 */
  40               	/* stack size = 0 */
  41               	.L__stack_usage = 0
  42               	.LVL0:
  43               	.L6:
 160:setup.c       **** 	while ( !( UCSRA & (1<<UDRE)) ); // Wait for empty transmit buffer
  44               		.loc 1 160 0 discriminator 1
  45 0008 5D9B      		sbis 0xb,5
  46 000a 00C0      		rjmp .L6
 161:setup.c       **** 	UDR = data;
  47               		.loc 1 161 0
  48 000c 8CB9      		out 0xc,r24
  49 000e 0895      		ret
  50               		.cfi_endproc
  51               	.LFE13:
  53               	.global	usart_read_bytes
  55               	usart_read_bytes:
  56               	.LFB14:
 162:setup.c       **** }
 163:setup.c       **** 
 164:setup.c       **** // Read 1-128 bytes from the USART 
 165:setup.c       **** void usart_read_bytes(uint8_t count) {
  57               		.loc 1 165 0
  58               		.cfi_startproc
  59               	.LVL1:
  60 0010 EF92      		push r14
  61               	.LCFI0:
  62               		.cfi_def_cfa_offset 3
  63               		.cfi_offset 14, -2
  64 0012 FF92      		push r15
  65               	.LCFI1:
  66               		.cfi_def_cfa_offset 4
  67               		.cfi_offset 15, -3
  68 0014 1F93      		push r17
  69               	.LCFI2:
  70               		.cfi_def_cfa_offset 5
  71               		.cfi_offset 17, -4
  72 0016 CF93      		push r28
  73               	.LCFI3:
  74               		.cfi_def_cfa_offset 6
  75               		.cfi_offset 28, -5
  76 0018 DF93      		push r29
  77               	.LCFI4:
  78               		.cfi_def_cfa_offset 7
  79               		.cfi_offset 29, -6
  80               	/* prologue: function */
  81               	/* frame size = 0 */
  82               	/* stack size = 5 */
  83               	.L__stack_usage = 5
  84 001a 182F      		mov r17,r24
  85               	.LVL2:
  86 001c 80E0      		ldi r24,lo8(receivedBuffer)
  87 001e E82E      		mov r14,r24
  88 0020 80E0      		ldi r24,hi8(receivedBuffer)
  89 0022 F82E      		mov r15,r24
  90               	.LVL3:
  91               	.LBB44:
 166:setup.c       **** 	for (uint8_t x = 0; x < count; x++) {
  92               		.loc 1 166 0
  93 0024 E701      		movw r28,r14
  94               	.LVL4:
  95               	.L10:
  96 0026 8C2F      		mov r24,r28
  97 0028 8E19      		sub r24,r14
  98               		.loc 1 166 0 is_stmt 0 discriminator 1
  99 002a 8117      		cp r24,r17
 100 002c 00F4      		brsh .L12
 167:setup.c       **** 		receivedBuffer[x] = USART_Receive();
 101               		.loc 1 167 0 is_stmt 1 discriminator 3
 102 002e 00D0      		rcall USART_Receive
 103               	.LVL5:
 104 0030 8993      		st Y+,r24
 105               	.LVL6:
 106 0032 00C0      		rjmp .L10
 107               	.L12:
 108               	/* epilogue start */
 109               	.LBE44:
 168:setup.c       **** 	}
 169:setup.c       **** }
 110               		.loc 1 169 0
 111 0034 DF91      		pop r29
 112 0036 CF91      		pop r28
 113               	.LVL7:
 114 0038 1F91      		pop r17
 115               	.LVL8:
 116 003a FF90      		pop r15
 117 003c EF90      		pop r14
 118 003e 0895      		ret
 119               		.cfi_endproc
 120               	.LFE14:
 122               	.global	usart_read_chars
 124               	usart_read_chars:
 125               	.LFB15:
 170:setup.c       **** 
 171:setup.c       **** // Read the USART until a 0 (string terminator byte) is received
 172:setup.c       **** void usart_read_chars(void) {
 126               		.loc 1 172 0
 127               		.cfi_startproc
 128 0040 CF93      		push r28
 129               	.LCFI5:
 130               		.cfi_def_cfa_offset 3
 131               		.cfi_offset 28, -2
 132               	/* prologue: function */
 133               	/* frame size = 0 */
 134               	/* stack size = 1 */
 135               	.L__stack_usage = 1
 136               	.LVL9:
 173:setup.c       **** 	uint8_t x = 0;
 137               		.loc 1 173 0
 138 0042 C0E0      		ldi r28,0
 139               	.LVL10:
 140               	.L15:
 174:setup.c       **** 	while (1) {
 175:setup.c       **** 		receivedBuffer[x] = USART_Receive();
 141               		.loc 1 175 0
 142 0044 00D0      		rcall USART_Receive
 143               	.LVL11:
 144 0046 EC2F      		mov r30,r28
 145 0048 F0E0      		ldi r31,0
 146 004a E050      		subi r30,lo8(-(receivedBuffer))
 147 004c F040      		sbci r31,hi8(-(receivedBuffer))
 148 004e 8083      		st Z,r24
 176:setup.c       **** 		if (receivedBuffer[x] == 0) {
 149               		.loc 1 176 0
 150 0050 8823      		tst r24
 151 0052 01F0      		breq .L13
 177:setup.c       **** 			break;
 178:setup.c       **** 		}
 179:setup.c       **** 		x++;
 152               		.loc 1 179 0
 153 0054 CF5F      		subi r28,lo8(-(1))
 154               	.LVL12:
 180:setup.c       **** 	}
 155               		.loc 1 180 0
 156 0056 00C0      		rjmp .L15
 157               	.L13:
 158               	/* epilogue start */
 181:setup.c       **** }
 159               		.loc 1 181 0
 160 0058 CF91      		pop r28
 161               	.LVL13:
 162 005a 0895      		ret
 163               		.cfi_endproc
 164               	.LFE15:
 166               	.global	rd_wr_csmreq_cs2_reset
 168               	rd_wr_csmreq_cs2_reset:
 169               	.LFB16:
 182:setup.c       **** 
 183:setup.c       **** // Turn RD, WR, CS/MREQ and CS2 to high so they are deselected (reset state)
 184:setup.c       **** void rd_wr_csmreq_cs2_reset(void) {
 170               		.loc 1 184 0
 171               		.cfi_startproc
 172               	/* prologue: function */
 173               	/* frame size = 0 */
 174               	/* stack size = 0 */
 175               	.L__stack_usage = 0
 185:setup.c       **** 	cs2Pin_high; // CS2 off
 176               		.loc 1 185 0
 177 005c 3A9A      		sbi 0x7,2
 186:setup.c       **** 	cs_mreqPin_high; // CS/MREQ off
 178               		.loc 1 186 0
 179 005e 949A      		sbi 0x12,4
 187:setup.c       **** 	rdPin_high; // RD off
 180               		.loc 1 187 0
 181 0060 959A      		sbi 0x12,5
 188:setup.c       **** 	wrPin_high; // WR off
 182               		.loc 1 188 0
 183 0062 969A      		sbi 0x12,6
 184 0064 0895      		ret
 185               		.cfi_endproc
 186               	.LFE16:
 188               	.global	gb_mode
 190               	gb_mode:
 191               	.LFB17:
 189:setup.c       **** }
 190:setup.c       **** 
 191:setup.c       **** 
 192:setup.c       **** 
 193:setup.c       **** // ****** Gameboy / Gameboy Colour functions ******
 194:setup.c       **** 
 195:setup.c       **** // Set Gameboy mode
 196:setup.c       **** void gb_mode(void) {
 192               		.loc 1 196 0
 193               		.cfi_startproc
 194               	/* prologue: function */
 195               	/* frame size = 0 */
 196               	/* stack size = 0 */
 197               	.L__stack_usage = 0
 197:setup.c       **** 	// Set inputs
 198:setup.c       **** 	PORT_DATA7_0 = 0;
 198               		.loc 1 198 0
 199 0066 15BA      		out 0x15,__zero_reg__
 199:setup.c       **** 	DDR_DATA7_0 = 0;
 200               		.loc 1 199 0
 201 0068 14BA      		out 0x14,__zero_reg__
 200:setup.c       **** 	
 201:setup.c       **** 	// Set outputs
 202:setup.c       **** 	PORT_ADDR7_0 = 0;
 202               		.loc 1 202 0
 203 006a 18BA      		out 0x18,__zero_reg__
 203:setup.c       **** 	PORT_ADDR15_8 = 0;
 204               		.loc 1 203 0
 205 006c 1BBA      		out 0x1b,__zero_reg__
 204:setup.c       **** 	DDR_ADDR7_0 = 0xFF;
 206               		.loc 1 204 0
 207 006e 8FEF      		ldi r24,lo8(-1)
 208 0070 87BB      		out 0x17,r24
 205:setup.c       **** 	DDR_ADDR15_8 = 0xFF;
 209               		.loc 1 205 0
 210 0072 8ABB      		out 0x1a,r24
 211 0074 0895      		ret
 212               		.cfi_endproc
 213               	.LFE17:
 215               	.global	set_16bit_address
 217               	set_16bit_address:
 218               	.LFB18:
 206:setup.c       **** }
 207:setup.c       **** 
 208:setup.c       **** // Set the 16 bit address on A15-0
 209:setup.c       **** void set_16bit_address(uint16_t address) {
 219               		.loc 1 209 0
 220               		.cfi_startproc
 221               	.LVL14:
 222               	/* prologue: function */
 223               	/* frame size = 0 */
 224               	/* stack size = 0 */
 225               	.L__stack_usage = 0
 210:setup.c       **** 	PORT_ADDR15_8 = (address >> 8);
 226               		.loc 1 210 0
 227 0076 9BBB      		out 0x1b,r25
 211:setup.c       **** 	PORT_ADDR7_0 = (address & 0xFF);
 228               		.loc 1 211 0
 229 0078 88BB      		out 0x18,r24
 230 007a 0895      		ret
 231               		.cfi_endproc
 232               	.LFE18:
 234               	.global	read_8bit_data
 236               	read_8bit_data:
 237               	.LFB19:
 212:setup.c       **** }
 213:setup.c       **** 
 214:setup.c       **** // Set the address and read a byte from the 8 bit data line
 215:setup.c       **** uint8_t read_8bit_data(uint16_t address) {
 238               		.loc 1 215 0
 239               		.cfi_startproc
 240               	.LVL15:
 241               	/* prologue: function */
 242               	/* frame size = 0 */
 243               	/* stack size = 0 */
 244               	.L__stack_usage = 0
 216:setup.c       **** 	set_16bit_address(address);
 245               		.loc 1 216 0
 246 007c 00D0      		rcall set_16bit_address
 247               	.LVL16:
 217:setup.c       **** 	
 218:setup.c       **** 	cs_mreqPin_low;
 248               		.loc 1 218 0
 249 007e 9498      		cbi 0x12,4
 219:setup.c       **** 	rdPin_low;
 250               		.loc 1 219 0
 251 0080 9598      		cbi 0x12,5
 220:setup.c       **** 	
 221:setup.c       **** 	asm volatile("nop"); // Delay a little (minimum needed is 1 nops, 2 nops for GB camera)
 252               		.loc 1 221 0
 253               	/* #APP */
 254               	 ;  221 "setup.c" 1
 255 0082 0000      		nop
 256               	 ;  0 "" 2
 222:setup.c       **** 	asm volatile("nop");
 257               		.loc 1 222 0
 258               	 ;  222 "setup.c" 1
 259 0084 0000      		nop
 260               	 ;  0 "" 2
 223:setup.c       **** 	uint8_t data = PIN_DATA7_0; // Read data
 261               		.loc 1 223 0
 262               	/* #NOAPP */
 263 0086 83B3      		in r24,0x13
 264               	.LVL17:
 224:setup.c       **** 	
 225:setup.c       **** 	rdPin_high;
 265               		.loc 1 225 0
 266 0088 959A      		sbi 0x12,5
 226:setup.c       **** 	cs_mreqPin_high;
 267               		.loc 1 226 0
 268 008a 949A      		sbi 0x12,4
 227:setup.c       **** 	
 228:setup.c       **** 	return data;
 229:setup.c       **** }
 269               		.loc 1 229 0
 270 008c 0895      		ret
 271               		.cfi_endproc
 272               	.LFE19:
 274               	.global	write_8bit_data
 276               	write_8bit_data:
 277               	.LFB20:
 230:setup.c       **** 
 231:setup.c       **** // Set the address and write a byte to the 8 bit data line and pulse cs/mREQ if writing to RAM
 232:setup.c       **** void write_8bit_data(uint16_t address, uint8_t data, uint8_t type) {
 278               		.loc 1 232 0
 279               		.cfi_startproc
 280               	.LVL18:
 281 008e CF93      		push r28
 282               	.LCFI6:
 283               		.cfi_def_cfa_offset 3
 284               		.cfi_offset 28, -2
 285 0090 DF93      		push r29
 286               	.LCFI7:
 287               		.cfi_def_cfa_offset 4
 288               		.cfi_offset 29, -3
 289 0092 00D0      		rcall .
 290               	.LCFI8:
 291               		.cfi_def_cfa_offset 6
 292 0094 CDB7      		in r28,__SP_L__
 293 0096 DEB7      		in r29,__SP_H__
 294               	.LCFI9:
 295               		.cfi_def_cfa_register 28
 296               	/* prologue: function */
 297               	/* frame size = 2 */
 298               	/* stack size = 4 */
 299               	.L__stack_usage = 4
 233:setup.c       **** 	set_16bit_address(address);
 300               		.loc 1 233 0
 301 0098 4A83      		std Y+2,r20
 302 009a 6983      		std Y+1,r22
 303 009c 00D0      		rcall set_16bit_address
 304               	.LVL19:
 234:setup.c       **** 	
 235:setup.c       **** 	DDR_DATA7_0 = 0xFF; // Set data pins as outputs
 305               		.loc 1 235 0
 306 009e 8FEF      		ldi r24,lo8(-1)
 307 00a0 84BB      		out 0x14,r24
 236:setup.c       **** 	PORT_DATA7_0 = data; // Set data
 308               		.loc 1 236 0
 309 00a2 6981      		ldd r22,Y+1
 310 00a4 65BB      		out 0x15,r22
 237:setup.c       **** 	
 238:setup.c       **** 	// Pulse WR and mREQ if the type matches
 239:setup.c       **** 	wrPin_low;
 311               		.loc 1 239 0
 312 00a6 9698      		cbi 0x12,6
 240:setup.c       **** 	if (type == MEMORY_WRITE) {
 313               		.loc 1 240 0
 314 00a8 4A81      		ldd r20,Y+2
 315 00aa 4130      		cpi r20,lo8(1)
 316 00ac 01F4      		brne .L21
 241:setup.c       **** 		cs_mreqPin_low;
 317               		.loc 1 241 0
 318 00ae 9498      		cbi 0x12,4
 319               	.L21:
 242:setup.c       **** 	}
 243:setup.c       **** 	
 244:setup.c       **** 	asm volatile("nop");
 320               		.loc 1 244 0
 321               	/* #APP */
 322               	 ;  244 "setup.c" 1
 323 00b0 0000      		nop
 324               	 ;  0 "" 2
 245:setup.c       **** 	
 246:setup.c       **** 	if (type == MEMORY_WRITE) {
 325               		.loc 1 246 0
 326               	/* #NOAPP */
 327 00b2 4130      		cpi r20,lo8(1)
 328 00b4 01F4      		brne .L22
 247:setup.c       **** 		cs_mreqPin_high;
 329               		.loc 1 247 0
 330 00b6 949A      		sbi 0x12,4
 331               	.L22:
 248:setup.c       **** 	}
 249:setup.c       **** 	wrPin_high;
 332               		.loc 1 249 0
 333 00b8 969A      		sbi 0x12,6
 250:setup.c       **** 	
 251:setup.c       **** 	// Clear data outputs and set data pins as inputs
 252:setup.c       **** 	PORT_DATA7_0 = 0;
 334               		.loc 1 252 0
 335 00ba 15BA      		out 0x15,__zero_reg__
 253:setup.c       **** 	DDR_DATA7_0 = 0;
 336               		.loc 1 253 0
 337 00bc 14BA      		out 0x14,__zero_reg__
 338               	/* epilogue start */
 254:setup.c       **** }
 339               		.loc 1 254 0
 340 00be 0F90      		pop __tmp_reg__
 341 00c0 0F90      		pop __tmp_reg__
 342 00c2 DF91      		pop r29
 343 00c4 CF91      		pop r28
 344 00c6 0895      		ret
 345               		.cfi_endproc
 346               	.LFE20:
 348               	.global	gba_mode
 350               	gba_mode:
 351               	.LFB21:
 255:setup.c       **** 
 256:setup.c       **** 
 257:setup.c       **** 
 258:setup.c       **** // ****** Gameboy Advance functions ****** 
 259:setup.c       **** 
 260:setup.c       **** // Set GBA mode
 261:setup.c       **** void gba_mode(void) {
 352               		.loc 1 261 0
 353               		.cfi_startproc
 354               	/* prologue: function */
 355               	/* frame size = 0 */
 356               	/* stack size = 0 */
 357               	.L__stack_usage = 0
 262:setup.c       **** 	// Set outputs for reading ROM addresses as default
 263:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = 0;
 358               		.loc 1 263 0
 359 00c8 18BA      		out 0x18,__zero_reg__
 264:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = 0;
 360               		.loc 1 264 0
 361 00ca 1BBA      		out 0x1b,__zero_reg__
 265:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = 0;
 362               		.loc 1 265 0
 363 00cc 15BA      		out 0x15,__zero_reg__
 266:setup.c       **** 	GBA_DDR_ROM_ADDR7_0 = 0xFF;
 364               		.loc 1 266 0
 365 00ce 8FEF      		ldi r24,lo8(-1)
 366 00d0 87BB      		out 0x17,r24
 267:setup.c       **** 	GBA_DDR_ROM_ADDR15_8 = 0xFF;
 367               		.loc 1 267 0
 368 00d2 8ABB      		out 0x1a,r24
 268:setup.c       **** 	GBA_DDR_ROM_ADDR23_16 = 0xFF;
 369               		.loc 1 268 0
 370 00d4 84BB      		out 0x14,r24
 371 00d6 0895      		ret
 372               		.cfi_endproc
 373               	.LFE21:
 375               	.global	gba_set_24bit_address
 377               	gba_set_24bit_address:
 378               	.LFB22:
 269:setup.c       **** }
 270:setup.c       **** 
 271:setup.c       **** // Set the 24 bit address on A23-0
 272:setup.c       **** void gba_set_24bit_address(uint32_t address) {	
 379               		.loc 1 272 0
 380               		.cfi_startproc
 381               	.LVL20:
 382 00d8 0F93      		push r16
 383               	.LCFI10:
 384               		.cfi_def_cfa_offset 3
 385               		.cfi_offset 16, -2
 386 00da 1F93      		push r17
 387               	.LCFI11:
 388               		.cfi_def_cfa_offset 4
 389               		.cfi_offset 17, -3
 390               	/* prologue: function */
 391               	/* frame size = 0 */
 392               	/* stack size = 2 */
 393               	.L__stack_usage = 2
 273:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = 0; // Set 0-23 address lines low and set as outputs
 394               		.loc 1 273 0
 395 00dc 15BA      		out 0x15,__zero_reg__
 274:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = 0;
 396               		.loc 1 274 0
 397 00de 1BBA      		out 0x1b,__zero_reg__
 275:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = 0;
 398               		.loc 1 275 0
 399 00e0 18BA      		out 0x18,__zero_reg__
 276:setup.c       **** 	GBA_DDR_ROM_ADDR23_16 = 0xFF;
 400               		.loc 1 276 0
 401 00e2 2FEF      		ldi r18,lo8(-1)
 402 00e4 24BB      		out 0x14,r18
 277:setup.c       **** 	GBA_DDR_ROM_ADDR15_8 = 0xFF;
 403               		.loc 1 277 0
 404 00e6 2ABB      		out 0x1a,r18
 278:setup.c       **** 	GBA_DDR_ROM_ADDR7_0 = 0xFF;
 405               		.loc 1 278 0
 406 00e8 27BB      		out 0x17,r18
 279:setup.c       **** 	
 280:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = (address >> 16);
 407               		.loc 1 280 0
 408 00ea 8C01      		movw r16,r24
 409 00ec 2227      		clr r18
 410 00ee 3327      		clr r19
 411 00f0 05BB      		out 0x15,r16
 281:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = (address >> 8);
 412               		.loc 1 281 0
 413 00f2 072F      		mov r16,r23
 414 00f4 182F      		mov r17,r24
 415 00f6 292F      		mov r18,r25
 416 00f8 3327      		clr r19
 417 00fa 0BBB      		out 0x1b,r16
 282:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = (address & 0xFF);
 418               		.loc 1 282 0
 419 00fc 68BB      		out 0x18,r22
 420               	/* epilogue start */
 283:setup.c       **** }
 421               		.loc 1 283 0
 422 00fe 1F91      		pop r17
 423 0100 0F91      		pop r16
 424 0102 0895      		ret
 425               		.cfi_endproc
 426               	.LFE22:
 428               	.global	gba_read_16bit_data
 430               	gba_read_16bit_data:
 431               	.LFB23:
 284:setup.c       **** 
 285:setup.c       **** 
 286:setup.c       **** 
 287:setup.c       **** // ---------- ROM/SRAM ----------
 288:setup.c       **** 
 289:setup.c       **** // Read a byte from the 16 bit data line non-sequentially
 290:setup.c       **** uint16_t gba_read_16bit_data(uint32_t address) {
 432               		.loc 1 290 0
 433               		.cfi_startproc
 434               	.LVL21:
 435               	/* prologue: function */
 436               	/* frame size = 0 */
 437               	/* stack size = 0 */
 438               	.L__stack_usage = 0
 291:setup.c       **** 	gba_set_24bit_address(address);
 439               		.loc 1 291 0
 440 0104 00D0      		rcall gba_set_24bit_address
 441               	.LVL22:
 292:setup.c       **** 	
 293:setup.c       **** 	cs_mreqPin_low;
 442               		.loc 1 293 0
 443 0106 9498      		cbi 0x12,4
 294:setup.c       **** 	
 295:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = 0; // Set address lines low and set as inputs
 444               		.loc 1 295 0
 445 0108 1BBA      		out 0x1b,__zero_reg__
 296:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = 0;
 446               		.loc 1 296 0
 447 010a 18BA      		out 0x18,__zero_reg__
 297:setup.c       **** 	GBA_DDR_ROM_ADDR15_8 = 0;
 448               		.loc 1 297 0
 449 010c 1ABA      		out 0x1a,__zero_reg__
 298:setup.c       **** 	GBA_DDR_ROM_ADDR7_0 = 0;
 450               		.loc 1 298 0
 451 010e 17BA      		out 0x17,__zero_reg__
 299:setup.c       **** 	
 300:setup.c       **** 	rdPin_low;
 452               		.loc 1 300 0
 453 0110 9598      		cbi 0x12,5
 301:setup.c       **** 	asm volatile("nop");
 454               		.loc 1 301 0
 455               	/* #APP */
 456               	 ;  301 "setup.c" 1
 457 0112 0000      		nop
 458               	 ;  0 "" 2
 302:setup.c       **** 	
 303:setup.c       **** 	uint16_t data = (GBA_PIN_ROM_DATA15_8 << 8) | GBA_PIN_ROM_DATA7_0; // Read data
 459               		.loc 1 303 0
 460               	/* #NOAPP */
 461 0114 29B3      		in r18,0x19
 462 0116 86B3      		in r24,0x16
 463               	.LVL23:
 304:setup.c       **** 	
 305:setup.c       **** 	rdPin_high;
 464               		.loc 1 305 0
 465 0118 959A      		sbi 0x12,5
 306:setup.c       **** 	cs_mreqPin_high;
 466               		.loc 1 306 0
 467 011a 949A      		sbi 0x12,4
 303:setup.c       **** 	
 468               		.loc 1 303 0
 469 011c 90E0      		ldi r25,0
 307:setup.c       **** 	
 308:setup.c       **** 	return data;
 309:setup.c       **** }
 470               		.loc 1 309 0
 471 011e 922B      		or r25,r18
 472 0120 0895      		ret
 473               		.cfi_endproc
 474               	.LFE23:
 476               	.global	gba_read_ram_8bit_data
 478               	gba_read_ram_8bit_data:
 479               	.LFB24:
 310:setup.c       **** 
 311:setup.c       **** // Set the address and read a byte from the 8 bit data line
 312:setup.c       **** uint8_t gba_read_ram_8bit_data(uint16_t address) {
 480               		.loc 1 312 0
 481               		.cfi_startproc
 482               	.LVL24:
 483               	/* prologue: function */
 484               	/* frame size = 0 */
 485               	/* stack size = 0 */
 486               	.L__stack_usage = 0
 313:setup.c       **** 	set_16bit_address(address);
 487               		.loc 1 313 0
 488 0122 00D0      		rcall set_16bit_address
 489               	.LVL25:
 314:setup.c       **** 	
 315:setup.c       **** 	rdPin_low;
 490               		.loc 1 315 0
 491 0124 9598      		cbi 0x12,5
 316:setup.c       **** 	cs2Pin_low; // CS2 pin low for SRAM/Flash select
 492               		.loc 1 316 0
 493 0126 3A98      		cbi 0x7,2
 317:setup.c       **** 	
 318:setup.c       **** 	asm volatile("nop"); // Delay a little (minimum needed is 2)
 494               		.loc 1 318 0
 495               	/* #APP */
 496               	 ;  318 "setup.c" 1
 497 0128 0000      		nop
 498               	 ;  0 "" 2
 319:setup.c       **** 	asm volatile("nop");
 499               		.loc 1 319 0
 500               	 ;  319 "setup.c" 1
 501 012a 0000      		nop
 502               	 ;  0 "" 2
 320:setup.c       **** 	
 321:setup.c       **** 	uint8_t data = GBA_PIN_RAM_DATA7_0; // Read data
 503               		.loc 1 321 0
 504               	/* #NOAPP */
 505 012c 83B3      		in r24,0x13
 506               	.LVL26:
 322:setup.c       **** 	
 323:setup.c       **** 	cs2Pin_high;
 507               		.loc 1 323 0
 508 012e 3A9A      		sbi 0x7,2
 324:setup.c       **** 	rdPin_high;
 509               		.loc 1 324 0
 510 0130 959A      		sbi 0x12,5
 325:setup.c       **** 	
 326:setup.c       **** 	return data;
 327:setup.c       **** }
 511               		.loc 1 327 0
 512 0132 0895      		ret
 513               		.cfi_endproc
 514               	.LFE24:
 516               	.global	gba_write_ram_8bit_data
 518               	gba_write_ram_8bit_data:
 519               	.LFB25:
 328:setup.c       **** 
 329:setup.c       **** // Set the address and write a byte to the 8 bit data line 
 330:setup.c       **** void gba_write_ram_8bit_data(uint16_t address, uint8_t data) {
 520               		.loc 1 330 0
 521               		.cfi_startproc
 522               	.LVL27:
 523 0134 CF93      		push r28
 524               	.LCFI12:
 525               		.cfi_def_cfa_offset 3
 526               		.cfi_offset 28, -2
 527 0136 DF93      		push r29
 528               	.LCFI13:
 529               		.cfi_def_cfa_offset 4
 530               		.cfi_offset 29, -3
 531 0138 1F92      		push __zero_reg__
 532               	.LCFI14:
 533               		.cfi_def_cfa_offset 5
 534 013a CDB7      		in r28,__SP_L__
 535 013c DEB7      		in r29,__SP_H__
 536               	.LCFI15:
 537               		.cfi_def_cfa_register 28
 538               	/* prologue: function */
 539               	/* frame size = 1 */
 540               	/* stack size = 3 */
 541               	.L__stack_usage = 3
 331:setup.c       **** 	set_16bit_address(address);
 542               		.loc 1 331 0
 543 013e 6983      		std Y+1,r22
 544 0140 00D0      		rcall set_16bit_address
 545               	.LVL28:
 332:setup.c       **** 	
 333:setup.c       **** 	GBA_DDR_RAM_DATA7_0 = 0xFF; // Set data pins as outputs
 546               		.loc 1 333 0
 547 0142 8FEF      		ldi r24,lo8(-1)
 548 0144 84BB      		out 0x14,r24
 334:setup.c       **** 	GBA_PORT_RAM_DATA7_0 = data; // Set data
 549               		.loc 1 334 0
 550 0146 6981      		ldd r22,Y+1
 551 0148 65BB      		out 0x15,r22
 335:setup.c       **** 	
 336:setup.c       **** 	// Pulse WR
 337:setup.c       **** 	wrPin_low;
 552               		.loc 1 337 0
 553 014a 9698      		cbi 0x12,6
 338:setup.c       **** 	cs2Pin_low; // CS2 pin low for SRAM/Flash select
 554               		.loc 1 338 0
 555 014c 3A98      		cbi 0x7,2
 339:setup.c       **** 	
 340:setup.c       **** 	asm volatile("nop");
 556               		.loc 1 340 0
 557               	/* #APP */
 558               	 ;  340 "setup.c" 1
 559 014e 0000      		nop
 560               	 ;  0 "" 2
 341:setup.c       **** 	asm volatile("nop");
 561               		.loc 1 341 0
 562               	 ;  341 "setup.c" 1
 563 0150 0000      		nop
 564               	 ;  0 "" 2
 342:setup.c       **** 	
 343:setup.c       **** 	cs2Pin_high;
 565               		.loc 1 343 0
 566               	/* #NOAPP */
 567 0152 3A9A      		sbi 0x7,2
 344:setup.c       **** 	wrPin_high;
 568               		.loc 1 344 0
 569 0154 969A      		sbi 0x12,6
 345:setup.c       **** 	
 346:setup.c       **** 	// Clear data outputs and set data pins as inputs
 347:setup.c       **** 	GBA_PORT_RAM_DATA7_0 = 0;
 570               		.loc 1 347 0
 571 0156 15BA      		out 0x15,__zero_reg__
 348:setup.c       **** 	GBA_DDR_RAM_DATA7_0 = 0;
 572               		.loc 1 348 0
 573 0158 14BA      		out 0x14,__zero_reg__
 574               	/* epilogue start */
 349:setup.c       **** }
 575               		.loc 1 349 0
 576 015a 0F90      		pop __tmp_reg__
 577 015c DF91      		pop r29
 578 015e CF91      		pop r28
 579 0160 0895      		ret
 580               		.cfi_endproc
 581               	.LFE25:
 583               	.global	gba_eeprom_mode
 585               	gba_eeprom_mode:
 586               	.LFB26:
 350:setup.c       **** 
 351:setup.c       **** 
 352:setup.c       **** 
 353:setup.c       **** // ---------- EEPROM ----------
 354:setup.c       **** 
 355:setup.c       **** // Set address/data all high (includes AD0/A23)
 356:setup.c       **** void gba_eeprom_mode (void) {
 587               		.loc 1 356 0
 588               		.cfi_startproc
 589               	/* prologue: function */
 590               	/* frame size = 0 */
 591               	/* stack size = 0 */
 592               	.L__stack_usage = 0
 357:setup.c       **** 	GBA_DDR_ROM_ADDR7_0 = 0xFF;
 593               		.loc 1 357 0
 594 0162 8FEF      		ldi r24,lo8(-1)
 595 0164 87BB      		out 0x17,r24
 358:setup.c       **** 	GBA_DDR_ROM_ADDR15_8 = 0xFF;
 596               		.loc 1 358 0
 597 0166 8ABB      		out 0x1a,r24
 359:setup.c       **** 	GBA_DDR_ROM_ADDR23_16 = 0xFF;
 598               		.loc 1 359 0
 599 0168 84BB      		out 0x14,r24
 360:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = 0x80;
 600               		.loc 1 360 0
 601 016a 90E8      		ldi r25,lo8(-128)
 602 016c 98BB      		out 0x18,r25
 361:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = 0xFF;
 603               		.loc 1 361 0
 604 016e 8BBB      		out 0x1b,r24
 362:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = 0xFF;
 605               		.loc 1 362 0
 606 0170 85BB      		out 0x15,r24
 607 0172 0895      		ret
 608               		.cfi_endproc
 609               	.LFE26:
 611               	.global	gba_eeprom_set_address
 613               	gba_eeprom_set_address:
 614               	.LFB27:
 363:setup.c       **** }
 364:setup.c       **** 
 365:setup.c       **** // Send out EEPROM address serially (WR clock, AD0 data out)
 366:setup.c       **** void gba_eeprom_set_address(uint16_t address, uint8_t eepromSize, uint8_t command) {
 615               		.loc 1 366 0
 616               		.cfi_startproc
 617               	.LVL29:
 618               	/* prologue: function */
 619               	/* frame size = 0 */
 620               	/* stack size = 0 */
 621               	.L__stack_usage = 0
 367:setup.c       **** 	cs_mreqPin_low;
 622               		.loc 1 367 0
 623 0174 9498      		cbi 0x12,4
 624               	.LVL30:
 368:setup.c       **** 	
 369:setup.c       **** 	int8_t x = 0;
 370:setup.c       **** 	if (eepromSize == EEPROM_64KBIT) {
 625               		.loc 1 370 0
 626 0176 6230      		cpi r22,lo8(2)
 627 0178 01F4      		brne .L30
 371:setup.c       **** 		if (command == EEPROM_READ) {
 628               		.loc 1 371 0
 629 017a 4111      		cpse r20,__zero_reg__
 630 017c 00C0      		rjmp .L31
 372:setup.c       **** 			address |= (1<<15) | (1<<14); // Set upper 2 bits high for read request
 631               		.loc 1 372 0
 632 017e 906C      		ori r25,192
 633               	.LVL31:
 634               	.L40:
 373:setup.c       **** 		}
 374:setup.c       **** 		else {
 375:setup.c       **** 			address |= (1<<15); // Set upper 1 bit high for write request
 376:setup.c       **** 		}
 377:setup.c       **** 		x = 15;
 635               		.loc 1 377 0
 636 0180 2FE0      		ldi r18,lo8(15)
 637               	.L33:
 638               	.LVL32:
 378:setup.c       **** 	}
 379:setup.c       **** 	else {
 380:setup.c       **** 		if (command == EEPROM_READ) {
 381:setup.c       **** 			address |= (1<<7) | (1<<6);
 382:setup.c       **** 		}
 383:setup.c       **** 		else {
 384:setup.c       **** 			address |= (1<<7);
 385:setup.c       **** 		}
 386:setup.c       **** 		x = 7;
 387:setup.c       **** 	}
 388:setup.c       **** 	
 389:setup.c       **** 	// Loop through address, 8 or 16 bits depending on EEPROM (includes the 2 bits for request type)
 390:setup.c       **** 	while (x >= 0) {
 391:setup.c       **** 		if (address & (1<<x)) {
 639               		.loc 1 391 0
 640 0182 E1E0      		ldi r30,lo8(1)
 641 0184 F0E0      		ldi r31,0
 642 0186 00C0      		rjmp .L32
 643               	.LVL33:
 644               	.L31:
 375:setup.c       **** 		}
 645               		.loc 1 375 0
 646 0188 9068      		ori r25,128
 647               	.LVL34:
 648 018a 00C0      		rjmp .L40
 649               	.L30:
 380:setup.c       **** 			address |= (1<<7) | (1<<6);
 650               		.loc 1 380 0
 651 018c 4111      		cpse r20,__zero_reg__
 652 018e 00C0      		rjmp .L34
 381:setup.c       **** 		}
 653               		.loc 1 381 0
 654 0190 806C      		ori r24,192
 655               	.LVL35:
 656 0192 00C0      		rjmp .L39
 657               	.L34:
 384:setup.c       **** 		}
 658               		.loc 1 384 0
 659 0194 8068      		ori r24,128
 660               	.LVL36:
 661               	.L39:
 386:setup.c       **** 	}
 662               		.loc 1 386 0
 663 0196 27E0      		ldi r18,lo8(7)
 664 0198 00C0      		rjmp .L33
 665               	.LVL37:
 666               	.L35:
 392:setup.c       **** 			ad0Pin_high;
 393:setup.c       **** 		}
 394:setup.c       **** 		else {
 395:setup.c       **** 			ad0Pin_low;
 667               		.loc 1 395 0
 668 019a C098      		cbi 0x18,0
 669               	.L36:
 396:setup.c       **** 		}
 397:setup.c       **** 		
 398:setup.c       **** 		wrPin_low; // CLK
 670               		.loc 1 398 0
 671 019c 9698      		cbi 0x12,6
 399:setup.c       **** 		asm ("nop");
 672               		.loc 1 399 0
 673               	/* #APP */
 674               	 ;  399 "setup.c" 1
 675 019e 0000      		nop
 676               	 ;  0 "" 2
 400:setup.c       **** 		asm ("nop");
 677               		.loc 1 400 0
 678               	 ;  400 "setup.c" 1
 679 01a0 0000      		nop
 680               	 ;  0 "" 2
 401:setup.c       **** 		wrPin_high; 
 681               		.loc 1 401 0
 682               	/* #NOAPP */
 683 01a2 969A      		sbi 0x12,6
 402:setup.c       **** 		asm ("nop");
 684               		.loc 1 402 0
 685               	/* #APP */
 686               	 ;  402 "setup.c" 1
 687 01a4 0000      		nop
 688               	 ;  0 "" 2
 403:setup.c       **** 		asm ("nop");
 689               		.loc 1 403 0
 690               	 ;  403 "setup.c" 1
 691 01a6 0000      		nop
 692               	 ;  0 "" 2
 693               	/* #NOAPP */
 694 01a8 2150      		subi r18,lo8(-(-1))
 695               	.LVL38:
 390:setup.c       **** 		if (address & (1<<x)) {
 696               		.loc 1 390 0
 697 01aa 27FD      		sbrc r18,7
 698 01ac 00C0      		rjmp .L41
 699               	.L32:
 391:setup.c       **** 			ad0Pin_high;
 700               		.loc 1 391 0
 701 01ae BF01      		movw r22,r30
 702 01b0 022E      		mov r0,r18
 703 01b2 00C0      		rjmp 2f
 704               		1:
 705 01b4 660F      		lsl r22
 706 01b6 771F      		rol r23
 707               		2:
 708 01b8 0A94      		dec r0
 709 01ba 02F4      		brpl 1b
 710 01bc 6823      		and r22,r24
 711 01be 7923      		and r23,r25
 712 01c0 672B      		or r22,r23
 713 01c2 01F0      		breq .L35
 392:setup.c       **** 		}
 714               		.loc 1 392 0
 715 01c4 C09A      		sbi 0x18,0
 716 01c6 00C0      		rjmp .L36
 717               	.L41:
 404:setup.c       **** 		
 405:setup.c       **** 		x--;
 406:setup.c       **** 	}
 407:setup.c       **** 	
 408:setup.c       **** 	// Only send stop bit (0) and WR/CS high if reading, as writing is done in 1 continuous chunk
 409:setup.c       **** 	if (command == EEPROM_READ) {  
 718               		.loc 1 409 0
 719 01c8 4111      		cpse r20,__zero_reg__
 720 01ca 00C0      		rjmp .L29
 410:setup.c       **** 		ad0Pin_low;
 721               		.loc 1 410 0
 722 01cc C098      		cbi 0x18,0
 411:setup.c       **** 		asm ("nop");
 723               		.loc 1 411 0
 724               	/* #APP */
 725               	 ;  411 "setup.c" 1
 726 01ce 0000      		nop
 727               	 ;  0 "" 2
 412:setup.c       **** 		wrPin_low;
 728               		.loc 1 412 0
 729               	/* #NOAPP */
 730 01d0 9698      		cbi 0x12,6
 413:setup.c       **** 		asm ("nop");
 731               		.loc 1 413 0
 732               	/* #APP */
 733               	 ;  413 "setup.c" 1
 734 01d2 0000      		nop
 735               	 ;  0 "" 2
 414:setup.c       **** 		asm ("nop");
 736               		.loc 1 414 0
 737               	 ;  414 "setup.c" 1
 738 01d4 0000      		nop
 739               	 ;  0 "" 2
 415:setup.c       **** 		
 416:setup.c       **** 		wrPin_high;
 740               		.loc 1 416 0
 741               	/* #NOAPP */
 742 01d6 969A      		sbi 0x12,6
 417:setup.c       **** 		cs_mreqPin_high;
 743               		.loc 1 417 0
 744 01d8 949A      		sbi 0x12,4
 745               	.L29:
 746 01da 0895      		ret
 747               		.cfi_endproc
 748               	.LFE27:
 750               	.global	gba_eeprom_read
 752               	gba_eeprom_read:
 753               	.LFB28:
 418:setup.c       **** 	}
 419:setup.c       **** }
 420:setup.c       **** 
 421:setup.c       **** // Read 8 bytes from the EEPROM address, data is valid on rising edge
 422:setup.c       **** void gba_eeprom_read(uint16_t address, uint8_t eepromSize) {
 754               		.loc 1 422 0
 755               		.cfi_startproc
 756               	.LVL39:
 757               	/* prologue: function */
 758               	/* frame size = 0 */
 759               	/* stack size = 0 */
 760               	.L__stack_usage = 0
 423:setup.c       **** 	gba_eeprom_set_address(address, eepromSize, EEPROM_READ);
 761               		.loc 1 423 0
 762 01dc 40E0      		ldi r20,0
 763 01de 00D0      		rcall gba_eeprom_set_address
 764               	.LVL40:
 424:setup.c       **** 	
 425:setup.c       **** 	// Set AD0 pin as input
 426:setup.c       **** 	GBA_PORT_EEPROM_DATA7_0 &= ~(1<<AD0);
 765               		.loc 1 426 0
 766 01e0 C098      		cbi 0x18,0
 427:setup.c       **** 	GBA_DDR_EEPROM_DATA7_0 &= ~(1<<AD0);
 767               		.loc 1 427 0
 768 01e2 B898      		cbi 0x17,0
 428:setup.c       **** 	
 429:setup.c       **** 	cs_mreqPin_low;
 769               		.loc 1 429 0
 770 01e4 9498      		cbi 0x12,4
 771               	.LVL41:
 772 01e6 84E0      		ldi r24,lo8(4)
 773               	.LVL42:
 774               	.L43:
 775               	.LBB45:
 430:setup.c       **** 	
 431:setup.c       **** 	// Ignore first 4 bits
 432:setup.c       **** 	for (int8_t x = 0; x < 4; x++) {
 433:setup.c       **** 		rdPin_low; // CLK
 776               		.loc 1 433 0 discriminator 3
 777 01e8 9598      		cbi 0x12,5
 434:setup.c       **** 		asm ("nop");
 778               		.loc 1 434 0 discriminator 3
 779               	/* #APP */
 780               	 ;  434 "setup.c" 1
 781 01ea 0000      		nop
 782               	 ;  0 "" 2
 435:setup.c       **** 		asm ("nop");
 783               		.loc 1 435 0 discriminator 3
 784               	 ;  435 "setup.c" 1
 785 01ec 0000      		nop
 786               	 ;  0 "" 2
 436:setup.c       **** 		rdPin_high; 
 787               		.loc 1 436 0 discriminator 3
 788               	/* #NOAPP */
 789 01ee 959A      		sbi 0x12,5
 437:setup.c       **** 		asm ("nop");
 790               		.loc 1 437 0 discriminator 3
 791               	/* #APP */
 792               	 ;  437 "setup.c" 1
 793 01f0 0000      		nop
 794               	 ;  0 "" 2
 438:setup.c       **** 		asm ("nop");
 795               		.loc 1 438 0 discriminator 3
 796               	 ;  438 "setup.c" 1
 797 01f2 0000      		nop
 798               	 ;  0 "" 2
 799               	.LVL43:
 800               	/* #NOAPP */
 801 01f4 8150      		subi r24,lo8(-(-1))
 802               	.LVL44:
 432:setup.c       **** 		rdPin_low; // CLK
 803               		.loc 1 432 0 discriminator 3
 804 01f6 01F4      		brne .L43
 432:setup.c       **** 		rdPin_low; // CLK
 805               		.loc 1 432 0 is_stmt 0
 806 01f8 E0E0      		ldi r30,lo8(eepromBuffer)
 807 01fa F0E0      		ldi r31,hi8(eepromBuffer)
 808               	.LBE45:
 809               	.LBB46:
 810               	.LBB47:
 811               	.LBB48:
 439:setup.c       **** 	}
 440:setup.c       **** 	
 441:setup.c       **** 	// Read out 64 bits
 442:setup.c       **** 	for (uint8_t c = 0; c < 8; c++) {
 443:setup.c       **** 		uint8_t data = 0;
 444:setup.c       **** 		for (int8_t x = 7; x >= 0; x--) {
 445:setup.c       **** 			rdPin_low; // CLK
 446:setup.c       **** 			asm ("nop");
 447:setup.c       **** 			asm ("nop");
 448:setup.c       **** 			rdPin_high;
 449:setup.c       **** 			
 450:setup.c       **** 			if (GBA_PIN_EEPROM_DATA7_0 & (1<<AD0)) {
 451:setup.c       **** 				data |= (1<<x);
 812               		.loc 1 451 0 is_stmt 1
 813 01fc 41E0      		ldi r20,lo8(1)
 814 01fe 50E0      		ldi r21,0
 815 0200 38E0      		ldi r19,lo8(8)
 816 0202 3E0F      		add r19,r30
 817               	.LVL45:
 818               	.L44:
 819               	.LBE48:
 820               	.LBE47:
 821               	.LBE46:
 429:setup.c       **** 	
 822               		.loc 1 429 0
 823 0204 87E0      		ldi r24,lo8(7)
 824 0206 90E0      		ldi r25,0
 825 0208 20E0      		ldi r18,0
 826               	.LVL46:
 827               	.L46:
 828               	.LBB51:
 829               	.LBB50:
 830               	.LBB49:
 445:setup.c       **** 			asm ("nop");
 831               		.loc 1 445 0
 832 020a 9598      		cbi 0x12,5
 446:setup.c       **** 			asm ("nop");
 833               		.loc 1 446 0
 834               	/* #APP */
 835               	 ;  446 "setup.c" 1
 836 020c 0000      		nop
 837               	 ;  0 "" 2
 447:setup.c       **** 			rdPin_high;
 838               		.loc 1 447 0
 839               	 ;  447 "setup.c" 1
 840 020e 0000      		nop
 841               	 ;  0 "" 2
 448:setup.c       **** 			
 842               		.loc 1 448 0
 843               	/* #NOAPP */
 844 0210 959A      		sbi 0x12,5
 450:setup.c       **** 				data |= (1<<x);
 845               		.loc 1 450 0
 846 0212 B09B      		sbis 0x16,0
 847 0214 00C0      		rjmp .L45
 848               		.loc 1 451 0
 849 0216 BA01      		movw r22,r20
 850 0218 082E      		mov r0,r24
 851 021a 00C0      		rjmp 2f
 852               		1:
 853 021c 660F      		lsl r22
 854               		2:
 855 021e 0A94      		dec r0
 856 0220 02F4      		brpl 1b
 857 0222 262B      		or r18,r22
 858               	.LVL47:
 859               	.L45:
 860               	.LVL48:
 861 0224 0197      		sbiw r24,1
 862 0226 00F4      		brcc .L46
 863               	.LBE49:
 452:setup.c       **** 			}
 453:setup.c       **** 		}
 454:setup.c       **** 		eepromBuffer[c] = data;
 864               		.loc 1 454 0
 865 0228 2193      		st Z+,r18
 866               	.LVL49:
 867               	.LBE50:
 442:setup.c       **** 		uint8_t data = 0;
 868               		.loc 1 442 0
 869 022a 3E13      		cpse r19,r30
 870 022c 00C0      		rjmp .L44
 871               	.LBE51:
 455:setup.c       **** 	}
 456:setup.c       **** 	
 457:setup.c       **** 	cs_mreqPin_high;
 872               		.loc 1 457 0
 873 022e 949A      		sbi 0x12,4
 458:setup.c       **** 	
 459:setup.c       **** 	// Set AD0 pin as output
 460:setup.c       **** 	GBA_PORT_EEPROM_DATA7_0 |= (1<<AD0);
 874               		.loc 1 460 0
 875 0230 C09A      		sbi 0x18,0
 461:setup.c       **** 	GBA_DDR_EEPROM_DATA7_0 |= (1<<AD0);
 876               		.loc 1 461 0
 877 0232 B89A      		sbi 0x17,0
 878 0234 0895      		ret
 879               		.cfi_endproc
 880               	.LFE28:
 882               	.global	gba_eeprom_write
 884               	gba_eeprom_write:
 885               	.LFB29:
 462:setup.c       **** }
 463:setup.c       **** 
 464:setup.c       **** // Write 8 bytes to the EEPROM address
 465:setup.c       **** void gba_eeprom_write(uint16_t address, uint8_t eepromSize) {
 886               		.loc 1 465 0
 887               		.cfi_startproc
 888               	.LVL50:
 889               	/* prologue: function */
 890               	/* frame size = 0 */
 891               	/* stack size = 0 */
 892               	.L__stack_usage = 0
 466:setup.c       **** 	gba_eeprom_set_address(address, eepromSize, EEPROM_WRITE);
 893               		.loc 1 466 0
 894 0236 41E0      		ldi r20,lo8(1)
 895 0238 00D0      		rcall gba_eeprom_set_address
 896               	.LVL51:
 897 023a E0E0      		ldi r30,lo8(eepromBuffer)
 898 023c F0E0      		ldi r31,hi8(eepromBuffer)
 899 023e 48E0      		ldi r20,lo8(8)
 900 0240 4E0F      		add r20,r30
 901               	.LVL52:
 902               	.L54:
 465:setup.c       **** 	gba_eeprom_set_address(address, eepromSize, EEPROM_WRITE);
 903               		.loc 1 465 0
 904 0242 27E0      		ldi r18,lo8(7)
 905 0244 30E0      		ldi r19,0
 906               	.LVL53:
 907               	.L57:
 908               	.LBB52:
 909               	.LBB53:
 467:setup.c       **** 	
 468:setup.c       **** 	// Write 64 bits
 469:setup.c       **** 	for (uint8_t c = 0; c < 8; c++) {
 470:setup.c       **** 		for (int8_t x = 7; x >= 0; x--) {
 471:setup.c       **** 			if (eepromBuffer[c] & (1<<x)) {
 910               		.loc 1 471 0
 911 0246 8081      		ld r24,Z
 912 0248 90E0      		ldi r25,0
 913 024a 022E      		mov r0,r18
 914 024c 00C0      		rjmp 2f
 915               		1:
 916 024e 9595      		asr r25
 917 0250 8795      		ror r24
 918               		2:
 919 0252 0A94      		dec r0
 920 0254 02F4      		brpl 1b
 921 0256 80FF      		sbrs r24,0
 922 0258 00C0      		rjmp .L55
 472:setup.c       **** 				ad0Pin_high;
 923               		.loc 1 472 0
 924 025a C09A      		sbi 0x18,0
 925 025c 00C0      		rjmp .L56
 926               	.L55:
 473:setup.c       **** 			}
 474:setup.c       **** 			else {
 475:setup.c       **** 				ad0Pin_low;
 927               		.loc 1 475 0
 928 025e C098      		cbi 0x18,0
 929               	.L56:
 476:setup.c       **** 			}
 477:setup.c       **** 			
 478:setup.c       **** 			wrPin_low; // CLK
 930               		.loc 1 478 0 discriminator 2
 931 0260 9698      		cbi 0x12,6
 479:setup.c       **** 			asm ("nop");
 932               		.loc 1 479 0 discriminator 2
 933               	/* #APP */
 934               	 ;  479 "setup.c" 1
 935 0262 0000      		nop
 936               	 ;  0 "" 2
 480:setup.c       **** 			asm ("nop");
 937               		.loc 1 480 0 discriminator 2
 938               	 ;  480 "setup.c" 1
 939 0264 0000      		nop
 940               	 ;  0 "" 2
 481:setup.c       **** 			wrPin_high; 
 941               		.loc 1 481 0 discriminator 2
 942               	/* #NOAPP */
 943 0266 969A      		sbi 0x12,6
 482:setup.c       **** 			asm ("nop");
 944               		.loc 1 482 0 discriminator 2
 945               	/* #APP */
 946               	 ;  482 "setup.c" 1
 947 0268 0000      		nop
 948               	 ;  0 "" 2
 483:setup.c       **** 			asm ("nop");
 949               		.loc 1 483 0 discriminator 2
 950               	 ;  483 "setup.c" 1
 951 026a 0000      		nop
 952               	 ;  0 "" 2
 953               	.LVL54:
 954               	/* #NOAPP */
 955               	.LVL55:
 956 026c 2150      		subi r18,1
 957 026e 3109      		sbc r19,__zero_reg__
 958 0270 00F4      		brcc .L57
 959 0272 3196      		adiw r30,1
 960               	.LVL56:
 961               	.LBE53:
 469:setup.c       **** 		for (int8_t x = 7; x >= 0; x--) {
 962               		.loc 1 469 0 discriminator 2
 963 0274 4E13      		cpse r20,r30
 964 0276 00C0      		rjmp .L54
 965               	.LBE52:
 484:setup.c       **** 		}
 485:setup.c       **** 	}
 486:setup.c       **** 	
 487:setup.c       **** 	// Last bit low
 488:setup.c       **** 	ad0Pin_low;
 966               		.loc 1 488 0
 967 0278 C098      		cbi 0x18,0
 489:setup.c       **** 	wrPin_low; // CLK
 968               		.loc 1 489 0
 969 027a 9698      		cbi 0x12,6
 490:setup.c       **** 	asm ("nop");
 970               		.loc 1 490 0
 971               	/* #APP */
 972               	 ;  490 "setup.c" 1
 973 027c 0000      		nop
 974               	 ;  0 "" 2
 491:setup.c       **** 	asm ("nop");
 975               		.loc 1 491 0
 976               	 ;  491 "setup.c" 1
 977 027e 0000      		nop
 978               	 ;  0 "" 2
 492:setup.c       **** 	wrPin_high; 
 979               		.loc 1 492 0
 980               	/* #NOAPP */
 981 0280 969A      		sbi 0x12,6
 493:setup.c       **** 	asm ("nop");
 982               		.loc 1 493 0
 983               	/* #APP */
 984               	 ;  493 "setup.c" 1
 985 0282 0000      		nop
 986               	 ;  0 "" 2
 494:setup.c       **** 	asm ("nop");
 987               		.loc 1 494 0
 988               	 ;  494 "setup.c" 1
 989 0284 0000      		nop
 990               	 ;  0 "" 2
 495:setup.c       **** 	
 496:setup.c       **** 	cs_mreqPin_high;
 991               		.loc 1 496 0
 992               	/* #NOAPP */
 993 0286 949A      		sbi 0x12,4
 994 0288 0895      		ret
 995               		.cfi_endproc
 996               	.LFE29:
 998               	.global	flash_write_bus_cycle
 1000               	flash_write_bus_cycle:
 1001               	.LFB30:
 497:setup.c       **** }
 498:setup.c       **** 
 499:setup.c       **** 
 500:setup.c       **** 
 501:setup.c       **** // ---------- FLASH ----------
 502:setup.c       **** 
 503:setup.c       **** // Set the address and data for the write byte cycle to the flash
 504:setup.c       **** void flash_write_bus_cycle(uint16_t address, uint8_t data) {
 1002               		.loc 1 504 0
 1003               		.cfi_startproc
 1004               	.LVL57:
 1005 028a CF93      		push r28
 1006               	.LCFI16:
 1007               		.cfi_def_cfa_offset 3
 1008               		.cfi_offset 28, -2
 1009 028c DF93      		push r29
 1010               	.LCFI17:
 1011               		.cfi_def_cfa_offset 4
 1012               		.cfi_offset 29, -3
 1013 028e 1F92      		push __zero_reg__
 1014               	.LCFI18:
 1015               		.cfi_def_cfa_offset 5
 1016 0290 CDB7      		in r28,__SP_L__
 1017 0292 DEB7      		in r29,__SP_H__
 1018               	.LCFI19:
 1019               		.cfi_def_cfa_register 28
 1020               	/* prologue: function */
 1021               	/* frame size = 1 */
 1022               	/* stack size = 3 */
 1023               	.L__stack_usage = 3
 505:setup.c       **** 	GBA_DDR_RAM_DATA7_0 = 0xFF; // Set data pins as outputs
 1024               		.loc 1 505 0
 1025 0294 2FEF      		ldi r18,lo8(-1)
 1026 0296 24BB      		out 0x14,r18
 506:setup.c       **** 	set_16bit_address(address);
 1027               		.loc 1 506 0
 1028 0298 6983      		std Y+1,r22
 1029 029a 00D0      		rcall set_16bit_address
 1030               	.LVL58:
 507:setup.c       **** 	GBA_PORT_RAM_DATA7_0 = data;
 1031               		.loc 1 507 0
 1032 029c 6981      		ldd r22,Y+1
 1033 029e 65BB      		out 0x15,r22
 508:setup.c       **** 	
 509:setup.c       **** 	wrPin_low;
 1034               		.loc 1 509 0
 1035 02a0 9698      		cbi 0x12,6
 510:setup.c       **** 	cs2Pin_low;
 1036               		.loc 1 510 0
 1037 02a2 3A98      		cbi 0x7,2
 511:setup.c       **** 	asm volatile("nop");
 1038               		.loc 1 511 0
 1039               	/* #APP */
 1040               	 ;  511 "setup.c" 1
 1041 02a4 0000      		nop
 1042               	 ;  0 "" 2
 512:setup.c       **** 	wrPin_high;
 1043               		.loc 1 512 0
 1044               	/* #NOAPP */
 1045 02a6 969A      		sbi 0x12,6
 513:setup.c       **** 	cs2Pin_high;
 1046               		.loc 1 513 0
 1047 02a8 3A9A      		sbi 0x7,2
 1048               	/* epilogue start */
 514:setup.c       **** }
 1049               		.loc 1 514 0
 1050 02aa 0F90      		pop __tmp_reg__
 1051 02ac DF91      		pop r29
 1052 02ae CF91      		pop r28
 1053 02b0 0895      		ret
 1054               		.cfi_endproc
 1055               	.LFE30:
 1057               	.global	flash_read_chip_id
 1059               	flash_read_chip_id:
 1060               	.LFB31:
 515:setup.c       **** 
 516:setup.c       **** // Read the flash manufacturer and device ID (Software ID)
 517:setup.c       **** void flash_read_chip_id(void) {
 1061               		.loc 1 517 0
 1062               		.cfi_startproc
 1063 02b2 CF93      		push r28
 1064               	.LCFI20:
 1065               		.cfi_def_cfa_offset 3
 1066               		.cfi_offset 28, -2
 1067 02b4 DF93      		push r29
 1068               	.LCFI21:
 1069               		.cfi_def_cfa_offset 4
 1070               		.cfi_offset 29, -3
 1071               	/* prologue: function */
 1072               	/* frame size = 0 */
 1073               	/* stack size = 2 */
 1074               	.L__stack_usage = 2
 518:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xAA);
 1075               		.loc 1 518 0
 1076 02b6 6AEA      		ldi r22,lo8(-86)
 1077 02b8 85E5      		ldi r24,lo8(85)
 1078 02ba 95E5      		ldi r25,lo8(85)
 1079 02bc 00D0      		rcall flash_write_bus_cycle
 1080               	.LVL59:
 519:setup.c       **** 	flash_write_bus_cycle(0x2AAA, 0x55);
 1081               		.loc 1 519 0
 1082 02be 65E5      		ldi r22,lo8(85)
 1083 02c0 8AEA      		ldi r24,lo8(-86)
 1084 02c2 9AE2      		ldi r25,lo8(42)
 1085 02c4 00D0      		rcall flash_write_bus_cycle
 1086               	.LVL60:
 520:setup.c       **** 	flash_write_bus_cycle(0x5555, 0x90); // Software ID entry
 1087               		.loc 1 520 0
 1088 02c6 60E9      		ldi r22,lo8(-112)
 1089 02c8 85E5      		ldi r24,lo8(85)
 1090 02ca 95E5      		ldi r25,lo8(85)
 1091 02cc 00D0      		rcall flash_write_bus_cycle
 1092               	.LVL61:
 1093               	.LBB54:
 1094               	.LBB55:
 1095               		.file 2 "c:\\winavr-20100110\\avr\\include\\util\\delay.h"
   1:c:\winavr-20100110\avr\include\util\delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:c:\winavr-20100110\avr\include\util\delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:c:\winavr-20100110\avr\include\util\delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:c:\winavr-20100110\avr\include\util\delay.h ****    All rights reserved.
   5:c:\winavr-20100110\avr\include\util\delay.h **** 
   6:c:\winavr-20100110\avr\include\util\delay.h ****    Redistribution and use in source and binary forms, with or without
   7:c:\winavr-20100110\avr\include\util\delay.h ****    modification, are permitted provided that the following conditions are met:
   8:c:\winavr-20100110\avr\include\util\delay.h **** 
   9:c:\winavr-20100110\avr\include\util\delay.h ****    * Redistributions of source code must retain the above copyright
  10:c:\winavr-20100110\avr\include\util\delay.h ****      notice, this list of conditions and the following disclaimer.
  11:c:\winavr-20100110\avr\include\util\delay.h **** 
  12:c:\winavr-20100110\avr\include\util\delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:c:\winavr-20100110\avr\include\util\delay.h ****      notice, this list of conditions and the following disclaimer in
  14:c:\winavr-20100110\avr\include\util\delay.h ****      the documentation and/or other materials provided with the
  15:c:\winavr-20100110\avr\include\util\delay.h ****      distribution.
  16:c:\winavr-20100110\avr\include\util\delay.h **** 
  17:c:\winavr-20100110\avr\include\util\delay.h ****    * Neither the name of the copyright holders nor the names of
  18:c:\winavr-20100110\avr\include\util\delay.h ****      contributors may be used to endorse or promote products derived
  19:c:\winavr-20100110\avr\include\util\delay.h ****      from this software without specific prior written permission.
  20:c:\winavr-20100110\avr\include\util\delay.h **** 
  21:c:\winavr-20100110\avr\include\util\delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:c:\winavr-20100110\avr\include\util\delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:c:\winavr-20100110\avr\include\util\delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:c:\winavr-20100110\avr\include\util\delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:c:\winavr-20100110\avr\include\util\delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:c:\winavr-20100110\avr\include\util\delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:c:\winavr-20100110\avr\include\util\delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:c:\winavr-20100110\avr\include\util\delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:c:\winavr-20100110\avr\include\util\delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:c:\winavr-20100110\avr\include\util\delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:c:\winavr-20100110\avr\include\util\delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:c:\winavr-20100110\avr\include\util\delay.h **** 
  33:c:\winavr-20100110\avr\include\util\delay.h **** /* $Id$ */
  34:c:\winavr-20100110\avr\include\util\delay.h **** 
  35:c:\winavr-20100110\avr\include\util\delay.h **** #ifndef _UTIL_DELAY_H_
  36:c:\winavr-20100110\avr\include\util\delay.h **** #define _UTIL_DELAY_H_ 1
  37:c:\winavr-20100110\avr\include\util\delay.h **** 
  38:c:\winavr-20100110\avr\include\util\delay.h **** #ifndef __DOXYGEN__
  39:c:\winavr-20100110\avr\include\util\delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:c:\winavr-20100110\avr\include\util\delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:c:\winavr-20100110\avr\include\util\delay.h **** #  endif
  42:c:\winavr-20100110\avr\include\util\delay.h **** #endif  /* __DOXYGEN__ */
  43:c:\winavr-20100110\avr\include\util\delay.h **** 
  44:c:\winavr-20100110\avr\include\util\delay.h **** #include <inttypes.h>
  45:c:\winavr-20100110\avr\include\util\delay.h **** #include <util/delay_basic.h>
  46:c:\winavr-20100110\avr\include\util\delay.h **** #include <math.h>
  47:c:\winavr-20100110\avr\include\util\delay.h **** 
  48:c:\winavr-20100110\avr\include\util\delay.h **** /** \file */
  49:c:\winavr-20100110\avr\include\util\delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:c:\winavr-20100110\avr\include\util\delay.h ****     \code
  51:c:\winavr-20100110\avr\include\util\delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:c:\winavr-20100110\avr\include\util\delay.h ****     //#define F_CPU 14.7456E6
  53:c:\winavr-20100110\avr\include\util\delay.h ****     #include <util/delay.h>
  54:c:\winavr-20100110\avr\include\util\delay.h ****     \endcode
  55:c:\winavr-20100110\avr\include\util\delay.h **** 
  56:c:\winavr-20100110\avr\include\util\delay.h ****     \note As an alternative method, it is possible to pass the
  57:c:\winavr-20100110\avr\include\util\delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:c:\winavr-20100110\avr\include\util\delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:c:\winavr-20100110\avr\include\util\delay.h ****     used.
  60:c:\winavr-20100110\avr\include\util\delay.h **** 
  61:c:\winavr-20100110\avr\include\util\delay.h ****     The functions in this header file are wrappers around the basic
  62:c:\winavr-20100110\avr\include\util\delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:c:\winavr-20100110\avr\include\util\delay.h ****     convenience functions where actual time values can be specified
  64:c:\winavr-20100110\avr\include\util\delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:c:\winavr-20100110\avr\include\util\delay.h ****     that compile-time constant expressions will be eliminated by
  66:c:\winavr-20100110\avr\include\util\delay.h ****     compiler optimization so floating-point expressions can be used
  67:c:\winavr-20100110\avr\include\util\delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:c:\winavr-20100110\avr\include\util\delay.h ****     frequency passed by the macro F_CPU.
  69:c:\winavr-20100110\avr\include\util\delay.h **** 
  70:c:\winavr-20100110\avr\include\util\delay.h ****     \note In order for these functions to work as intended, compiler
  71:c:\winavr-20100110\avr\include\util\delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:c:\winavr-20100110\avr\include\util\delay.h ****     <em>must</em> be an expression that is a known constant at
  73:c:\winavr-20100110\avr\include\util\delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:c:\winavr-20100110\avr\include\util\delay.h ****     delay will be much longer (and basically unpredictable), and
  75:c:\winavr-20100110\avr\include\util\delay.h ****     applications that otherwise do not use floating-point calculations
  76:c:\winavr-20100110\avr\include\util\delay.h ****     will experience severe code bloat by the floating-point library
  77:c:\winavr-20100110\avr\include\util\delay.h ****     routines linked into the application.
  78:c:\winavr-20100110\avr\include\util\delay.h **** 
  79:c:\winavr-20100110\avr\include\util\delay.h ****     The functions available allow the specification of microsecond, and
  80:c:\winavr-20100110\avr\include\util\delay.h ****     millisecond delays directly, using the application-supplied macro
  81:c:\winavr-20100110\avr\include\util\delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:c:\winavr-20100110\avr\include\util\delay.h **** 
  83:c:\winavr-20100110\avr\include\util\delay.h **** */
  84:c:\winavr-20100110\avr\include\util\delay.h **** 
  85:c:\winavr-20100110\avr\include\util\delay.h **** #if !defined(__DOXYGEN__)
  86:c:\winavr-20100110\avr\include\util\delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:c:\winavr-20100110\avr\include\util\delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:c:\winavr-20100110\avr\include\util\delay.h **** #endif
  89:c:\winavr-20100110\avr\include\util\delay.h **** 
  90:c:\winavr-20100110\avr\include\util\delay.h **** #ifndef F_CPU
  91:c:\winavr-20100110\avr\include\util\delay.h **** /* prevent compiler error by supplying a default */
  92:c:\winavr-20100110\avr\include\util\delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:c:\winavr-20100110\avr\include\util\delay.h **** /** \ingroup util_delay
  94:c:\winavr-20100110\avr\include\util\delay.h ****     \def F_CPU
  95:c:\winavr-20100110\avr\include\util\delay.h ****     \brief CPU frequency in Hz
  96:c:\winavr-20100110\avr\include\util\delay.h **** 
  97:c:\winavr-20100110\avr\include\util\delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:c:\winavr-20100110\avr\include\util\delay.h ****     the delay macros.  This macro is normally supplied by the
  99:c:\winavr-20100110\avr\include\util\delay.h ****     environment (e.g. from within a project header, or the project's
 100:c:\winavr-20100110\avr\include\util\delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:c:\winavr-20100110\avr\include\util\delay.h ****     fallback if no such user-provided definition could be found.
 102:c:\winavr-20100110\avr\include\util\delay.h **** 
 103:c:\winavr-20100110\avr\include\util\delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:c:\winavr-20100110\avr\include\util\delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:c:\winavr-20100110\avr\include\util\delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:c:\winavr-20100110\avr\include\util\delay.h ****     integer value.
 107:c:\winavr-20100110\avr\include\util\delay.h ****  */
 108:c:\winavr-20100110\avr\include\util\delay.h **** # define F_CPU 1000000UL
 109:c:\winavr-20100110\avr\include\util\delay.h **** #endif
 110:c:\winavr-20100110\avr\include\util\delay.h **** 
 111:c:\winavr-20100110\avr\include\util\delay.h **** #ifndef __OPTIMIZE__
 112:c:\winavr-20100110\avr\include\util\delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:c:\winavr-20100110\avr\include\util\delay.h **** #endif
 114:c:\winavr-20100110\avr\include\util\delay.h **** 
 115:c:\winavr-20100110\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:c:\winavr-20100110\avr\include\util\delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:c:\winavr-20100110\avr\include\util\delay.h ****   __STDC_HOSTED__
 118:c:\winavr-20100110\avr\include\util\delay.h **** #  include <math.h>
 119:c:\winavr-20100110\avr\include\util\delay.h **** #endif
 120:c:\winavr-20100110\avr\include\util\delay.h **** 
 121:c:\winavr-20100110\avr\include\util\delay.h **** /**
 122:c:\winavr-20100110\avr\include\util\delay.h ****    \ingroup util_delay
 123:c:\winavr-20100110\avr\include\util\delay.h **** 
 124:c:\winavr-20100110\avr\include\util\delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:c:\winavr-20100110\avr\include\util\delay.h **** 
 126:c:\winavr-20100110\avr\include\util\delay.h ****    The macro F_CPU is supposed to be defined to a
 127:c:\winavr-20100110\avr\include\util\delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:c:\winavr-20100110\avr\include\util\delay.h **** 
 129:c:\winavr-20100110\avr\include\util\delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:c:\winavr-20100110\avr\include\util\delay.h **** 
 131:c:\winavr-20100110\avr\include\util\delay.h ****    When the user request delay which exceed the maximum possible one,
 132:c:\winavr-20100110\avr\include\util\delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:c:\winavr-20100110\avr\include\util\delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:c:\winavr-20100110\avr\include\util\delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:c:\winavr-20100110\avr\include\util\delay.h ****    user will not be informed about decreased resolution.
 136:c:\winavr-20100110\avr\include\util\delay.h **** 
 137:c:\winavr-20100110\avr\include\util\delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:c:\winavr-20100110\avr\include\util\delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:c:\winavr-20100110\avr\include\util\delay.h ****    values greater than the maximal possible delay, overflows results in
 140:c:\winavr-20100110\avr\include\util\delay.h ****    no delay i.e., 0ms.
 141:c:\winavr-20100110\avr\include\util\delay.h **** 
 142:c:\winavr-20100110\avr\include\util\delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:c:\winavr-20100110\avr\include\util\delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:c:\winavr-20100110\avr\include\util\delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:c:\winavr-20100110\avr\include\util\delay.h ****    microseconds of delay.
 146:c:\winavr-20100110\avr\include\util\delay.h **** 
 147:c:\winavr-20100110\avr\include\util\delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:c:\winavr-20100110\avr\include\util\delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:c:\winavr-20100110\avr\include\util\delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:c:\winavr-20100110\avr\include\util\delay.h ****    respectively.
 151:c:\winavr-20100110\avr\include\util\delay.h **** 
 152:c:\winavr-20100110\avr\include\util\delay.h ****    \note
 153:c:\winavr-20100110\avr\include\util\delay.h **** 
 154:c:\winavr-20100110\avr\include\util\delay.h ****    The implementation of _delay_ms() based on
 155:c:\winavr-20100110\avr\include\util\delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:c:\winavr-20100110\avr\include\util\delay.h ****    implementations.  In order to get functionality backward compatible
 157:c:\winavr-20100110\avr\include\util\delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:c:\winavr-20100110\avr\include\util\delay.h ****    must be defined before including this header file. Also, the
 159:c:\winavr-20100110\avr\include\util\delay.h ****    backward compatible algorithm will be chosen if the code is
 160:c:\winavr-20100110\avr\include\util\delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:c:\winavr-20100110\avr\include\util\delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:c:\winavr-20100110\avr\include\util\delay.h ****    not available to the compiler then.
 163:c:\winavr-20100110\avr\include\util\delay.h **** 
 164:c:\winavr-20100110\avr\include\util\delay.h ****  */
 165:c:\winavr-20100110\avr\include\util\delay.h **** void
 166:c:\winavr-20100110\avr\include\util\delay.h **** _delay_ms(double __ms)
 167:c:\winavr-20100110\avr\include\util\delay.h **** {
 168:c:\winavr-20100110\avr\include\util\delay.h **** 	double __tmp ;
 169:c:\winavr-20100110\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:c:\winavr-20100110\avr\include\util\delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:c:\winavr-20100110\avr\include\util\delay.h ****   __STDC_HOSTED__
 172:c:\winavr-20100110\avr\include\util\delay.h **** 	uint32_t __ticks_dc;
 173:c:\winavr-20100110\avr\include\util\delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 174:c:\winavr-20100110\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 175:c:\winavr-20100110\avr\include\util\delay.h **** 
 176:c:\winavr-20100110\avr\include\util\delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:c:\winavr-20100110\avr\include\util\delay.h **** 
 179:c:\winavr-20100110\avr\include\util\delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:c:\winavr-20100110\avr\include\util\delay.h **** 
 182:c:\winavr-20100110\avr\include\util\delay.h **** 	#else
 183:c:\winavr-20100110\avr\include\util\delay.h **** 		//round up by default
 184:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 185:c:\winavr-20100110\avr\include\util\delay.h **** 	#endif
 186:c:\winavr-20100110\avr\include\util\delay.h **** 
 187:c:\winavr-20100110\avr\include\util\delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 1096               		.loc 2 187 0
 1097 02ce 8FE3      		ldi r24,lo8(-25537)
 1098 02d0 9CE9      		ldi r25,hi8(-25537)
 1099 02d2 0197      	1:	sbiw r24,1
 1100 02d4 01F4      		brne 1b
 1101 02d6 00C0      		rjmp .
 1102 02d8 0000      		nop
 1103               	.LBE55:
 1104               	.LBE54:
 521:setup.c       **** 	_delay_ms(20); // Wait a little (for Atmel chip)
 522:setup.c       **** 	
 523:setup.c       **** 	// Set data as inputs
 524:setup.c       **** 	GBA_PORT_RAM_DATA7_0 = 0;
 1105               		.loc 1 524 0
 1106 02da 15BA      		out 0x15,__zero_reg__
 525:setup.c       **** 	GBA_DDR_RAM_DATA7_0 = 0;
 1107               		.loc 1 525 0
 1108 02dc 14BA      		out 0x14,__zero_reg__
 526:setup.c       **** 	
 527:setup.c       **** 	// Read and transmit the 2 bytes
 528:setup.c       **** 	flashChipIdBuffer[0] = gba_read_ram_8bit_data(0x0000);
 1109               		.loc 1 528 0
 1110 02de 80E0      		ldi r24,0
 1111 02e0 90E0      		ldi r25,0
 1112 02e2 00D0      		rcall gba_read_ram_8bit_data
 1113               	.LVL62:
 1114 02e4 C0E0      		ldi r28,lo8(flashChipIdBuffer)
 1115 02e6 D0E0      		ldi r29,hi8(flashChipIdBuffer)
 1116 02e8 8883      		st Y,r24
 529:setup.c       **** 	flashChipIdBuffer[1] = gba_read_ram_8bit_data(0x0001);
 1117               		.loc 1 529 0
 1118 02ea 81E0      		ldi r24,lo8(1)
 1119 02ec 90E0      		ldi r25,0
 1120 02ee 00D0      		rcall gba_read_ram_8bit_data
 1121               	.LVL63:
 1122 02f0 8983      		std Y+1,r24
 530:setup.c       **** 	
 531:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xAA);
 1123               		.loc 1 531 0
 1124 02f2 6AEA      		ldi r22,lo8(-86)
 1125 02f4 85E5      		ldi r24,lo8(85)
 1126 02f6 95E5      		ldi r25,lo8(85)
 1127 02f8 00D0      		rcall flash_write_bus_cycle
 1128               	.LVL64:
 532:setup.c       **** 	flash_write_bus_cycle(0x2AAA, 0x55);
 1129               		.loc 1 532 0
 1130 02fa 65E5      		ldi r22,lo8(85)
 1131 02fc 8AEA      		ldi r24,lo8(-86)
 1132 02fe 9AE2      		ldi r25,lo8(42)
 1133 0300 00D0      		rcall flash_write_bus_cycle
 1134               	.LVL65:
 533:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xF0); // Software ID exit
 1135               		.loc 1 533 0
 1136 0302 60EF      		ldi r22,lo8(-16)
 1137 0304 85E5      		ldi r24,lo8(85)
 1138 0306 95E5      		ldi r25,lo8(85)
 1139 0308 00D0      		rcall flash_write_bus_cycle
 1140               	.LVL66:
 1141               	.LBB56:
 1142               	.LBB57:
 1143               		.loc 2 187 0
 1144 030a 8FE3      		ldi r24,lo8(-25537)
 1145 030c 9CE9      		ldi r25,hi8(-25537)
 1146 030e 0197      	1:	sbiw r24,1
 1147 0310 01F4      		brne 1b
 1148 0312 00C0      		rjmp .
 1149 0314 0000      		nop
 1150               	/* epilogue start */
 1151               	.LBE57:
 1152               	.LBE56:
 534:setup.c       **** 	_delay_ms(20); // Wait a little (for Atmel chip)
 535:setup.c       **** }
 1153               		.loc 1 535 0
 1154 0316 DF91      		pop r29
 1155 0318 CF91      		pop r28
 1156 031a 0895      		ret
 1157               		.cfi_endproc
 1158               	.LFE31:
 1160               	.global	flash_switch_bank
 1162               	flash_switch_bank:
 1163               	.LFB32:
 536:setup.c       **** 
 537:setup.c       **** // Switch banks on the Flash
 538:setup.c       **** void flash_switch_bank(uint8_t bank) {
 1164               		.loc 1 538 0
 1165               		.cfi_startproc
 1166               	.LVL67:
 1167 031c CF93      		push r28
 1168               	.LCFI22:
 1169               		.cfi_def_cfa_offset 3
 1170               		.cfi_offset 28, -2
 1171               	/* prologue: function */
 1172               	/* frame size = 0 */
 1173               	/* stack size = 1 */
 1174               	.L__stack_usage = 1
 1175 031e C82F      		mov r28,r24
 539:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xAA);
 1176               		.loc 1 539 0
 1177 0320 6AEA      		ldi r22,lo8(-86)
 1178 0322 85E5      		ldi r24,lo8(85)
 1179 0324 95E5      		ldi r25,lo8(85)
 1180               	.LVL68:
 1181 0326 00D0      		rcall flash_write_bus_cycle
 1182               	.LVL69:
 540:setup.c       **** 	flash_write_bus_cycle(0x2AAA, 0x55);
 1183               		.loc 1 540 0
 1184 0328 65E5      		ldi r22,lo8(85)
 1185 032a 8AEA      		ldi r24,lo8(-86)
 1186 032c 9AE2      		ldi r25,lo8(42)
 1187 032e 00D0      		rcall flash_write_bus_cycle
 1188               	.LVL70:
 541:setup.c       **** 	
 542:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xB0);
 1189               		.loc 1 542 0
 1190 0330 60EB      		ldi r22,lo8(-80)
 1191 0332 85E5      		ldi r24,lo8(85)
 1192 0334 95E5      		ldi r25,lo8(85)
 1193 0336 00D0      		rcall flash_write_bus_cycle
 1194               	.LVL71:
 543:setup.c       **** 	flash_write_bus_cycle(0x0000, bank);
 1195               		.loc 1 543 0
 1196 0338 6C2F      		mov r22,r28
 1197 033a 80E0      		ldi r24,0
 1198 033c 90E0      		ldi r25,0
 1199               	/* epilogue start */
 544:setup.c       **** }
 1200               		.loc 1 544 0
 1201 033e CF91      		pop r28
 1202               	.LVL72:
 543:setup.c       **** 	flash_write_bus_cycle(0x0000, bank);
 1203               		.loc 1 543 0
 1204 0340 00C0      		rjmp flash_write_bus_cycle
 1205               	.LVL73:
 1206               		.cfi_endproc
 1207               	.LFE32:
 1209               	.global	flash_erase_4k_sector
 1211               	flash_erase_4k_sector:
 1212               	.LFB33:
 545:setup.c       **** 
 546:setup.c       **** // Erase 4K sector on Flash, expects first sector to start at 0, left shifts by 12 (A15-A12 to sele
 547:setup.c       **** // Takes 25ms after last command to erase sector
 548:setup.c       **** void flash_erase_4k_sector(uint8_t sector) {
 1213               		.loc 1 548 0
 1214               		.cfi_startproc
 1215               	.LVL74:
 1216 0342 CF93      		push r28
 1217               	.LCFI23:
 1218               		.cfi_def_cfa_offset 3
 1219               		.cfi_offset 28, -2
 1220               	/* prologue: function */
 1221               	/* frame size = 0 */
 1222               	/* stack size = 1 */
 1223               	.L__stack_usage = 1
 1224 0344 C82F      		mov r28,r24
 549:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xAA);
 1225               		.loc 1 549 0
 1226 0346 6AEA      		ldi r22,lo8(-86)
 1227 0348 85E5      		ldi r24,lo8(85)
 1228 034a 95E5      		ldi r25,lo8(85)
 1229               	.LVL75:
 1230 034c 00D0      		rcall flash_write_bus_cycle
 1231               	.LVL76:
 550:setup.c       **** 	flash_write_bus_cycle(0x2AAA, 0x55);
 1232               		.loc 1 550 0
 1233 034e 65E5      		ldi r22,lo8(85)
 1234 0350 8AEA      		ldi r24,lo8(-86)
 1235 0352 9AE2      		ldi r25,lo8(42)
 1236 0354 00D0      		rcall flash_write_bus_cycle
 1237               	.LVL77:
 551:setup.c       **** 	flash_write_bus_cycle(0x5555, 0x80);
 1238               		.loc 1 551 0
 1239 0356 60E8      		ldi r22,lo8(-128)
 1240 0358 85E5      		ldi r24,lo8(85)
 1241 035a 95E5      		ldi r25,lo8(85)
 1242 035c 00D0      		rcall flash_write_bus_cycle
 1243               	.LVL78:
 552:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xAA);
 1244               		.loc 1 552 0
 1245 035e 6AEA      		ldi r22,lo8(-86)
 1246 0360 85E5      		ldi r24,lo8(85)
 1247 0362 95E5      		ldi r25,lo8(85)
 1248 0364 00D0      		rcall flash_write_bus_cycle
 1249               	.LVL79:
 553:setup.c       **** 	flash_write_bus_cycle(0x2AAA, 0x55);
 1250               		.loc 1 553 0
 1251 0366 65E5      		ldi r22,lo8(85)
 1252 0368 8AEA      		ldi r24,lo8(-86)
 1253 036a 9AE2      		ldi r25,lo8(42)
 1254 036c 00D0      		rcall flash_write_bus_cycle
 1255               	.LVL80:
 554:setup.c       **** 	
 555:setup.c       **** 	flash_write_bus_cycle((uint16_t) sector << 12, 0x30);
 1256               		.loc 1 555 0
 1257 036e 60E3      		ldi r22,lo8(48)
 1258 0370 80E0      		ldi r24,0
 1259 0372 9C2F      		mov r25,r28
 1260 0374 9295      		swap r25
 1261 0376 907F      		andi r25,lo8(-16)
 1262 0378 00D0      		rcall flash_write_bus_cycle
 1263               	.LVL81:
 1264               	.LBB58:
 1265               	.LBB59:
 1266               		.loc 2 187 0
 1267 037a 8FE4      		ldi r24,lo8(-15537)
 1268 037c 93EC      		ldi r25,hi8(-15537)
 1269 037e 0197      	1:	sbiw r24,1
 1270 0380 01F4      		brne 1b
 1271 0382 00C0      		rjmp .
 1272 0384 0000      		nop
 1273               	/* epilogue start */
 1274               	.LBE59:
 1275               	.LBE58:
 556:setup.c       **** 	_delay_ms(25); // Wait 25ms for sector erase
 557:setup.c       **** }
 1276               		.loc 1 557 0
 1277 0386 CF91      		pop r28
 1278               	.LVL82:
 1279 0388 0895      		ret
 1280               		.cfi_endproc
 1281               	.LFE33:
 1283               	.global	flash_write_byte
 1285               	flash_write_byte:
 1286               	.LFB34:
 558:setup.c       **** 
 559:setup.c       **** // Write a single byte to the Flash address
 560:setup.c       **** // Takes 20us to program Flash
 561:setup.c       **** void flash_write_byte(uint16_t address, uint8_t data) {
 1287               		.loc 1 561 0
 1288               		.cfi_startproc
 1289               	.LVL83:
 1290 038a 1F93      		push r17
 1291               	.LCFI24:
 1292               		.cfi_def_cfa_offset 3
 1293               		.cfi_offset 17, -2
 1294 038c CF93      		push r28
 1295               	.LCFI25:
 1296               		.cfi_def_cfa_offset 4
 1297               		.cfi_offset 28, -3
 1298 038e DF93      		push r29
 1299               	.LCFI26:
 1300               		.cfi_def_cfa_offset 5
 1301               		.cfi_offset 29, -4
 1302               	/* prologue: function */
 1303               	/* frame size = 0 */
 1304               	/* stack size = 3 */
 1305               	.L__stack_usage = 3
 1306 0390 EC01      		movw r28,r24
 1307 0392 162F      		mov r17,r22
 562:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xAA);
 1308               		.loc 1 562 0
 1309 0394 6AEA      		ldi r22,lo8(-86)
 1310               	.LVL84:
 1311 0396 85E5      		ldi r24,lo8(85)
 1312 0398 95E5      		ldi r25,lo8(85)
 1313               	.LVL85:
 1314 039a 00D0      		rcall flash_write_bus_cycle
 1315               	.LVL86:
 563:setup.c       **** 	flash_write_bus_cycle(0x2AAA, 0x55);
 1316               		.loc 1 563 0
 1317 039c 65E5      		ldi r22,lo8(85)
 1318 039e 8AEA      		ldi r24,lo8(-86)
 1319 03a0 9AE2      		ldi r25,lo8(42)
 1320 03a2 00D0      		rcall flash_write_bus_cycle
 1321               	.LVL87:
 564:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xA0);
 1322               		.loc 1 564 0
 1323 03a4 60EA      		ldi r22,lo8(-96)
 1324 03a6 85E5      		ldi r24,lo8(85)
 1325 03a8 95E5      		ldi r25,lo8(85)
 1326 03aa 00D0      		rcall flash_write_bus_cycle
 1327               	.LVL88:
 565:setup.c       **** 	
 566:setup.c       **** 	flash_write_bus_cycle(address, data);
 1328               		.loc 1 566 0
 1329 03ac 612F      		mov r22,r17
 1330 03ae CE01      		movw r24,r28
 1331 03b0 00D0      		rcall flash_write_bus_cycle
 1332               	.LVL89:
 1333               	.LBB60:
 1334               	.LBB61:
 188:c:\winavr-20100110\avr\include\util\delay.h **** 
 189:c:\winavr-20100110\avr\include\util\delay.h **** #else
 190:c:\winavr-20100110\avr\include\util\delay.h **** 	uint16_t __ticks;
 191:c:\winavr-20100110\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 4e3) * __ms;
 192:c:\winavr-20100110\avr\include\util\delay.h **** 	if (__tmp < 1.0)
 193:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks = 1;
 194:c:\winavr-20100110\avr\include\util\delay.h **** 	else if (__tmp > 65535)
 195:c:\winavr-20100110\avr\include\util\delay.h **** 	{
 196:c:\winavr-20100110\avr\include\util\delay.h **** 		//	__ticks = requested delay in 1/10 ms
 197:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 198:c:\winavr-20100110\avr\include\util\delay.h **** 		while(__ticks)
 199:c:\winavr-20100110\avr\include\util\delay.h **** 		{
 200:c:\winavr-20100110\avr\include\util\delay.h **** 			// wait 1/10 ms
 201:c:\winavr-20100110\avr\include\util\delay.h **** 			_delay_loop_2(((F_CPU) / 4e3) / 10);
 202:c:\winavr-20100110\avr\include\util\delay.h **** 			__ticks --;
 203:c:\winavr-20100110\avr\include\util\delay.h **** 		}
 204:c:\winavr-20100110\avr\include\util\delay.h **** 		return;
 205:c:\winavr-20100110\avr\include\util\delay.h **** 	}
 206:c:\winavr-20100110\avr\include\util\delay.h **** 	else
 207:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks = (uint16_t)__tmp;
 208:c:\winavr-20100110\avr\include\util\delay.h **** 	_delay_loop_2(__ticks);
 209:c:\winavr-20100110\avr\include\util\delay.h **** #endif
 210:c:\winavr-20100110\avr\include\util\delay.h **** }
 211:c:\winavr-20100110\avr\include\util\delay.h **** 
 212:c:\winavr-20100110\avr\include\util\delay.h **** /**
 213:c:\winavr-20100110\avr\include\util\delay.h ****    \ingroup util_delay
 214:c:\winavr-20100110\avr\include\util\delay.h **** 
 215:c:\winavr-20100110\avr\include\util\delay.h ****    Perform a delay of \c __us microseconds, using _delay_loop_1().
 216:c:\winavr-20100110\avr\include\util\delay.h **** 
 217:c:\winavr-20100110\avr\include\util\delay.h ****    The macro F_CPU is supposed to be defined to a
 218:c:\winavr-20100110\avr\include\util\delay.h ****    constant defining the CPU clock frequency (in Hertz).
 219:c:\winavr-20100110\avr\include\util\delay.h **** 
 220:c:\winavr-20100110\avr\include\util\delay.h ****    The maximal possible delay is 768 us / F_CPU in MHz.
 221:c:\winavr-20100110\avr\include\util\delay.h **** 
 222:c:\winavr-20100110\avr\include\util\delay.h ****    If the user requests a delay greater than the maximal possible one,
 223:c:\winavr-20100110\avr\include\util\delay.h ****    _delay_us() will automatically call _delay_ms() instead.  The user
 224:c:\winavr-20100110\avr\include\util\delay.h ****    will not be informed about this case.
 225:c:\winavr-20100110\avr\include\util\delay.h **** 
 226:c:\winavr-20100110\avr\include\util\delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 227:c:\winavr-20100110\avr\include\util\delay.h ****    support, maximal possible delay is 4294967.295 us/ F_CPU in MHz. For
 228:c:\winavr-20100110\avr\include\util\delay.h ****    values greater than the maximal possible delay, overflow results in
 229:c:\winavr-20100110\avr\include\util\delay.h ****    no delay i.e., 0us.
 230:c:\winavr-20100110\avr\include\util\delay.h **** 
 231:c:\winavr-20100110\avr\include\util\delay.h ****    Conversion of \c __us into clock cycles may not always result in
 232:c:\winavr-20100110\avr\include\util\delay.h ****    integer.  By default, the clock cycles rounded up to next
 233:c:\winavr-20100110\avr\include\util\delay.h ****    integer. This ensures that the user gets at least \c __us
 234:c:\winavr-20100110\avr\include\util\delay.h ****    microseconds of delay.
 235:c:\winavr-20100110\avr\include\util\delay.h **** 
 236:c:\winavr-20100110\avr\include\util\delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 237:c:\winavr-20100110\avr\include\util\delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 238:c:\winavr-20100110\avr\include\util\delay.h ****    algorithm can be made to round down, or round to closest integer,
 239:c:\winavr-20100110\avr\include\util\delay.h ****    respectively.
 240:c:\winavr-20100110\avr\include\util\delay.h **** 
 241:c:\winavr-20100110\avr\include\util\delay.h ****    \note
 242:c:\winavr-20100110\avr\include\util\delay.h **** 
 243:c:\winavr-20100110\avr\include\util\delay.h ****    The implementation of _delay_ms() based on
 244:c:\winavr-20100110\avr\include\util\delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 245:c:\winavr-20100110\avr\include\util\delay.h ****    implementations.  In order to get functionality backward compatible
 246:c:\winavr-20100110\avr\include\util\delay.h ****    with previous versions, the macro \c __DELAY_BACKWARD_COMPATIBLE__
 247:c:\winavr-20100110\avr\include\util\delay.h ****    must be defined before including this header file. Also, the
 248:c:\winavr-20100110\avr\include\util\delay.h ****    backward compatible algorithm will be chosen if the code is
 249:c:\winavr-20100110\avr\include\util\delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 250:c:\winavr-20100110\avr\include\util\delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 251:c:\winavr-20100110\avr\include\util\delay.h ****    not available to the compiler then.
 252:c:\winavr-20100110\avr\include\util\delay.h **** 
 253:c:\winavr-20100110\avr\include\util\delay.h ****  */
 254:c:\winavr-20100110\avr\include\util\delay.h **** void
 255:c:\winavr-20100110\avr\include\util\delay.h **** _delay_us(double __us)
 256:c:\winavr-20100110\avr\include\util\delay.h **** {
 257:c:\winavr-20100110\avr\include\util\delay.h **** 	double __tmp ;
 258:c:\winavr-20100110\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 259:c:\winavr-20100110\avr\include\util\delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 260:c:\winavr-20100110\avr\include\util\delay.h ****   __STDC_HOSTED__
 261:c:\winavr-20100110\avr\include\util\delay.h **** 	uint32_t __ticks_dc;
 262:c:\winavr-20100110\avr\include\util\delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 263:c:\winavr-20100110\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 264:c:\winavr-20100110\avr\include\util\delay.h **** 
 265:c:\winavr-20100110\avr\include\util\delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 266:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 267:c:\winavr-20100110\avr\include\util\delay.h **** 
 268:c:\winavr-20100110\avr\include\util\delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 269:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 270:c:\winavr-20100110\avr\include\util\delay.h **** 
 271:c:\winavr-20100110\avr\include\util\delay.h **** 	#else
 272:c:\winavr-20100110\avr\include\util\delay.h **** 		//round up by default
 273:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 274:c:\winavr-20100110\avr\include\util\delay.h **** 	#endif
 275:c:\winavr-20100110\avr\include\util\delay.h **** 
 276:c:\winavr-20100110\avr\include\util\delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 1335               		.loc 2 276 0
 1336 03b2 85E3      		ldi r24,lo8(53)
 1337 03b4 8A95      	1:	dec r24
 1338 03b6 01F4      		brne 1b
 1339 03b8 0000      		nop
 1340               	/* epilogue start */
 1341               	.LBE61:
 1342               	.LBE60:
 567:setup.c       **** 	_delay_us(20); // Wait byte program time
 568:setup.c       **** }
 1343               		.loc 1 568 0
 1344 03ba DF91      		pop r29
 1345 03bc CF91      		pop r28
 1346               	.LVL90:
 1347 03be 1F91      		pop r17
 1348               	.LVL91:
 1349 03c0 0895      		ret
 1350               		.cfi_endproc
 1351               	.LFE34:
 1353               	.global	flash_write_sector
 1355               	flash_write_sector:
 1356               	.LFB35:
 569:setup.c       **** 
 570:setup.c       **** // Write a sector (128 bytes) to the Atmel flash
 571:setup.c       **** // Takes 20ms for write cycle
 572:setup.c       **** void flash_write_sector(uint16_t sector) {
 1357               		.loc 1 572 0
 1358               		.cfi_startproc
 1359               	.LVL92:
 1360 03c2 EF92      		push r14
 1361               	.LCFI27:
 1362               		.cfi_def_cfa_offset 3
 1363               		.cfi_offset 14, -2
 1364 03c4 FF92      		push r15
 1365               	.LCFI28:
 1366               		.cfi_def_cfa_offset 4
 1367               		.cfi_offset 15, -3
 1368 03c6 0F93      		push r16
 1369               	.LCFI29:
 1370               		.cfi_def_cfa_offset 5
 1371               		.cfi_offset 16, -4
 1372 03c8 1F93      		push r17
 1373               	.LCFI30:
 1374               		.cfi_def_cfa_offset 6
 1375               		.cfi_offset 17, -5
 1376 03ca CF93      		push r28
 1377               	.LCFI31:
 1378               		.cfi_def_cfa_offset 7
 1379               		.cfi_offset 28, -6
 1380 03cc DF93      		push r29
 1381               	.LCFI32:
 1382               		.cfi_def_cfa_offset 8
 1383               		.cfi_offset 29, -7
 1384               	/* prologue: function */
 1385               	/* frame size = 0 */
 1386               	/* stack size = 6 */
 1387               	.L__stack_usage = 6
 1388 03ce 8C01      		movw r16,r24
 573:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xAA);
 1389               		.loc 1 573 0
 1390 03d0 6AEA      		ldi r22,lo8(-86)
 1391 03d2 85E5      		ldi r24,lo8(85)
 1392 03d4 95E5      		ldi r25,lo8(85)
 1393               	.LVL93:
 1394 03d6 00D0      		rcall flash_write_bus_cycle
 1395               	.LVL94:
 574:setup.c       **** 	flash_write_bus_cycle(0x2AAA, 0x55);
 1396               		.loc 1 574 0
 1397 03d8 65E5      		ldi r22,lo8(85)
 1398 03da 8AEA      		ldi r24,lo8(-86)
 1399 03dc 9AE2      		ldi r25,lo8(42)
 1400 03de 00D0      		rcall flash_write_bus_cycle
 1401               	.LVL95:
 575:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xA0);
 1402               		.loc 1 575 0
 1403 03e0 60EA      		ldi r22,lo8(-96)
 1404 03e2 85E5      		ldi r24,lo8(85)
 1405 03e4 95E5      		ldi r25,lo8(85)
 1406 03e6 00D0      		rcall flash_write_bus_cycle
 1407               	.LVL96:
 1408               	.LBB62:
 576:setup.c       **** 	
 577:setup.c       **** 	// Write the bytes (A0-A6 byte address, A7-A15 sector address)
 578:setup.c       **** 	for (uint8_t x = 0; x < 128; x++) {
 579:setup.c       **** 		flash_write_bus_cycle((uint16_t) (sector << 7) | (uint16_t) x, receivedBuffer[x]);
 1409               		.loc 1 579 0
 1410 03e8 1695      		lsr r17
 1411 03ea 102F      		mov r17,r16
 1412 03ec 0027      		clr r16
 1413 03ee 1795      		ror r17
 1414 03f0 0795      		ror r16
 1415               	.LVL97:
 1416 03f2 90E0      		ldi r25,lo8(receivedBuffer)
 1417 03f4 E92E      		mov r14,r25
 1418 03f6 90E0      		ldi r25,hi8(receivedBuffer)
 1419 03f8 F92E      		mov r15,r25
 1420 03fa C0E0      		ldi r28,0
 1421 03fc D0E0      		ldi r29,0
 1422               	.LVL98:
 1423               	.L66:
 1424               		.loc 1 579 0 is_stmt 0 discriminator 3
 1425 03fe F701      		movw r30,r14
 1426 0400 6191      		ld r22,Z+
 1427 0402 7F01      		movw r14,r30
 1428 0404 CE01      		movw r24,r28
 1429 0406 802B      		or r24,r16
 1430 0408 912B      		or r25,r17
 1431 040a 00D0      		rcall flash_write_bus_cycle
 1432               	.LVL99:
 1433 040c 2196      		adiw r28,1
 1434               	.LVL100:
 578:setup.c       **** 		flash_write_bus_cycle((uint16_t) (sector << 7) | (uint16_t) x, receivedBuffer[x]);
 1435               		.loc 1 578 0 is_stmt 1 discriminator 3
 1436 040e C038      		cpi r28,-128
 1437 0410 D105      		cpc r29,__zero_reg__
 1438 0412 01F4      		brne .L66
 1439               	.LVL101:
 1440               	.LBE62:
 1441               	.LBB63:
 1442               	.LBB64:
 187:c:\winavr-20100110\avr\include\util\delay.h **** 
 1443               		.loc 2 187 0
 1444 0414 8FE3      		ldi r24,lo8(-25537)
 1445 0416 9CE9      		ldi r25,hi8(-25537)
 1446 0418 0197      	1:	sbiw r24,1
 1447 041a 01F4      		brne 1b
 1448 041c 00C0      		rjmp .
 1449 041e 0000      		nop
 1450               	/* epilogue start */
 1451               	.LBE64:
 1452               	.LBE63:
 580:setup.c       **** 	}
 581:setup.c       **** 	_delay_ms(20); // Wait sector program time
 582:setup.c       **** }
 1453               		.loc 1 582 0
 1454 0420 DF91      		pop r29
 1455 0422 CF91      		pop r28
 1456               	.LVL102:
 1457 0424 1F91      		pop r17
 1458 0426 0F91      		pop r16
 1459 0428 FF90      		pop r15
 1460 042a EF90      		pop r14
 1461 042c 0895      		ret
 1462               		.cfi_endproc
 1463               	.LFE35:
 1465               	.global	audio_flash_write_bus_cycle
 1467               	audio_flash_write_bus_cycle:
 1468               	.LFB36:
 583:setup.c       **** 
 584:setup.c       **** 
 585:setup.c       **** 
 586:setup.c       **** // ---------- FLASH CARTS ----------
 587:setup.c       **** 
 588:setup.c       **** // Set the address and data for the write byte cycle to the flash (pulsing audio pin)
 589:setup.c       **** void audio_flash_write_bus_cycle(uint16_t address, uint8_t data) {
 1469               		.loc 1 589 0
 1470               		.cfi_startproc
 1471               	.LVL103:
 1472 042e CF93      		push r28
 1473               	.LCFI33:
 1474               		.cfi_def_cfa_offset 3
 1475               		.cfi_offset 28, -2
 1476 0430 DF93      		push r29
 1477               	.LCFI34:
 1478               		.cfi_def_cfa_offset 4
 1479               		.cfi_offset 29, -3
 1480 0432 1F92      		push __zero_reg__
 1481               	.LCFI35:
 1482               		.cfi_def_cfa_offset 5
 1483 0434 CDB7      		in r28,__SP_L__
 1484 0436 DEB7      		in r29,__SP_H__
 1485               	.LCFI36:
 1486               		.cfi_def_cfa_register 28
 1487               	/* prologue: function */
 1488               	/* frame size = 1 */
 1489               	/* stack size = 3 */
 1490               	.L__stack_usage = 3
 590:setup.c       **** 	GBA_DDR_RAM_DATA7_0 = 0xFF; // Set data pins as outputs
 1491               		.loc 1 590 0
 1492 0438 2FEF      		ldi r18,lo8(-1)
 1493 043a 24BB      		out 0x14,r18
 591:setup.c       **** 	set_16bit_address(address);
 1494               		.loc 1 591 0
 1495 043c 6983      		std Y+1,r22
 1496 043e 00D0      		rcall set_16bit_address
 1497               	.LVL104:
 592:setup.c       **** 	GBA_PORT_RAM_DATA7_0 = data;
 1498               		.loc 1 592 0
 1499 0440 6981      		ldd r22,Y+1
 1500 0442 65BB      		out 0x15,r22
 593:setup.c       **** 	
 594:setup.c       **** 	audioPin_low; // WE low
 1501               		.loc 1 594 0
 1502 0444 3998      		cbi 0x7,1
 595:setup.c       **** 	asm volatile("nop");
 1503               		.loc 1 595 0
 1504               	/* #APP */
 1505               	 ;  595 "setup.c" 1
 1506 0446 0000      		nop
 1507               	 ;  0 "" 2
 596:setup.c       **** 	asm volatile("nop");
 1508               		.loc 1 596 0
 1509               	 ;  596 "setup.c" 1
 1510 0448 0000      		nop
 1511               	 ;  0 "" 2
 597:setup.c       **** 	asm volatile("nop");
 1512               		.loc 1 597 0
 1513               	 ;  597 "setup.c" 1
 1514 044a 0000      		nop
 1515               	 ;  0 "" 2
 598:setup.c       **** 	audioPin_high; // WE high
 1516               		.loc 1 598 0
 1517               	/* #NOAPP */
 1518 044c 399A      		sbi 0x7,1
 1519               	/* epilogue start */
 599:setup.c       **** }
 1520               		.loc 1 599 0
 1521 044e 0F90      		pop __tmp_reg__
 1522 0450 DF91      		pop r29
 1523 0452 CF91      		pop r28
 1524 0454 0895      		ret
 1525               		.cfi_endproc
 1526               	.LFE36:
 1528               	.global	audio_flash_write_byte
 1530               	audio_flash_write_byte:
 1531               	.LFB37:
 600:setup.c       **** 
 601:setup.c       **** // Write a single byte to the Flash address. Takes 20us to program Flash.
 602:setup.c       **** void audio_flash_write_byte(uint16_t address, uint8_t data) {
 1532               		.loc 1 602 0
 1533               		.cfi_startproc
 1534               	.LVL105:
 1535 0456 1F93      		push r17
 1536               	.LCFI37:
 1537               		.cfi_def_cfa_offset 3
 1538               		.cfi_offset 17, -2
 1539 0458 CF93      		push r28
 1540               	.LCFI38:
 1541               		.cfi_def_cfa_offset 4
 1542               		.cfi_offset 28, -3
 1543 045a DF93      		push r29
 1544               	.LCFI39:
 1545               		.cfi_def_cfa_offset 5
 1546               		.cfi_offset 29, -4
 1547               	/* prologue: function */
 1548               	/* frame size = 0 */
 1549               	/* stack size = 3 */
 1550               	.L__stack_usage = 3
 1551 045c EC01      		movw r28,r24
 1552 045e 162F      		mov r17,r22
 603:setup.c       **** 	audio_flash_write_bus_cycle(0x555, 0xAA);
 1553               		.loc 1 603 0
 1554 0460 6AEA      		ldi r22,lo8(-86)
 1555               	.LVL106:
 1556 0462 85E5      		ldi r24,lo8(85)
 1557 0464 95E0      		ldi r25,lo8(5)
 1558               	.LVL107:
 1559 0466 00D0      		rcall audio_flash_write_bus_cycle
 1560               	.LVL108:
 604:setup.c       **** 	audio_flash_write_bus_cycle(0x2AA, 0x55);
 1561               		.loc 1 604 0
 1562 0468 65E5      		ldi r22,lo8(85)
 1563 046a 8AEA      		ldi r24,lo8(-86)
 1564 046c 92E0      		ldi r25,lo8(2)
 1565 046e 00D0      		rcall audio_flash_write_bus_cycle
 1566               	.LVL109:
 605:setup.c       **** 	audio_flash_write_bus_cycle(0x555, 0xA0);
 1567               		.loc 1 605 0
 1568 0470 60EA      		ldi r22,lo8(-96)
 1569 0472 85E5      		ldi r24,lo8(85)
 1570 0474 95E0      		ldi r25,lo8(5)
 1571 0476 00D0      		rcall audio_flash_write_bus_cycle
 1572               	.LVL110:
 606:setup.c       **** 	audio_flash_write_bus_cycle(address, data);
 1573               		.loc 1 606 0
 1574 0478 612F      		mov r22,r17
 1575 047a CE01      		movw r24,r28
 1576 047c 00D0      		rcall audio_flash_write_bus_cycle
 1577               	.LVL111:
 1578               	.LBB65:
 1579               	.LBB66:
 1580               		.loc 2 276 0
 1581 047e 85E3      		ldi r24,lo8(53)
 1582 0480 8A95      	1:	dec r24
 1583 0482 01F4      		brne 1b
 1584 0484 0000      		nop
 1585               	/* epilogue start */
 1586               	.LBE66:
 1587               	.LBE65:
 607:setup.c       **** 	_delay_us(20); // Wait byte program time
 608:setup.c       **** }
 1588               		.loc 1 608 0
 1589 0486 DF91      		pop r29
 1590 0488 CF91      		pop r28
 1591               	.LVL112:
 1592 048a 1F91      		pop r17
 1593               	.LVL113:
 1594 048c 0895      		ret
 1595               		.cfi_endproc
 1596               	.LFE37:
 1598               	.global	setup
 1600               	setup:
 1601               	.LFB38:
 609:setup.c       **** 
 610:setup.c       **** 
 611:setup.c       **** // Setup
 612:setup.c       **** void setup(void) {
 1602               		.loc 1 612 0
 1603               		.cfi_startproc
 1604               	/* prologue: function */
 1605               	/* frame size = 0 */
 1606               	/* stack size = 0 */
 1607               	.L__stack_usage = 0
 613:setup.c       **** 	// Turn off watchdog
 614:setup.c       **** 	MCUCSR &= ~(1<<WDRF);
 1608               		.loc 1 614 0
 1609 048e 84B7      		in r24,0x34
 1610 0490 877F      		andi r24,lo8(-9)
 1611 0492 84BF      		out 0x34,r24
 615:setup.c       **** 	WDTCR = (1<<WDCE) | (1<<WDE);
 1612               		.loc 1 615 0
 1613 0494 88E1      		ldi r24,lo8(24)
 1614 0496 81BD      		out 0x21,r24
 616:setup.c       **** 	WDTCR = 0;
 1615               		.loc 1 616 0
 1616 0498 11BC      		out 0x21,__zero_reg__
 617:setup.c       **** 	
 618:setup.c       **** 	// Reset common lines
 619:setup.c       **** 	rd_wr_csmreq_cs2_reset();
 1617               		.loc 1 619 0
 1618 049a 00D0      		rcall rd_wr_csmreq_cs2_reset
 1619               	.LVL114:
 620:setup.c       **** 	
 621:setup.c       **** 	// Set outputs
 622:setup.c       **** 	DDRD |= (1<<ACTIVITY_LED) | (1<<WR_PIN) | (1<<RD_PIN) | (1<<CS_MREQ_PIN) | (1<<LED_5V);
 1620               		.loc 1 622 0
 1621 049c 81B3      		in r24,0x11
 1622 049e 886F      		ori r24,lo8(-8)
 1623 04a0 81BB      		out 0x11,r24
 623:setup.c       **** 	DDRE |= (1<<CS2_PIN) | (1<<LED_3V);
 1624               		.loc 1 623 0
 1625 04a2 86B1      		in r24,0x6
 1626 04a4 8560      		ori r24,lo8(5)
 1627 04a6 86B9      		out 0x6,r24
 624:setup.c       **** 	
 625:setup.c       **** 	// Set all pins as inputs
 626:setup.c       **** 	PORT_DATA7_0 = 0;
 1628               		.loc 1 626 0
 1629 04a8 15BA      		out 0x15,__zero_reg__
 627:setup.c       **** 	DDR_DATA7_0 = 0;
 1630               		.loc 1 627 0
 1631 04aa 14BA      		out 0x14,__zero_reg__
 628:setup.c       **** 	PORT_ADDR7_0 = 0;
 1632               		.loc 1 628 0
 1633 04ac 18BA      		out 0x18,__zero_reg__
 629:setup.c       **** 	DDR_ADDR7_0 = 0;
 1634               		.loc 1 629 0
 1635 04ae 17BA      		out 0x17,__zero_reg__
 630:setup.c       **** 	PORT_ADDR15_8 = 0;
 1636               		.loc 1 630 0
 1637 04b0 1BBA      		out 0x1b,__zero_reg__
 631:setup.c       **** 	DDR_ADDR15_8 = 0;
 1638               		.loc 1 631 0
 1639 04b2 1ABA      		out 0x1a,__zero_reg__
 632:setup.c       **** 	
 633:setup.c       **** 	// Light up 3.3V or 5V
 634:setup.c       **** 	if (PIND & (1<<SWITCH_DETECT)) {
 1640               		.loc 1 634 0
 1641 04b4 829B      		sbis 0x10,2
 1642 04b6 00C0      		rjmp .L71
 635:setup.c       **** 		PORTD |= (1<<LED_5V);
 1643               		.loc 1 635 0
 1644 04b8 979A      		sbi 0x12,7
 636:setup.c       **** 		PORTE &= ~(1<<LED_3V);
 1645               		.loc 1 636 0
 1646 04ba 3898      		cbi 0x7,0
 1647 04bc 00C0      		rjmp .L72
 1648               	.L71:
 637:setup.c       **** 	}
 638:setup.c       **** 	else {
 639:setup.c       **** 		PORTE |= (1<<LED_3V);
 1649               		.loc 1 639 0
 1650 04be 389A      		sbi 0x7,0
 640:setup.c       **** 		PORTD &= ~(1<<LED_5V);
 1651               		.loc 1 640 0
 1652 04c0 9798      		cbi 0x12,7
 1653               	.L72:
 641:setup.c       **** 	}
 642:setup.c       **** 	
 643:setup.c       **** 	// Light LED
 644:setup.c       **** 	PORTD |= (1<<ACTIVITY_LED);
 1654               		.loc 1 644 0
 1655 04c2 939A      		sbi 0x12,3
 1656               	.LVL115:
 1657               	.LBB67:
 1658               	.LBB68:
 187:c:\winavr-20100110\avr\include\util\delay.h **** 
 1659               		.loc 2 187 0
 1660 04c4 2FEF      		ldi r18,lo8(799999)
 1661 04c6 84E3      		ldi r24,hi8(799999)
 1662 04c8 9CE0      		ldi r25,hlo8(799999)
 1663 04ca 2150      	1:	subi r18,1
 1664 04cc 8040      		sbci r24,0
 1665 04ce 9040      		sbci r25,0
 1666 04d0 01F4      		brne 1b
 1667 04d2 00C0      		rjmp .
 1668 04d4 0000      		nop
 1669               	.LBE68:
 1670               	.LBE67:
 645:setup.c       **** 	_delay_ms(500);
 646:setup.c       **** 	PORTD &= ~(1<<ACTIVITY_LED);
 1671               		.loc 1 646 0
 1672 04d6 9398      		cbi 0x12,3
 647:setup.c       **** 	
 648:setup.c       **** 	// Setup USART
 649:setup.c       **** 	UBRRL = 0; // 1Mbps Baud rate
 1673               		.loc 1 649 0
 1674 04d8 19B8      		out 0x9,__zero_reg__
 650:setup.c       **** 	sbi(UCSRA, U2X); // Double rate
 1675               		.loc 1 650 0
 1676 04da 599A      		sbi 0xb,1
 651:setup.c       **** 	sbi(UCSRB, TXEN); // Transmitter enable
 1677               		.loc 1 651 0
 1678 04dc 539A      		sbi 0xa,3
 652:setup.c       **** 	sbi(UCSRB, RXEN); // Receiver enable
 1679               		.loc 1 652 0
 1680 04de 549A      		sbi 0xa,4
 653:setup.c       **** 	
 654:setup.c       **** 	// Turn on interrupts
 655:setup.c       **** 	sei();
 1681               		.loc 1 655 0
 1682               	/* #APP */
 1683               	 ;  655 "setup.c" 1
 1684 04e0 7894      		sei
 1685               	 ;  0 "" 2
 1686               	/* #NOAPP */
 1687 04e2 0895      		ret
 1688               		.cfi_endproc
 1689               	.LFE38:
 1691               		.section	.text.startup,"ax",@progbits
 1692               	.global	main
 1694               	main:
 1695               	.LFB39:
 1696               		.file 3 "main.c"
   1:main.c        **** /*
   2:main.c        ****  GBxCart RW
   3:main.c        ****  PCB version: 1.1
   4:main.c        ****  Firmware version: R3
   5:main.c        ****  Author: Alex from insideGadgets (www.insidegadgets.com)
   6:main.c        ****  Created: 7/11/2016
   7:main.c        ****  Last Modified: 26/08/2017
   8:main.c        ****  
   9:main.c        ****  GBxCart RW allows you to dump your Gameboy/Gameboy Colour/Gameboy Advance games ROM, save the RAM 
  10:main.c        ****  
  11:main.c        ****  The ATmega8515L talks to the cartridge and interfaces with the CH340G serial to USB converter with
  12:main.c        ****  
  13:main.c        ****  
  14:main.c        ****  Set fuse bits: External 8MHz crystal, divide clock by 8 is off, boot loader is on (512 bytes), BOD
  15:main.c        ****  avrdude -p atmega8515 -c usbasp -U lfuse:w:0xaf:m -U hfuse:w:0xda:m
  16:main.c        ****  
  17:main.c        ****  Program the TinySafeBoot boot loader (modified ASM code, watchdog reset will act as a hardware res
  18:main.c        ****  avrdude -p atmega8515 -c usbasp -U flash:w:GBxCart_RW_v1.1_R3\tsb\tsb_m8515_d0d1_resetwdt.hex
  19:main.c        ****  
  20:main.c        ****  Program GBxCart RW through TinySafeBoot
  21:main.c        ****  tsb com16:57600 fw GBxCart_RW_v1.1_R3\main.hex
  22:main.c        ****  
  23:main.c        ****  Set TinySafeBoot delay time to 25 (T 25)
  24:main.c        ****  tsb com16:9600 T 25
  25:main.c        ****  
  26:main.c        ****  */
  27:main.c        **** 
  28:main.c        **** // ATmega8515L Pin Map
  29:main.c        **** //
  30:main.c        **** // VCC (5)			GND (6)			XTAL (7 ,8)		Activity LED PD3 (9)				Switch sense PD2 (8)
  31:main.c        **** // SCK PB7 (3)		MOSI PB5 (1)	MISO PB6 (2)	RST (4)		RXD PD0 (5)			TXD PD1 (7)
  32:main.c        **** // 
  33:main.c        **** // Gameboy / Gameboy Colour
  34:main.c        **** // A0-A7 PB0-7 (40-44, 1-3) 		A8-A15 PA0-7 (37-30)			D0-D7 PC0-7 (18-25)		Audio PE1 (27)
  35:main.c        **** // 
  36:main.c        **** // Gameboy Advance
  37:main.c        **** // AD0-AD7 PB0-7 (40-44, 1-3) 	AD8-AD15 PA0-7 (37-30)		A16-23 / D0-D7 PC0-7 (19-26)
  38:main.c        **** // *WR PD6 (13)						*RD PD5 (14)					*MREQ/CS PD4 (15)			CS2/RST PE2 (16)
  39:main.c        **** 
  40:main.c        **** #define F_CPU 8000000 // 8 MHz
  41:main.c        **** #define PCB_VERSION 2
  42:main.c        **** #define FIRMWARE_VERSION 3
  43:main.c        **** 
  44:main.c        **** #include <avr/io.h>
  45:main.c        **** #include <avr/wdt.h>
  46:main.c        **** #include <avr/eeprom.h>
  47:main.c        **** #include <avr/interrupt.h>
  48:main.c        **** #include <avr/sleep.h>
  49:main.c        **** #include <util/delay.h>
  50:main.c        **** #include <stdlib.h>
  51:main.c        **** #include <string.h>
  52:main.c        **** #include "setup.c" // See defines, variables, constants, functions here
  53:main.c        **** 
  54:main.c        **** 
  55:main.c        **** int main(void) {
 1697               		.loc 3 55 0
 1698               		.cfi_startproc
 1699 0000 CF93      		push r28
 1700               	.LCFI40:
 1701               		.cfi_def_cfa_offset 3
 1702               		.cfi_offset 28, -2
 1703 0002 DF93      		push r29
 1704               	.LCFI41:
 1705               		.cfi_def_cfa_offset 4
 1706               		.cfi_offset 29, -3
 1707 0004 00D0      		rcall .
 1708 0006 00D0      		rcall .
 1709               	.LCFI42:
 1710               		.cfi_def_cfa_offset 8
 1711 0008 CDB7      		in r28,__SP_L__
 1712 000a DEB7      		in r29,__SP_H__
 1713               	.LCFI43:
 1714               		.cfi_def_cfa_register 28
 1715               	/* prologue: function */
 1716               	/* frame size = 4 */
 1717               	/* stack size = 6 */
 1718               	.L__stack_usage = 6
  56:main.c        **** 	setup();
 1719               		.loc 3 56 0
 1720 000c 00D0      		rcall setup
 1721               	.LVL116:
  57:main.c        **** 	
  58:main.c        **** 	uint32_t address = 0;
  59:main.c        **** 	uint8_t eepromSize = EEPROM_4KBIT;
  60:main.c        **** 	uint8_t cartMode = GB_MODE;
  61:main.c        **** 	uint8_t resetCommonLines = 1;
 1722               		.loc 3 61 0
 1723 000e 21E0      		ldi r18,lo8(1)
 1724 0010 2983      		std Y+1,r18
  59:main.c        **** 	uint8_t cartMode = GB_MODE;
 1725               		.loc 3 59 0
 1726 0012 2B83      		std Y+3,r18
  58:main.c        **** 	uint8_t eepromSize = EEPROM_4KBIT;
 1727               		.loc 3 58 0
 1728 0014 C12C      		mov r12,__zero_reg__
 1729 0016 D12C      		mov r13,__zero_reg__
 1730 0018 7601      		movw r14,r12
 1731               	.LBB69:
 1732               	.LBB70:
 1733               	.LBB71:
 1734               		.file 4 "c:\\winavr-20100110\\avr\\include\\util\\delay_basic.h"
   1:c:\winavr-20100110\avr\include\util\delay_basic.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:c:\winavr-20100110\avr\include\util\delay_basic.h ****    Copyright (c) 2007 Joerg Wunsch
   3:c:\winavr-20100110\avr\include\util\delay_basic.h ****    All rights reserved.
   4:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
   5:c:\winavr-20100110\avr\include\util\delay_basic.h ****    Redistribution and use in source and binary forms, with or without
   6:c:\winavr-20100110\avr\include\util\delay_basic.h ****    modification, are permitted provided that the following conditions are met:
   7:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
   8:c:\winavr-20100110\avr\include\util\delay_basic.h ****    * Redistributions of source code must retain the above copyright
   9:c:\winavr-20100110\avr\include\util\delay_basic.h ****      notice, this list of conditions and the following disclaimer.
  10:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  11:c:\winavr-20100110\avr\include\util\delay_basic.h ****    * Redistributions in binary form must reproduce the above copyright
  12:c:\winavr-20100110\avr\include\util\delay_basic.h ****      notice, this list of conditions and the following disclaimer in
  13:c:\winavr-20100110\avr\include\util\delay_basic.h ****      the documentation and/or other materials provided with the
  14:c:\winavr-20100110\avr\include\util\delay_basic.h ****      distribution.
  15:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  16:c:\winavr-20100110\avr\include\util\delay_basic.h ****    * Neither the name of the copyright holders nor the names of
  17:c:\winavr-20100110\avr\include\util\delay_basic.h ****      contributors may be used to endorse or promote products derived
  18:c:\winavr-20100110\avr\include\util\delay_basic.h ****      from this software without specific prior written permission.
  19:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  20:c:\winavr-20100110\avr\include\util\delay_basic.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  21:c:\winavr-20100110\avr\include\util\delay_basic.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  22:c:\winavr-20100110\avr\include\util\delay_basic.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  23:c:\winavr-20100110\avr\include\util\delay_basic.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  24:c:\winavr-20100110\avr\include\util\delay_basic.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  25:c:\winavr-20100110\avr\include\util\delay_basic.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  26:c:\winavr-20100110\avr\include\util\delay_basic.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  27:c:\winavr-20100110\avr\include\util\delay_basic.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  28:c:\winavr-20100110\avr\include\util\delay_basic.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  29:c:\winavr-20100110\avr\include\util\delay_basic.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  30:c:\winavr-20100110\avr\include\util\delay_basic.h ****   POSSIBILITY OF SUCH DAMAGE. */
  31:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  32:c:\winavr-20100110\avr\include\util\delay_basic.h **** /* $Id$ */
  33:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  34:c:\winavr-20100110\avr\include\util\delay_basic.h **** #ifndef _UTIL_DELAY_BASIC_H_
  35:c:\winavr-20100110\avr\include\util\delay_basic.h **** #define _UTIL_DELAY_BASIC_H_ 1
  36:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  37:c:\winavr-20100110\avr\include\util\delay_basic.h **** #include <inttypes.h>
  38:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  39:c:\winavr-20100110\avr\include\util\delay_basic.h **** #if !defined(__DOXYGEN__)
  40:c:\winavr-20100110\avr\include\util\delay_basic.h **** static __inline__ void _delay_loop_1(uint8_t __count) __attribute__((__always_inline__));
  41:c:\winavr-20100110\avr\include\util\delay_basic.h **** static __inline__ void _delay_loop_2(uint16_t __count) __attribute__((__always_inline__));
  42:c:\winavr-20100110\avr\include\util\delay_basic.h **** #endif
  43:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  44:c:\winavr-20100110\avr\include\util\delay_basic.h **** /** \file */
  45:c:\winavr-20100110\avr\include\util\delay_basic.h **** /** \defgroup util_delay_basic <util/delay_basic.h>: Basic busy-wait delay loops
  46:c:\winavr-20100110\avr\include\util\delay_basic.h ****     \code
  47:c:\winavr-20100110\avr\include\util\delay_basic.h ****     #include <util/delay_basic.h>
  48:c:\winavr-20100110\avr\include\util\delay_basic.h ****     \endcode
  49:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  50:c:\winavr-20100110\avr\include\util\delay_basic.h ****     The functions in this header file implement simple delay loops
  51:c:\winavr-20100110\avr\include\util\delay_basic.h ****     that perform a busy-waiting.  They are typically used to
  52:c:\winavr-20100110\avr\include\util\delay_basic.h ****     facilitate short delays in the program execution.  They are
  53:c:\winavr-20100110\avr\include\util\delay_basic.h ****     implemented as count-down loops with a well-known CPU cycle
  54:c:\winavr-20100110\avr\include\util\delay_basic.h ****     count per loop iteration.  As such, no other processing can
  55:c:\winavr-20100110\avr\include\util\delay_basic.h ****     occur simultaneously.  It should be kept in mind that the
  56:c:\winavr-20100110\avr\include\util\delay_basic.h ****     functions described here do not disable interrupts.
  57:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  58:c:\winavr-20100110\avr\include\util\delay_basic.h ****     In general, for long delays, the use of hardware timers is
  59:c:\winavr-20100110\avr\include\util\delay_basic.h ****     much preferrable, as they free the CPU, and allow for
  60:c:\winavr-20100110\avr\include\util\delay_basic.h ****     concurrent processing of other events while the timer is
  61:c:\winavr-20100110\avr\include\util\delay_basic.h ****     running.  However, in particular for very short delays, the
  62:c:\winavr-20100110\avr\include\util\delay_basic.h ****     overhead of setting up a hardware timer is too much compared
  63:c:\winavr-20100110\avr\include\util\delay_basic.h ****     to the overall delay time.
  64:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  65:c:\winavr-20100110\avr\include\util\delay_basic.h ****     Two inline functions are provided for the actual delay algorithms.
  66:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  67:c:\winavr-20100110\avr\include\util\delay_basic.h **** */
  68:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  69:c:\winavr-20100110\avr\include\util\delay_basic.h **** /** \ingroup util_delay_basic
  70:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  71:c:\winavr-20100110\avr\include\util\delay_basic.h ****     Delay loop using an 8-bit counter \c __count, so up to 256
  72:c:\winavr-20100110\avr\include\util\delay_basic.h ****     iterations are possible.  (The value 256 would have to be passed
  73:c:\winavr-20100110\avr\include\util\delay_basic.h ****     as 0.)  The loop executes three CPU cycles per iteration, not
  74:c:\winavr-20100110\avr\include\util\delay_basic.h ****     including the overhead the compiler needs to setup the counter
  75:c:\winavr-20100110\avr\include\util\delay_basic.h ****     register.
  76:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  77:c:\winavr-20100110\avr\include\util\delay_basic.h ****     Thus, at a CPU speed of 1 MHz, delays of up to 768 microseconds
  78:c:\winavr-20100110\avr\include\util\delay_basic.h ****     can be achieved.
  79:c:\winavr-20100110\avr\include\util\delay_basic.h **** */
  80:c:\winavr-20100110\avr\include\util\delay_basic.h **** void
  81:c:\winavr-20100110\avr\include\util\delay_basic.h **** _delay_loop_1(uint8_t __count)
  82:c:\winavr-20100110\avr\include\util\delay_basic.h **** {
  83:c:\winavr-20100110\avr\include\util\delay_basic.h **** 	__asm__ volatile (
  84:c:\winavr-20100110\avr\include\util\delay_basic.h **** 		"1: dec %0" "\n\t"
  85:c:\winavr-20100110\avr\include\util\delay_basic.h **** 		"brne 1b"
  86:c:\winavr-20100110\avr\include\util\delay_basic.h **** 		: "=r" (__count)
  87:c:\winavr-20100110\avr\include\util\delay_basic.h **** 		: "0" (__count)
  88:c:\winavr-20100110\avr\include\util\delay_basic.h **** 	);
  89:c:\winavr-20100110\avr\include\util\delay_basic.h **** }
  90:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  91:c:\winavr-20100110\avr\include\util\delay_basic.h **** /** \ingroup util_delay_basic
  92:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  93:c:\winavr-20100110\avr\include\util\delay_basic.h ****     Delay loop using a 16-bit counter \c __count, so up to 65536
  94:c:\winavr-20100110\avr\include\util\delay_basic.h ****     iterations are possible.  (The value 65536 would have to be
  95:c:\winavr-20100110\avr\include\util\delay_basic.h ****     passed as 0.)  The loop executes four CPU cycles per iteration,
  96:c:\winavr-20100110\avr\include\util\delay_basic.h ****     not including the overhead the compiler requires to setup the
  97:c:\winavr-20100110\avr\include\util\delay_basic.h ****     counter register pair.
  98:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  99:c:\winavr-20100110\avr\include\util\delay_basic.h ****     Thus, at a CPU speed of 1 MHz, delays of up to about 262.1
 100:c:\winavr-20100110\avr\include\util\delay_basic.h ****     milliseconds can be achieved.
 101:c:\winavr-20100110\avr\include\util\delay_basic.h ****  */
 102:c:\winavr-20100110\avr\include\util\delay_basic.h **** void
 103:c:\winavr-20100110\avr\include\util\delay_basic.h **** _delay_loop_2(uint16_t __count)
 104:c:\winavr-20100110\avr\include\util\delay_basic.h **** {
 105:c:\winavr-20100110\avr\include\util\delay_basic.h **** 	__asm__ volatile (
 1735               		.loc 4 105 0
 1736 001a AA24      		clr r10
 1737 001c AA94      		dec r10
 1738 001e BA2C      		mov r11,r10
 1739 0020 80E0      		ldi r24,lo8(eepromBuffer)
 1740 0022 90E0      		ldi r25,hi8(eepromBuffer)
 1741 0024 28E0      		ldi r18,lo8(8)
 1742 0026 280F      		add r18,r24
 1743 0028 2C83      		std Y+4,r18
 1744               	.LVL117:
 1745               	.L74:
 1746               	.LBE71:
 1747               	.LBE70:
 1748               	.LBE69:
  62:main.c        **** 	
  63:main.c        **** 	while(1) {
  64:main.c        **** 		if (resetCommonLines == 1) {
 1749               		.loc 3 64 0
 1750 002a 2981      		ldd r18,Y+1
 1751 002c 2130      		cpi r18,lo8(1)
 1752 002e 01F4      		brne .L75
 1753               	.LVL118:
 1754               	.L163:
  65:main.c        **** 			rd_wr_csmreq_cs2_reset();
 1755               		.loc 3 65 0
 1756 0030 00D0      		rcall rd_wr_csmreq_cs2_reset
 1757               	.LVL119:
 1758               	.L75:
  66:main.c        **** 		}
  67:main.c        **** 		receivedChar = USART_Receive(); // Wait for 1 byte of data
 1759               		.loc 3 67 0
 1760 0032 00D0      		rcall USART_Receive
 1761               	.LVL120:
 1762 0034 8093 0000 		sts receivedChar,r24
  68:main.c        **** 		
  69:main.c        **** 		// Read the pin to find out which mode we are in, if high (3.3V), we are powered by 5V
  70:main.c        **** 		if (PIND & (1<<SWITCH_DETECT)) {
 1763               		.loc 3 70 0
 1764 0038 829B      		sbis 0x10,2
 1765 003a 00C0      		rjmp .L76
 1766               	.LVL121:
  71:main.c        **** 			cartMode = GB_MODE;
  72:main.c        **** 			PORTD |= (1<<LED_5V);
 1767               		.loc 3 72 0
 1768 003c 979A      		sbi 0x12,7
  73:main.c        **** 			PORTE &= ~(1<<LED_3V);
 1769               		.loc 3 73 0
 1770 003e 3898      		cbi 0x7,0
  71:main.c        **** 			cartMode = GB_MODE;
 1771               		.loc 3 71 0
 1772 0040 81E0      		ldi r24,lo8(1)
 1773 0042 00C0      		rjmp .L77
 1774               	.LVL122:
 1775               	.L76:
  74:main.c        **** 		}
  75:main.c        **** 		else {
  76:main.c        **** 			cartMode = GBA_MODE;
  77:main.c        **** 			PORTE |= (1<<LED_3V);
 1776               		.loc 3 77 0
 1777 0044 389A      		sbi 0x7,0
  78:main.c        **** 			PORTD &= ~(1<<LED_5V);
 1778               		.loc 3 78 0
 1779 0046 9798      		cbi 0x12,7
  76:main.c        **** 			PORTE |= (1<<LED_3V);
 1780               		.loc 3 76 0
 1781 0048 82E0      		ldi r24,lo8(2)
 1782               	.LVL123:
 1783               	.L77:
  79:main.c        **** 		}
  80:main.c        **** 		
  81:main.c        **** 		// Return the cart mode in use
  82:main.c        **** 		if (receivedChar == CART_MODE) {
 1784               		.loc 3 82 0
 1785 004a 9091 0000 		lds r25,receivedChar
 1786 004e 9334      		cpi r25,lo8(67)
 1787 0050 01F4      		brne .+2
 1788 0052 00C0      		rjmp .L164
  83:main.c        **** 			USART_Transmit(cartMode);
  84:main.c        **** 		}
  85:main.c        **** 		
  86:main.c        **** 		// Change to GB mode or GBA mode if requested
  87:main.c        **** 		else if (receivedChar == GB_CART_MODE) {
 1789               		.loc 3 87 0
 1790 0054 9734      		cpi r25,lo8(71)
 1791 0056 01F4      		brne .L80
  88:main.c        **** 			gb_mode();
 1792               		.loc 3 88 0
 1793 0058 00D0      		rcall gb_mode
 1794               	.LVL124:
 1795 005a 00C0      		rjmp .L74
 1796               	.LVL125:
 1797               	.L80:
  89:main.c        **** 		}
  90:main.c        **** 		else if (receivedChar == GBA_CART_MODE) {
 1798               		.loc 3 90 0
 1799 005c 9736      		cpi r25,lo8(103)
 1800 005e 01F4      		brne .+2
 1801 0060 00C0      		rjmp .L166
  91:main.c        **** 			gba_mode();
  92:main.c        **** 		}
  93:main.c        **** 		
  94:main.c        **** 		// Set address
  95:main.c        **** 		else if (receivedChar == SET_START_ADDRESS) {
 1802               		.loc 3 95 0
 1803 0062 9134      		cpi r25,lo8(65)
 1804 0064 01F4      		brne .L82
  96:main.c        **** 			usart_read_chars(); // Read start address
 1805               		.loc 3 96 0
 1806 0066 00D0      		rcall usart_read_chars
 1807               	.LVL126:
  97:main.c        **** 			address = strtol(receivedBuffer, NULL, 16); // Convert address string in hex to dec
 1808               		.loc 3 97 0
 1809 0068 40E1      		ldi r20,lo8(16)
 1810 006a 50E0      		ldi r21,0
 1811 006c 60E0      		ldi r22,0
 1812 006e 70E0      		ldi r23,0
 1813 0070 80E0      		ldi r24,lo8(receivedBuffer)
 1814 0072 90E0      		ldi r25,hi8(receivedBuffer)
 1815 0074 00D0      		rcall strtol
 1816               	.LVL127:
 1817 0076 6B01      		movw r12,r22
 1818 0078 7C01      		movw r14,r24
 1819               	.LVL128:
 1820 007a 00C0      		rjmp .L74
 1821               	.LVL129:
 1822               	.L82:
  98:main.c        **** 		}
  99:main.c        **** 		
 100:main.c        **** 		
 101:main.c        **** 		// ****** Gameboy / Gameboy Colour ******
 102:main.c        **** 		
 103:main.c        **** 		// Read 64 bytes of ROM/RAM from address (and increment) until anything but 1 is received
 104:main.c        **** 		else if (receivedChar == READ_ROM_RAM) {
 1823               		.loc 3 104 0
 1824 007c 9235      		cpi r25,lo8(82)
 1825 007e 01F4      		brne .L83
 105:main.c        **** 			gb_mode();
 1826               		.loc 3 105 0
 1827 0080 00D0      		rcall gb_mode
 1828               	.LVL130:
 106:main.c        **** 			receivedChar = '1';
 1829               		.loc 3 106 0
 1830 0082 81E3      		ldi r24,lo8(49)
 1831               	.LVL131:
 1832               	.L169:
 107:main.c        **** 			while (receivedChar == '1') {
 108:main.c        **** 				PORTD |= (1<<ACTIVITY_LED);
 109:main.c        **** 				for (uint8_t x = 0; x < 64; x++) {
 110:main.c        **** 					USART_Transmit(read_8bit_data(address));
 111:main.c        **** 					address++;
 112:main.c        **** 				}
 113:main.c        **** 				
 114:main.c        **** 				PORTD &= ~(1<<ACTIVITY_LED);
 115:main.c        **** 				receivedChar = USART_Receive();
 1833               		.loc 3 115 0
 1834 0084 8093 0000 		sts receivedChar,r24
 1835               	.LVL132:
 107:main.c        **** 			while (receivedChar == '1') {
 1836               		.loc 3 107 0
 1837 0088 8091 0000 		lds r24,receivedChar
 1838 008c 8133      		cpi r24,lo8(49)
 1839 008e 01F4      		brne .L74
 108:main.c        **** 				for (uint8_t x = 0; x < 64; x++) {
 1840               		.loc 3 108 0
 1841 0090 939A      		sbi 0x12,3
 1842               	.LVL133:
 1843 0092 00E0      		ldi r16,0
 1844 0094 10E0      		ldi r17,0
 1845               	.LVL134:
 1846               	.L85:
 1847 0096 C801      		movw r24,r16
 1848 0098 8C0D      		add r24,r12
 1849 009a 9D1D      		adc r25,r13
 1850               	.LBB74:
 110:main.c        **** 					address++;
 1851               		.loc 3 110 0 discriminator 3
 1852 009c 00D0      		rcall read_8bit_data
 1853               	.LVL135:
 1854 009e 00D0      		rcall USART_Transmit
 1855               	.LVL136:
 1856 00a0 0F5F      		subi r16,-1
 1857 00a2 1F4F      		sbci r17,-1
 1858               	.LVL137:
 109:main.c        **** 					USART_Transmit(read_8bit_data(address));
 1859               		.loc 3 109 0 discriminator 3
 1860 00a4 0034      		cpi r16,64
 1861 00a6 1105      		cpc r17,__zero_reg__
 1862 00a8 01F4      		brne .L85
 1863 00aa 80E4      		ldi r24,64
 1864 00ac C80E      		add r12,r24
 1865 00ae D11C      		adc r13,__zero_reg__
 1866 00b0 E11C      		adc r14,__zero_reg__
 1867 00b2 F11C      		adc r15,__zero_reg__
 1868               	.LBE74:
 114:main.c        **** 				receivedChar = USART_Receive();
 1869               		.loc 3 114 0
 1870 00b4 9398      		cbi 0x12,3
 1871               		.loc 3 115 0
 1872 00b6 00D0      		rcall USART_Receive
 1873               	.LVL138:
 1874 00b8 00C0      		rjmp .L169
 1875               	.LVL139:
 1876               	.L83:
 116:main.c        **** 			}
 117:main.c        **** 		}
 118:main.c        **** 		
 119:main.c        **** 		// Write 64 bytes to RAM on address (and increment)
 120:main.c        **** 		else if (receivedChar == WRITE_RAM) {
 1877               		.loc 3 120 0
 1878 00ba 9735      		cpi r25,lo8(87)
 1879 00bc 01F4      		brne .L87
 121:main.c        **** 			gb_mode();
 1880               		.loc 3 121 0
 1881 00be 00D0      		rcall gb_mode
 1882               	.LVL140:
 122:main.c        **** 			
 123:main.c        **** 			// Read 64 bytes first as CH340G sends them all at once
 124:main.c        **** 			usart_read_bytes(64);
 1883               		.loc 3 124 0
 1884 00c0 80E4      		ldi r24,lo8(64)
 1885 00c2 00D0      		rcall usart_read_bytes
 1886               	.LVL141:
 125:main.c        **** 			
 126:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 1887               		.loc 3 126 0
 1888 00c4 939A      		sbi 0x12,3
 1889               	.LVL142:
 1890 00c6 00E0      		ldi r16,lo8(receivedBuffer)
 1891 00c8 10E0      		ldi r17,hi8(receivedBuffer)
 1892 00ca 812C      		mov r8,__zero_reg__
 1893 00cc 912C      		mov r9,__zero_reg__
 1894               	.LVL143:
 1895               	.L88:
 1896               	.LBB75:
 127:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 128:main.c        **** 				write_8bit_data(address, receivedBuffer[x], MEMORY_WRITE);
 1897               		.loc 3 128 0 discriminator 3
 1898 00ce F801      		movw r30,r16
 1899 00d0 6191      		ld r22,Z+
 1900 00d2 8F01      		movw r16,r30
 1901 00d4 C401      		movw r24,r8
 1902 00d6 8C0D      		add r24,r12
 1903 00d8 9D1D      		adc r25,r13
 1904 00da 41E0      		ldi r20,lo8(1)
 1905 00dc 00D0      		rcall write_8bit_data
 1906               	.LVL144:
 1907 00de FFEF      		ldi r31,-1
 1908 00e0 8F1A      		sub r8,r31
 1909 00e2 9F0A      		sbc r9,r31
 1910               	.LVL145:
 127:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 1911               		.loc 3 127 0 discriminator 3
 1912 00e4 20E4      		ldi r18,64
 1913 00e6 8216      		cp r8,r18
 1914 00e8 9104      		cpc r9,__zero_reg__
 1915 00ea 01F4      		brne .L88
 1916 00ec 80E4      		ldi r24,64
 1917 00ee C80E      		add r12,r24
 1918 00f0 D11C      		adc r13,__zero_reg__
 1919 00f2 E11C      		adc r14,__zero_reg__
 1920 00f4 F11C      		adc r15,__zero_reg__
 1921 00f6 00C0      		rjmp .L185
 1922               	.LVL146:
 1923               	.L87:
 1924               	.LBE75:
 129:main.c        **** 				address++;
 130:main.c        **** 			}
 131:main.c        **** 			
 132:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 133:main.c        **** 			USART_Transmit('1'); // Send back acknowledgement
 134:main.c        **** 		}
 135:main.c        **** 		
 136:main.c        **** 		// Set bank address and write a byte
 137:main.c        **** 		else if (receivedChar == SET_BANK) {
 1925               		.loc 3 137 0
 1926 00f8 9234      		cpi r25,lo8(66)
 1927 00fa 01F4      		brne .L89
 1928               	.LBB76:
 138:main.c        **** 			gb_mode();
 1929               		.loc 3 138 0
 1930 00fc 00D0      		rcall gb_mode
 1931               	.LVL147:
 139:main.c        **** 			
 140:main.c        **** 			usart_read_chars(); // Read start address
 1932               		.loc 3 140 0
 1933 00fe 00D0      		rcall usart_read_chars
 1934               	.LVL148:
 141:main.c        **** 			uint16_t bankaddress = strtol(receivedBuffer, NULL, 16); // Convert address string in hex to dec
 1935               		.loc 3 141 0
 1936 0100 40E1      		ldi r20,lo8(16)
 1937 0102 50E0      		ldi r21,0
 1938 0104 60E0      		ldi r22,0
 1939 0106 70E0      		ldi r23,0
 1940 0108 80E0      		ldi r24,lo8(receivedBuffer)
 1941 010a 90E0      		ldi r25,hi8(receivedBuffer)
 1942 010c 00D0      		rcall strtol
 1943               	.LVL149:
 1944 010e 2B01      		movw r4,r22
 1945 0110 3C01      		movw r6,r24
 1946               	.LVL150:
 142:main.c        **** 			
 143:main.c        **** 			receivedChar = USART_Receive(); // Wait for bank number
 1947               		.loc 3 143 0
 1948 0112 00D0      		rcall USART_Receive
 1949               	.LVL151:
 1950 0114 8093 0000 		sts receivedChar,r24
 144:main.c        **** 			if (receivedChar == 'B') {
 1951               		.loc 3 144 0
 1952 0118 8234      		cpi r24,lo8(66)
 1953 011a 01F0      		breq .+2
 1954 011c 00C0      		rjmp .L74
 1955               	.LBB77:
 145:main.c        **** 				usart_read_chars(); // Read data
 1956               		.loc 3 145 0
 1957 011e 00D0      		rcall usart_read_chars
 1958               	.LVL152:
 146:main.c        **** 				uint8_t data = atoi(receivedBuffer); // Convert data string to dec
 1959               		.loc 3 146 0
 1960 0120 80E0      		ldi r24,lo8(receivedBuffer)
 1961 0122 90E0      		ldi r25,hi8(receivedBuffer)
 1962 0124 00D0      		rcall atoi
 1963               	.LVL153:
 147:main.c        **** 				
 148:main.c        **** 				write_8bit_data(bankaddress, data, BANK_WRITE);
 1964               		.loc 3 148 0
 1965 0126 40E0      		ldi r20,0
 1966 0128 682F      		mov r22,r24
 1967 012a C201      		movw r24,r4
 1968               	.LVL154:
 1969 012c 00D0      		rcall write_8bit_data
 1970               	.LVL155:
 1971 012e 00C0      		rjmp .L74
 1972               	.LVL156:
 1973               	.L89:
 1974               	.LBE77:
 1975               	.LBE76:
 149:main.c        **** 			}
 150:main.c        **** 		}
 151:main.c        **** 		
 152:main.c        **** 		
 153:main.c        **** 		// ****** Gameboy Advance ******
 154:main.c        **** 		
 155:main.c        **** 		// ---------- ROM ----------
 156:main.c        **** 		// Read one 16bit byte from ROM using address (and increment) until anything but 1 is received
 157:main.c        **** 		else if (receivedChar == GBA_READ_ROM) {
 1976               		.loc 3 157 0
 1977 0130 9237      		cpi r25,lo8(114)
 1978 0132 01F4      		brne .L90
 158:main.c        **** 			gba_mode(); 
 1979               		.loc 3 158 0
 1980 0134 00D0      		rcall gba_mode
 1981               	.LVL157:
 159:main.c        **** 			
 160:main.c        **** 			receivedChar = '1';
 1982               		.loc 3 160 0
 1983 0136 81E3      		ldi r24,lo8(49)
 1984               	.LVL158:
 1985               	.L170:
 161:main.c        **** 			while (receivedChar == '1') {
 162:main.c        **** 				PORTD |= (1<<ACTIVITY_LED);
 163:main.c        **** 				for (uint8_t x = 0; x < 32; x++) {
 164:main.c        **** 					uint16_t dataRead = gba_read_16bit_data(address);
 165:main.c        **** 					
 166:main.c        **** 					// Low byte & High byte
 167:main.c        **** 					USART_Transmit(dataRead & 0xFF);
 168:main.c        **** 					USART_Transmit(dataRead >> 8);
 169:main.c        **** 					
 170:main.c        **** 					address++;
 171:main.c        **** 				}
 172:main.c        **** 				
 173:main.c        **** 				PORTD &= ~(1<<ACTIVITY_LED);
 174:main.c        **** 				receivedChar = USART_Receive();
 1986               		.loc 3 174 0
 1987 0138 8093 0000 		sts receivedChar,r24
 1988               	.LVL159:
 161:main.c        **** 			while (receivedChar == '1') {
 1989               		.loc 3 161 0
 1990 013c 8091 0000 		lds r24,receivedChar
 1991 0140 8133      		cpi r24,lo8(49)
 1992 0142 01F0      		breq .+2
 1993 0144 00C0      		rjmp .L74
 162:main.c        **** 				for (uint8_t x = 0; x < 32; x++) {
 1994               		.loc 3 162 0
 1995 0146 939A      		sbi 0x12,3
 1996               	.LVL160:
 1997 0148 2601      		movw r4,r12
 1998 014a 3701      		movw r6,r14
 1999 014c 10E2      		ldi r17,lo8(32)
 2000 014e 1C0D      		add r17,r12
 2001               	.LVL161:
 2002               	.L92:
 2003               	.LBB78:
 2004               	.LBB79:
 164:main.c        **** 					
 2005               		.loc 3 164 0 discriminator 3
 2006 0150 C301      		movw r24,r6
 2007 0152 B201      		movw r22,r4
 2008 0154 00D0      		rcall gba_read_16bit_data
 2009               	.LVL162:
 167:main.c        **** 					USART_Transmit(dataRead >> 8);
 2010               		.loc 3 167 0 discriminator 3
 2011 0156 9A83      		std Y+2,r25
 2012 0158 00D0      		rcall USART_Transmit
 2013               	.LVL163:
 168:main.c        **** 					
 2014               		.loc 3 168 0 discriminator 3
 2015 015a 9A81      		ldd r25,Y+2
 2016 015c 892F      		mov r24,r25
 2017 015e 00D0      		rcall USART_Transmit
 2018               	.LVL164:
 170:main.c        **** 				}
 2019               		.loc 3 170 0 discriminator 3
 2020 0160 9FEF      		ldi r25,-1
 2021 0162 491A      		sub r4,r25
 2022 0164 590A      		sbc r5,r25
 2023 0166 690A      		sbc r6,r25
 2024 0168 790A      		sbc r7,r25
 2025               	.LVL165:
 2026               	.LBE79:
 163:main.c        **** 					uint16_t dataRead = gba_read_16bit_data(address);
 2027               		.loc 3 163 0 discriminator 3
 2028 016a 1411      		cpse r17,r4
 2029 016c 00C0      		rjmp .L92
 2030 016e E0E2      		ldi r30,32
 2031 0170 CE0E      		add r12,r30
 2032 0172 D11C      		adc r13,__zero_reg__
 2033 0174 E11C      		adc r14,__zero_reg__
 2034 0176 F11C      		adc r15,__zero_reg__
 2035               	.LVL166:
 2036               	.LBE78:
 173:main.c        **** 				receivedChar = USART_Receive();
 2037               		.loc 3 173 0
 2038 0178 9398      		cbi 0x12,3
 2039               		.loc 3 174 0
 2040 017a 00D0      		rcall USART_Receive
 2041               	.LVL167:
 2042 017c 00C0      		rjmp .L170
 2043               	.LVL168:
 2044               	.L90:
 175:main.c        **** 			}
 176:main.c        **** 		}
 177:main.c        **** 		
 178:main.c        **** 		
 179:main.c        **** 		// ---------- SRAM ----------
 180:main.c        **** 		// Read RAM from address (and increment) until anything but 1 is received
 181:main.c        **** 		else if (receivedChar == GBA_READ_SRAM) {
 2045               		.loc 3 181 0
 2046 017e 9D36      		cpi r25,lo8(109)
 2047 0180 01F4      		brne .L94
 182:main.c        **** 			gb_mode(); // Set GB mode as it uses 16 bit address with 8 bit data
 2048               		.loc 3 182 0
 2049 0182 00D0      		rcall gb_mode
 2050               	.LVL169:
 183:main.c        **** 			
 184:main.c        **** 			receivedChar = '1';
 2051               		.loc 3 184 0
 2052 0184 81E3      		ldi r24,lo8(49)
 2053               	.LVL170:
 2054               	.L171:
 185:main.c        **** 			while (receivedChar == '1') {
 186:main.c        **** 				PORTD |= (1<<ACTIVITY_LED);
 187:main.c        **** 				for (uint8_t x = 0; x < 64; x++) {
 188:main.c        **** 					USART_Transmit(gba_read_ram_8bit_data(address));
 189:main.c        **** 					address++;
 190:main.c        **** 				}
 191:main.c        **** 				
 192:main.c        **** 				PORTD &= ~(1<<ACTIVITY_LED);
 193:main.c        **** 				receivedChar = USART_Receive();
 2055               		.loc 3 193 0
 2056 0186 8093 0000 		sts receivedChar,r24
 2057               	.LVL171:
 185:main.c        **** 			while (receivedChar == '1') {
 2058               		.loc 3 185 0
 2059 018a 8091 0000 		lds r24,receivedChar
 2060 018e 8133      		cpi r24,lo8(49)
 2061 0190 01F4      		brne .L166
 186:main.c        **** 				for (uint8_t x = 0; x < 64; x++) {
 2062               		.loc 3 186 0
 2063 0192 939A      		sbi 0x12,3
 2064               	.LVL172:
 2065 0194 00E0      		ldi r16,0
 2066 0196 10E0      		ldi r17,0
 2067               	.LVL173:
 2068               	.L96:
 2069 0198 C801      		movw r24,r16
 2070 019a 8C0D      		add r24,r12
 2071 019c 9D1D      		adc r25,r13
 2072               	.LBB80:
 188:main.c        **** 					address++;
 2073               		.loc 3 188 0 discriminator 3
 2074 019e 00D0      		rcall gba_read_ram_8bit_data
 2075               	.LVL174:
 2076 01a0 00D0      		rcall USART_Transmit
 2077               	.LVL175:
 2078 01a2 0F5F      		subi r16,-1
 2079 01a4 1F4F      		sbci r17,-1
 2080               	.LVL176:
 187:main.c        **** 					USART_Transmit(gba_read_ram_8bit_data(address));
 2081               		.loc 3 187 0 discriminator 3
 2082 01a6 0034      		cpi r16,64
 2083 01a8 1105      		cpc r17,__zero_reg__
 2084 01aa 01F4      		brne .L96
 2085 01ac F0E4      		ldi r31,64
 2086 01ae CF0E      		add r12,r31
 2087 01b0 D11C      		adc r13,__zero_reg__
 2088 01b2 E11C      		adc r14,__zero_reg__
 2089 01b4 F11C      		adc r15,__zero_reg__
 2090               	.LBE80:
 192:main.c        **** 				receivedChar = USART_Receive();
 2091               		.loc 3 192 0
 2092 01b6 9398      		cbi 0x12,3
 2093               		.loc 3 193 0
 2094 01b8 00D0      		rcall USART_Receive
 2095               	.LVL177:
 2096 01ba 00C0      		rjmp .L171
 2097               	.LVL178:
 2098               	.L94:
 194:main.c        **** 			}
 195:main.c        **** 			
 196:main.c        **** 			gba_mode(); // Set back
 197:main.c        **** 		}
 198:main.c        **** 		
 199:main.c        **** 		// Write to RAM on address (and increment) with 64 bytes of data
 200:main.c        **** 		else if (receivedChar == GBA_WRITE_SRAM) {
 2099               		.loc 3 200 0
 2100 01bc 9737      		cpi r25,lo8(119)
 2101 01be 01F4      		brne .L98
 201:main.c        **** 			gb_mode();
 2102               		.loc 3 201 0
 2103 01c0 00D0      		rcall gb_mode
 2104               	.LVL179:
 202:main.c        **** 			
 203:main.c        **** 			usart_read_bytes(64);
 2105               		.loc 3 203 0
 2106 01c2 80E4      		ldi r24,lo8(64)
 2107 01c4 00D0      		rcall usart_read_bytes
 2108               	.LVL180:
 204:main.c        **** 			
 205:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 2109               		.loc 3 205 0
 2110 01c6 939A      		sbi 0x12,3
 2111               	.LVL181:
 2112 01c8 00E0      		ldi r16,lo8(receivedBuffer)
 2113 01ca 10E0      		ldi r17,hi8(receivedBuffer)
 2114 01cc 812C      		mov r8,__zero_reg__
 2115 01ce 912C      		mov r9,__zero_reg__
 2116               	.LVL182:
 2117               	.L99:
 2118               	.LBB81:
 206:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 207:main.c        **** 				gba_write_ram_8bit_data(address, receivedBuffer[x]);
 2119               		.loc 3 207 0 discriminator 3
 2120 01d0 F801      		movw r30,r16
 2121 01d2 6191      		ld r22,Z+
 2122 01d4 8F01      		movw r16,r30
 2123 01d6 C401      		movw r24,r8
 2124 01d8 8C0D      		add r24,r12
 2125 01da 9D1D      		adc r25,r13
 2126 01dc 00D0      		rcall gba_write_ram_8bit_data
 2127               	.LVL183:
 2128 01de FFEF      		ldi r31,-1
 2129 01e0 8F1A      		sub r8,r31
 2130 01e2 9F0A      		sbc r9,r31
 2131               	.LVL184:
 206:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 2132               		.loc 3 206 0 discriminator 3
 2133 01e4 20E4      		ldi r18,64
 2134 01e6 8216      		cp r8,r18
 2135 01e8 9104      		cpc r9,__zero_reg__
 2136 01ea 01F4      		brne .L99
 2137 01ec 80E4      		ldi r24,64
 2138 01ee C80E      		add r12,r24
 2139 01f0 D11C      		adc r13,__zero_reg__
 2140 01f2 E11C      		adc r14,__zero_reg__
 2141 01f4 F11C      		adc r15,__zero_reg__
 2142               	.LVL185:
 2143               	.L168:
 2144               	.LBE81:
 208:main.c        **** 				address++;
 209:main.c        **** 			}
 210:main.c        **** 			USART_Transmit('1'); // Send back acknowledgement
 2145               		.loc 3 210 0
 2146 01f6 81E3      		ldi r24,lo8(49)
 2147 01f8 00D0      		rcall USART_Transmit
 2148               	.LVL186:
 211:main.c        **** 			
 212:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 2149               		.loc 3 212 0
 2150 01fa 9398      		cbi 0x12,3
 2151               	.L166:
 213:main.c        **** 			gba_mode(); // Set back
 2152               		.loc 3 213 0
 2153 01fc 00D0      		rcall gba_mode
 2154               	.LVL187:
 2155 01fe 00C0      		rjmp .L74
 2156               	.LVL188:
 2157               	.L98:
 214:main.c        **** 		}
 215:main.c        **** 		
 216:main.c        **** 		// 'o' - Write 1 byte to SRAM address
 217:main.c        **** 		else if (receivedChar == GBA_WRITE_ONE_BYTE_SRAM) {
 2158               		.loc 3 217 0
 2159 0200 9F36      		cpi r25,lo8(111)
 2160 0202 01F4      		brne .L100
 2161               	.LBB82:
 218:main.c        **** 			gb_mode();
 2162               		.loc 3 218 0
 2163 0204 00D0      		rcall gb_mode
 2164               	.LVL189:
 219:main.c        **** 			
 220:main.c        **** 			uint8_t data = USART_Receive();
 2165               		.loc 3 220 0
 2166 0206 00D0      		rcall USART_Receive
 2167               	.LVL190:
 221:main.c        **** 			gba_write_ram_8bit_data(address, data);
 2168               		.loc 3 221 0
 2169 0208 682F      		mov r22,r24
 2170 020a C601      		movw r24,r12
 2171               	.LVL191:
 2172 020c 00D0      		rcall gba_write_ram_8bit_data
 2173               	.LVL192:
 2174 020e 00C0      		rjmp .L173
 2175               	.LVL193:
 2176               	.L100:
 2177               	.LBE82:
 222:main.c        **** 			USART_Transmit('1'); // Send back acknowledgement
 223:main.c        **** 			
 224:main.c        **** 			gba_mode(); // Set back
 225:main.c        **** 		}
 226:main.c        **** 		
 227:main.c        **** 		
 228:main.c        **** 		// ---------- FLASH ----------
 229:main.c        **** 		// Read the Flash Manufacturer and Device ID
 230:main.c        **** 		else if (receivedChar == GBA_FLASH_READ_ID) {
 2178               		.loc 3 230 0
 2179 0210 9936      		cpi r25,lo8(105)
 2180 0212 01F4      		brne .L101
 231:main.c        **** 			gb_mode();
 2181               		.loc 3 231 0
 2182 0214 00D0      		rcall gb_mode
 2183               	.LVL194:
 232:main.c        **** 			
 233:main.c        **** 			flash_read_chip_id();
 2184               		.loc 3 233 0
 2185 0216 00D0      		rcall flash_read_chip_id
 2186               	.LVL195:
 234:main.c        **** 			USART_Transmit(flashChipIdBuffer[0]);
 2187               		.loc 3 234 0
 2188 0218 8091 0000 		lds r24,flashChipIdBuffer
 2189 021c 00D0      		rcall USART_Transmit
 2190               	.LVL196:
 235:main.c        **** 			USART_Transmit(flashChipIdBuffer[1]);
 2191               		.loc 3 235 0
 2192 021e 8091 0000 		lds r24,flashChipIdBuffer+1
 2193               	.L172:
 2194 0222 00D0      		rcall USART_Transmit
 2195               	.LVL197:
 2196 0224 00C0      		rjmp .L166
 2197               	.LVL198:
 2198               	.L101:
 236:main.c        **** 			
 237:main.c        **** 			gba_mode(); // Set back
 238:main.c        **** 		}
 239:main.c        **** 		
 240:main.c        **** 		// Change bank
 241:main.c        **** 		else if (receivedChar == GBA_FLASH_SET_BANK) {
 2199               		.loc 3 241 0
 2200 0226 9B36      		cpi r25,lo8(107)
 2201 0228 01F4      		brne .L102
 2202               	.LBB83:
 242:main.c        **** 			usart_read_chars(); // Read data
 2203               		.loc 3 242 0
 2204 022a 00D0      		rcall usart_read_chars
 2205               	.LVL199:
 243:main.c        **** 			uint8_t bank = atoi(receivedBuffer); // Convert data string to dec
 2206               		.loc 3 243 0
 2207 022c 80E0      		ldi r24,lo8(receivedBuffer)
 2208 022e 90E0      		ldi r25,hi8(receivedBuffer)
 2209 0230 00D0      		rcall atoi
 2210               	.LVL200:
 244:main.c        **** 			
 245:main.c        **** 			gb_mode();
 2211               		.loc 3 245 0
 2212 0232 8A83      		std Y+2,r24
 2213 0234 00D0      		rcall gb_mode
 2214               	.LVL201:
 246:main.c        **** 			flash_switch_bank(bank);
 2215               		.loc 3 246 0
 2216 0236 8A81      		ldd r24,Y+2
 2217 0238 00D0      		rcall flash_switch_bank
 2218               	.LVL202:
 2219 023a 00C0      		rjmp .L166
 2220               	.LVL203:
 2221               	.L102:
 2222               	.LBE83:
 247:main.c        **** 			
 248:main.c        **** 			gba_mode(); // Set back
 249:main.c        **** 		}
 250:main.c        **** 		
 251:main.c        **** 		// Erase 4K sector on Flash (sector 0 to 15 for 512Kbit)
 252:main.c        **** 		else if (receivedChar == GBA_FLASH_4K_SECTOR_ERASE) {
 2223               		.loc 3 252 0
 2224 023c 9337      		cpi r25,lo8(115)
 2225 023e 01F4      		brne .L103
 2226               	.LBB84:
 253:main.c        **** 			gb_mode();
 2227               		.loc 3 253 0
 2228 0240 00D0      		rcall gb_mode
 2229               	.LVL204:
 254:main.c        **** 			
 255:main.c        **** 			usart_read_chars(); // Read sector
 2230               		.loc 3 255 0
 2231 0242 00D0      		rcall usart_read_chars
 2232               	.LVL205:
 256:main.c        **** 			uint8_t sectorAddress = strtol(receivedBuffer, NULL, 16); // Convert address string in hex to de
 2233               		.loc 3 256 0
 2234 0244 40E1      		ldi r20,lo8(16)
 2235 0246 50E0      		ldi r21,0
 2236 0248 60E0      		ldi r22,0
 2237 024a 70E0      		ldi r23,0
 2238 024c 80E0      		ldi r24,lo8(receivedBuffer)
 2239 024e 90E0      		ldi r25,hi8(receivedBuffer)
 2240 0250 00D0      		rcall strtol
 2241               	.LVL206:
 2242 0252 862F      		mov r24,r22
 2243               	.LVL207:
 257:main.c        **** 			
 258:main.c        **** 			flash_erase_4k_sector(sectorAddress);
 2244               		.loc 3 258 0
 2245 0254 00D0      		rcall flash_erase_4k_sector
 2246               	.LVL208:
 2247               	.L173:
 259:main.c        **** 			USART_Transmit('1'); // Send back acknowledgement
 2248               		.loc 3 259 0
 2249 0256 81E3      		ldi r24,lo8(49)
 2250 0258 00C0      		rjmp .L172
 2251               	.LVL209:
 2252               	.L103:
 2253               	.LBE84:
 260:main.c        **** 			
 261:main.c        **** 			gba_mode(); // Set back
 262:main.c        **** 		}
 263:main.c        **** 		
 264:main.c        **** 		// Write 64 bytes to Flash address one byte write at a time (and increment)
 265:main.c        **** 		else if (receivedChar == GBA_FLASH_WRITE_BYTE) {
 2254               		.loc 3 265 0
 2255 025a 9236      		cpi r25,lo8(98)
 2256 025c 01F4      		brne .L104
 266:main.c        **** 			gb_mode();
 2257               		.loc 3 266 0
 2258 025e 00D0      		rcall gb_mode
 2259               	.LVL210:
 267:main.c        **** 			
 268:main.c        **** 			usart_read_bytes(64);
 2260               		.loc 3 268 0
 2261 0260 80E4      		ldi r24,lo8(64)
 2262 0262 00D0      		rcall usart_read_bytes
 2263               	.LVL211:
 269:main.c        **** 			
 270:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 2264               		.loc 3 270 0
 2265 0264 939A      		sbi 0x12,3
 2266               	.LVL212:
 2267 0266 90E0      		ldi r25,lo8(receivedBuffer)
 2268 0268 892E      		mov r8,r25
 2269 026a 90E0      		ldi r25,hi8(receivedBuffer)
 2270 026c 992E      		mov r9,r25
 2271 026e 00E0      		ldi r16,0
 2272 0270 10E0      		ldi r17,0
 2273               	.LVL213:
 2274               	.L105:
 2275               	.LBB85:
 271:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 272:main.c        **** 				flash_write_byte(address, receivedBuffer[x]);
 2276               		.loc 3 272 0 discriminator 3
 2277 0272 F401      		movw r30,r8
 2278 0274 6191      		ld r22,Z+
 2279 0276 4F01      		movw r8,r30
 2280 0278 C801      		movw r24,r16
 2281 027a 8C0D      		add r24,r12
 2282 027c 9D1D      		adc r25,r13
 2283 027e 00D0      		rcall flash_write_byte
 2284               	.LVL214:
 2285 0280 0F5F      		subi r16,-1
 2286 0282 1F4F      		sbci r17,-1
 2287               	.LVL215:
 271:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 2288               		.loc 3 271 0 discriminator 3
 2289 0284 0034      		cpi r16,64
 2290 0286 1105      		cpc r17,__zero_reg__
 2291 0288 01F4      		brne .L105
 2292 028a F0E4      		ldi r31,64
 2293 028c CF0E      		add r12,r31
 2294 028e D11C      		adc r13,__zero_reg__
 2295 0290 E11C      		adc r14,__zero_reg__
 2296 0292 F11C      		adc r15,__zero_reg__
 2297 0294 00C0      		rjmp .L168
 2298               	.LVL216:
 2299               	.L104:
 2300               	.LBE85:
 273:main.c        **** 				address++;
 274:main.c        **** 			}
 275:main.c        **** 			USART_Transmit('1'); // Send back acknowledgement
 276:main.c        **** 			
 277:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 278:main.c        **** 			gba_mode(); // Set back
 279:main.c        **** 		}
 280:main.c        **** 		
 281:main.c        **** 		// Write 128 bytes to flash sector for Atmel flash (and increment)
 282:main.c        **** 		else if (receivedChar == GBA_FLASH_WRITE_ATMEL) {
 2301               		.loc 3 282 0
 2302 0296 9136      		cpi r25,lo8(97)
 2303 0298 01F4      		brne .L106
 283:main.c        **** 			gb_mode();
 2304               		.loc 3 283 0
 2305 029a 00D0      		rcall gb_mode
 2306               	.LVL217:
 284:main.c        **** 			
 285:main.c        **** 			usart_read_bytes(128);
 2307               		.loc 3 285 0
 2308 029c 80E8      		ldi r24,lo8(-128)
 2309 029e 00D0      		rcall usart_read_bytes
 2310               	.LVL218:
 286:main.c        **** 			
 287:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 2311               		.loc 3 287 0
 2312 02a0 939A      		sbi 0x12,3
 288:main.c        **** 			flash_write_sector(address); // Address used as sector number
 2313               		.loc 3 288 0
 2314 02a2 C601      		movw r24,r12
 2315 02a4 00D0      		rcall flash_write_sector
 2316               	.LVL219:
 289:main.c        **** 			address++;
 2317               		.loc 3 289 0
 2318 02a6 2FEF      		ldi r18,-1
 2319 02a8 C21A      		sub r12,r18
 2320 02aa D20A      		sbc r13,r18
 2321 02ac E20A      		sbc r14,r18
 2322 02ae F20A      		sbc r15,r18
 2323               	.LVL220:
 2324 02b0 00C0      		rjmp .L168
 2325               	.LVL221:
 2326               	.L106:
 290:main.c        **** 			USART_Transmit('1'); // Send back acknowledgement
 291:main.c        **** 			
 292:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 293:main.c        **** 			gba_mode(); // Set back
 294:main.c        **** 		}
 295:main.c        **** 		
 296:main.c        **** 		
 297:main.c        **** 		// ---------- EEPROM ----------
 298:main.c        **** 		// Set EEPROM size
 299:main.c        **** 		else if (receivedChar == GBA_SET_EEPROM_SIZE) {
 2327               		.loc 3 299 0
 2328 02b2 9335      		cpi r25,lo8(83)
 2329 02b4 01F4      		brne .L107
 300:main.c        **** 			usart_read_chars(); // Read size
 2330               		.loc 3 300 0
 2331 02b6 00D0      		rcall usart_read_chars
 2332               	.LVL222:
 301:main.c        **** 			eepromSize = strtol(receivedBuffer, NULL, 16); // Convert size to dec
 2333               		.loc 3 301 0
 2334 02b8 40E1      		ldi r20,lo8(16)
 2335 02ba 50E0      		ldi r21,0
 2336 02bc 60E0      		ldi r22,0
 2337 02be 70E0      		ldi r23,0
 2338 02c0 80E0      		ldi r24,lo8(receivedBuffer)
 2339 02c2 90E0      		ldi r25,hi8(receivedBuffer)
 2340 02c4 00D0      		rcall strtol
 2341               	.LVL223:
 2342 02c6 6B83      		std Y+3,r22
 2343               	.LVL224:
 2344 02c8 00C0      		rjmp .L74
 2345               	.LVL225:
 2346               	.L107:
 302:main.c        **** 		}
 303:main.c        **** 		
 304:main.c        **** 		// Read the EEPROM on address (and increment) until anything but 1 is received
 305:main.c        **** 		else if (receivedChar == GBA_READ_EEPROM) {
 2347               		.loc 3 305 0
 2348 02ca 9536      		cpi r25,lo8(101)
 2349 02cc 01F4      		brne .L108
 306:main.c        **** 			gba_eeprom_mode();
 2350               		.loc 3 306 0
 2351 02ce 00D0      		rcall gba_eeprom_mode
 2352               	.LVL226:
 307:main.c        **** 			
 308:main.c        **** 			receivedChar = '1';
 2353               		.loc 3 308 0
 2354 02d0 81E3      		ldi r24,lo8(49)
 2355               	.L174:
 309:main.c        **** 			while (receivedChar == '1') {
 310:main.c        **** 				PORTD |= (1<<ACTIVITY_LED);
 311:main.c        **** 				gba_eeprom_read(address, eepromSize);
 312:main.c        **** 				
 313:main.c        **** 				// Send back the 8 bytes of data
 314:main.c        **** 				for (uint8_t c = 0; c < 8; c++) {
 315:main.c        **** 					USART_Transmit(eepromBuffer[c]);
 316:main.c        **** 				}
 317:main.c        **** 				address++; // Increment to next 8 bytes
 318:main.c        **** 				
 319:main.c        **** 				PORTD &= ~(1<<ACTIVITY_LED);
 320:main.c        **** 				receivedChar = USART_Receive();
 2356               		.loc 3 320 0
 2357 02d2 8093 0000 		sts receivedChar,r24
 309:main.c        **** 			while (receivedChar == '1') {
 2358               		.loc 3 309 0
 2359 02d6 8091 0000 		lds r24,receivedChar
 2360 02da 8133      		cpi r24,lo8(49)
 2361 02dc 01F0      		breq .+2
 2362 02de 00C0      		rjmp .L166
 310:main.c        **** 				gba_eeprom_read(address, eepromSize);
 2363               		.loc 3 310 0
 2364 02e0 939A      		sbi 0x12,3
 311:main.c        **** 				
 2365               		.loc 3 311 0
 2366 02e2 6B81      		ldd r22,Y+3
 2367 02e4 C601      		movw r24,r12
 2368 02e6 00D0      		rcall gba_eeprom_read
 2369               	.LVL227:
 2370 02e8 00E0      		ldi r16,lo8(eepromBuffer)
 2371 02ea 10E0      		ldi r17,hi8(eepromBuffer)
 2372               	.LVL228:
 2373               	.L110:
 2374               	.LBB86:
 315:main.c        **** 				}
 2375               		.loc 3 315 0 discriminator 3
 2376 02ec F801      		movw r30,r16
 2377 02ee 8191      		ld r24,Z+
 2378 02f0 8F01      		movw r16,r30
 2379               	.LVL229:
 2380 02f2 00D0      		rcall USART_Transmit
 2381               	.LVL230:
 314:main.c        **** 					USART_Transmit(eepromBuffer[c]);
 2382               		.loc 3 314 0 discriminator 3
 2383 02f4 2C81      		ldd r18,Y+4
 2384 02f6 2013      		cpse r18,r16
 2385 02f8 00C0      		rjmp .L110
 2386               	.LBE86:
 317:main.c        **** 				
 2387               		.loc 3 317 0
 2388 02fa 8FEF      		ldi r24,-1
 2389 02fc C81A      		sub r12,r24
 2390 02fe D80A      		sbc r13,r24
 2391 0300 E80A      		sbc r14,r24
 2392 0302 F80A      		sbc r15,r24
 2393               	.LVL231:
 319:main.c        **** 				receivedChar = USART_Receive();
 2394               		.loc 3 319 0
 2395 0304 9398      		cbi 0x12,3
 2396               		.loc 3 320 0
 2397 0306 00D0      		rcall USART_Receive
 2398               	.LVL232:
 2399 0308 00C0      		rjmp .L174
 2400               	.LVL233:
 2401               	.L108:
 321:main.c        **** 			}
 322:main.c        **** 			
 323:main.c        **** 			gba_mode(); // Set back
 324:main.c        **** 		}
 325:main.c        **** 		
 326:main.c        **** 		// Write 8 bytes to the EEPROM address (and increment)
 327:main.c        **** 		else if (receivedChar == GBA_WRITE_EEPROM) {
 2402               		.loc 3 327 0
 2403 030a 9037      		cpi r25,lo8(112)
 2404 030c 01F4      		brne .L112
 328:main.c        **** 			gba_eeprom_mode();
 2405               		.loc 3 328 0
 2406 030e 00D0      		rcall gba_eeprom_mode
 2407               	.LVL234:
 2408 0310 00E0      		ldi r16,lo8(eepromBuffer)
 2409 0312 10E0      		ldi r17,hi8(eepromBuffer)
 2410               	.LVL235:
 2411               	.L113:
 2412               	.LBB87:
 329:main.c        **** 			
 330:main.c        **** 			// Read 8 bytes from USART and place in buffer
 331:main.c        **** 			for (uint8_t x = 0; x < 8; x++) {
 332:main.c        **** 				eepromBuffer[x] = USART_Receive();
 2413               		.loc 3 332 0 discriminator 3
 2414 0314 00D0      		rcall USART_Receive
 2415               	.LVL236:
 2416 0316 F801      		movw r30,r16
 2417 0318 8193      		st Z+,r24
 2418 031a 8F01      		movw r16,r30
 2419               	.LVL237:
 331:main.c        **** 				eepromBuffer[x] = USART_Receive();
 2420               		.loc 3 331 0 discriminator 3
 2421 031c 2C81      		ldd r18,Y+4
 2422 031e 2E13      		cpse r18,r30
 2423 0320 00C0      		rjmp .L113
 2424               	.LBE87:
 333:main.c        **** 			}
 334:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 2425               		.loc 3 334 0
 2426 0322 939A      		sbi 0x12,3
 335:main.c        **** 			
 336:main.c        **** 			gba_eeprom_write(address, eepromSize);
 2427               		.loc 3 336 0
 2428 0324 6B81      		ldd r22,Y+3
 2429 0326 C601      		movw r24,r12
 2430 0328 00D0      		rcall gba_eeprom_write
 2431               	.LVL238:
 337:main.c        **** 			address++;
 2432               		.loc 3 337 0
 2433 032a 8FEF      		ldi r24,-1
 2434 032c C81A      		sub r12,r24
 2435 032e D80A      		sbc r13,r24
 2436 0330 E80A      		sbc r14,r24
 2437 0332 F80A      		sbc r15,r24
 2438               	.LVL239:
 2439               	.LBB88:
 2440               	.LBB89:
 187:c:\winavr-20100110\avr\include\util\delay.h **** 
 2441               		.loc 2 187 0
 2442 0334 EFE7      		ldi r30,lo8(15999)
 2443 0336 FEE3      		ldi r31,hi8(15999)
 2444 0338 3197      	1:	sbiw r30,1
 2445 033a 01F4      		brne 1b
 2446 033c 00C0      		rjmp .
 2447 033e 0000      		nop
 2448 0340 00C0      		rjmp .L168
 2449               	.LVL240:
 2450               	.L112:
 2451               	.LBE89:
 2452               	.LBE88:
 338:main.c        **** 			
 339:main.c        **** 			_delay_ms(8); // Wait for EEPROM to write data (8ms)
 340:main.c        **** 			USART_Transmit('1'); // Send back acknowledgement
 341:main.c        **** 			
 342:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 343:main.c        **** 			gba_mode(); // Set back
 344:main.c        **** 		}
 345:main.c        **** 		
 346:main.c        **** 		
 347:main.c        **** 		// ---------- FLASH CARTS ----------
 348:main.c        **** 		
 349:main.c        **** 		// Write address, one byte and pulse audio pin
 350:main.c        **** 		else if (receivedChar == GB_FLASH_WRITE_BYTE_AUDIO) {
 2453               		.loc 3 350 0
 2454 0342 9634      		cpi r25,lo8(70)
 2455 0344 01F4      		brne .L114
 2456               	.LBB90:
 351:main.c        **** 			usart_read_chars(); // Read address
 2457               		.loc 3 351 0
 2458 0346 00D0      		rcall usart_read_chars
 2459               	.LVL241:
 352:main.c        **** 			uint16_t flashAddress = strtol(receivedBuffer, NULL, 16); // Convert address string in hex to de
 2460               		.loc 3 352 0
 2461 0348 40E1      		ldi r20,lo8(16)
 2462 034a 50E0      		ldi r21,0
 2463 034c 60E0      		ldi r22,0
 2464 034e 70E0      		ldi r23,0
 2465 0350 80E0      		ldi r24,lo8(receivedBuffer)
 2466 0352 90E0      		ldi r25,hi8(receivedBuffer)
 2467 0354 00D0      		rcall strtol
 2468               	.LVL242:
 2469 0356 1B01      		movw r2,r22
 2470 0358 2C01      		movw r4,r24
 2471               	.LVL243:
 353:main.c        **** 			
 354:main.c        **** 			receivedChar = USART_Receive(); // Wait for byte
 2472               		.loc 3 354 0
 2473 035a 00D0      		rcall USART_Receive
 2474               	.LVL244:
 2475 035c 8093 0000 		sts receivedChar,r24
 355:main.c        **** 			if (receivedChar == GB_FLASH_WRITE_BYTE_AUDIO) {
 2476               		.loc 3 355 0
 2477 0360 8634      		cpi r24,lo8(70)
 2478 0362 01F0      		breq .+2
 2479 0364 00C0      		rjmp .L74
 2480               	.LBB91:
 356:main.c        **** 				usart_read_chars(); // Read data
 2481               		.loc 3 356 0
 2482 0366 00D0      		rcall usart_read_chars
 2483               	.LVL245:
 357:main.c        **** 				uint8_t flashByte = strtol(receivedBuffer, NULL, 16); // Convert data byte in hex to dec
 2484               		.loc 3 357 0
 2485 0368 40E1      		ldi r20,lo8(16)
 2486 036a 50E0      		ldi r21,0
 2487 036c 60E0      		ldi r22,0
 2488 036e 70E0      		ldi r23,0
 2489 0370 80E0      		ldi r24,lo8(receivedBuffer)
 2490 0372 90E0      		ldi r25,hi8(receivedBuffer)
 2491 0374 00D0      		rcall strtol
 2492               	.LVL246:
 358:main.c        **** 				
 359:main.c        **** 				PORTD |= (1<<ACTIVITY_LED);
 2493               		.loc 3 359 0
 2494 0376 939A      		sbi 0x12,3
 360:main.c        **** 				audio_flash_write_bus_cycle(flashAddress, flashByte);
 2495               		.loc 3 360 0
 2496 0378 C101      		movw r24,r2
 2497 037a 00D0      		rcall audio_flash_write_bus_cycle
 2498               	.LVL247:
 2499               	.L185:
 361:main.c        **** 				PORTD &= ~(1<<ACTIVITY_LED);
 2500               		.loc 3 361 0
 2501 037c 9398      		cbi 0x12,3
 362:main.c        **** 				
 363:main.c        **** 				USART_Transmit('1'); // Send back acknowledgement
 2502               		.loc 3 363 0
 2503 037e 81E3      		ldi r24,lo8(49)
 2504 0380 00C0      		rjmp .L164
 2505               	.LVL248:
 2506               	.L114:
 2507               	.LBE91:
 2508               	.LBE90:
 364:main.c        **** 			}
 365:main.c        **** 		}
 366:main.c        **** 		
 367:main.c        **** 		// Write 64 bytes to Flash address one byte write at a time (and increment), pulse audio pin
 368:main.c        **** 		else if (receivedChar == GB_FLASH_WRITE_64BYTE_AUDIO) {
 2509               		.loc 3 368 0
 2510 0382 9535      		cpi r25,lo8(85)
 2511 0384 01F4      		brne .L115
 369:main.c        **** 			usart_read_bytes(64);
 2512               		.loc 3 369 0
 2513 0386 80E4      		ldi r24,lo8(64)
 2514               	.LVL249:
 2515 0388 00D0      		rcall usart_read_bytes
 2516               	.LVL250:
 370:main.c        **** 			
 371:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 2517               		.loc 3 371 0
 2518 038a 939A      		sbi 0x12,3
 2519               	.LVL251:
 2520 038c 80E0      		ldi r24,lo8(receivedBuffer)
 2521 038e 882E      		mov r8,r24
 2522 0390 80E0      		ldi r24,hi8(receivedBuffer)
 2523 0392 982E      		mov r9,r24
 2524 0394 00E0      		ldi r16,0
 2525 0396 10E0      		ldi r17,0
 2526               	.LVL252:
 2527               	.L116:
 2528               	.LBB92:
 372:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 373:main.c        **** 				audio_flash_write_byte(address, receivedBuffer[x]);
 2529               		.loc 3 373 0 discriminator 3
 2530 0398 F401      		movw r30,r8
 2531 039a 6191      		ld r22,Z+
 2532 039c 4F01      		movw r8,r30
 2533 039e C801      		movw r24,r16
 2534 03a0 8C0D      		add r24,r12
 2535 03a2 9D1D      		adc r25,r13
 2536 03a4 00D0      		rcall audio_flash_write_byte
 2537               	.LVL253:
 2538 03a6 0F5F      		subi r16,-1
 2539 03a8 1F4F      		sbci r17,-1
 2540               	.LVL254:
 372:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 2541               		.loc 3 372 0 discriminator 3
 2542 03aa 0034      		cpi r16,64
 2543 03ac 1105      		cpc r17,__zero_reg__
 2544 03ae 01F4      		brne .L116
 2545 03b0 F0E4      		ldi r31,64
 2546 03b2 CF0E      		add r12,r31
 2547 03b4 D11C      		adc r13,__zero_reg__
 2548 03b6 E11C      		adc r14,__zero_reg__
 2549 03b8 F11C      		adc r15,__zero_reg__
 2550               	.LBE92:
 374:main.c        **** 				address++;
 375:main.c        **** 			}
 376:main.c        **** 			USART_Transmit('1'); // Send back acknowledgement
 2551               		.loc 3 376 0
 2552 03ba 81E3      		ldi r24,lo8(49)
 2553 03bc 00C0      		rjmp .L167
 2554               	.LVL255:
 2555               	.L115:
 377:main.c        **** 			
 378:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 379:main.c        **** 		}
 380:main.c        **** 		
 381:main.c        **** 		
 382:main.c        **** 		
 383:main.c        **** 		// ---------- General commands ----------
 384:main.c        **** 		// Set any pin as input/output
 385:main.c        **** 		// Reads the DDR/PORT (e.g. DDRB/PORTB is 'B') and the hex value that represents pins to set to a
 386:main.c        **** 		else if (receivedChar == SET_INPUT || receivedChar == SET_OUTPUT) {
 2556               		.loc 3 386 0
 2557 03be 9934      		cpi r25,lo8(73)
 2558 03c0 01F0      		breq .L117
 2559               		.loc 3 386 0 is_stmt 0 discriminator 1
 2560 03c2 9F34      		cpi r25,lo8(79)
 2561 03c4 01F0      		breq .+2
 2562 03c6 00C0      		rjmp .L118
 2563               	.L117:
 2564               	.LBB93:
 387:main.c        **** 			char portChar = USART_Receive();
 2565               		.loc 3 387 0 is_stmt 1
 2566 03c8 00D0      		rcall USART_Receive
 2567               	.LVL256:
 2568 03ca 182F      		mov r17,r24
 2569               	.LVL257:
 388:main.c        **** 			usart_read_chars();
 2570               		.loc 3 388 0
 2571 03cc 00D0      		rcall usart_read_chars
 2572               	.LVL258:
 389:main.c        **** 			uint8_t setValue = strtol(receivedBuffer, NULL, 16);
 2573               		.loc 3 389 0
 2574 03ce 40E1      		ldi r20,lo8(16)
 2575 03d0 50E0      		ldi r21,0
 2576 03d2 60E0      		ldi r22,0
 2577 03d4 70E0      		ldi r23,0
 2578 03d6 80E0      		ldi r24,lo8(receivedBuffer)
 2579 03d8 90E0      		ldi r25,hi8(receivedBuffer)
 2580 03da 00D0      		rcall strtol
 2581               	.LVL259:
 390:main.c        **** 			
 391:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 2582               		.loc 3 391 0
 2583 03dc 939A      		sbi 0x12,3
 392:main.c        **** 			if (receivedChar == SET_INPUT) {
 2584               		.loc 3 392 0
 2585 03de 8091 0000 		lds r24,receivedChar
 2586 03e2 8934      		cpi r24,lo8(73)
 2587 03e4 01F4      		brne .L119
 393:main.c        **** 				if (portChar == 'A') {
 2588               		.loc 3 393 0
 2589 03e6 1134      		cpi r17,lo8(65)
 2590 03e8 01F4      		brne .L120
 394:main.c        **** 					DDRA &= ~(setValue);
 2591               		.loc 3 394 0
 2592 03ea 8AB3      		in r24,0x1a
 2593 03ec 6095      		com r22
 2594               	.LVL260:
 2595 03ee 6823      		and r22,r24
 2596               	.LVL261:
 2597 03f0 00C0      		rjmp .L176
 2598               	.LVL262:
 2599               	.L120:
 395:main.c        **** 				}
 396:main.c        **** 				else if (portChar == 'B') {
 2600               		.loc 3 396 0
 2601 03f2 1234      		cpi r17,lo8(66)
 2602 03f4 01F4      		brne .L122
 397:main.c        **** 					DDRB &= ~(setValue);
 2603               		.loc 3 397 0
 2604 03f6 87B3      		in r24,0x17
 2605 03f8 6095      		com r22
 2606               	.LVL263:
 2607 03fa 6823      		and r22,r24
 2608               	.LVL264:
 2609 03fc 00C0      		rjmp .L177
 2610               	.LVL265:
 2611               	.L122:
 398:main.c        **** 				}
 399:main.c        **** 				else if (portChar == 'C') {
 2612               		.loc 3 399 0
 2613 03fe 1334      		cpi r17,lo8(67)
 2614 0400 01F4      		brne .L123
 400:main.c        **** 					DDRC &= ~(setValue);
 2615               		.loc 3 400 0
 2616 0402 84B3      		in r24,0x14
 2617 0404 6095      		com r22
 2618               	.LVL266:
 2619 0406 6823      		and r22,r24
 2620               	.LVL267:
 2621 0408 00C0      		rjmp .L182
 2622               	.LVL268:
 2623               	.L123:
 401:main.c        **** 				}
 402:main.c        **** 				else if (portChar == 'D') {
 2624               		.loc 3 402 0
 2625 040a 1434      		cpi r17,lo8(68)
 2626 040c 01F4      		brne .L124
 403:main.c        **** 					DDRD &= ~(setValue);
 2627               		.loc 3 403 0
 2628 040e 81B3      		in r24,0x11
 2629 0410 6095      		com r22
 2630               	.LVL269:
 2631 0412 6823      		and r22,r24
 2632               	.LVL270:
 2633 0414 00C0      		rjmp .L183
 2634               	.LVL271:
 2635               	.L124:
 404:main.c        **** 				}
 405:main.c        **** 				else if (portChar == 'E') {
 2636               		.loc 3 405 0
 2637 0416 1534      		cpi r17,lo8(69)
 2638 0418 01F0      		breq .+2
 2639 041a 00C0      		rjmp .L143
 406:main.c        **** 					DDRE &= ~(setValue);
 2640               		.loc 3 406 0
 2641 041c 86B1      		in r24,0x6
 2642 041e 6095      		com r22
 2643               	.LVL272:
 2644 0420 6823      		and r22,r24
 2645               	.LVL273:
 2646 0422 00C0      		rjmp .L184
 2647               	.LVL274:
 2648               	.L119:
 407:main.c        **** 				}
 408:main.c        **** 			}
 409:main.c        **** 			else if (receivedChar == SET_OUTPUT) {
 2649               		.loc 3 409 0
 2650 0424 8F34      		cpi r24,lo8(79)
 2651 0426 01F0      		breq .+2
 2652 0428 00C0      		rjmp .L143
 410:main.c        **** 				if (portChar == 'A') {
 2653               		.loc 3 410 0
 2654 042a 1134      		cpi r17,lo8(65)
 2655 042c 01F4      		brne .L125
 411:main.c        **** 					DDRA |= (setValue);
 2656               		.loc 3 411 0
 2657 042e 8AB3      		in r24,0x1a
 2658 0430 682B      		or r22,r24
 2659               	.LVL275:
 2660               	.L176:
 2661 0432 6ABB      		out 0x1a,r22
 2662 0434 00C0      		rjmp .L143
 2663               	.LVL276:
 2664               	.L125:
 412:main.c        **** 				}
 413:main.c        **** 				else if (portChar == 'B') {
 2665               		.loc 3 413 0
 2666 0436 1234      		cpi r17,lo8(66)
 2667 0438 01F4      		brne .L126
 414:main.c        **** 					DDRB |= (setValue);
 2668               		.loc 3 414 0
 2669 043a 87B3      		in r24,0x17
 2670 043c 682B      		or r22,r24
 2671               	.LVL277:
 2672               	.L177:
 2673 043e 67BB      		out 0x17,r22
 2674 0440 00C0      		rjmp .L143
 2675               	.LVL278:
 2676               	.L126:
 415:main.c        **** 				}
 416:main.c        **** 				else if (portChar == 'C') {
 2677               		.loc 3 416 0
 2678 0442 1334      		cpi r17,lo8(67)
 2679 0444 01F4      		brne .L127
 417:main.c        **** 					DDRC |= (setValue);
 2680               		.loc 3 417 0
 2681 0446 84B3      		in r24,0x14
 2682 0448 682B      		or r22,r24
 2683               	.LVL279:
 2684               	.L182:
 2685 044a 64BB      		out 0x14,r22
 2686 044c 00C0      		rjmp .L143
 2687               	.LVL280:
 2688               	.L127:
 418:main.c        **** 				}
 419:main.c        **** 				else if (portChar == 'D') {
 2689               		.loc 3 419 0
 2690 044e 1434      		cpi r17,lo8(68)
 2691 0450 01F4      		brne .L128
 420:main.c        **** 					DDRD |= (setValue);
 2692               		.loc 3 420 0
 2693 0452 81B3      		in r24,0x11
 2694 0454 682B      		or r22,r24
 2695               	.LVL281:
 2696               	.L183:
 2697 0456 61BB      		out 0x11,r22
 2698 0458 00C0      		rjmp .L143
 2699               	.LVL282:
 2700               	.L128:
 421:main.c        **** 				}
 422:main.c        **** 				else if (portChar == 'E') {
 2701               		.loc 3 422 0
 2702 045a 1534      		cpi r17,lo8(69)
 2703 045c 01F0      		breq .+2
 2704 045e 00C0      		rjmp .L143
 423:main.c        **** 					DDRE |= (setValue);
 2705               		.loc 3 423 0
 2706 0460 86B1      		in r24,0x6
 2707 0462 682B      		or r22,r24
 2708               	.LVL283:
 2709               	.L184:
 2710 0464 66B9      		out 0x6,r22
 2711 0466 00C0      		rjmp .L143
 2712               	.LVL284:
 2713               	.L118:
 2714               	.LBE93:
 424:main.c        **** 				}
 425:main.c        **** 			}
 426:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 427:main.c        **** 		}
 428:main.c        **** 		
 429:main.c        **** 		// Set pin output as low
 430:main.c        **** 		else if (receivedChar == SET_OUTPUT_LOW) {
 2715               		.loc 3 430 0
 2716 0468 9C34      		cpi r25,lo8(76)
 2717 046a 01F4      		brne .L129
 2718               	.LBB94:
 431:main.c        **** 			char portChar = USART_Receive();			
 2719               		.loc 3 431 0
 2720 046c 00D0      		rcall USART_Receive
 2721               	.LVL285:
 2722 046e 182F      		mov r17,r24
 2723               	.LVL286:
 432:main.c        **** 			usart_read_chars();
 2724               		.loc 3 432 0
 2725 0470 00D0      		rcall usart_read_chars
 2726               	.LVL287:
 433:main.c        **** 			uint8_t setValue = strtol(receivedBuffer, NULL, 16);
 2727               		.loc 3 433 0
 2728 0472 40E1      		ldi r20,lo8(16)
 2729 0474 50E0      		ldi r21,0
 2730 0476 60E0      		ldi r22,0
 2731 0478 70E0      		ldi r23,0
 2732 047a 80E0      		ldi r24,lo8(receivedBuffer)
 2733 047c 90E0      		ldi r25,hi8(receivedBuffer)
 2734 047e 00D0      		rcall strtol
 2735               	.LVL288:
 434:main.c        **** 			
 435:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 2736               		.loc 3 435 0
 2737 0480 939A      		sbi 0x12,3
 436:main.c        **** 			if (portChar == 'A') {
 2738               		.loc 3 436 0
 2739 0482 1134      		cpi r17,lo8(65)
 2740 0484 01F4      		brne .L130
 437:main.c        **** 				PORTA &= ~(setValue);
 2741               		.loc 3 437 0
 2742 0486 8BB3      		in r24,0x1b
 2743 0488 6095      		com r22
 2744               	.LVL289:
 2745 048a 6823      		and r22,r24
 2746               	.LVL290:
 2747 048c 00C0      		rjmp .L181
 2748               	.LVL291:
 2749               	.L130:
 438:main.c        **** 			}
 439:main.c        **** 			else if (portChar == 'B') {
 2750               		.loc 3 439 0
 2751 048e 1234      		cpi r17,lo8(66)
 2752 0490 01F4      		brne .L132
 440:main.c        **** 				PORTB &= ~(setValue);
 2753               		.loc 3 440 0
 2754 0492 88B3      		in r24,0x18
 2755 0494 6095      		com r22
 2756               	.LVL292:
 2757 0496 6823      		and r22,r24
 2758               	.LVL293:
 2759 0498 00C0      		rjmp .L180
 2760               	.LVL294:
 2761               	.L132:
 441:main.c        **** 			}
 442:main.c        **** 			else if (portChar == 'C') {
 2762               		.loc 3 442 0
 2763 049a 1334      		cpi r17,lo8(67)
 2764 049c 01F4      		brne .L133
 443:main.c        **** 				PORTC &= ~(setValue);
 2765               		.loc 3 443 0
 2766 049e 85B3      		in r24,0x15
 2767 04a0 6095      		com r22
 2768               	.LVL295:
 2769 04a2 6823      		and r22,r24
 2770               	.LVL296:
 2771 04a4 00C0      		rjmp .L179
 2772               	.LVL297:
 2773               	.L133:
 444:main.c        **** 			}
 445:main.c        **** 			else if (portChar == 'D') {
 2774               		.loc 3 445 0
 2775 04a6 1434      		cpi r17,lo8(68)
 2776 04a8 01F4      		brne .L134
 446:main.c        **** 				PORTD &= ~(setValue);
 2777               		.loc 3 446 0
 2778 04aa 82B3      		in r24,0x12
 2779 04ac 6095      		com r22
 2780               	.LVL298:
 2781 04ae 6823      		and r22,r24
 2782               	.LVL299:
 2783 04b0 00C0      		rjmp .L178
 2784               	.LVL300:
 2785               	.L134:
 447:main.c        **** 			}
 448:main.c        **** 			else if (portChar == 'E') {
 2786               		.loc 3 448 0
 2787 04b2 1534      		cpi r17,lo8(69)
 2788 04b4 01F0      		breq .+2
 2789 04b6 00C0      		rjmp .L143
 449:main.c        **** 				PORTE &= ~(setValue);
 2790               		.loc 3 449 0
 2791 04b8 87B1      		in r24,0x7
 2792 04ba 6095      		com r22
 2793               	.LVL301:
 2794 04bc 6823      		and r22,r24
 2795               	.LVL302:
 2796 04be 00C0      		rjmp .L175
 2797               	.LVL303:
 2798               	.L129:
 2799               	.LBE94:
 450:main.c        **** 			}
 451:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 452:main.c        **** 		}
 453:main.c        **** 		
 454:main.c        **** 		// Set pin output as high
 455:main.c        **** 		else if (receivedChar == SET_OUTPUT_HIGH) {
 2800               		.loc 3 455 0
 2801 04c0 9834      		cpi r25,lo8(72)
 2802 04c2 01F4      		brne .L135
 2803               	.LBB95:
 456:main.c        **** 			char portChar = USART_Receive();			
 2804               		.loc 3 456 0
 2805 04c4 00D0      		rcall USART_Receive
 2806               	.LVL304:
 2807 04c6 182F      		mov r17,r24
 2808               	.LVL305:
 457:main.c        **** 			usart_read_chars();
 2809               		.loc 3 457 0
 2810 04c8 00D0      		rcall usart_read_chars
 2811               	.LVL306:
 458:main.c        **** 			uint8_t setValue = strtol(receivedBuffer, NULL, 16);
 2812               		.loc 3 458 0
 2813 04ca 40E1      		ldi r20,lo8(16)
 2814 04cc 50E0      		ldi r21,0
 2815 04ce 60E0      		ldi r22,0
 2816 04d0 70E0      		ldi r23,0
 2817 04d2 80E0      		ldi r24,lo8(receivedBuffer)
 2818 04d4 90E0      		ldi r25,hi8(receivedBuffer)
 2819 04d6 00D0      		rcall strtol
 2820               	.LVL307:
 459:main.c        **** 			
 460:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 2821               		.loc 3 460 0
 2822 04d8 939A      		sbi 0x12,3
 461:main.c        **** 			if (portChar == 'A') {
 2823               		.loc 3 461 0
 2824 04da 1134      		cpi r17,lo8(65)
 2825 04dc 01F4      		brne .L136
 462:main.c        **** 				PORTA |= (setValue);
 2826               		.loc 3 462 0
 2827 04de 8BB3      		in r24,0x1b
 2828 04e0 682B      		or r22,r24
 2829               	.LVL308:
 2830               	.L181:
 2831 04e2 6BBB      		out 0x1b,r22
 2832 04e4 00C0      		rjmp .L143
 2833               	.LVL309:
 2834               	.L136:
 463:main.c        **** 			}
 464:main.c        **** 			else if (portChar == 'B') {
 2835               		.loc 3 464 0
 2836 04e6 1234      		cpi r17,lo8(66)
 2837 04e8 01F4      		brne .L138
 465:main.c        **** 				PORTB |= (setValue);
 2838               		.loc 3 465 0
 2839 04ea 88B3      		in r24,0x18
 2840 04ec 682B      		or r22,r24
 2841               	.LVL310:
 2842               	.L180:
 2843 04ee 68BB      		out 0x18,r22
 2844 04f0 00C0      		rjmp .L143
 2845               	.LVL311:
 2846               	.L138:
 466:main.c        **** 			}
 467:main.c        **** 			else if (portChar == 'C') {
 2847               		.loc 3 467 0
 2848 04f2 1334      		cpi r17,lo8(67)
 2849 04f4 01F4      		brne .L139
 468:main.c        **** 				PORTC |= (setValue);
 2850               		.loc 3 468 0
 2851 04f6 85B3      		in r24,0x15
 2852 04f8 682B      		or r22,r24
 2853               	.LVL312:
 2854               	.L179:
 2855 04fa 65BB      		out 0x15,r22
 2856 04fc 00C0      		rjmp .L143
 2857               	.LVL313:
 2858               	.L139:
 469:main.c        **** 			}
 470:main.c        **** 			else if (portChar == 'D') {
 2859               		.loc 3 470 0
 2860 04fe 1434      		cpi r17,lo8(68)
 2861 0500 01F4      		brne .L140
 471:main.c        **** 				PORTD |= (setValue);
 2862               		.loc 3 471 0
 2863 0502 82B3      		in r24,0x12
 2864 0504 682B      		or r22,r24
 2865               	.LVL314:
 2866               	.L178:
 2867 0506 62BB      		out 0x12,r22
 2868 0508 00C0      		rjmp .L143
 2869               	.LVL315:
 2870               	.L140:
 472:main.c        **** 			}
 473:main.c        **** 			else if (portChar == 'E') {
 2871               		.loc 3 473 0
 2872 050a 1534      		cpi r17,lo8(69)
 2873 050c 01F4      		brne .L143
 474:main.c        **** 				PORTE |= (setValue);
 2874               		.loc 3 474 0
 2875 050e 87B1      		in r24,0x7
 2876 0510 682B      		or r22,r24
 2877               	.LVL316:
 2878               	.L175:
 2879 0512 67B9      		out 0x7,r22
 2880 0514 00C0      		rjmp .L143
 2881               	.LVL317:
 2882               	.L135:
 2883               	.LBE95:
 475:main.c        **** 			}
 476:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 477:main.c        **** 		}
 478:main.c        **** 		
 479:main.c        **** 		// Read all pins of a PORT and return the value
 480:main.c        **** 		else if (receivedChar == READ_INPUT) {
 2884               		.loc 3 480 0
 2885 0516 9434      		cpi r25,lo8(68)
 2886 0518 01F4      		brne .L141
 2887               	.LBB96:
 481:main.c        **** 			char portChar = USART_Receive();			
 2888               		.loc 3 481 0
 2889 051a 00D0      		rcall USART_Receive
 2890               	.LVL318:
 482:main.c        **** 			
 483:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 2891               		.loc 3 483 0
 2892 051c 939A      		sbi 0x12,3
 484:main.c        **** 			if (portChar == 'A') {
 2893               		.loc 3 484 0
 2894 051e 8134      		cpi r24,lo8(65)
 2895 0520 01F4      		brne .L142
 485:main.c        **** 				USART_Transmit(PINA);
 2896               		.loc 3 485 0
 2897 0522 89B3      		in r24,0x19
 2898               	.LVL319:
 2899 0524 00C0      		rjmp .L167
 2900               	.LVL320:
 2901               	.L142:
 486:main.c        **** 			}
 487:main.c        **** 			else if (portChar == 'B') {
 2902               		.loc 3 487 0
 2903 0526 8234      		cpi r24,lo8(66)
 2904 0528 01F4      		brne .L144
 488:main.c        **** 				USART_Transmit(PINB);
 2905               		.loc 3 488 0
 2906 052a 86B3      		in r24,0x16
 2907               	.LVL321:
 2908 052c 00C0      		rjmp .L167
 2909               	.LVL322:
 2910               	.L144:
 489:main.c        **** 			}
 490:main.c        **** 			else if (portChar == 'C') {
 2911               		.loc 3 490 0
 2912 052e 8334      		cpi r24,lo8(67)
 2913 0530 01F4      		brne .L145
 491:main.c        **** 				USART_Transmit(PINC);
 2914               		.loc 3 491 0
 2915 0532 83B3      		in r24,0x13
 2916               	.LVL323:
 2917 0534 00C0      		rjmp .L167
 2918               	.LVL324:
 2919               	.L145:
 492:main.c        **** 			}
 493:main.c        **** 			else if (portChar == 'D') {
 2920               		.loc 3 493 0
 2921 0536 8434      		cpi r24,lo8(68)
 2922 0538 01F4      		brne .L146
 494:main.c        **** 				USART_Transmit(PIND);
 2923               		.loc 3 494 0
 2924 053a 80B3      		in r24,0x10
 2925               	.LVL325:
 2926 053c 00C0      		rjmp .L167
 2927               	.LVL326:
 2928               	.L146:
 495:main.c        **** 			}
 496:main.c        **** 			else if (portChar == 'E') {
 2929               		.loc 3 496 0
 2930 053e 8534      		cpi r24,lo8(69)
 2931 0540 01F4      		brne .L143
 497:main.c        **** 				USART_Transmit(PINE);
 2932               		.loc 3 497 0
 2933 0542 85B1      		in r24,0x5
 2934               	.LVL327:
 2935               	.L167:
 2936 0544 00D0      		rcall USART_Transmit
 2937               	.LVL328:
 2938               	.L143:
 498:main.c        **** 			}
 499:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 2939               		.loc 3 499 0
 2940 0546 9398      		cbi 0x12,3
 2941               	.LBE96:
 2942 0548 00C0      		rjmp .L74
 2943               	.LVL329:
 2944               	.L141:
 500:main.c        **** 		}
 501:main.c        **** 		
 502:main.c        **** 		// Set the reset common lines variable on or off, useful if you are controlling all the pins dire
 503:main.c        **** 		else if (receivedChar == RESET_COMMON_LINES) {
 2945               		.loc 3 503 0
 2946 054a 9D34      		cpi r25,lo8(77)
 2947 054c 01F4      		brne .L147
 2948               	.LBB97:
 504:main.c        **** 			char commonChar = USART_Receive();
 2949               		.loc 3 504 0
 2950 054e 00D0      		rcall USART_Receive
 2951               	.LVL330:
 505:main.c        **** 			if (commonChar == '1') {
 2952               		.loc 3 505 0
 2953 0550 8133      		cpi r24,lo8(49)
 2954 0552 01F4      		brne .L186
 506:main.c        **** 				resetCommonLines = 1;
 2955               		.loc 3 506 0
 2956 0554 21E0      		ldi r18,lo8(1)
 2957 0556 2983      		std Y+1,r18
 2958 0558 00C0      		rjmp .L163
 2959               	.L186:
 507:main.c        **** 			}
 508:main.c        **** 			else if (commonChar == '0') {
 2960               		.loc 3 508 0
 2961 055a 8033      		cpi r24,lo8(48)
 2962 055c 01F0      		breq .+2
 2963 055e 00C0      		rjmp .L74
 509:main.c        **** 				resetCommonLines = 0;
 2964               		.loc 3 509 0
 2965 0560 1982      		std Y+1,__zero_reg__
 2966 0562 00C0      		rjmp .L75
 2967               	.LVL331:
 2968               	.L147:
 2969               	.LBE97:
 510:main.c        **** 			}
 511:main.c        **** 		}
 512:main.c        **** 		
 513:main.c        **** 		// Send back the PCB version number
 514:main.c        **** 		else if (receivedChar == READ_PCB_VERSION) {
 2970               		.loc 3 514 0
 2971 0564 9836      		cpi r25,lo8(104)
 2972 0566 01F4      		brne .L148
 515:main.c        **** 			USART_Transmit(PCB_VERSION);
 2973               		.loc 3 515 0
 2974 0568 82E0      		ldi r24,lo8(2)
 2975               	.LVL332:
 2976 056a 00C0      		rjmp .L164
 2977               	.LVL333:
 2978               	.L148:
 516:main.c        **** 		}
 517:main.c        **** 		
 518:main.c        **** 		// Send back the firmware version number
 519:main.c        **** 		else if (receivedChar == READ_FIRMWARE_VERSION) {
 2979               		.loc 3 519 0
 2980 056c 9635      		cpi r25,lo8(86)
 2981 056e 01F4      		brne .L149
 520:main.c        **** 			USART_Transmit(FIRMWARE_VERSION);
 2982               		.loc 3 520 0
 2983 0570 83E0      		ldi r24,lo8(3)
 2984               	.LVL334:
 2985               	.L164:
 2986 0572 00D0      		rcall USART_Transmit
 2987               	.LVL335:
 2988 0574 00C0      		rjmp .L74
 2989               	.LVL336:
 2990               	.L149:
 521:main.c        **** 		}
 522:main.c        **** 		
 523:main.c        **** 		// Reset the AVR if it matches the number
 524:main.c        **** 		else if (receivedChar == RESET_AVR) {
 2991               		.loc 3 524 0
 2992 0576 9A32      		cpi r25,lo8(42)
 2993 0578 01F0      		breq .+2
 2994 057a 00C0      		rjmp .L74
 2995               	.LBB98:
 525:main.c        **** 			usart_read_chars();
 2996               		.loc 3 525 0
 2997 057c 00D0      		rcall usart_read_chars
 2998               	.LVL337:
 526:main.c        **** 			uint32_t resetValue = strtol(receivedBuffer, NULL, 16);
 2999               		.loc 3 526 0
 3000 057e 40E1      		ldi r20,lo8(16)
 3001 0580 50E0      		ldi r21,0
 3002 0582 60E0      		ldi r22,0
 3003 0584 70E0      		ldi r23,0
 3004 0586 80E0      		ldi r24,lo8(receivedBuffer)
 3005 0588 90E0      		ldi r25,hi8(receivedBuffer)
 3006 058a 00D0      		rcall strtol
 3007               	.LVL338:
 527:main.c        **** 			if (resetValue == RESET_VALUE) {
 3008               		.loc 3 527 0
 3009 058c 613E      		cpi r22,-31
 3010 058e 754E      		sbci r23,-27
 3011 0590 8740      		sbci r24,7
 3012 0592 9105      		cpc r25,__zero_reg__
 3013 0594 01F0      		breq .+2
 3014 0596 00C0      		rjmp .L74
 528:main.c        **** 				// Clear watchdog flag
 529:main.c        **** 				MCUCSR &= ~(1<<WDRF);
 3015               		.loc 3 529 0
 3016 0598 84B7      		in r24,0x34
 3017 059a 877F      		andi r24,lo8(-9)
 3018 059c 84BF      		out 0x34,r24
 530:main.c        **** 				
 531:main.c        **** 				// Start timed sequence
 532:main.c        **** 				WDTCR = (1<<WDCE) | (1<<WDE);
 3019               		.loc 3 532 0
 3020 059e 88E1      		ldi r24,lo8(24)
 3021 05a0 81BD      		out 0x21,r24
 533:main.c        **** 				
 534:main.c        **** 				// Reset in 250 ms
 535:main.c        **** 				WDTCR = (1<<WDP2) | (1<<WDE);
 3022               		.loc 3 535 0
 3023 05a2 9CE0      		ldi r25,lo8(12)
 3024 05a4 91BD      		out 0x21,r25
 3025               	.LVL339:
 3026               	.LBB73:
 3027               	.LBB72:
 3028               		.loc 4 105 0
 3029 05a6 C501      		movw r24,r10
 3030               	/* #APP */
 3031               	 ;  105 "c:\winavr-20100110\avr\include\util\delay_basic.h" 1
 3032 05a8 0197      		1: sbiw r24,1
 3033 05aa 01F4      		brne 1b
 3034               	 ;  0 "" 2
 3035               	.LVL340:
 3036               	/* #NOAPP */
 3037 05ac 00C0      		rjmp .L74
 3038               	.LBE72:
 3039               	.LBE73:
 3040               	.LBE98:
 3041               		.cfi_endproc
 3042               	.LFE39:
 3044               		.comm	flashChipIdBuffer,2,1
 3045               		.comm	eepromBuffer,8,1
 3046               		.comm	receivedChar,1,1
 3047               		.comm	receivedBuffer,129,1
 3048               		.text
 3049               	.Letext0:
 3050               		.file 5 "c:\\winavr-20100110\\avr\\include\\stdint.h"
 3051               		.file 6 "c:\\winavr-20100110\\avr\\include\\stdlib.h"
DEFINED SYMBOLS
                            *ABS*:00000000 main.c
C:\Users\Alex\AppData\Local\Temp\cc8AKZ2a.s:2      *ABS*:0000003e __SP_H__
C:\Users\Alex\AppData\Local\Temp\cc8AKZ2a.s:3      *ABS*:0000003d __SP_L__
C:\Users\Alex\AppData\Local\Temp\cc8AKZ2a.s:4      *ABS*:0000003f __SREG__
C:\Users\Alex\AppData\Local\Temp\cc8AKZ2a.s:5      *ABS*:00000000 __tmp_reg__
C:\Users\Alex\AppData\Local\Temp\cc8AKZ2a.s:6      *ABS*:00000001 __zero_reg__
C:\Users\Alex\AppData\Local\Temp\cc8AKZ2a.s:12     .text:00000000 USART_Receive
C:\Users\Alex\AppData\Local\Temp\cc8AKZ2a.s:34     .text:00000008 USART_Transmit
C:\Users\Alex\AppData\Local\Temp\cc8AKZ2a.s:55     .text:00000010 usart_read_bytes
                            *COM*:00000081 receivedBuffer
C:\Users\Alex\AppData\Local\Temp\cc8AKZ2a.s:124    .text:00000040 usart_read_chars
C:\Users\Alex\AppData\Local\Temp\cc8AKZ2a.s:168    .text:0000005c rd_wr_csmreq_cs2_reset
C:\Users\Alex\AppData\Local\Temp\cc8AKZ2a.s:190    .text:00000066 gb_mode
C:\Users\Alex\AppData\Local\Temp\cc8AKZ2a.s:217    .text:00000076 set_16bit_address
C:\Users\Alex\AppData\Local\Temp\cc8AKZ2a.s:236    .text:0000007c read_8bit_data
C:\Users\Alex\AppData\Local\Temp\cc8AKZ2a.s:276    .text:0000008e write_8bit_data
C:\Users\Alex\AppData\Local\Temp\cc8AKZ2a.s:350    .text:000000c8 gba_mode
C:\Users\Alex\AppData\Local\Temp\cc8AKZ2a.s:377    .text:000000d8 gba_set_24bit_address
C:\Users\Alex\AppData\Local\Temp\cc8AKZ2a.s:430    .text:00000104 gba_read_16bit_data
C:\Users\Alex\AppData\Local\Temp\cc8AKZ2a.s:478    .text:00000122 gba_read_ram_8bit_data
C:\Users\Alex\AppData\Local\Temp\cc8AKZ2a.s:518    .text:00000134 gba_write_ram_8bit_data
C:\Users\Alex\AppData\Local\Temp\cc8AKZ2a.s:585    .text:00000162 gba_eeprom_mode
C:\Users\Alex\AppData\Local\Temp\cc8AKZ2a.s:613    .text:00000174 gba_eeprom_set_address
C:\Users\Alex\AppData\Local\Temp\cc8AKZ2a.s:752    .text:000001dc gba_eeprom_read
                            *COM*:00000008 eepromBuffer
C:\Users\Alex\AppData\Local\Temp\cc8AKZ2a.s:884    .text:00000236 gba_eeprom_write
C:\Users\Alex\AppData\Local\Temp\cc8AKZ2a.s:1000   .text:0000028a flash_write_bus_cycle
C:\Users\Alex\AppData\Local\Temp\cc8AKZ2a.s:1059   .text:000002b2 flash_read_chip_id
                            *COM*:00000002 flashChipIdBuffer
C:\Users\Alex\AppData\Local\Temp\cc8AKZ2a.s:1162   .text:0000031c flash_switch_bank
C:\Users\Alex\AppData\Local\Temp\cc8AKZ2a.s:1211   .text:00000342 flash_erase_4k_sector
C:\Users\Alex\AppData\Local\Temp\cc8AKZ2a.s:1285   .text:0000038a flash_write_byte
C:\Users\Alex\AppData\Local\Temp\cc8AKZ2a.s:1355   .text:000003c2 flash_write_sector
C:\Users\Alex\AppData\Local\Temp\cc8AKZ2a.s:1467   .text:0000042e audio_flash_write_bus_cycle
C:\Users\Alex\AppData\Local\Temp\cc8AKZ2a.s:1530   .text:00000456 audio_flash_write_byte
C:\Users\Alex\AppData\Local\Temp\cc8AKZ2a.s:1600   .text:0000048e setup
C:\Users\Alex\AppData\Local\Temp\cc8AKZ2a.s:1694   .text.startup:00000000 main
                            *COM*:00000001 receivedChar

UNDEFINED SYMBOLS
strtol
atoi
__do_clear_bss
