   1               		.file	"main.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               	.global	USART_Receive
  12               	USART_Receive:
  13               	.LFB12:
  14               		.file 1 "setup.c"
   1:setup.c       **** /*
   2:setup.c       ****  GBxCart RW
   3:setup.c       ****  PCB version: 1.1 or 1.2
   4:setup.c       ****  Firmware version: R8
   5:setup.c       ****  Author: Alex from insideGadgets (www.insidegadgets.com)
   6:setup.c       ****  Created: 7/11/2016
   7:setup.c       ****  Last Modified: 15/02/2018
   8:setup.c       ****  
   9:setup.c       ****  */
  10:setup.c       ****  
  11:setup.c       **** #ifndef cbi
  12:setup.c       **** #define cbi(sfr, bit) (_SFR_BYTE(sfr) &= ~_BV(bit))
  13:setup.c       **** #endif
  14:setup.c       **** #ifndef sbi
  15:setup.c       **** #define sbi(sfr, bit) (_SFR_BYTE(sfr) |= _BV(bit))
  16:setup.c       **** #endif
  17:setup.c       **** 
  18:setup.c       **** #ifndef NULL
  19:setup.c       **** #define NULL ((void *)0)
  20:setup.c       **** #endif
  21:setup.c       **** 
  22:setup.c       **** #define LOW 0
  23:setup.c       **** #define HIGH 1
  24:setup.c       **** #define false 0
  25:setup.c       **** #define true 1
  26:setup.c       **** 
  27:setup.c       **** #define SWITCH_DETECT PD2
  28:setup.c       **** #define ACTIVITY_LED PD3
  29:setup.c       **** #define LED_5V PD7
  30:setup.c       **** #define LED_3V PE0
  31:setup.c       **** 
  32:setup.c       **** #define WR_PIN PD6
  33:setup.c       **** #define RD_PIN PD5
  34:setup.c       **** #define CS_MREQ_PIN PD4
  35:setup.c       **** #define CS2_PIN PE2
  36:setup.c       **** #define AUDIO_PIN PE1
  37:setup.c       **** 
  38:setup.c       **** #define wrPin_high	PORTD |= (1<<WR_PIN);
  39:setup.c       **** #define wrPin_low		PORTD &= ~(1<<WR_PIN);
  40:setup.c       **** #define rdPin_high	PORTD |= (1<<RD_PIN);
  41:setup.c       **** #define rdPin_low		PORTD &= ~(1<<RD_PIN);
  42:setup.c       **** #define cs_mreqPin_high		PORTD |= (1<<CS_MREQ_PIN);
  43:setup.c       **** #define cs_mreqPin_low		PORTD &= ~(1<<CS_MREQ_PIN);
  44:setup.c       **** #define cs2Pin_high		PORTE |= (1<<CS2_PIN);
  45:setup.c       **** #define cs2Pin_low		PORTE &= ~(1<<CS2_PIN);
  46:setup.c       **** #define audioPin_high		PORTE |= (1<<AUDIO_PIN);
  47:setup.c       **** #define audioPin_low		PORTE &= ~(1<<AUDIO_PIN);
  48:setup.c       **** 
  49:setup.c       **** #define GB_MODE 1
  50:setup.c       **** #define GBA_MODE 2
  51:setup.c       **** 
  52:setup.c       **** // GB/GBC
  53:setup.c       **** #define PORT_ADDR7_0 PORTB
  54:setup.c       **** #define PORT_ADDR15_8 PORTA
  55:setup.c       **** #define PORT_DATA7_0 PORTC
  56:setup.c       **** 
  57:setup.c       **** #define DDR_ADDR7_0 DDRB
  58:setup.c       **** #define DDR_ADDR15_8 DDRA
  59:setup.c       **** #define DDR_DATA7_0 DDRC
  60:setup.c       **** 
  61:setup.c       **** #define PIN_ADDR7_0 PINB
  62:setup.c       **** #define PIN_ADDR15_8 PINA
  63:setup.c       **** #define PIN_DATA7_0 PINC
  64:setup.c       **** 
  65:setup.c       **** #define BANK_WRITE 0
  66:setup.c       **** #define MEMORY_WRITE 1
  67:setup.c       **** 
  68:setup.c       **** // GBA
  69:setup.c       **** #define EEPROM_WRITE 1
  70:setup.c       **** #define EEPROM_READ 0
  71:setup.c       **** 
  72:setup.c       **** #define EEPROM_NONE 0
  73:setup.c       **** #define EEPROM_4KBIT 1
  74:setup.c       **** #define EEPROM_64KBIT 2
  75:setup.c       **** 
  76:setup.c       **** #define AD0 PB0
  77:setup.c       **** #define ad0Pin_high		PORTB |= (1<<AD0);
  78:setup.c       **** #define ad0Pin_low		PORTB &= ~(1<<AD0);
  79:setup.c       **** 
  80:setup.c       **** #define A23 PC7
  81:setup.c       **** #define a23Pin_high		PORTC |= (1<<A23);
  82:setup.c       **** #define a23Pin_low		PORTC &= ~(1<<A23);
  83:setup.c       **** 
  84:setup.c       **** #define GBA_DDR_ROM_ADDR7_0 DDRB
  85:setup.c       **** #define GBA_DDR_ROM_ADDR15_8 DDRA
  86:setup.c       **** #define GBA_DDR_ROM_ADDR23_16 DDRC
  87:setup.c       **** #define GBA_DDR_ROM_DATA7_0 DDRB
  88:setup.c       **** #define GBA_DDR_ROM_DATA15_8 DDRA
  89:setup.c       **** #define GBA_DDR_RAM_DATA7_0 DDRC
  90:setup.c       **** #define GBA_DDR_EEPROM_DATA7_0 DDRB
  91:setup.c       **** 
  92:setup.c       **** #define GBA_PORT_ROM_ADDR7_0 PORTB
  93:setup.c       **** #define GBA_PORT_ROM_ADDR15_8 PORTA
  94:setup.c       **** #define GBA_PORT_ROM_ADDR23_16 PORTC
  95:setup.c       **** #define GBA_PORT_ROM_DATA7_0 PORTB
  96:setup.c       **** #define GBA_PORT_ROM_DATA15_8 PORTA
  97:setup.c       **** #define GBA_PORT_RAM_DATA7_0 PORTC
  98:setup.c       **** #define GBA_PORT_EEPROM_DATA7_0 PORTB
  99:setup.c       **** 
 100:setup.c       **** #define GBA_PIN_ROM_DATA7_0 PINB
 101:setup.c       **** #define GBA_PIN_ROM_DATA15_8 PINA
 102:setup.c       **** #define GBA_PIN_RAM_DATA7_0 PINC
 103:setup.c       **** #define GBA_PIN_EEPROM_DATA7_0 PINB
 104:setup.c       **** 
 105:setup.c       **** // GB/GBC commands
 106:setup.c       **** #define SET_START_ADDRESS 'A'
 107:setup.c       **** #define READ_ROM_RAM 'R'
 108:setup.c       **** #define WRITE_RAM 'W'
 109:setup.c       **** #define SET_BANK 'B'
 110:setup.c       **** #define GB_CART_MODE 'G'
 111:setup.c       **** 
 112:setup.c       **** // GBA commands
 113:setup.c       **** #define GBA_READ_ROM 'r'
 114:setup.c       **** #define GBA_READ_SRAM 'm'
 115:setup.c       **** #define GBA_WRITE_SRAM 'w'
 116:setup.c       **** #define GBA_WRITE_ONE_BYTE_SRAM 'o'
 117:setup.c       **** #define GBA_CART_MODE 'g'
 118:setup.c       **** 
 119:setup.c       **** #define GBA_FLASH_READ_ID 'i'
 120:setup.c       **** #define GBA_FLASH_SET_BANK 'k'
 121:setup.c       **** #define GBA_FLASH_4K_SECTOR_ERASE 's'
 122:setup.c       **** #define GBA_FLASH_WRITE_BYTE 'b'
 123:setup.c       **** #define GBA_FLASH_WRITE_ATMEL 'a'
 124:setup.c       **** 
 125:setup.c       **** #define GBA_SET_EEPROM_SIZE 'S'
 126:setup.c       **** #define GBA_READ_EEPROM 'e'
 127:setup.c       **** #define GBA_WRITE_EEPROM 'p'
 128:setup.c       **** 
 129:setup.c       **** // Flash Cart commands
 130:setup.c       **** #define GB_FLASH_WRITE_BYTE 'F'
 131:setup.c       **** #define GB_FLASH_WRITE_64BYTE 'T'
 132:setup.c       **** 	#define GB_AUDIO_FLASH_WRITE 'U'
 133:setup.c       **** 	#define GB_WR_FLASH_WRITE 'E'
 134:setup.c       **** 	#define GB_WR_FLASH_BYTE_WRITE 'N'
 135:setup.c       **** 	#define GB_BV5_FLASH_WRITE '5'
 136:setup.c       **** 	#define GB_WORD_FLASH_WRITE 'Y'
 137:setup.c       **** 
 138:setup.c       **** #define GBA_FLASH_CART_WRITE_BYTE 'n'
 139:setup.c       **** #define GBA_FLASH_WRITE_64BYTE 'q'
 140:setup.c       **** 
 141:setup.c       **** // General commands
 142:setup.c       **** #define CART_MODE 'C'
 143:setup.c       **** #define SET_INPUT 'I'
 144:setup.c       **** #define SET_OUTPUT 'O'
 145:setup.c       **** #define SET_OUTPUT_LOW 'L'
 146:setup.c       **** #define SET_OUTPUT_HIGH 'H'
 147:setup.c       **** #define READ_INPUT 'D'
 148:setup.c       **** #define RESET_COMMON_LINES 'M'
 149:setup.c       **** #define READ_FIRMWARE_VERSION 'V'
 150:setup.c       **** #define READ_PCB_VERSION 'h'
 151:setup.c       **** 
 152:setup.c       **** #define RESET_AVR '*'
 153:setup.c       **** #define RESET_VALUE 0x7E5E1
 154:setup.c       **** 
 155:setup.c       **** 
 156:setup.c       **** char receivedBuffer[129];
 157:setup.c       **** char receivedChar;
 158:setup.c       **** uint8_t eepromBuffer[8];
 159:setup.c       **** uint8_t flashChipIdBuffer[2];
 160:setup.c       **** 
 161:setup.c       **** // Receive USART data
 162:setup.c       **** uint8_t USART_Receive(void) {
  15               		.loc 1 162 0
  16               		.cfi_startproc
  17               	/* prologue: function */
  18               	/* frame size = 0 */
  19               	/* stack size = 0 */
  20               	.L__stack_usage = 0
  21               	.L2:
 163:setup.c       **** 	while ( !(UCSRA & (1<<RXC)) ); // Wait for data to be received
  22               		.loc 1 163 0 discriminator 1
  23 0000 5F9B      		sbis 0xb,7
  24 0002 00C0      		rjmp .L2
 164:setup.c       **** 	return UDR; // Get and return received data from buffer
  25               		.loc 1 164 0
  26 0004 8CB1      		in r24,0xc
 165:setup.c       **** }
  27               		.loc 1 165 0
  28 0006 0895      		ret
  29               		.cfi_endproc
  30               	.LFE12:
  32               	.global	USART_Transmit
  34               	USART_Transmit:
  35               	.LFB13:
 166:setup.c       **** 
 167:setup.c       **** // Transmit USART data
 168:setup.c       **** void USART_Transmit(unsigned char data) {
  36               		.loc 1 168 0
  37               		.cfi_startproc
  38               	/* prologue: function */
  39               	/* frame size = 0 */
  40               	/* stack size = 0 */
  41               	.L__stack_usage = 0
  42               	.LVL0:
  43               	.L6:
 169:setup.c       **** 	while ( !( UCSRA & (1<<UDRE)) ); // Wait for empty transmit buffer
  44               		.loc 1 169 0 discriminator 1
  45 0008 5D9B      		sbis 0xb,5
  46 000a 00C0      		rjmp .L6
 170:setup.c       **** 	UDR = data;
  47               		.loc 1 170 0
  48 000c 8CB9      		out 0xc,r24
  49 000e 0895      		ret
  50               		.cfi_endproc
  51               	.LFE13:
  53               	.global	usart_read_bytes
  55               	usart_read_bytes:
  56               	.LFB14:
 171:setup.c       **** }
 172:setup.c       **** 
 173:setup.c       **** // Read 1-128 bytes from the USART 
 174:setup.c       **** void usart_read_bytes(uint8_t count) {
  57               		.loc 1 174 0
  58               		.cfi_startproc
  59               	.LVL1:
  60 0010 0F93      		push r16
  61               	.LCFI0:
  62               		.cfi_def_cfa_offset 3
  63               		.cfi_offset 16, -2
  64 0012 1F93      		push r17
  65               	.LCFI1:
  66               		.cfi_def_cfa_offset 4
  67               		.cfi_offset 17, -3
  68 0014 CF93      		push r28
  69               	.LCFI2:
  70               		.cfi_def_cfa_offset 5
  71               		.cfi_offset 28, -4
  72 0016 DF93      		push r29
  73               	.LCFI3:
  74               		.cfi_def_cfa_offset 6
  75               		.cfi_offset 29, -5
  76               	/* prologue: function */
  77               	/* frame size = 0 */
  78               	/* stack size = 4 */
  79               	.L__stack_usage = 4
  80 0018 D82F      		mov r29,r24
  81               	.LVL2:
  82 001a 00E0      		ldi r16,lo8(receivedBuffer)
  83 001c 10E0      		ldi r17,hi8(receivedBuffer)
  84               	.LBB69:
 175:setup.c       **** 	for (uint8_t x = 0; x < count; x++) {
  85               		.loc 1 175 0
  86 001e C0E0      		ldi r28,0
  87               	.LVL3:
  88               	.L10:
  89               		.loc 1 175 0 is_stmt 0 discriminator 1
  90 0020 CD17      		cp r28,r29
  91 0022 01F0      		breq .L12
 176:setup.c       **** 		receivedBuffer[x] = USART_Receive();
  92               		.loc 1 176 0 is_stmt 1 discriminator 3
  93 0024 00D0      		rcall USART_Receive
  94               	.LVL4:
  95 0026 F801      		movw r30,r16
  96 0028 8193      		st Z+,r24
  97 002a 8F01      		movw r16,r30
 175:setup.c       **** 	for (uint8_t x = 0; x < count; x++) {
  98               		.loc 1 175 0 discriminator 3
  99 002c CF5F      		subi r28,lo8(-(1))
 100               	.LVL5:
 101 002e 00C0      		rjmp .L10
 102               	.L12:
 103               	/* epilogue start */
 104               	.LBE69:
 177:setup.c       **** 	}
 178:setup.c       **** }
 105               		.loc 1 178 0
 106 0030 DF91      		pop r29
 107               	.LVL6:
 108 0032 CF91      		pop r28
 109               	.LVL7:
 110 0034 1F91      		pop r17
 111 0036 0F91      		pop r16
 112 0038 0895      		ret
 113               		.cfi_endproc
 114               	.LFE14:
 116               	.global	usart_read_chars
 118               	usart_read_chars:
 119               	.LFB15:
 179:setup.c       **** 
 180:setup.c       **** // Read the USART until a 0 (string terminator byte) is received
 181:setup.c       **** void usart_read_chars(void) {
 120               		.loc 1 181 0
 121               		.cfi_startproc
 122 003a CF93      		push r28
 123               	.LCFI4:
 124               		.cfi_def_cfa_offset 3
 125               		.cfi_offset 28, -2
 126               	/* prologue: function */
 127               	/* frame size = 0 */
 128               	/* stack size = 1 */
 129               	.L__stack_usage = 1
 130               	.LVL8:
 182:setup.c       **** 	uint8_t x = 0;
 131               		.loc 1 182 0
 132 003c C0E0      		ldi r28,0
 133               	.LVL9:
 134               	.L15:
 183:setup.c       **** 	while (1) {
 184:setup.c       **** 		receivedBuffer[x] = USART_Receive();
 135               		.loc 1 184 0
 136 003e 00D0      		rcall USART_Receive
 137               	.LVL10:
 138 0040 EC2F      		mov r30,r28
 139 0042 F0E0      		ldi r31,0
 140 0044 E050      		subi r30,lo8(-(receivedBuffer))
 141 0046 F040      		sbci r31,hi8(-(receivedBuffer))
 142 0048 8083      		st Z,r24
 185:setup.c       **** 		if (receivedBuffer[x] == 0) {
 143               		.loc 1 185 0
 144 004a 8823      		tst r24
 145 004c 01F0      		breq .L13
 186:setup.c       **** 			break;
 187:setup.c       **** 		}
 188:setup.c       **** 		x++;
 146               		.loc 1 188 0
 147 004e CF5F      		subi r28,lo8(-(1))
 148               	.LVL11:
 189:setup.c       **** 	}
 149               		.loc 1 189 0
 150 0050 00C0      		rjmp .L15
 151               	.L13:
 152               	/* epilogue start */
 190:setup.c       **** }
 153               		.loc 1 190 0
 154 0052 CF91      		pop r28
 155               	.LVL12:
 156 0054 0895      		ret
 157               		.cfi_endproc
 158               	.LFE15:
 160               	.global	rd_wr_csmreq_cs2_reset
 162               	rd_wr_csmreq_cs2_reset:
 163               	.LFB16:
 191:setup.c       **** 
 192:setup.c       **** // Turn RD, WR, CS/MREQ and CS2 to high so they are deselected (reset state)
 193:setup.c       **** void rd_wr_csmreq_cs2_reset(void) {
 164               		.loc 1 193 0
 165               		.cfi_startproc
 166               	/* prologue: function */
 167               	/* frame size = 0 */
 168               	/* stack size = 0 */
 169               	.L__stack_usage = 0
 194:setup.c       **** 	cs2Pin_high; // CS2 off
 170               		.loc 1 194 0
 171 0056 3A9A      		sbi 0x7,2
 195:setup.c       **** 	cs_mreqPin_high; // CS/MREQ off
 172               		.loc 1 195 0
 173 0058 949A      		sbi 0x12,4
 196:setup.c       **** 	rdPin_high; // RD off
 174               		.loc 1 196 0
 175 005a 959A      		sbi 0x12,5
 197:setup.c       **** 	wrPin_high; // WR off
 176               		.loc 1 197 0
 177 005c 969A      		sbi 0x12,6
 178 005e 0895      		ret
 179               		.cfi_endproc
 180               	.LFE16:
 182               	.global	gb_mode
 184               	gb_mode:
 185               	.LFB17:
 198:setup.c       **** }
 199:setup.c       **** 
 200:setup.c       **** 
 201:setup.c       **** 
 202:setup.c       **** // ****** Gameboy / Gameboy Colour functions ******
 203:setup.c       **** 
 204:setup.c       **** // Set Gameboy mode
 205:setup.c       **** void gb_mode(void) {
 186               		.loc 1 205 0
 187               		.cfi_startproc
 188               	/* prologue: function */
 189               	/* frame size = 0 */
 190               	/* stack size = 0 */
 191               	.L__stack_usage = 0
 206:setup.c       **** 	// Set inputs
 207:setup.c       **** 	PORT_DATA7_0 = 0;
 192               		.loc 1 207 0
 193 0060 15BA      		out 0x15,__zero_reg__
 208:setup.c       **** 	DDR_DATA7_0 = 0;
 194               		.loc 1 208 0
 195 0062 14BA      		out 0x14,__zero_reg__
 209:setup.c       **** 	
 210:setup.c       **** 	// Set outputs
 211:setup.c       **** 	PORT_ADDR7_0 = 0;
 196               		.loc 1 211 0
 197 0064 18BA      		out 0x18,__zero_reg__
 212:setup.c       **** 	PORT_ADDR15_8 = 0;
 198               		.loc 1 212 0
 199 0066 1BBA      		out 0x1b,__zero_reg__
 213:setup.c       **** 	DDR_ADDR7_0 = 0xFF;
 200               		.loc 1 213 0
 201 0068 8FEF      		ldi r24,lo8(-1)
 202 006a 87BB      		out 0x17,r24
 214:setup.c       **** 	DDR_ADDR15_8 = 0xFF;
 203               		.loc 1 214 0
 204 006c 8ABB      		out 0x1a,r24
 205 006e 0895      		ret
 206               		.cfi_endproc
 207               	.LFE17:
 209               	.global	set_16bit_address
 211               	set_16bit_address:
 212               	.LFB18:
 215:setup.c       **** }
 216:setup.c       **** 
 217:setup.c       **** // Set the 16 bit address on A15-0
 218:setup.c       **** void set_16bit_address(uint16_t address) {
 213               		.loc 1 218 0
 214               		.cfi_startproc
 215               	.LVL13:
 216               	/* prologue: function */
 217               	/* frame size = 0 */
 218               	/* stack size = 0 */
 219               	.L__stack_usage = 0
 219:setup.c       **** 	PORT_ADDR15_8 = (address >> 8);
 220               		.loc 1 219 0
 221 0070 9BBB      		out 0x1b,r25
 220:setup.c       **** 	PORT_ADDR7_0 = (address & 0xFF);
 222               		.loc 1 220 0
 223 0072 88BB      		out 0x18,r24
 224 0074 0895      		ret
 225               		.cfi_endproc
 226               	.LFE18:
 228               	.global	read_8bit_data
 230               	read_8bit_data:
 231               	.LFB19:
 221:setup.c       **** }
 222:setup.c       **** 
 223:setup.c       **** // Set the address and read a byte from the 8 bit data line
 224:setup.c       **** uint8_t read_8bit_data(uint16_t address) {
 232               		.loc 1 224 0
 233               		.cfi_startproc
 234               	.LVL14:
 235               	/* prologue: function */
 236               	/* frame size = 0 */
 237               	/* stack size = 0 */
 238               	.L__stack_usage = 0
 225:setup.c       **** 	set_16bit_address(address);
 239               		.loc 1 225 0
 240 0076 00D0      		rcall set_16bit_address
 241               	.LVL15:
 226:setup.c       **** 	
 227:setup.c       **** 	cs_mreqPin_low;
 242               		.loc 1 227 0
 243 0078 9498      		cbi 0x12,4
 228:setup.c       **** 	rdPin_low;
 244               		.loc 1 228 0
 245 007a 9598      		cbi 0x12,5
 229:setup.c       **** 	
 230:setup.c       **** 	asm volatile("nop"); // Delay a little (minimum needed is 1 nops, 2 nops for GB camera)
 246               		.loc 1 230 0
 247               	/* #APP */
 248               	 ;  230 "setup.c" 1
 249 007c 0000      		nop
 250               	 ;  0 "" 2
 231:setup.c       **** 	asm volatile("nop");
 251               		.loc 1 231 0
 252               	 ;  231 "setup.c" 1
 253 007e 0000      		nop
 254               	 ;  0 "" 2
 232:setup.c       **** 	uint8_t data = PIN_DATA7_0; // Read data
 255               		.loc 1 232 0
 256               	/* #NOAPP */
 257 0080 83B3      		in r24,0x13
 258               	.LVL16:
 233:setup.c       **** 	
 234:setup.c       **** 	rdPin_high;
 259               		.loc 1 234 0
 260 0082 959A      		sbi 0x12,5
 235:setup.c       **** 	cs_mreqPin_high;
 261               		.loc 1 235 0
 262 0084 949A      		sbi 0x12,4
 236:setup.c       **** 	
 237:setup.c       **** 	return data;
 238:setup.c       **** }
 263               		.loc 1 238 0
 264 0086 0895      		ret
 265               		.cfi_endproc
 266               	.LFE19:
 268               	.global	write_8bit_data
 270               	write_8bit_data:
 271               	.LFB20:
 239:setup.c       **** 
 240:setup.c       **** // Set the address and write a byte to the 8 bit data line and pulse cs/mREQ if writing to RAM
 241:setup.c       **** void write_8bit_data(uint16_t address, uint8_t data, uint8_t type) {
 272               		.loc 1 241 0
 273               		.cfi_startproc
 274               	.LVL17:
 275 0088 CF93      		push r28
 276               	.LCFI5:
 277               		.cfi_def_cfa_offset 3
 278               		.cfi_offset 28, -2
 279 008a DF93      		push r29
 280               	.LCFI6:
 281               		.cfi_def_cfa_offset 4
 282               		.cfi_offset 29, -3
 283               	/* prologue: function */
 284               	/* frame size = 0 */
 285               	/* stack size = 2 */
 286               	.L__stack_usage = 2
 287 008c D62F      		mov r29,r22
 288 008e C42F      		mov r28,r20
 242:setup.c       **** 	set_16bit_address(address);
 289               		.loc 1 242 0
 290 0090 00D0      		rcall set_16bit_address
 291               	.LVL18:
 243:setup.c       **** 	
 244:setup.c       **** 	DDR_DATA7_0 = 0xFF; // Set data pins as outputs
 292               		.loc 1 244 0
 293 0092 8FEF      		ldi r24,lo8(-1)
 294 0094 84BB      		out 0x14,r24
 245:setup.c       **** 	PORT_DATA7_0 = data; // Set data
 295               		.loc 1 245 0
 296 0096 D5BB      		out 0x15,r29
 246:setup.c       **** 	
 247:setup.c       **** 	// Pulse WR and mREQ if the type matches
 248:setup.c       **** 	wrPin_low;
 297               		.loc 1 248 0
 298 0098 9698      		cbi 0x12,6
 249:setup.c       **** 	if (type == MEMORY_WRITE) {
 299               		.loc 1 249 0
 300 009a C130      		cpi r28,lo8(1)
 301 009c 01F4      		brne .L21
 250:setup.c       **** 		cs_mreqPin_low;
 302               		.loc 1 250 0
 303 009e 9498      		cbi 0x12,4
 304               	.L21:
 251:setup.c       **** 	}
 252:setup.c       **** 	
 253:setup.c       **** 	asm volatile("nop");
 305               		.loc 1 253 0
 306               	/* #APP */
 307               	 ;  253 "setup.c" 1
 308 00a0 0000      		nop
 309               	 ;  0 "" 2
 254:setup.c       **** 	
 255:setup.c       **** 	if (type == MEMORY_WRITE) {
 310               		.loc 1 255 0
 311               	/* #NOAPP */
 312 00a2 C130      		cpi r28,lo8(1)
 313 00a4 01F4      		brne .L22
 256:setup.c       **** 		cs_mreqPin_high;
 314               		.loc 1 256 0
 315 00a6 949A      		sbi 0x12,4
 316               	.L22:
 257:setup.c       **** 	}
 258:setup.c       **** 	wrPin_high;
 317               		.loc 1 258 0
 318 00a8 969A      		sbi 0x12,6
 259:setup.c       **** 	
 260:setup.c       **** 	// Clear data outputs and set data pins as inputs
 261:setup.c       **** 	PORT_DATA7_0 = 0;
 319               		.loc 1 261 0
 320 00aa 15BA      		out 0x15,__zero_reg__
 262:setup.c       **** 	DDR_DATA7_0 = 0;
 321               		.loc 1 262 0
 322 00ac 14BA      		out 0x14,__zero_reg__
 323               	/* epilogue start */
 263:setup.c       **** }
 324               		.loc 1 263 0
 325 00ae DF91      		pop r29
 326               	.LVL19:
 327 00b0 CF91      		pop r28
 328               	.LVL20:
 329 00b2 0895      		ret
 330               		.cfi_endproc
 331               	.LFE20:
 333               	.global	gba_mode
 335               	gba_mode:
 336               	.LFB21:
 264:setup.c       **** 
 265:setup.c       **** 
 266:setup.c       **** 
 267:setup.c       **** // ****** Gameboy Advance functions ****** 
 268:setup.c       **** 
 269:setup.c       **** // Set GBA mode
 270:setup.c       **** void gba_mode(void) {
 337               		.loc 1 270 0
 338               		.cfi_startproc
 339               	/* prologue: function */
 340               	/* frame size = 0 */
 341               	/* stack size = 0 */
 342               	.L__stack_usage = 0
 271:setup.c       **** 	// Set outputs for reading ROM addresses as default
 272:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = 0;
 343               		.loc 1 272 0
 344 00b4 18BA      		out 0x18,__zero_reg__
 273:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = 0;
 345               		.loc 1 273 0
 346 00b6 1BBA      		out 0x1b,__zero_reg__
 274:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = 0;
 347               		.loc 1 274 0
 348 00b8 15BA      		out 0x15,__zero_reg__
 275:setup.c       **** 	GBA_DDR_ROM_ADDR7_0 = 0xFF;
 349               		.loc 1 275 0
 350 00ba 8FEF      		ldi r24,lo8(-1)
 351 00bc 87BB      		out 0x17,r24
 276:setup.c       **** 	GBA_DDR_ROM_ADDR15_8 = 0xFF;
 352               		.loc 1 276 0
 353 00be 8ABB      		out 0x1a,r24
 277:setup.c       **** 	GBA_DDR_ROM_ADDR23_16 = 0xFF;
 354               		.loc 1 277 0
 355 00c0 84BB      		out 0x14,r24
 356 00c2 0895      		ret
 357               		.cfi_endproc
 358               	.LFE21:
 360               	.global	gba_set_24bit_address
 362               	gba_set_24bit_address:
 363               	.LFB22:
 278:setup.c       **** }
 279:setup.c       **** 
 280:setup.c       **** // Set the 24 bit address on A23-0
 281:setup.c       **** void gba_set_24bit_address(uint32_t address) {	
 364               		.loc 1 281 0
 365               		.cfi_startproc
 366               	.LVL21:
 367 00c4 0F93      		push r16
 368               	.LCFI7:
 369               		.cfi_def_cfa_offset 3
 370               		.cfi_offset 16, -2
 371 00c6 1F93      		push r17
 372               	.LCFI8:
 373               		.cfi_def_cfa_offset 4
 374               		.cfi_offset 17, -3
 375               	/* prologue: function */
 376               	/* frame size = 0 */
 377               	/* stack size = 2 */
 378               	.L__stack_usage = 2
 282:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = 0; // Set 0-23 address lines low and set as outputs
 379               		.loc 1 282 0
 380 00c8 15BA      		out 0x15,__zero_reg__
 283:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = 0;
 381               		.loc 1 283 0
 382 00ca 1BBA      		out 0x1b,__zero_reg__
 284:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = 0;
 383               		.loc 1 284 0
 384 00cc 18BA      		out 0x18,__zero_reg__
 285:setup.c       **** 	GBA_DDR_ROM_ADDR23_16 = 0xFF;
 385               		.loc 1 285 0
 386 00ce 2FEF      		ldi r18,lo8(-1)
 387 00d0 24BB      		out 0x14,r18
 286:setup.c       **** 	GBA_DDR_ROM_ADDR15_8 = 0xFF;
 388               		.loc 1 286 0
 389 00d2 2ABB      		out 0x1a,r18
 287:setup.c       **** 	GBA_DDR_ROM_ADDR7_0 = 0xFF;
 390               		.loc 1 287 0
 391 00d4 27BB      		out 0x17,r18
 288:setup.c       **** 	
 289:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = (address >> 16);
 392               		.loc 1 289 0
 393 00d6 8C01      		movw r16,r24
 394 00d8 2227      		clr r18
 395 00da 3327      		clr r19
 396 00dc 05BB      		out 0x15,r16
 290:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = (address >> 8);
 397               		.loc 1 290 0
 398 00de 072F      		mov r16,r23
 399 00e0 182F      		mov r17,r24
 400 00e2 292F      		mov r18,r25
 401 00e4 3327      		clr r19
 402 00e6 0BBB      		out 0x1b,r16
 291:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = (address & 0xFF);
 403               		.loc 1 291 0
 404 00e8 68BB      		out 0x18,r22
 405               	/* epilogue start */
 292:setup.c       **** }
 406               		.loc 1 292 0
 407 00ea 1F91      		pop r17
 408 00ec 0F91      		pop r16
 409 00ee 0895      		ret
 410               		.cfi_endproc
 411               	.LFE22:
 413               	.global	gba_read_16bit_data
 415               	gba_read_16bit_data:
 416               	.LFB23:
 293:setup.c       **** 
 294:setup.c       **** 
 295:setup.c       **** 
 296:setup.c       **** // ---------- ROM/SRAM ----------
 297:setup.c       **** 
 298:setup.c       **** // Read a byte from the 16 bit data line non-sequentially
 299:setup.c       **** uint16_t gba_read_16bit_data(uint32_t address) {
 417               		.loc 1 299 0
 418               		.cfi_startproc
 419               	.LVL22:
 420               	/* prologue: function */
 421               	/* frame size = 0 */
 422               	/* stack size = 0 */
 423               	.L__stack_usage = 0
 300:setup.c       **** 	gba_set_24bit_address(address);
 424               		.loc 1 300 0
 425 00f0 00D0      		rcall gba_set_24bit_address
 426               	.LVL23:
 301:setup.c       **** 	
 302:setup.c       **** 	cs_mreqPin_low;
 427               		.loc 1 302 0
 428 00f2 9498      		cbi 0x12,4
 303:setup.c       **** 	
 304:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = 0; // Set address lines low and set as inputs
 429               		.loc 1 304 0
 430 00f4 1BBA      		out 0x1b,__zero_reg__
 305:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = 0;
 431               		.loc 1 305 0
 432 00f6 18BA      		out 0x18,__zero_reg__
 306:setup.c       **** 	GBA_DDR_ROM_ADDR15_8 = 0;
 433               		.loc 1 306 0
 434 00f8 1ABA      		out 0x1a,__zero_reg__
 307:setup.c       **** 	GBA_DDR_ROM_ADDR7_0 = 0;
 435               		.loc 1 307 0
 436 00fa 17BA      		out 0x17,__zero_reg__
 308:setup.c       **** 	
 309:setup.c       **** 	rdPin_low;
 437               		.loc 1 309 0
 438 00fc 9598      		cbi 0x12,5
 310:setup.c       **** 	asm volatile("nop");
 439               		.loc 1 310 0
 440               	/* #APP */
 441               	 ;  310 "setup.c" 1
 442 00fe 0000      		nop
 443               	 ;  0 "" 2
 311:setup.c       **** 	
 312:setup.c       **** 	uint16_t data = (GBA_PIN_ROM_DATA15_8 << 8) | GBA_PIN_ROM_DATA7_0; // Read data
 444               		.loc 1 312 0
 445               	/* #NOAPP */
 446 0100 29B3      		in r18,0x19
 447 0102 86B3      		in r24,0x16
 448               	.LVL24:
 313:setup.c       **** 	
 314:setup.c       **** 	rdPin_high;
 449               		.loc 1 314 0
 450 0104 959A      		sbi 0x12,5
 315:setup.c       **** 	cs_mreqPin_high;
 451               		.loc 1 315 0
 452 0106 949A      		sbi 0x12,4
 316:setup.c       **** 	
 317:setup.c       **** 	return data;
 453               		.loc 1 317 0
 454 0108 90E0      		ldi r25,0
 318:setup.c       **** }
 455               		.loc 1 318 0
 456 010a 922B      		or r25,r18
 457 010c 0895      		ret
 458               		.cfi_endproc
 459               	.LFE23:
 461               	.global	gba_read_ram_8bit_data
 463               	gba_read_ram_8bit_data:
 464               	.LFB24:
 319:setup.c       **** 
 320:setup.c       **** // Set the address and read a byte from the 8 bit data line
 321:setup.c       **** uint8_t gba_read_ram_8bit_data(uint16_t address) {
 465               		.loc 1 321 0
 466               		.cfi_startproc
 467               	.LVL25:
 468               	/* prologue: function */
 469               	/* frame size = 0 */
 470               	/* stack size = 0 */
 471               	.L__stack_usage = 0
 322:setup.c       **** 	set_16bit_address(address);
 472               		.loc 1 322 0
 473 010e 00D0      		rcall set_16bit_address
 474               	.LVL26:
 323:setup.c       **** 	
 324:setup.c       **** 	rdPin_low;
 475               		.loc 1 324 0
 476 0110 9598      		cbi 0x12,5
 325:setup.c       **** 	cs2Pin_low; // CS2 pin low for SRAM/Flash select
 477               		.loc 1 325 0
 478 0112 3A98      		cbi 0x7,2
 326:setup.c       **** 	
 327:setup.c       **** 	asm volatile("nop"); // Delay a little (minimum needed is 2)
 479               		.loc 1 327 0
 480               	/* #APP */
 481               	 ;  327 "setup.c" 1
 482 0114 0000      		nop
 483               	 ;  0 "" 2
 328:setup.c       **** 	asm volatile("nop");
 484               		.loc 1 328 0
 485               	 ;  328 "setup.c" 1
 486 0116 0000      		nop
 487               	 ;  0 "" 2
 329:setup.c       **** 	
 330:setup.c       **** 	uint8_t data = GBA_PIN_RAM_DATA7_0; // Read data
 488               		.loc 1 330 0
 489               	/* #NOAPP */
 490 0118 83B3      		in r24,0x13
 491               	.LVL27:
 331:setup.c       **** 	
 332:setup.c       **** 	cs2Pin_high;
 492               		.loc 1 332 0
 493 011a 3A9A      		sbi 0x7,2
 333:setup.c       **** 	rdPin_high;
 494               		.loc 1 333 0
 495 011c 959A      		sbi 0x12,5
 334:setup.c       **** 	
 335:setup.c       **** 	return data;
 336:setup.c       **** }
 496               		.loc 1 336 0
 497 011e 0895      		ret
 498               		.cfi_endproc
 499               	.LFE24:
 501               	.global	gba_write_ram_8bit_data
 503               	gba_write_ram_8bit_data:
 504               	.LFB25:
 337:setup.c       **** 
 338:setup.c       **** // Set the address and write a byte to the 8 bit data line 
 339:setup.c       **** void gba_write_ram_8bit_data(uint16_t address, uint8_t data) {
 505               		.loc 1 339 0
 506               		.cfi_startproc
 507               	.LVL28:
 508 0120 CF93      		push r28
 509               	.LCFI9:
 510               		.cfi_def_cfa_offset 3
 511               		.cfi_offset 28, -2
 512               	/* prologue: function */
 513               	/* frame size = 0 */
 514               	/* stack size = 1 */
 515               	.L__stack_usage = 1
 516 0122 C62F      		mov r28,r22
 340:setup.c       **** 	set_16bit_address(address);
 517               		.loc 1 340 0
 518 0124 00D0      		rcall set_16bit_address
 519               	.LVL29:
 341:setup.c       **** 	
 342:setup.c       **** 	GBA_DDR_RAM_DATA7_0 = 0xFF; // Set data pins as outputs
 520               		.loc 1 342 0
 521 0126 8FEF      		ldi r24,lo8(-1)
 522 0128 84BB      		out 0x14,r24
 343:setup.c       **** 	GBA_PORT_RAM_DATA7_0 = data; // Set data
 523               		.loc 1 343 0
 524 012a C5BB      		out 0x15,r28
 344:setup.c       **** 	
 345:setup.c       **** 	// Pulse WR
 346:setup.c       **** 	wrPin_low;
 525               		.loc 1 346 0
 526 012c 9698      		cbi 0x12,6
 347:setup.c       **** 	cs2Pin_low; // CS2 pin low for SRAM/Flash select
 527               		.loc 1 347 0
 528 012e 3A98      		cbi 0x7,2
 348:setup.c       **** 	
 349:setup.c       **** 	asm volatile("nop");
 529               		.loc 1 349 0
 530               	/* #APP */
 531               	 ;  349 "setup.c" 1
 532 0130 0000      		nop
 533               	 ;  0 "" 2
 350:setup.c       **** 	asm volatile("nop");
 534               		.loc 1 350 0
 535               	 ;  350 "setup.c" 1
 536 0132 0000      		nop
 537               	 ;  0 "" 2
 351:setup.c       **** 	
 352:setup.c       **** 	cs2Pin_high;
 538               		.loc 1 352 0
 539               	/* #NOAPP */
 540 0134 3A9A      		sbi 0x7,2
 353:setup.c       **** 	wrPin_high;
 541               		.loc 1 353 0
 542 0136 969A      		sbi 0x12,6
 354:setup.c       **** 	
 355:setup.c       **** 	// Clear data outputs and set data pins as inputs
 356:setup.c       **** 	GBA_PORT_RAM_DATA7_0 = 0;
 543               		.loc 1 356 0
 544 0138 15BA      		out 0x15,__zero_reg__
 357:setup.c       **** 	GBA_DDR_RAM_DATA7_0 = 0;
 545               		.loc 1 357 0
 546 013a 14BA      		out 0x14,__zero_reg__
 547               	/* epilogue start */
 358:setup.c       **** }
 548               		.loc 1 358 0
 549 013c CF91      		pop r28
 550               	.LVL30:
 551 013e 0895      		ret
 552               		.cfi_endproc
 553               	.LFE25:
 555               	.global	gba_eeprom_mode
 557               	gba_eeprom_mode:
 558               	.LFB26:
 359:setup.c       **** 
 360:setup.c       **** 
 361:setup.c       **** 
 362:setup.c       **** // ---------- EEPROM ----------
 363:setup.c       **** 
 364:setup.c       **** // Set address/data all high (includes AD0/A23)
 365:setup.c       **** void gba_eeprom_mode (void) {
 559               		.loc 1 365 0
 560               		.cfi_startproc
 561               	/* prologue: function */
 562               	/* frame size = 0 */
 563               	/* stack size = 0 */
 564               	.L__stack_usage = 0
 366:setup.c       **** 	GBA_DDR_ROM_ADDR7_0 = 0xFF;
 565               		.loc 1 366 0
 566 0140 8FEF      		ldi r24,lo8(-1)
 567 0142 87BB      		out 0x17,r24
 367:setup.c       **** 	GBA_DDR_ROM_ADDR15_8 = 0xFF;
 568               		.loc 1 367 0
 569 0144 8ABB      		out 0x1a,r24
 368:setup.c       **** 	GBA_DDR_ROM_ADDR23_16 = 0xFF;
 570               		.loc 1 368 0
 571 0146 84BB      		out 0x14,r24
 369:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = 0x80;
 572               		.loc 1 369 0
 573 0148 90E8      		ldi r25,lo8(-128)
 574 014a 98BB      		out 0x18,r25
 370:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = 0xFF;
 575               		.loc 1 370 0
 576 014c 8BBB      		out 0x1b,r24
 371:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = 0xFF;
 577               		.loc 1 371 0
 578 014e 85BB      		out 0x15,r24
 579 0150 0895      		ret
 580               		.cfi_endproc
 581               	.LFE26:
 583               	.global	gba_eeprom_set_address
 585               	gba_eeprom_set_address:
 586               	.LFB27:
 372:setup.c       **** }
 373:setup.c       **** 
 374:setup.c       **** // Send out EEPROM address serially (WR clock, AD0 data out)
 375:setup.c       **** void gba_eeprom_set_address(uint16_t address, uint8_t eepromSize, uint8_t command) {
 587               		.loc 1 375 0
 588               		.cfi_startproc
 589               	.LVL31:
 590               	/* prologue: function */
 591               	/* frame size = 0 */
 592               	/* stack size = 0 */
 593               	.L__stack_usage = 0
 376:setup.c       **** 	cs_mreqPin_low;
 594               		.loc 1 376 0
 595 0152 9498      		cbi 0x12,4
 596               	.LVL32:
 377:setup.c       **** 	
 378:setup.c       **** 	int8_t x = 0;
 379:setup.c       **** 	if (eepromSize == EEPROM_64KBIT) {
 597               		.loc 1 379 0
 598 0154 6230      		cpi r22,lo8(2)
 599 0156 01F4      		brne .L30
 380:setup.c       **** 		if (command == EEPROM_READ) {
 600               		.loc 1 380 0
 601 0158 4111      		cpse r20,__zero_reg__
 602 015a 00C0      		rjmp .L31
 381:setup.c       **** 			address |= (1<<15) | (1<<14); // Set upper 2 bits high for read request
 603               		.loc 1 381 0
 604 015c 906C      		ori r25,192
 605               	.LVL33:
 606               	.L40:
 382:setup.c       **** 		}
 383:setup.c       **** 		else {
 384:setup.c       **** 			address |= (1<<15); // Set upper 1 bit high for write request
 385:setup.c       **** 		}
 386:setup.c       **** 		x = 15;
 607               		.loc 1 386 0
 608 015e 2FE0      		ldi r18,lo8(15)
 609               	.L33:
 610               	.LVL34:
 387:setup.c       **** 	}
 388:setup.c       **** 	else {
 389:setup.c       **** 		if (command == EEPROM_READ) {
 390:setup.c       **** 			address |= (1<<7) | (1<<6);
 391:setup.c       **** 		}
 392:setup.c       **** 		else {
 393:setup.c       **** 			address |= (1<<7);
 394:setup.c       **** 		}
 395:setup.c       **** 		x = 7;
 396:setup.c       **** 	}
 397:setup.c       **** 	
 398:setup.c       **** 	// Loop through address, 8 or 16 bits depending on EEPROM (includes the 2 bits for request type)
 399:setup.c       **** 	while (x >= 0) {
 400:setup.c       **** 		if (address & (1<<x)) {
 611               		.loc 1 400 0
 612 0160 E1E0      		ldi r30,lo8(1)
 613 0162 F0E0      		ldi r31,0
 614 0164 00C0      		rjmp .L32
 615               	.LVL35:
 616               	.L31:
 384:setup.c       **** 		}
 617               		.loc 1 384 0
 618 0166 9068      		ori r25,128
 619               	.LVL36:
 620 0168 00C0      		rjmp .L40
 621               	.L30:
 389:setup.c       **** 			address |= (1<<7) | (1<<6);
 622               		.loc 1 389 0
 623 016a 4111      		cpse r20,__zero_reg__
 624 016c 00C0      		rjmp .L34
 390:setup.c       **** 		}
 625               		.loc 1 390 0
 626 016e 806C      		ori r24,192
 627               	.LVL37:
 628 0170 00C0      		rjmp .L39
 629               	.L34:
 393:setup.c       **** 		}
 630               		.loc 1 393 0
 631 0172 8068      		ori r24,128
 632               	.LVL38:
 633               	.L39:
 395:setup.c       **** 	}
 634               		.loc 1 395 0
 635 0174 27E0      		ldi r18,lo8(7)
 636 0176 00C0      		rjmp .L33
 637               	.LVL39:
 638               	.L35:
 401:setup.c       **** 			ad0Pin_high;
 402:setup.c       **** 		}
 403:setup.c       **** 		else {
 404:setup.c       **** 			ad0Pin_low;
 639               		.loc 1 404 0
 640 0178 C098      		cbi 0x18,0
 641               	.L36:
 405:setup.c       **** 		}
 406:setup.c       **** 		
 407:setup.c       **** 		wrPin_low; // CLK
 642               		.loc 1 407 0
 643 017a 9698      		cbi 0x12,6
 408:setup.c       **** 		asm ("nop");
 644               		.loc 1 408 0
 645               	/* #APP */
 646               	 ;  408 "setup.c" 1
 647 017c 0000      		nop
 648               	 ;  0 "" 2
 409:setup.c       **** 		asm ("nop");
 649               		.loc 1 409 0
 650               	 ;  409 "setup.c" 1
 651 017e 0000      		nop
 652               	 ;  0 "" 2
 410:setup.c       **** 		wrPin_high; 
 653               		.loc 1 410 0
 654               	/* #NOAPP */
 655 0180 969A      		sbi 0x12,6
 411:setup.c       **** 		asm ("nop");
 656               		.loc 1 411 0
 657               	/* #APP */
 658               	 ;  411 "setup.c" 1
 659 0182 0000      		nop
 660               	 ;  0 "" 2
 412:setup.c       **** 		asm ("nop");
 661               		.loc 1 412 0
 662               	 ;  412 "setup.c" 1
 663 0184 0000      		nop
 664               	 ;  0 "" 2
 665               	/* #NOAPP */
 666 0186 2150      		subi r18,lo8(-(-1))
 667               	.LVL40:
 399:setup.c       **** 		if (address & (1<<x)) {
 668               		.loc 1 399 0
 669 0188 27FD      		sbrc r18,7
 670 018a 00C0      		rjmp .L41
 671               	.L32:
 400:setup.c       **** 			ad0Pin_high;
 672               		.loc 1 400 0
 673 018c BF01      		movw r22,r30
 674 018e 022E      		mov r0,r18
 675 0190 00C0      		rjmp 2f
 676               		1:
 677 0192 660F      		lsl r22
 678 0194 771F      		rol r23
 679               		2:
 680 0196 0A94      		dec r0
 681 0198 02F4      		brpl 1b
 682 019a 6823      		and r22,r24
 683 019c 7923      		and r23,r25
 684 019e 672B      		or r22,r23
 685 01a0 01F0      		breq .L35
 401:setup.c       **** 		}
 686               		.loc 1 401 0
 687 01a2 C09A      		sbi 0x18,0
 688 01a4 00C0      		rjmp .L36
 689               	.L41:
 413:setup.c       **** 		
 414:setup.c       **** 		x--;
 415:setup.c       **** 	}
 416:setup.c       **** 	
 417:setup.c       **** 	// Only send stop bit (0) and WR/CS high if reading, as writing is done in 1 continuous chunk
 418:setup.c       **** 	if (command == EEPROM_READ) {  
 690               		.loc 1 418 0
 691 01a6 4111      		cpse r20,__zero_reg__
 692 01a8 00C0      		rjmp .L29
 419:setup.c       **** 		ad0Pin_low;
 693               		.loc 1 419 0
 694 01aa C098      		cbi 0x18,0
 420:setup.c       **** 		asm ("nop");
 695               		.loc 1 420 0
 696               	/* #APP */
 697               	 ;  420 "setup.c" 1
 698 01ac 0000      		nop
 699               	 ;  0 "" 2
 421:setup.c       **** 		wrPin_low;
 700               		.loc 1 421 0
 701               	/* #NOAPP */
 702 01ae 9698      		cbi 0x12,6
 422:setup.c       **** 		asm ("nop");
 703               		.loc 1 422 0
 704               	/* #APP */
 705               	 ;  422 "setup.c" 1
 706 01b0 0000      		nop
 707               	 ;  0 "" 2
 423:setup.c       **** 		asm ("nop");
 708               		.loc 1 423 0
 709               	 ;  423 "setup.c" 1
 710 01b2 0000      		nop
 711               	 ;  0 "" 2
 424:setup.c       **** 		
 425:setup.c       **** 		wrPin_high;
 712               		.loc 1 425 0
 713               	/* #NOAPP */
 714 01b4 969A      		sbi 0x12,6
 426:setup.c       **** 		cs_mreqPin_high;
 715               		.loc 1 426 0
 716 01b6 949A      		sbi 0x12,4
 717               	.L29:
 718 01b8 0895      		ret
 719               		.cfi_endproc
 720               	.LFE27:
 722               	.global	gba_eeprom_read
 724               	gba_eeprom_read:
 725               	.LFB28:
 427:setup.c       **** 	}
 428:setup.c       **** }
 429:setup.c       **** 
 430:setup.c       **** // Read 8 bytes from the EEPROM address, data is valid on rising edge
 431:setup.c       **** void gba_eeprom_read(uint16_t address, uint8_t eepromSize) {
 726               		.loc 1 431 0
 727               		.cfi_startproc
 728               	.LVL41:
 729               	/* prologue: function */
 730               	/* frame size = 0 */
 731               	/* stack size = 0 */
 732               	.L__stack_usage = 0
 432:setup.c       **** 	gba_eeprom_set_address(address, eepromSize, EEPROM_READ);
 733               		.loc 1 432 0
 734 01ba 40E0      		ldi r20,0
 735 01bc 00D0      		rcall gba_eeprom_set_address
 736               	.LVL42:
 433:setup.c       **** 	
 434:setup.c       **** 	// Set AD0 pin as input
 435:setup.c       **** 	GBA_PORT_EEPROM_DATA7_0 &= ~(1<<AD0);
 737               		.loc 1 435 0
 738 01be C098      		cbi 0x18,0
 436:setup.c       **** 	GBA_DDR_EEPROM_DATA7_0 &= ~(1<<AD0);
 739               		.loc 1 436 0
 740 01c0 B898      		cbi 0x17,0
 437:setup.c       **** 	
 438:setup.c       **** 	cs_mreqPin_low;
 741               		.loc 1 438 0
 742 01c2 9498      		cbi 0x12,4
 743               	.LVL43:
 744 01c4 84E0      		ldi r24,lo8(4)
 745               	.LVL44:
 746               	.L43:
 747               	.LBB70:
 439:setup.c       **** 	
 440:setup.c       **** 	// Ignore first 4 bits
 441:setup.c       **** 	for (int8_t x = 0; x < 4; x++) {
 442:setup.c       **** 		rdPin_low; // CLK
 748               		.loc 1 442 0 discriminator 3
 749 01c6 9598      		cbi 0x12,5
 443:setup.c       **** 		asm ("nop");
 750               		.loc 1 443 0 discriminator 3
 751               	/* #APP */
 752               	 ;  443 "setup.c" 1
 753 01c8 0000      		nop
 754               	 ;  0 "" 2
 444:setup.c       **** 		asm ("nop");
 755               		.loc 1 444 0 discriminator 3
 756               	 ;  444 "setup.c" 1
 757 01ca 0000      		nop
 758               	 ;  0 "" 2
 445:setup.c       **** 		rdPin_high; 
 759               		.loc 1 445 0 discriminator 3
 760               	/* #NOAPP */
 761 01cc 959A      		sbi 0x12,5
 446:setup.c       **** 		asm ("nop");
 762               		.loc 1 446 0 discriminator 3
 763               	/* #APP */
 764               	 ;  446 "setup.c" 1
 765 01ce 0000      		nop
 766               	 ;  0 "" 2
 447:setup.c       **** 		asm ("nop");
 767               		.loc 1 447 0 discriminator 3
 768               	 ;  447 "setup.c" 1
 769 01d0 0000      		nop
 770               	 ;  0 "" 2
 771               	.LVL45:
 772               	/* #NOAPP */
 773 01d2 8150      		subi r24,lo8(-(-1))
 774               	.LVL46:
 441:setup.c       **** 		rdPin_low; // CLK
 775               		.loc 1 441 0 discriminator 3
 776 01d4 01F4      		brne .L43
 777 01d6 E0E0      		ldi r30,lo8(eepromBuffer)
 778 01d8 F0E0      		ldi r31,hi8(eepromBuffer)
 779               	.LBE70:
 780               	.LBB71:
 781               	.LBB72:
 782               	.LBB73:
 448:setup.c       **** 	}
 449:setup.c       **** 	
 450:setup.c       **** 	// Read out 64 bits
 451:setup.c       **** 	for (uint8_t c = 0; c < 8; c++) {
 452:setup.c       **** 		uint8_t data = 0;
 453:setup.c       **** 		for (int8_t x = 7; x >= 0; x--) {
 454:setup.c       **** 			rdPin_low; // CLK
 455:setup.c       **** 			asm ("nop");
 456:setup.c       **** 			asm ("nop");
 457:setup.c       **** 			rdPin_high;
 458:setup.c       **** 			
 459:setup.c       **** 			if (GBA_PIN_EEPROM_DATA7_0 & (1<<AD0)) {
 460:setup.c       **** 				data |= (1<<x);
 783               		.loc 1 460 0
 784 01da 41E0      		ldi r20,lo8(1)
 785 01dc 50E0      		ldi r21,0
 786               	.LVL47:
 787               	.L44:
 788               	.LBE73:
 789               	.LBE72:
 790               	.LBE71:
 438:setup.c       **** 	
 791               		.loc 1 438 0
 792 01de 87E0      		ldi r24,lo8(7)
 793 01e0 90E0      		ldi r25,0
 794 01e2 20E0      		ldi r18,0
 795               	.LVL48:
 796               	.L46:
 797               	.LBB76:
 798               	.LBB75:
 799               	.LBB74:
 454:setup.c       **** 			asm ("nop");
 800               		.loc 1 454 0
 801 01e4 9598      		cbi 0x12,5
 455:setup.c       **** 			asm ("nop");
 802               		.loc 1 455 0
 803               	/* #APP */
 804               	 ;  455 "setup.c" 1
 805 01e6 0000      		nop
 806               	 ;  0 "" 2
 456:setup.c       **** 			rdPin_high;
 807               		.loc 1 456 0
 808               	 ;  456 "setup.c" 1
 809 01e8 0000      		nop
 810               	 ;  0 "" 2
 457:setup.c       **** 			
 811               		.loc 1 457 0
 812               	/* #NOAPP */
 813 01ea 959A      		sbi 0x12,5
 459:setup.c       **** 				data |= (1<<x);
 814               		.loc 1 459 0
 815 01ec B09B      		sbis 0x16,0
 816 01ee 00C0      		rjmp .L45
 817               		.loc 1 460 0
 818 01f0 BA01      		movw r22,r20
 819 01f2 082E      		mov r0,r24
 820 01f4 00C0      		rjmp 2f
 821               		1:
 822 01f6 660F      		lsl r22
 823               		2:
 824 01f8 0A94      		dec r0
 825 01fa 02F4      		brpl 1b
 826 01fc 262B      		or r18,r22
 827               	.LVL49:
 828               	.L45:
 829               	.LVL50:
 830 01fe 0197      		sbiw r24,1
 831 0200 00F4      		brcc .L46
 832               	.LBE74:
 461:setup.c       **** 			}
 462:setup.c       **** 		}
 463:setup.c       **** 		eepromBuffer[c] = data;
 833               		.loc 1 463 0 discriminator 2
 834 0202 2193      		st Z+,r18
 835               	.LVL51:
 836               	.LBE75:
 451:setup.c       **** 		uint8_t data = 0;
 837               		.loc 1 451 0 discriminator 2
 838 0204 80E0      		ldi r24,hi8(eepromBuffer+8)
 839 0206 E030      		cpi r30,lo8(eepromBuffer+8)
 840 0208 F807      		cpc r31,r24
 841               	.LVL52:
 842 020a 01F4      		brne .L44
 843               	.LBE76:
 464:setup.c       **** 	}
 465:setup.c       **** 	
 466:setup.c       **** 	cs_mreqPin_high;
 844               		.loc 1 466 0
 845 020c 949A      		sbi 0x12,4
 467:setup.c       **** 	
 468:setup.c       **** 	// Set AD0 pin as output
 469:setup.c       **** 	GBA_PORT_EEPROM_DATA7_0 |= (1<<AD0);
 846               		.loc 1 469 0
 847 020e C09A      		sbi 0x18,0
 470:setup.c       **** 	GBA_DDR_EEPROM_DATA7_0 |= (1<<AD0);
 848               		.loc 1 470 0
 849 0210 B89A      		sbi 0x17,0
 850 0212 0895      		ret
 851               		.cfi_endproc
 852               	.LFE28:
 854               	.global	gba_eeprom_write
 856               	gba_eeprom_write:
 857               	.LFB29:
 471:setup.c       **** }
 472:setup.c       **** 
 473:setup.c       **** // Write 8 bytes to the EEPROM address
 474:setup.c       **** void gba_eeprom_write(uint16_t address, uint8_t eepromSize) {
 858               		.loc 1 474 0
 859               		.cfi_startproc
 860               	.LVL53:
 861               	/* prologue: function */
 862               	/* frame size = 0 */
 863               	/* stack size = 0 */
 864               	.L__stack_usage = 0
 475:setup.c       **** 	gba_eeprom_set_address(address, eepromSize, EEPROM_WRITE);
 865               		.loc 1 475 0
 866 0214 41E0      		ldi r20,lo8(1)
 867 0216 00D0      		rcall gba_eeprom_set_address
 868               	.LVL54:
 869 0218 E0E0      		ldi r30,lo8(eepromBuffer)
 870 021a F0E0      		ldi r31,hi8(eepromBuffer)
 871 021c 48E0      		ldi r20,lo8(8)
 872               	.LVL55:
 873               	.L54:
 474:setup.c       **** 	gba_eeprom_set_address(address, eepromSize, EEPROM_WRITE);
 874               		.loc 1 474 0
 875 021e 27E0      		ldi r18,lo8(7)
 876 0220 30E0      		ldi r19,0
 877               	.LVL56:
 878               	.L57:
 879               	.LBB77:
 880               	.LBB78:
 476:setup.c       **** 	
 477:setup.c       **** 	// Write 64 bits
 478:setup.c       **** 	for (uint8_t c = 0; c < 8; c++) {
 479:setup.c       **** 		for (int8_t x = 7; x >= 0; x--) {
 480:setup.c       **** 			if (eepromBuffer[c] & (1<<x)) {
 881               		.loc 1 480 0
 882 0222 8081      		ld r24,Z
 883 0224 90E0      		ldi r25,0
 884 0226 022E      		mov r0,r18
 885 0228 00C0      		rjmp 2f
 886               		1:
 887 022a 9595      		asr r25
 888 022c 8795      		ror r24
 889               		2:
 890 022e 0A94      		dec r0
 891 0230 02F4      		brpl 1b
 892 0232 80FF      		sbrs r24,0
 893 0234 00C0      		rjmp .L55
 481:setup.c       **** 				ad0Pin_high;
 894               		.loc 1 481 0
 895 0236 C09A      		sbi 0x18,0
 896 0238 00C0      		rjmp .L56
 897               	.L55:
 482:setup.c       **** 			}
 483:setup.c       **** 			else {
 484:setup.c       **** 				ad0Pin_low;
 898               		.loc 1 484 0
 899 023a C098      		cbi 0x18,0
 900               	.L56:
 485:setup.c       **** 			}
 486:setup.c       **** 			
 487:setup.c       **** 			wrPin_low; // CLK
 901               		.loc 1 487 0 discriminator 2
 902 023c 9698      		cbi 0x12,6
 488:setup.c       **** 			asm ("nop");
 903               		.loc 1 488 0 discriminator 2
 904               	/* #APP */
 905               	 ;  488 "setup.c" 1
 906 023e 0000      		nop
 907               	 ;  0 "" 2
 489:setup.c       **** 			asm ("nop");
 908               		.loc 1 489 0 discriminator 2
 909               	 ;  489 "setup.c" 1
 910 0240 0000      		nop
 911               	 ;  0 "" 2
 490:setup.c       **** 			wrPin_high; 
 912               		.loc 1 490 0 discriminator 2
 913               	/* #NOAPP */
 914 0242 969A      		sbi 0x12,6
 491:setup.c       **** 			asm ("nop");
 915               		.loc 1 491 0 discriminator 2
 916               	/* #APP */
 917               	 ;  491 "setup.c" 1
 918 0244 0000      		nop
 919               	 ;  0 "" 2
 492:setup.c       **** 			asm ("nop");
 920               		.loc 1 492 0 discriminator 2
 921               	 ;  492 "setup.c" 1
 922 0246 0000      		nop
 923               	 ;  0 "" 2
 924               	.LVL57:
 925               	/* #NOAPP */
 926               	.LVL58:
 927 0248 2150      		subi r18,1
 928 024a 3109      		sbc r19,__zero_reg__
 929 024c 00F4      		brcc .L57
 930 024e 4150      		subi r20,lo8(-(-1))
 931 0250 3196      		adiw r30,1
 932               	.LVL59:
 933               	.LBE78:
 478:setup.c       **** 		for (int8_t x = 7; x >= 0; x--) {
 934               		.loc 1 478 0 discriminator 2
 935 0252 4111      		cpse r20,__zero_reg__
 936 0254 00C0      		rjmp .L54
 937               	.LBE77:
 493:setup.c       **** 		}
 494:setup.c       **** 	}
 495:setup.c       **** 	
 496:setup.c       **** 	// Last bit low
 497:setup.c       **** 	ad0Pin_low;
 938               		.loc 1 497 0
 939 0256 C098      		cbi 0x18,0
 498:setup.c       **** 	wrPin_low; // CLK
 940               		.loc 1 498 0
 941 0258 9698      		cbi 0x12,6
 499:setup.c       **** 	asm ("nop");
 942               		.loc 1 499 0
 943               	/* #APP */
 944               	 ;  499 "setup.c" 1
 945 025a 0000      		nop
 946               	 ;  0 "" 2
 500:setup.c       **** 	asm ("nop");
 947               		.loc 1 500 0
 948               	 ;  500 "setup.c" 1
 949 025c 0000      		nop
 950               	 ;  0 "" 2
 501:setup.c       **** 	wrPin_high; 
 951               		.loc 1 501 0
 952               	/* #NOAPP */
 953 025e 969A      		sbi 0x12,6
 502:setup.c       **** 	asm ("nop");
 954               		.loc 1 502 0
 955               	/* #APP */
 956               	 ;  502 "setup.c" 1
 957 0260 0000      		nop
 958               	 ;  0 "" 2
 503:setup.c       **** 	asm ("nop");
 959               		.loc 1 503 0
 960               	 ;  503 "setup.c" 1
 961 0262 0000      		nop
 962               	 ;  0 "" 2
 504:setup.c       **** 	
 505:setup.c       **** 	cs_mreqPin_high;
 963               		.loc 1 505 0
 964               	/* #NOAPP */
 965 0264 949A      		sbi 0x12,4
 966 0266 0895      		ret
 967               		.cfi_endproc
 968               	.LFE29:
 970               	.global	flash_write_bus_cycle
 972               	flash_write_bus_cycle:
 973               	.LFB30:
 506:setup.c       **** }
 507:setup.c       **** 
 508:setup.c       **** 
 509:setup.c       **** 
 510:setup.c       **** // ---------- FLASH ----------
 511:setup.c       **** 
 512:setup.c       **** // Set the address and data for the write byte cycle to the flash
 513:setup.c       **** void flash_write_bus_cycle(uint16_t address, uint8_t data) {
 974               		.loc 1 513 0
 975               		.cfi_startproc
 976               	.LVL60:
 977 0268 CF93      		push r28
 978               	.LCFI10:
 979               		.cfi_def_cfa_offset 3
 980               		.cfi_offset 28, -2
 981               	/* prologue: function */
 982               	/* frame size = 0 */
 983               	/* stack size = 1 */
 984               	.L__stack_usage = 1
 985 026a C62F      		mov r28,r22
 514:setup.c       **** 	GBA_DDR_RAM_DATA7_0 = 0xFF; // Set data pins as outputs
 986               		.loc 1 514 0
 987 026c 2FEF      		ldi r18,lo8(-1)
 988 026e 24BB      		out 0x14,r18
 515:setup.c       **** 	set_16bit_address(address);
 989               		.loc 1 515 0
 990 0270 00D0      		rcall set_16bit_address
 991               	.LVL61:
 516:setup.c       **** 	GBA_PORT_RAM_DATA7_0 = data;
 992               		.loc 1 516 0
 993 0272 C5BB      		out 0x15,r28
 517:setup.c       **** 	
 518:setup.c       **** 	wrPin_low;
 994               		.loc 1 518 0
 995 0274 9698      		cbi 0x12,6
 519:setup.c       **** 	cs2Pin_low;
 996               		.loc 1 519 0
 997 0276 3A98      		cbi 0x7,2
 520:setup.c       **** 	asm volatile("nop");
 998               		.loc 1 520 0
 999               	/* #APP */
 1000               	 ;  520 "setup.c" 1
 1001 0278 0000      		nop
 1002               	 ;  0 "" 2
 521:setup.c       **** 	wrPin_high;
 1003               		.loc 1 521 0
 1004               	/* #NOAPP */
 1005 027a 969A      		sbi 0x12,6
 522:setup.c       **** 	cs2Pin_high;
 1006               		.loc 1 522 0
 1007 027c 3A9A      		sbi 0x7,2
 1008               	/* epilogue start */
 523:setup.c       **** }
 1009               		.loc 1 523 0
 1010 027e CF91      		pop r28
 1011               	.LVL62:
 1012 0280 0895      		ret
 1013               		.cfi_endproc
 1014               	.LFE30:
 1016               	.global	flash_read_chip_id
 1018               	flash_read_chip_id:
 1019               	.LFB31:
 524:setup.c       **** 
 525:setup.c       **** // Read the flash manufacturer and device ID (Software ID)
 526:setup.c       **** void flash_read_chip_id(void) {
 1020               		.loc 1 526 0
 1021               		.cfi_startproc
 1022 0282 CF93      		push r28
 1023               	.LCFI11:
 1024               		.cfi_def_cfa_offset 3
 1025               		.cfi_offset 28, -2
 1026 0284 DF93      		push r29
 1027               	.LCFI12:
 1028               		.cfi_def_cfa_offset 4
 1029               		.cfi_offset 29, -3
 1030               	/* prologue: function */
 1031               	/* frame size = 0 */
 1032               	/* stack size = 2 */
 1033               	.L__stack_usage = 2
 527:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xAA);
 1034               		.loc 1 527 0
 1035 0286 6AEA      		ldi r22,lo8(-86)
 1036 0288 85E5      		ldi r24,lo8(85)
 1037 028a 95E5      		ldi r25,lo8(85)
 1038 028c 00D0      		rcall flash_write_bus_cycle
 1039               	.LVL63:
 528:setup.c       **** 	flash_write_bus_cycle(0x2AAA, 0x55);
 1040               		.loc 1 528 0
 1041 028e 65E5      		ldi r22,lo8(85)
 1042 0290 8AEA      		ldi r24,lo8(-86)
 1043 0292 9AE2      		ldi r25,lo8(42)
 1044 0294 00D0      		rcall flash_write_bus_cycle
 1045               	.LVL64:
 529:setup.c       **** 	flash_write_bus_cycle(0x5555, 0x90); // Software ID entry
 1046               		.loc 1 529 0
 1047 0296 60E9      		ldi r22,lo8(-112)
 1048 0298 85E5      		ldi r24,lo8(85)
 1049 029a 95E5      		ldi r25,lo8(85)
 1050 029c 00D0      		rcall flash_write_bus_cycle
 1051               	.LVL65:
 1052               	.LBB79:
 1053               	.LBB80:
 1054               		.file 2 "c:\\winavr-20100110\\avr\\include\\util\\delay.h"
   1:c:\winavr-20100110\avr\include\util\delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:c:\winavr-20100110\avr\include\util\delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:c:\winavr-20100110\avr\include\util\delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:c:\winavr-20100110\avr\include\util\delay.h ****    All rights reserved.
   5:c:\winavr-20100110\avr\include\util\delay.h **** 
   6:c:\winavr-20100110\avr\include\util\delay.h ****    Redistribution and use in source and binary forms, with or without
   7:c:\winavr-20100110\avr\include\util\delay.h ****    modification, are permitted provided that the following conditions are met:
   8:c:\winavr-20100110\avr\include\util\delay.h **** 
   9:c:\winavr-20100110\avr\include\util\delay.h ****    * Redistributions of source code must retain the above copyright
  10:c:\winavr-20100110\avr\include\util\delay.h ****      notice, this list of conditions and the following disclaimer.
  11:c:\winavr-20100110\avr\include\util\delay.h **** 
  12:c:\winavr-20100110\avr\include\util\delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:c:\winavr-20100110\avr\include\util\delay.h ****      notice, this list of conditions and the following disclaimer in
  14:c:\winavr-20100110\avr\include\util\delay.h ****      the documentation and/or other materials provided with the
  15:c:\winavr-20100110\avr\include\util\delay.h ****      distribution.
  16:c:\winavr-20100110\avr\include\util\delay.h **** 
  17:c:\winavr-20100110\avr\include\util\delay.h ****    * Neither the name of the copyright holders nor the names of
  18:c:\winavr-20100110\avr\include\util\delay.h ****      contributors may be used to endorse or promote products derived
  19:c:\winavr-20100110\avr\include\util\delay.h ****      from this software without specific prior written permission.
  20:c:\winavr-20100110\avr\include\util\delay.h **** 
  21:c:\winavr-20100110\avr\include\util\delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:c:\winavr-20100110\avr\include\util\delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:c:\winavr-20100110\avr\include\util\delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:c:\winavr-20100110\avr\include\util\delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:c:\winavr-20100110\avr\include\util\delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:c:\winavr-20100110\avr\include\util\delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:c:\winavr-20100110\avr\include\util\delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:c:\winavr-20100110\avr\include\util\delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:c:\winavr-20100110\avr\include\util\delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:c:\winavr-20100110\avr\include\util\delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:c:\winavr-20100110\avr\include\util\delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:c:\winavr-20100110\avr\include\util\delay.h **** 
  33:c:\winavr-20100110\avr\include\util\delay.h **** /* $Id$ */
  34:c:\winavr-20100110\avr\include\util\delay.h **** 
  35:c:\winavr-20100110\avr\include\util\delay.h **** #ifndef _UTIL_DELAY_H_
  36:c:\winavr-20100110\avr\include\util\delay.h **** #define _UTIL_DELAY_H_ 1
  37:c:\winavr-20100110\avr\include\util\delay.h **** 
  38:c:\winavr-20100110\avr\include\util\delay.h **** #ifndef __DOXYGEN__
  39:c:\winavr-20100110\avr\include\util\delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:c:\winavr-20100110\avr\include\util\delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:c:\winavr-20100110\avr\include\util\delay.h **** #  endif
  42:c:\winavr-20100110\avr\include\util\delay.h **** #endif  /* __DOXYGEN__ */
  43:c:\winavr-20100110\avr\include\util\delay.h **** 
  44:c:\winavr-20100110\avr\include\util\delay.h **** #include <inttypes.h>
  45:c:\winavr-20100110\avr\include\util\delay.h **** #include <util/delay_basic.h>
  46:c:\winavr-20100110\avr\include\util\delay.h **** #include <math.h>
  47:c:\winavr-20100110\avr\include\util\delay.h **** 
  48:c:\winavr-20100110\avr\include\util\delay.h **** /** \file */
  49:c:\winavr-20100110\avr\include\util\delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:c:\winavr-20100110\avr\include\util\delay.h ****     \code
  51:c:\winavr-20100110\avr\include\util\delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:c:\winavr-20100110\avr\include\util\delay.h ****     //#define F_CPU 14.7456E6
  53:c:\winavr-20100110\avr\include\util\delay.h ****     #include <util/delay.h>
  54:c:\winavr-20100110\avr\include\util\delay.h ****     \endcode
  55:c:\winavr-20100110\avr\include\util\delay.h **** 
  56:c:\winavr-20100110\avr\include\util\delay.h ****     \note As an alternative method, it is possible to pass the
  57:c:\winavr-20100110\avr\include\util\delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:c:\winavr-20100110\avr\include\util\delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:c:\winavr-20100110\avr\include\util\delay.h ****     used.
  60:c:\winavr-20100110\avr\include\util\delay.h **** 
  61:c:\winavr-20100110\avr\include\util\delay.h ****     The functions in this header file are wrappers around the basic
  62:c:\winavr-20100110\avr\include\util\delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:c:\winavr-20100110\avr\include\util\delay.h ****     convenience functions where actual time values can be specified
  64:c:\winavr-20100110\avr\include\util\delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:c:\winavr-20100110\avr\include\util\delay.h ****     that compile-time constant expressions will be eliminated by
  66:c:\winavr-20100110\avr\include\util\delay.h ****     compiler optimization so floating-point expressions can be used
  67:c:\winavr-20100110\avr\include\util\delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:c:\winavr-20100110\avr\include\util\delay.h ****     frequency passed by the macro F_CPU.
  69:c:\winavr-20100110\avr\include\util\delay.h **** 
  70:c:\winavr-20100110\avr\include\util\delay.h ****     \note In order for these functions to work as intended, compiler
  71:c:\winavr-20100110\avr\include\util\delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:c:\winavr-20100110\avr\include\util\delay.h ****     <em>must</em> be an expression that is a known constant at
  73:c:\winavr-20100110\avr\include\util\delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:c:\winavr-20100110\avr\include\util\delay.h ****     delay will be much longer (and basically unpredictable), and
  75:c:\winavr-20100110\avr\include\util\delay.h ****     applications that otherwise do not use floating-point calculations
  76:c:\winavr-20100110\avr\include\util\delay.h ****     will experience severe code bloat by the floating-point library
  77:c:\winavr-20100110\avr\include\util\delay.h ****     routines linked into the application.
  78:c:\winavr-20100110\avr\include\util\delay.h **** 
  79:c:\winavr-20100110\avr\include\util\delay.h ****     The functions available allow the specification of microsecond, and
  80:c:\winavr-20100110\avr\include\util\delay.h ****     millisecond delays directly, using the application-supplied macro
  81:c:\winavr-20100110\avr\include\util\delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:c:\winavr-20100110\avr\include\util\delay.h **** 
  83:c:\winavr-20100110\avr\include\util\delay.h **** */
  84:c:\winavr-20100110\avr\include\util\delay.h **** 
  85:c:\winavr-20100110\avr\include\util\delay.h **** #if !defined(__DOXYGEN__)
  86:c:\winavr-20100110\avr\include\util\delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:c:\winavr-20100110\avr\include\util\delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:c:\winavr-20100110\avr\include\util\delay.h **** #endif
  89:c:\winavr-20100110\avr\include\util\delay.h **** 
  90:c:\winavr-20100110\avr\include\util\delay.h **** #ifndef F_CPU
  91:c:\winavr-20100110\avr\include\util\delay.h **** /* prevent compiler error by supplying a default */
  92:c:\winavr-20100110\avr\include\util\delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:c:\winavr-20100110\avr\include\util\delay.h **** /** \ingroup util_delay
  94:c:\winavr-20100110\avr\include\util\delay.h ****     \def F_CPU
  95:c:\winavr-20100110\avr\include\util\delay.h ****     \brief CPU frequency in Hz
  96:c:\winavr-20100110\avr\include\util\delay.h **** 
  97:c:\winavr-20100110\avr\include\util\delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:c:\winavr-20100110\avr\include\util\delay.h ****     the delay macros.  This macro is normally supplied by the
  99:c:\winavr-20100110\avr\include\util\delay.h ****     environment (e.g. from within a project header, or the project's
 100:c:\winavr-20100110\avr\include\util\delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:c:\winavr-20100110\avr\include\util\delay.h ****     fallback if no such user-provided definition could be found.
 102:c:\winavr-20100110\avr\include\util\delay.h **** 
 103:c:\winavr-20100110\avr\include\util\delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:c:\winavr-20100110\avr\include\util\delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:c:\winavr-20100110\avr\include\util\delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:c:\winavr-20100110\avr\include\util\delay.h ****     integer value.
 107:c:\winavr-20100110\avr\include\util\delay.h ****  */
 108:c:\winavr-20100110\avr\include\util\delay.h **** # define F_CPU 1000000UL
 109:c:\winavr-20100110\avr\include\util\delay.h **** #endif
 110:c:\winavr-20100110\avr\include\util\delay.h **** 
 111:c:\winavr-20100110\avr\include\util\delay.h **** #ifndef __OPTIMIZE__
 112:c:\winavr-20100110\avr\include\util\delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:c:\winavr-20100110\avr\include\util\delay.h **** #endif
 114:c:\winavr-20100110\avr\include\util\delay.h **** 
 115:c:\winavr-20100110\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:c:\winavr-20100110\avr\include\util\delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:c:\winavr-20100110\avr\include\util\delay.h ****   __STDC_HOSTED__
 118:c:\winavr-20100110\avr\include\util\delay.h **** #  include <math.h>
 119:c:\winavr-20100110\avr\include\util\delay.h **** #endif
 120:c:\winavr-20100110\avr\include\util\delay.h **** 
 121:c:\winavr-20100110\avr\include\util\delay.h **** /**
 122:c:\winavr-20100110\avr\include\util\delay.h ****    \ingroup util_delay
 123:c:\winavr-20100110\avr\include\util\delay.h **** 
 124:c:\winavr-20100110\avr\include\util\delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:c:\winavr-20100110\avr\include\util\delay.h **** 
 126:c:\winavr-20100110\avr\include\util\delay.h ****    The macro F_CPU is supposed to be defined to a
 127:c:\winavr-20100110\avr\include\util\delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:c:\winavr-20100110\avr\include\util\delay.h **** 
 129:c:\winavr-20100110\avr\include\util\delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:c:\winavr-20100110\avr\include\util\delay.h **** 
 131:c:\winavr-20100110\avr\include\util\delay.h ****    When the user request delay which exceed the maximum possible one,
 132:c:\winavr-20100110\avr\include\util\delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:c:\winavr-20100110\avr\include\util\delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:c:\winavr-20100110\avr\include\util\delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:c:\winavr-20100110\avr\include\util\delay.h ****    user will not be informed about decreased resolution.
 136:c:\winavr-20100110\avr\include\util\delay.h **** 
 137:c:\winavr-20100110\avr\include\util\delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:c:\winavr-20100110\avr\include\util\delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:c:\winavr-20100110\avr\include\util\delay.h ****    values greater than the maximal possible delay, overflows results in
 140:c:\winavr-20100110\avr\include\util\delay.h ****    no delay i.e., 0ms.
 141:c:\winavr-20100110\avr\include\util\delay.h **** 
 142:c:\winavr-20100110\avr\include\util\delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:c:\winavr-20100110\avr\include\util\delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:c:\winavr-20100110\avr\include\util\delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:c:\winavr-20100110\avr\include\util\delay.h ****    microseconds of delay.
 146:c:\winavr-20100110\avr\include\util\delay.h **** 
 147:c:\winavr-20100110\avr\include\util\delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:c:\winavr-20100110\avr\include\util\delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:c:\winavr-20100110\avr\include\util\delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:c:\winavr-20100110\avr\include\util\delay.h ****    respectively.
 151:c:\winavr-20100110\avr\include\util\delay.h **** 
 152:c:\winavr-20100110\avr\include\util\delay.h ****    \note
 153:c:\winavr-20100110\avr\include\util\delay.h **** 
 154:c:\winavr-20100110\avr\include\util\delay.h ****    The implementation of _delay_ms() based on
 155:c:\winavr-20100110\avr\include\util\delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:c:\winavr-20100110\avr\include\util\delay.h ****    implementations.  In order to get functionality backward compatible
 157:c:\winavr-20100110\avr\include\util\delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:c:\winavr-20100110\avr\include\util\delay.h ****    must be defined before including this header file. Also, the
 159:c:\winavr-20100110\avr\include\util\delay.h ****    backward compatible algorithm will be chosen if the code is
 160:c:\winavr-20100110\avr\include\util\delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:c:\winavr-20100110\avr\include\util\delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:c:\winavr-20100110\avr\include\util\delay.h ****    not available to the compiler then.
 163:c:\winavr-20100110\avr\include\util\delay.h **** 
 164:c:\winavr-20100110\avr\include\util\delay.h ****  */
 165:c:\winavr-20100110\avr\include\util\delay.h **** void
 166:c:\winavr-20100110\avr\include\util\delay.h **** _delay_ms(double __ms)
 167:c:\winavr-20100110\avr\include\util\delay.h **** {
 168:c:\winavr-20100110\avr\include\util\delay.h **** 	double __tmp ;
 169:c:\winavr-20100110\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:c:\winavr-20100110\avr\include\util\delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:c:\winavr-20100110\avr\include\util\delay.h ****   __STDC_HOSTED__
 172:c:\winavr-20100110\avr\include\util\delay.h **** 	uint32_t __ticks_dc;
 173:c:\winavr-20100110\avr\include\util\delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 174:c:\winavr-20100110\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 175:c:\winavr-20100110\avr\include\util\delay.h **** 
 176:c:\winavr-20100110\avr\include\util\delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:c:\winavr-20100110\avr\include\util\delay.h **** 
 179:c:\winavr-20100110\avr\include\util\delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:c:\winavr-20100110\avr\include\util\delay.h **** 
 182:c:\winavr-20100110\avr\include\util\delay.h **** 	#else
 183:c:\winavr-20100110\avr\include\util\delay.h **** 		//round up by default
 184:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 185:c:\winavr-20100110\avr\include\util\delay.h **** 	#endif
 186:c:\winavr-20100110\avr\include\util\delay.h **** 
 187:c:\winavr-20100110\avr\include\util\delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 1055               		.loc 2 187 0
 1056 029e 8FE3      		ldi r24,lo8(-25537)
 1057 02a0 9CE9      		ldi r25,hi8(-25537)
 1058 02a2 0197      	1:	sbiw r24,1
 1059 02a4 01F4      		brne 1b
 1060 02a6 00C0      		rjmp .
 1061 02a8 0000      		nop
 1062               	.LVL66:
 1063               	.LBE80:
 1064               	.LBE79:
 530:setup.c       **** 	_delay_ms(20); // Wait a little (for Atmel chip)
 531:setup.c       **** 	
 532:setup.c       **** 	// Set data as inputs
 533:setup.c       **** 	GBA_PORT_RAM_DATA7_0 = 0;
 1065               		.loc 1 533 0
 1066 02aa 15BA      		out 0x15,__zero_reg__
 534:setup.c       **** 	GBA_DDR_RAM_DATA7_0 = 0;
 1067               		.loc 1 534 0
 1068 02ac 14BA      		out 0x14,__zero_reg__
 535:setup.c       **** 	
 536:setup.c       **** 	// Read and transmit the 2 bytes
 537:setup.c       **** 	flashChipIdBuffer[0] = gba_read_ram_8bit_data(0x0000);
 1069               		.loc 1 537 0
 1070 02ae 80E0      		ldi r24,0
 1071 02b0 90E0      		ldi r25,0
 1072 02b2 00D0      		rcall gba_read_ram_8bit_data
 1073               	.LVL67:
 1074 02b4 C0E0      		ldi r28,lo8(flashChipIdBuffer)
 1075 02b6 D0E0      		ldi r29,hi8(flashChipIdBuffer)
 1076 02b8 8883      		st Y,r24
 538:setup.c       **** 	flashChipIdBuffer[1] = gba_read_ram_8bit_data(0x0001);
 1077               		.loc 1 538 0
 1078 02ba 81E0      		ldi r24,lo8(1)
 1079 02bc 90E0      		ldi r25,0
 1080 02be 00D0      		rcall gba_read_ram_8bit_data
 1081               	.LVL68:
 1082 02c0 8983      		std Y+1,r24
 539:setup.c       **** 	
 540:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xAA);
 1083               		.loc 1 540 0
 1084 02c2 6AEA      		ldi r22,lo8(-86)
 1085 02c4 85E5      		ldi r24,lo8(85)
 1086 02c6 95E5      		ldi r25,lo8(85)
 1087 02c8 00D0      		rcall flash_write_bus_cycle
 1088               	.LVL69:
 541:setup.c       **** 	flash_write_bus_cycle(0x2AAA, 0x55);
 1089               		.loc 1 541 0
 1090 02ca 65E5      		ldi r22,lo8(85)
 1091 02cc 8AEA      		ldi r24,lo8(-86)
 1092 02ce 9AE2      		ldi r25,lo8(42)
 1093 02d0 00D0      		rcall flash_write_bus_cycle
 1094               	.LVL70:
 542:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xF0); // Software ID exit
 1095               		.loc 1 542 0
 1096 02d2 60EF      		ldi r22,lo8(-16)
 1097 02d4 85E5      		ldi r24,lo8(85)
 1098 02d6 95E5      		ldi r25,lo8(85)
 1099 02d8 00D0      		rcall flash_write_bus_cycle
 1100               	.LVL71:
 1101               	.LBB81:
 1102               	.LBB82:
 1103               		.loc 2 187 0
 1104 02da 8FE3      		ldi r24,lo8(-25537)
 1105 02dc 9CE9      		ldi r25,hi8(-25537)
 1106 02de 0197      	1:	sbiw r24,1
 1107 02e0 01F4      		brne 1b
 1108 02e2 00C0      		rjmp .
 1109 02e4 0000      		nop
 1110               	.LVL72:
 1111               	/* epilogue start */
 1112               	.LBE82:
 1113               	.LBE81:
 543:setup.c       **** 	_delay_ms(20); // Wait a little (for Atmel chip)
 544:setup.c       **** }
 1114               		.loc 1 544 0
 1115 02e6 DF91      		pop r29
 1116 02e8 CF91      		pop r28
 1117 02ea 0895      		ret
 1118               		.cfi_endproc
 1119               	.LFE31:
 1121               	.global	flash_switch_bank
 1123               	flash_switch_bank:
 1124               	.LFB32:
 545:setup.c       **** 
 546:setup.c       **** // Switch banks on the Flash
 547:setup.c       **** void flash_switch_bank(uint8_t bank) {
 1125               		.loc 1 547 0
 1126               		.cfi_startproc
 1127               	.LVL73:
 1128 02ec CF93      		push r28
 1129               	.LCFI13:
 1130               		.cfi_def_cfa_offset 3
 1131               		.cfi_offset 28, -2
 1132               	/* prologue: function */
 1133               	/* frame size = 0 */
 1134               	/* stack size = 1 */
 1135               	.L__stack_usage = 1
 1136 02ee C82F      		mov r28,r24
 548:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xAA);
 1137               		.loc 1 548 0
 1138 02f0 6AEA      		ldi r22,lo8(-86)
 1139 02f2 85E5      		ldi r24,lo8(85)
 1140 02f4 95E5      		ldi r25,lo8(85)
 1141               	.LVL74:
 1142 02f6 00D0      		rcall flash_write_bus_cycle
 1143               	.LVL75:
 549:setup.c       **** 	flash_write_bus_cycle(0x2AAA, 0x55);
 1144               		.loc 1 549 0
 1145 02f8 65E5      		ldi r22,lo8(85)
 1146 02fa 8AEA      		ldi r24,lo8(-86)
 1147 02fc 9AE2      		ldi r25,lo8(42)
 1148 02fe 00D0      		rcall flash_write_bus_cycle
 1149               	.LVL76:
 550:setup.c       **** 	
 551:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xB0);
 1150               		.loc 1 551 0
 1151 0300 60EB      		ldi r22,lo8(-80)
 1152 0302 85E5      		ldi r24,lo8(85)
 1153 0304 95E5      		ldi r25,lo8(85)
 1154 0306 00D0      		rcall flash_write_bus_cycle
 1155               	.LVL77:
 552:setup.c       **** 	flash_write_bus_cycle(0x0000, bank);
 1156               		.loc 1 552 0
 1157 0308 6C2F      		mov r22,r28
 1158 030a 80E0      		ldi r24,0
 1159 030c 90E0      		ldi r25,0
 1160               	/* epilogue start */
 553:setup.c       **** }
 1161               		.loc 1 553 0
 1162 030e CF91      		pop r28
 1163               	.LVL78:
 552:setup.c       **** 	flash_write_bus_cycle(0x0000, bank);
 1164               		.loc 1 552 0
 1165 0310 00C0      		rjmp flash_write_bus_cycle
 1166               	.LVL79:
 1167               		.cfi_endproc
 1168               	.LFE32:
 1170               	.global	flash_erase_4k_sector
 1172               	flash_erase_4k_sector:
 1173               	.LFB33:
 554:setup.c       **** 
 555:setup.c       **** // Erase 4K sector on Flash, expects first sector to start at 0, left shifts by 12 (A15-A12 to sele
 556:setup.c       **** // Takes 25ms after last command to erase sector
 557:setup.c       **** void flash_erase_4k_sector(uint8_t sector) {
 1174               		.loc 1 557 0
 1175               		.cfi_startproc
 1176               	.LVL80:
 1177 0312 CF93      		push r28
 1178               	.LCFI14:
 1179               		.cfi_def_cfa_offset 3
 1180               		.cfi_offset 28, -2
 1181               	/* prologue: function */
 1182               	/* frame size = 0 */
 1183               	/* stack size = 1 */
 1184               	.L__stack_usage = 1
 1185 0314 C82F      		mov r28,r24
 558:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xAA);
 1186               		.loc 1 558 0
 1187 0316 6AEA      		ldi r22,lo8(-86)
 1188 0318 85E5      		ldi r24,lo8(85)
 1189 031a 95E5      		ldi r25,lo8(85)
 1190               	.LVL81:
 1191 031c 00D0      		rcall flash_write_bus_cycle
 1192               	.LVL82:
 559:setup.c       **** 	flash_write_bus_cycle(0x2AAA, 0x55);
 1193               		.loc 1 559 0
 1194 031e 65E5      		ldi r22,lo8(85)
 1195 0320 8AEA      		ldi r24,lo8(-86)
 1196 0322 9AE2      		ldi r25,lo8(42)
 1197 0324 00D0      		rcall flash_write_bus_cycle
 1198               	.LVL83:
 560:setup.c       **** 	flash_write_bus_cycle(0x5555, 0x80);
 1199               		.loc 1 560 0
 1200 0326 60E8      		ldi r22,lo8(-128)
 1201 0328 85E5      		ldi r24,lo8(85)
 1202 032a 95E5      		ldi r25,lo8(85)
 1203 032c 00D0      		rcall flash_write_bus_cycle
 1204               	.LVL84:
 561:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xAA);
 1205               		.loc 1 561 0
 1206 032e 6AEA      		ldi r22,lo8(-86)
 1207 0330 85E5      		ldi r24,lo8(85)
 1208 0332 95E5      		ldi r25,lo8(85)
 1209 0334 00D0      		rcall flash_write_bus_cycle
 1210               	.LVL85:
 562:setup.c       **** 	flash_write_bus_cycle(0x2AAA, 0x55);
 1211               		.loc 1 562 0
 1212 0336 65E5      		ldi r22,lo8(85)
 1213 0338 8AEA      		ldi r24,lo8(-86)
 1214 033a 9AE2      		ldi r25,lo8(42)
 1215 033c 00D0      		rcall flash_write_bus_cycle
 1216               	.LVL86:
 563:setup.c       **** 	
 564:setup.c       **** 	flash_write_bus_cycle((uint16_t) sector << 12, 0x30);
 1217               		.loc 1 564 0
 1218 033e 60E3      		ldi r22,lo8(48)
 1219 0340 80E0      		ldi r24,0
 1220 0342 9C2F      		mov r25,r28
 1221 0344 9295      		swap r25
 1222 0346 907F      		andi r25,lo8(-16)
 1223 0348 00D0      		rcall flash_write_bus_cycle
 1224               	.LVL87:
 1225               	.LBB83:
 1226               	.LBB84:
 1227               		.loc 2 187 0
 1228 034a 8FE4      		ldi r24,lo8(-15537)
 1229 034c 93EC      		ldi r25,hi8(-15537)
 1230 034e 0197      	1:	sbiw r24,1
 1231 0350 01F4      		brne 1b
 1232 0352 00C0      		rjmp .
 1233 0354 0000      		nop
 1234               	.LVL88:
 1235               	/* epilogue start */
 1236               	.LBE84:
 1237               	.LBE83:
 565:setup.c       **** 	_delay_ms(25); // Wait 25ms for sector erase
 566:setup.c       **** }
 1238               		.loc 1 566 0
 1239 0356 CF91      		pop r28
 1240               	.LVL89:
 1241 0358 0895      		ret
 1242               		.cfi_endproc
 1243               	.LFE33:
 1245               	.global	flash_write_byte
 1247               	flash_write_byte:
 1248               	.LFB34:
 567:setup.c       **** 
 568:setup.c       **** // Write a single byte to the Flash address
 569:setup.c       **** // Takes 20us to program Flash
 570:setup.c       **** void flash_write_byte(uint16_t address, uint8_t data) {
 1249               		.loc 1 570 0
 1250               		.cfi_startproc
 1251               	.LVL90:
 1252 035a 1F93      		push r17
 1253               	.LCFI15:
 1254               		.cfi_def_cfa_offset 3
 1255               		.cfi_offset 17, -2
 1256 035c CF93      		push r28
 1257               	.LCFI16:
 1258               		.cfi_def_cfa_offset 4
 1259               		.cfi_offset 28, -3
 1260 035e DF93      		push r29
 1261               	.LCFI17:
 1262               		.cfi_def_cfa_offset 5
 1263               		.cfi_offset 29, -4
 1264               	/* prologue: function */
 1265               	/* frame size = 0 */
 1266               	/* stack size = 3 */
 1267               	.L__stack_usage = 3
 1268 0360 EC01      		movw r28,r24
 1269 0362 162F      		mov r17,r22
 571:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xAA);
 1270               		.loc 1 571 0
 1271 0364 6AEA      		ldi r22,lo8(-86)
 1272               	.LVL91:
 1273 0366 85E5      		ldi r24,lo8(85)
 1274 0368 95E5      		ldi r25,lo8(85)
 1275               	.LVL92:
 1276 036a 00D0      		rcall flash_write_bus_cycle
 1277               	.LVL93:
 572:setup.c       **** 	flash_write_bus_cycle(0x2AAA, 0x55);
 1278               		.loc 1 572 0
 1279 036c 65E5      		ldi r22,lo8(85)
 1280 036e 8AEA      		ldi r24,lo8(-86)
 1281 0370 9AE2      		ldi r25,lo8(42)
 1282 0372 00D0      		rcall flash_write_bus_cycle
 1283               	.LVL94:
 573:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xA0);
 1284               		.loc 1 573 0
 1285 0374 60EA      		ldi r22,lo8(-96)
 1286 0376 85E5      		ldi r24,lo8(85)
 1287 0378 95E5      		ldi r25,lo8(85)
 1288 037a 00D0      		rcall flash_write_bus_cycle
 1289               	.LVL95:
 574:setup.c       **** 	
 575:setup.c       **** 	flash_write_bus_cycle(address, data);
 1290               		.loc 1 575 0
 1291 037c 612F      		mov r22,r17
 1292 037e CE01      		movw r24,r28
 1293 0380 00D0      		rcall flash_write_bus_cycle
 1294               	.LVL96:
 1295               	.LBB85:
 1296               	.LBB86:
 188:c:\winavr-20100110\avr\include\util\delay.h **** 
 189:c:\winavr-20100110\avr\include\util\delay.h **** #else
 190:c:\winavr-20100110\avr\include\util\delay.h **** 	uint16_t __ticks;
 191:c:\winavr-20100110\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 4e3) * __ms;
 192:c:\winavr-20100110\avr\include\util\delay.h **** 	if (__tmp < 1.0)
 193:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks = 1;
 194:c:\winavr-20100110\avr\include\util\delay.h **** 	else if (__tmp > 65535)
 195:c:\winavr-20100110\avr\include\util\delay.h **** 	{
 196:c:\winavr-20100110\avr\include\util\delay.h **** 		//	__ticks = requested delay in 1/10 ms
 197:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 198:c:\winavr-20100110\avr\include\util\delay.h **** 		while(__ticks)
 199:c:\winavr-20100110\avr\include\util\delay.h **** 		{
 200:c:\winavr-20100110\avr\include\util\delay.h **** 			// wait 1/10 ms
 201:c:\winavr-20100110\avr\include\util\delay.h **** 			_delay_loop_2(((F_CPU) / 4e3) / 10);
 202:c:\winavr-20100110\avr\include\util\delay.h **** 			__ticks --;
 203:c:\winavr-20100110\avr\include\util\delay.h **** 		}
 204:c:\winavr-20100110\avr\include\util\delay.h **** 		return;
 205:c:\winavr-20100110\avr\include\util\delay.h **** 	}
 206:c:\winavr-20100110\avr\include\util\delay.h **** 	else
 207:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks = (uint16_t)__tmp;
 208:c:\winavr-20100110\avr\include\util\delay.h **** 	_delay_loop_2(__ticks);
 209:c:\winavr-20100110\avr\include\util\delay.h **** #endif
 210:c:\winavr-20100110\avr\include\util\delay.h **** }
 211:c:\winavr-20100110\avr\include\util\delay.h **** 
 212:c:\winavr-20100110\avr\include\util\delay.h **** /**
 213:c:\winavr-20100110\avr\include\util\delay.h ****    \ingroup util_delay
 214:c:\winavr-20100110\avr\include\util\delay.h **** 
 215:c:\winavr-20100110\avr\include\util\delay.h ****    Perform a delay of \c __us microseconds, using _delay_loop_1().
 216:c:\winavr-20100110\avr\include\util\delay.h **** 
 217:c:\winavr-20100110\avr\include\util\delay.h ****    The macro F_CPU is supposed to be defined to a
 218:c:\winavr-20100110\avr\include\util\delay.h ****    constant defining the CPU clock frequency (in Hertz).
 219:c:\winavr-20100110\avr\include\util\delay.h **** 
 220:c:\winavr-20100110\avr\include\util\delay.h ****    The maximal possible delay is 768 us / F_CPU in MHz.
 221:c:\winavr-20100110\avr\include\util\delay.h **** 
 222:c:\winavr-20100110\avr\include\util\delay.h ****    If the user requests a delay greater than the maximal possible one,
 223:c:\winavr-20100110\avr\include\util\delay.h ****    _delay_us() will automatically call _delay_ms() instead.  The user
 224:c:\winavr-20100110\avr\include\util\delay.h ****    will not be informed about this case.
 225:c:\winavr-20100110\avr\include\util\delay.h **** 
 226:c:\winavr-20100110\avr\include\util\delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 227:c:\winavr-20100110\avr\include\util\delay.h ****    support, maximal possible delay is 4294967.295 us/ F_CPU in MHz. For
 228:c:\winavr-20100110\avr\include\util\delay.h ****    values greater than the maximal possible delay, overflow results in
 229:c:\winavr-20100110\avr\include\util\delay.h ****    no delay i.e., 0us.
 230:c:\winavr-20100110\avr\include\util\delay.h **** 
 231:c:\winavr-20100110\avr\include\util\delay.h ****    Conversion of \c __us into clock cycles may not always result in
 232:c:\winavr-20100110\avr\include\util\delay.h ****    integer.  By default, the clock cycles rounded up to next
 233:c:\winavr-20100110\avr\include\util\delay.h ****    integer. This ensures that the user gets at least \c __us
 234:c:\winavr-20100110\avr\include\util\delay.h ****    microseconds of delay.
 235:c:\winavr-20100110\avr\include\util\delay.h **** 
 236:c:\winavr-20100110\avr\include\util\delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 237:c:\winavr-20100110\avr\include\util\delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 238:c:\winavr-20100110\avr\include\util\delay.h ****    algorithm can be made to round down, or round to closest integer,
 239:c:\winavr-20100110\avr\include\util\delay.h ****    respectively.
 240:c:\winavr-20100110\avr\include\util\delay.h **** 
 241:c:\winavr-20100110\avr\include\util\delay.h ****    \note
 242:c:\winavr-20100110\avr\include\util\delay.h **** 
 243:c:\winavr-20100110\avr\include\util\delay.h ****    The implementation of _delay_ms() based on
 244:c:\winavr-20100110\avr\include\util\delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 245:c:\winavr-20100110\avr\include\util\delay.h ****    implementations.  In order to get functionality backward compatible
 246:c:\winavr-20100110\avr\include\util\delay.h ****    with previous versions, the macro \c __DELAY_BACKWARD_COMPATIBLE__
 247:c:\winavr-20100110\avr\include\util\delay.h ****    must be defined before including this header file. Also, the
 248:c:\winavr-20100110\avr\include\util\delay.h ****    backward compatible algorithm will be chosen if the code is
 249:c:\winavr-20100110\avr\include\util\delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 250:c:\winavr-20100110\avr\include\util\delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 251:c:\winavr-20100110\avr\include\util\delay.h ****    not available to the compiler then.
 252:c:\winavr-20100110\avr\include\util\delay.h **** 
 253:c:\winavr-20100110\avr\include\util\delay.h ****  */
 254:c:\winavr-20100110\avr\include\util\delay.h **** void
 255:c:\winavr-20100110\avr\include\util\delay.h **** _delay_us(double __us)
 256:c:\winavr-20100110\avr\include\util\delay.h **** {
 257:c:\winavr-20100110\avr\include\util\delay.h **** 	double __tmp ;
 258:c:\winavr-20100110\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 259:c:\winavr-20100110\avr\include\util\delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 260:c:\winavr-20100110\avr\include\util\delay.h ****   __STDC_HOSTED__
 261:c:\winavr-20100110\avr\include\util\delay.h **** 	uint32_t __ticks_dc;
 262:c:\winavr-20100110\avr\include\util\delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 263:c:\winavr-20100110\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 264:c:\winavr-20100110\avr\include\util\delay.h **** 
 265:c:\winavr-20100110\avr\include\util\delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 266:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 267:c:\winavr-20100110\avr\include\util\delay.h **** 
 268:c:\winavr-20100110\avr\include\util\delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 269:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 270:c:\winavr-20100110\avr\include\util\delay.h **** 
 271:c:\winavr-20100110\avr\include\util\delay.h **** 	#else
 272:c:\winavr-20100110\avr\include\util\delay.h **** 		//round up by default
 273:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 274:c:\winavr-20100110\avr\include\util\delay.h **** 	#endif
 275:c:\winavr-20100110\avr\include\util\delay.h **** 
 276:c:\winavr-20100110\avr\include\util\delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 1297               		.loc 2 276 0
 1298 0382 85E3      		ldi r24,lo8(53)
 1299 0384 8A95      	1:	dec r24
 1300 0386 01F4      		brne 1b
 1301 0388 0000      		nop
 1302               	.LVL97:
 1303               	/* epilogue start */
 1304               	.LBE86:
 1305               	.LBE85:
 576:setup.c       **** 	_delay_us(20); // Wait byte program time
 577:setup.c       **** }
 1306               		.loc 1 577 0
 1307 038a DF91      		pop r29
 1308 038c CF91      		pop r28
 1309               	.LVL98:
 1310 038e 1F91      		pop r17
 1311               	.LVL99:
 1312 0390 0895      		ret
 1313               		.cfi_endproc
 1314               	.LFE34:
 1316               	.global	flash_write_sector
 1318               	flash_write_sector:
 1319               	.LFB35:
 578:setup.c       **** 
 579:setup.c       **** // Write a sector (128 bytes) to the Atmel flash
 580:setup.c       **** // Takes 20ms for write cycle
 581:setup.c       **** void flash_write_sector(uint16_t sector) {
 1320               		.loc 1 581 0
 1321               		.cfi_startproc
 1322               	.LVL100:
 1323 0392 EF92      		push r14
 1324               	.LCFI18:
 1325               		.cfi_def_cfa_offset 3
 1326               		.cfi_offset 14, -2
 1327 0394 FF92      		push r15
 1328               	.LCFI19:
 1329               		.cfi_def_cfa_offset 4
 1330               		.cfi_offset 15, -3
 1331 0396 0F93      		push r16
 1332               	.LCFI20:
 1333               		.cfi_def_cfa_offset 5
 1334               		.cfi_offset 16, -4
 1335 0398 1F93      		push r17
 1336               	.LCFI21:
 1337               		.cfi_def_cfa_offset 6
 1338               		.cfi_offset 17, -5
 1339 039a CF93      		push r28
 1340               	.LCFI22:
 1341               		.cfi_def_cfa_offset 7
 1342               		.cfi_offset 28, -6
 1343 039c DF93      		push r29
 1344               	.LCFI23:
 1345               		.cfi_def_cfa_offset 8
 1346               		.cfi_offset 29, -7
 1347               	/* prologue: function */
 1348               	/* frame size = 0 */
 1349               	/* stack size = 6 */
 1350               	.L__stack_usage = 6
 1351 039e 8C01      		movw r16,r24
 582:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xAA);
 1352               		.loc 1 582 0
 1353 03a0 6AEA      		ldi r22,lo8(-86)
 1354 03a2 85E5      		ldi r24,lo8(85)
 1355 03a4 95E5      		ldi r25,lo8(85)
 1356               	.LVL101:
 1357 03a6 00D0      		rcall flash_write_bus_cycle
 1358               	.LVL102:
 583:setup.c       **** 	flash_write_bus_cycle(0x2AAA, 0x55);
 1359               		.loc 1 583 0
 1360 03a8 65E5      		ldi r22,lo8(85)
 1361 03aa 8AEA      		ldi r24,lo8(-86)
 1362 03ac 9AE2      		ldi r25,lo8(42)
 1363 03ae 00D0      		rcall flash_write_bus_cycle
 1364               	.LVL103:
 584:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xA0);
 1365               		.loc 1 584 0
 1366 03b0 60EA      		ldi r22,lo8(-96)
 1367 03b2 85E5      		ldi r24,lo8(85)
 1368 03b4 95E5      		ldi r25,lo8(85)
 1369 03b6 00D0      		rcall flash_write_bus_cycle
 1370               	.LVL104:
 1371               	.LBB87:
 585:setup.c       **** 	
 586:setup.c       **** 	// Write the bytes (A0-A6 byte address, A7-A15 sector address)
 587:setup.c       **** 	for (uint8_t x = 0; x < 128; x++) {
 588:setup.c       **** 		flash_write_bus_cycle((uint16_t) (sector << 7) | (uint16_t) x, receivedBuffer[x]);
 1372               		.loc 1 588 0
 1373 03b8 1695      		lsr r17
 1374 03ba 102F      		mov r17,r16
 1375 03bc 0027      		clr r16
 1376 03be 1795      		ror r17
 1377 03c0 0795      		ror r16
 1378               	.LVL105:
 1379 03c2 90E0      		ldi r25,lo8(receivedBuffer)
 1380 03c4 E92E      		mov r14,r25
 1381 03c6 90E0      		ldi r25,hi8(receivedBuffer)
 1382 03c8 F92E      		mov r15,r25
 1383 03ca C0E0      		ldi r28,0
 1384 03cc D0E0      		ldi r29,0
 1385               	.LVL106:
 1386               	.L66:
 1387               		.loc 1 588 0 is_stmt 0 discriminator 3
 1388 03ce F701      		movw r30,r14
 1389 03d0 6191      		ld r22,Z+
 1390 03d2 7F01      		movw r14,r30
 1391 03d4 CE01      		movw r24,r28
 1392 03d6 802B      		or r24,r16
 1393 03d8 912B      		or r25,r17
 1394 03da 00D0      		rcall flash_write_bus_cycle
 1395               	.LVL107:
 1396 03dc 2196      		adiw r28,1
 1397               	.LVL108:
 587:setup.c       **** 		flash_write_bus_cycle((uint16_t) (sector << 7) | (uint16_t) x, receivedBuffer[x]);
 1398               		.loc 1 587 0 is_stmt 1 discriminator 3
 1399 03de C038      		cpi r28,-128
 1400 03e0 D105      		cpc r29,__zero_reg__
 1401 03e2 01F4      		brne .L66
 1402               	.LVL109:
 1403               	.LBE87:
 1404               	.LBB88:
 1405               	.LBB89:
 187:c:\winavr-20100110\avr\include\util\delay.h **** 
 1406               		.loc 2 187 0
 1407 03e4 8FE3      		ldi r24,lo8(-25537)
 1408 03e6 9CE9      		ldi r25,hi8(-25537)
 1409 03e8 0197      	1:	sbiw r24,1
 1410 03ea 01F4      		brne 1b
 1411 03ec 00C0      		rjmp .
 1412 03ee 0000      		nop
 1413               	.LVL110:
 1414               	/* epilogue start */
 1415               	.LBE89:
 1416               	.LBE88:
 589:setup.c       **** 	}
 590:setup.c       **** 	_delay_ms(20); // Wait sector program time
 591:setup.c       **** }
 1417               		.loc 1 591 0
 1418 03f0 DF91      		pop r29
 1419 03f2 CF91      		pop r28
 1420               	.LVL111:
 1421 03f4 1F91      		pop r17
 1422 03f6 0F91      		pop r16
 1423 03f8 FF90      		pop r15
 1424 03fa EF90      		pop r14
 1425 03fc 0895      		ret
 1426               		.cfi_endproc
 1427               	.LFE35:
 1429               	.global	gb_flash_read_byte
 1431               	gb_flash_read_byte:
 1432               	.LFB36:
 592:setup.c       **** 
 593:setup.c       **** 
 594:setup.c       **** 
 595:setup.c       **** // ---------- GB FLASH CARTS ----------
 596:setup.c       **** 
 597:setup.c       **** // Read a byte from the flash (No CS pin pulse)
 598:setup.c       **** uint8_t gb_flash_read_byte(uint16_t address) {
 1433               		.loc 1 598 0
 1434               		.cfi_startproc
 1435               	.LVL112:
 1436               	/* prologue: function */
 1437               	/* frame size = 0 */
 1438               	/* stack size = 0 */
 1439               	.L__stack_usage = 0
 599:setup.c       **** 	PORT_DATA7_0 = 0;
 1440               		.loc 1 599 0
 1441 03fe 15BA      		out 0x15,__zero_reg__
 600:setup.c       **** 	DDR_DATA7_0 = 0;
 1442               		.loc 1 600 0
 1443 0400 14BA      		out 0x14,__zero_reg__
 601:setup.c       **** 	
 602:setup.c       **** 	set_16bit_address(address);
 1444               		.loc 1 602 0
 1445 0402 00D0      		rcall set_16bit_address
 1446               	.LVL113:
 603:setup.c       **** 	
 604:setup.c       **** 	rdPin_low;
 1447               		.loc 1 604 0
 1448 0404 9598      		cbi 0x12,5
 605:setup.c       **** 	asm volatile("nop"); // Delay a little
 1449               		.loc 1 605 0
 1450               	/* #APP */
 1451               	 ;  605 "setup.c" 1
 1452 0406 0000      		nop
 1453               	 ;  0 "" 2
 606:setup.c       **** 	asm volatile("nop");
 1454               		.loc 1 606 0
 1455               	 ;  606 "setup.c" 1
 1456 0408 0000      		nop
 1457               	 ;  0 "" 2
 607:setup.c       **** 	uint8_t data = PIN_DATA7_0; // Read data
 1458               		.loc 1 607 0
 1459               	/* #NOAPP */
 1460 040a 83B3      		in r24,0x13
 1461               	.LVL114:
 608:setup.c       **** 	rdPin_high;
 1462               		.loc 1 608 0
 1463 040c 959A      		sbi 0x12,5
 609:setup.c       **** 	
 610:setup.c       **** 	return data;
 611:setup.c       **** }
 1464               		.loc 1 611 0
 1465 040e 0895      		ret
 1466               		.cfi_endproc
 1467               	.LFE36:
 1469               	.global	audio_flash_write_bus_cycle
 1471               	audio_flash_write_bus_cycle:
 1472               	.LFB37:
 612:setup.c       **** 
 613:setup.c       **** 
 614:setup.c       **** // 32K Audio WE - Set the address and data for the write byte cycle to the flash (pulsing audio pin
 615:setup.c       **** void audio_flash_write_bus_cycle(uint16_t address, uint8_t data) {
 1473               		.loc 1 615 0
 1474               		.cfi_startproc
 1475               	.LVL115:
 1476 0410 CF93      		push r28
 1477               	.LCFI24:
 1478               		.cfi_def_cfa_offset 3
 1479               		.cfi_offset 28, -2
 1480               	/* prologue: function */
 1481               	/* frame size = 0 */
 1482               	/* stack size = 1 */
 1483               	.L__stack_usage = 1
 1484 0412 C62F      		mov r28,r22
 616:setup.c       **** 	DDR_DATA7_0 = 0xFF; // Set data pins as outputs
 1485               		.loc 1 616 0
 1486 0414 2FEF      		ldi r18,lo8(-1)
 1487 0416 24BB      		out 0x14,r18
 617:setup.c       **** 	set_16bit_address(address);
 1488               		.loc 1 617 0
 1489 0418 00D0      		rcall set_16bit_address
 1490               	.LVL116:
 618:setup.c       **** 	PORT_DATA7_0 = data;
 1491               		.loc 1 618 0
 1492 041a C5BB      		out 0x15,r28
 619:setup.c       **** 	
 620:setup.c       **** 	audioPin_low; // WE low
 1493               		.loc 1 620 0
 1494 041c 3998      		cbi 0x7,1
 621:setup.c       **** 	asm volatile("nop");
 1495               		.loc 1 621 0
 1496               	/* #APP */
 1497               	 ;  621 "setup.c" 1
 1498 041e 0000      		nop
 1499               	 ;  0 "" 2
 622:setup.c       **** 	asm volatile("nop");
 1500               		.loc 1 622 0
 1501               	 ;  622 "setup.c" 1
 1502 0420 0000      		nop
 1503               	 ;  0 "" 2
 623:setup.c       **** 	asm volatile("nop");
 1504               		.loc 1 623 0
 1505               	 ;  623 "setup.c" 1
 1506 0422 0000      		nop
 1507               	 ;  0 "" 2
 624:setup.c       **** 	audioPin_high; // WE high
 1508               		.loc 1 624 0
 1509               	/* #NOAPP */
 1510 0424 399A      		sbi 0x7,1
 1511               	/* epilogue start */
 625:setup.c       **** }
 1512               		.loc 1 625 0
 1513 0426 CF91      		pop r28
 1514               	.LVL117:
 1515 0428 0895      		ret
 1516               		.cfi_endproc
 1517               	.LFE37:
 1519               	.global	audio_flash_write_byte
 1521               	audio_flash_write_byte:
 1522               	.LFB38:
 626:setup.c       **** 
 627:setup.c       **** // 32K Audio WE - Write a single byte to the Flash address. Takes 20us to program Flash.
 628:setup.c       **** void audio_flash_write_byte(uint16_t address, uint8_t data) {
 1523               		.loc 1 628 0
 1524               		.cfi_startproc
 1525               	.LVL118:
 1526 042a 1F93      		push r17
 1527               	.LCFI25:
 1528               		.cfi_def_cfa_offset 3
 1529               		.cfi_offset 17, -2
 1530 042c CF93      		push r28
 1531               	.LCFI26:
 1532               		.cfi_def_cfa_offset 4
 1533               		.cfi_offset 28, -3
 1534 042e DF93      		push r29
 1535               	.LCFI27:
 1536               		.cfi_def_cfa_offset 5
 1537               		.cfi_offset 29, -4
 1538               	/* prologue: function */
 1539               	/* frame size = 0 */
 1540               	/* stack size = 3 */
 1541               	.L__stack_usage = 3
 1542 0430 EC01      		movw r28,r24
 1543 0432 162F      		mov r17,r22
 629:setup.c       **** 	audio_flash_write_bus_cycle(0x555, 0xAA);
 1544               		.loc 1 629 0
 1545 0434 6AEA      		ldi r22,lo8(-86)
 1546               	.LVL119:
 1547 0436 85E5      		ldi r24,lo8(85)
 1548 0438 95E0      		ldi r25,lo8(5)
 1549               	.LVL120:
 1550 043a 00D0      		rcall audio_flash_write_bus_cycle
 1551               	.LVL121:
 630:setup.c       **** 	audio_flash_write_bus_cycle(0x2AA, 0x55);
 1552               		.loc 1 630 0
 1553 043c 65E5      		ldi r22,lo8(85)
 1554 043e 8AEA      		ldi r24,lo8(-86)
 1555 0440 92E0      		ldi r25,lo8(2)
 1556 0442 00D0      		rcall audio_flash_write_bus_cycle
 1557               	.LVL122:
 631:setup.c       **** 	audio_flash_write_bus_cycle(0x555, 0xA0);
 1558               		.loc 1 631 0
 1559 0444 60EA      		ldi r22,lo8(-96)
 1560 0446 85E5      		ldi r24,lo8(85)
 1561 0448 95E0      		ldi r25,lo8(5)
 1562 044a 00D0      		rcall audio_flash_write_bus_cycle
 1563               	.LVL123:
 632:setup.c       **** 	audio_flash_write_bus_cycle(address, data);
 1564               		.loc 1 632 0
 1565 044c 612F      		mov r22,r17
 1566 044e CE01      		movw r24,r28
 1567 0450 00D0      		rcall audio_flash_write_bus_cycle
 1568               	.LVL124:
 1569               	.LBB90:
 1570               	.LBB91:
 1571               		.loc 2 276 0
 1572 0452 85E3      		ldi r24,lo8(53)
 1573 0454 8A95      	1:	dec r24
 1574 0456 01F4      		brne 1b
 1575 0458 0000      		nop
 1576               	.LVL125:
 1577               	.LBE91:
 1578               	.LBE90:
 633:setup.c       **** 	_delay_us(20); // Wait byte program time
 634:setup.c       **** 	
 635:setup.c       **** 	// Set data pins inputs
 636:setup.c       **** 	PORT_DATA7_0 = 0;
 1579               		.loc 1 636 0
 1580 045a 15BA      		out 0x15,__zero_reg__
 637:setup.c       **** 	DDR_DATA7_0 = 0;
 1581               		.loc 1 637 0
 1582 045c 14BA      		out 0x14,__zero_reg__
 638:setup.c       **** 	
 639:setup.c       **** 	// Verify data
 640:setup.c       **** 	uint8_t dataVerify = gb_flash_read_byte(address);
 1583               		.loc 1 640 0
 1584 045e CE01      		movw r24,r28
 1585 0460 00D0      		rcall gb_flash_read_byte
 1586               	.LVL126:
 1587               	.L71:
 641:setup.c       **** 	while (data != dataVerify) {
 1588               		.loc 1 641 0
 1589 0462 8117      		cp r24,r17
 1590 0464 01F0      		breq .L73
 642:setup.c       **** 		dataVerify = gb_flash_read_byte(address);
 1591               		.loc 1 642 0
 1592 0466 CE01      		movw r24,r28
 1593               	.LVL127:
 1594 0468 00D0      		rcall gb_flash_read_byte
 1595               	.LVL128:
 1596               	.LBB92:
 1597               	.LBB93:
 1598               		.loc 2 276 0
 1599 046a 95E3      		ldi r25,lo8(53)
 1600 046c 9A95      	1:	dec r25
 1601 046e 01F4      		brne 1b
 1602 0470 0000      		nop
 1603 0472 00C0      		rjmp .L71
 1604               	.LVL129:
 1605               	.L73:
 1606               	/* epilogue start */
 1607               	.LBE93:
 1608               	.LBE92:
 643:setup.c       **** 		_delay_us(20);
 644:setup.c       **** 	}
 645:setup.c       **** }
 1609               		.loc 1 645 0
 1610 0474 DF91      		pop r29
 1611 0476 CF91      		pop r28
 1612               	.LVL130:
 1613 0478 1F91      		pop r17
 1614               	.LVL131:
 1615 047a 0895      		ret
 1616               		.cfi_endproc
 1617               	.LFE38:
 1619               	.global	bv5_flash_write_bus_cycle
 1621               	bv5_flash_write_bus_cycle:
 1622               	.LFB42:
 646:setup.c       **** 
 647:setup.c       **** 
 648:setup.c       **** // Regular WR - Set the address and data for the write byte cycle to the flash (pulsing WR pin, no 
 649:setup.c       **** void gb_wr_flash_write_bus_cycle(uint16_t address, uint8_t data) {
 650:setup.c       **** 	DDR_DATA7_0 = 0xFF; // Set data pins as outputs
 651:setup.c       **** 	set_16bit_address(address);
 652:setup.c       **** 	PORT_DATA7_0 = data;
 653:setup.c       **** 	
 654:setup.c       **** 	wrPin_low; // WE low
 655:setup.c       **** 	asm volatile("nop");
 656:setup.c       **** 	asm volatile("nop");
 657:setup.c       **** 	asm volatile("nop");
 658:setup.c       **** 	wrPin_high; // WE high
 659:setup.c       **** }
 660:setup.c       **** 
 661:setup.c       **** // Regular WR (Word bus cycle) - Write a single byte to the Flash address. Takes 20us to program Fl
 662:setup.c       **** void gb_wr_flash_write_byte(uint16_t address, uint8_t data) {
 663:setup.c       **** 	gb_wr_flash_write_bus_cycle(0x555, 0xAA);
 664:setup.c       **** 	gb_wr_flash_write_bus_cycle(0x2AA, 0x55);
 665:setup.c       **** 	gb_wr_flash_write_bus_cycle(0x555, 0xA0);
 666:setup.c       **** 	gb_wr_flash_write_bus_cycle(address, data);
 667:setup.c       **** 	_delay_us(20); // Wait byte program time
 668:setup.c       **** 	
 669:setup.c       **** 	// Verify data
 670:setup.c       **** 	uint8_t dataVerify = gb_flash_read_byte(address);
 671:setup.c       **** 	while (data != dataVerify) {
 672:setup.c       **** 		dataVerify = gb_flash_read_byte(address);
 673:setup.c       **** 		_delay_us(20);
 674:setup.c       **** 	}
 675:setup.c       **** }
 676:setup.c       **** 
 677:setup.c       **** // Regular WR (Byte bus cycle) - Write a single byte to the Flash address. Takes 20us to program Fl
 678:setup.c       **** void gb_wr_flash_byte_write_byte(uint16_t address, uint8_t data) {
 679:setup.c       **** 	gb_wr_flash_write_bus_cycle(0xAAA, 0xAA);
 680:setup.c       **** 	gb_wr_flash_write_bus_cycle(0x555, 0x55);
 681:setup.c       **** 	gb_wr_flash_write_bus_cycle(0xAAA, 0xA0);
 682:setup.c       **** 	gb_wr_flash_write_bus_cycle(address, data);
 683:setup.c       **** 	_delay_us(20); // Wait byte program time
 684:setup.c       **** 	
 685:setup.c       **** 	// Verify data
 686:setup.c       **** 	uint8_t dataVerify = gb_flash_read_byte(address);
 687:setup.c       **** 	while (data != dataVerify) {
 688:setup.c       **** 		dataVerify = gb_flash_read_byte(address);
 689:setup.c       **** 		_delay_us(20);
 690:setup.c       **** 	}
 691:setup.c       **** }
 692:setup.c       **** 
 693:setup.c       **** 
 694:setup.c       **** // BV5 - Set the address and data for the write byte cycle to the flash (pulsing WR pin)
 695:setup.c       **** void bv5_flash_write_bus_cycle(uint16_t address, uint8_t data) {
 1623               		.loc 1 695 0
 1624               		.cfi_startproc
 1625               	.LVL132:
 1626 047c CF93      		push r28
 1627               	.LCFI28:
 1628               		.cfi_def_cfa_offset 3
 1629               		.cfi_offset 28, -2
 1630               	/* prologue: function */
 1631               	/* frame size = 0 */
 1632               	/* stack size = 1 */
 1633               	.L__stack_usage = 1
 1634 047e C62F      		mov r28,r22
 696:setup.c       **** 	DDR_DATA7_0 = 0xFF; // Set data pins as outputs
 1635               		.loc 1 696 0
 1636 0480 2FEF      		ldi r18,lo8(-1)
 1637 0482 24BB      		out 0x14,r18
 697:setup.c       **** 	set_16bit_address(address);
 1638               		.loc 1 697 0
 1639 0484 00D0      		rcall set_16bit_address
 1640               	.LVL133:
 698:setup.c       **** 	PORT_DATA7_0 = data;
 1641               		.loc 1 698 0
 1642 0486 C5BB      		out 0x15,r28
 699:setup.c       **** 	
 700:setup.c       **** 	wrPin_low;
 1643               		.loc 1 700 0
 1644 0488 9698      		cbi 0x12,6
 701:setup.c       **** 	asm volatile("nop");
 1645               		.loc 1 701 0
 1646               	/* #APP */
 1647               	 ;  701 "setup.c" 1
 1648 048a 0000      		nop
 1649               	 ;  0 "" 2
 702:setup.c       **** 	asm volatile("nop");
 1650               		.loc 1 702 0
 1651               	 ;  702 "setup.c" 1
 1652 048c 0000      		nop
 1653               	 ;  0 "" 2
 703:setup.c       **** 	asm volatile("nop");
 1654               		.loc 1 703 0
 1655               	 ;  703 "setup.c" 1
 1656 048e 0000      		nop
 1657               	 ;  0 "" 2
 704:setup.c       **** 	wrPin_high;
 1658               		.loc 1 704 0
 1659               	/* #NOAPP */
 1660 0490 969A      		sbi 0x12,6
 1661               	/* epilogue start */
 705:setup.c       **** }
 1662               		.loc 1 705 0
 1663 0492 CF91      		pop r28
 1664               	.LVL134:
 1665 0494 0895      		ret
 1666               		.cfi_endproc
 1667               	.LFE42:
 1669               	.global	gb_wr_flash_byte_write_byte
 1671               	gb_wr_flash_byte_write_byte:
 1672               	.LFB41:
 678:setup.c       **** 	gb_wr_flash_write_bus_cycle(0xAAA, 0xAA);
 1673               		.loc 1 678 0
 1674               		.cfi_startproc
 1675               	.LVL135:
 1676 0496 1F93      		push r17
 1677               	.LCFI29:
 1678               		.cfi_def_cfa_offset 3
 1679               		.cfi_offset 17, -2
 1680 0498 CF93      		push r28
 1681               	.LCFI30:
 1682               		.cfi_def_cfa_offset 4
 1683               		.cfi_offset 28, -3
 1684 049a DF93      		push r29
 1685               	.LCFI31:
 1686               		.cfi_def_cfa_offset 5
 1687               		.cfi_offset 29, -4
 1688               	/* prologue: function */
 1689               	/* frame size = 0 */
 1690               	/* stack size = 3 */
 1691               	.L__stack_usage = 3
 1692 049c EC01      		movw r28,r24
 1693 049e 162F      		mov r17,r22
 679:setup.c       **** 	gb_wr_flash_write_bus_cycle(0x555, 0x55);
 1694               		.loc 1 679 0
 1695 04a0 6AEA      		ldi r22,lo8(-86)
 1696               	.LVL136:
 1697 04a2 8AEA      		ldi r24,lo8(-86)
 1698 04a4 9AE0      		ldi r25,lo8(10)
 1699               	.LVL137:
 1700 04a6 00D0      		rcall bv5_flash_write_bus_cycle
 1701               	.LVL138:
 680:setup.c       **** 	gb_wr_flash_write_bus_cycle(0xAAA, 0xA0);
 1702               		.loc 1 680 0
 1703 04a8 65E5      		ldi r22,lo8(85)
 1704 04aa 85E5      		ldi r24,lo8(85)
 1705 04ac 95E0      		ldi r25,lo8(5)
 1706 04ae 00D0      		rcall bv5_flash_write_bus_cycle
 1707               	.LVL139:
 681:setup.c       **** 	gb_wr_flash_write_bus_cycle(address, data);
 1708               		.loc 1 681 0
 1709 04b0 60EA      		ldi r22,lo8(-96)
 1710 04b2 8AEA      		ldi r24,lo8(-86)
 1711 04b4 9AE0      		ldi r25,lo8(10)
 1712 04b6 00D0      		rcall bv5_flash_write_bus_cycle
 1713               	.LVL140:
 682:setup.c       **** 	_delay_us(20); // Wait byte program time
 1714               		.loc 1 682 0
 1715 04b8 612F      		mov r22,r17
 1716 04ba CE01      		movw r24,r28
 1717 04bc 00D0      		rcall bv5_flash_write_bus_cycle
 1718               	.LVL141:
 1719               	.LBB94:
 1720               	.LBB95:
 1721               		.loc 2 276 0
 1722 04be 85E3      		ldi r24,lo8(53)
 1723 04c0 8A95      	1:	dec r24
 1724 04c2 01F4      		brne 1b
 1725 04c4 0000      		nop
 1726               	.LVL142:
 1727               	.LBE95:
 1728               	.LBE94:
 686:setup.c       **** 	while (data != dataVerify) {
 1729               		.loc 1 686 0
 1730 04c6 CE01      		movw r24,r28
 1731 04c8 00D0      		rcall gb_flash_read_byte
 1732               	.LVL143:
 1733               	.L76:
 687:setup.c       **** 		dataVerify = gb_flash_read_byte(address);
 1734               		.loc 1 687 0
 1735 04ca 8117      		cp r24,r17
 1736 04cc 01F0      		breq .L78
 688:setup.c       **** 		_delay_us(20);
 1737               		.loc 1 688 0
 1738 04ce CE01      		movw r24,r28
 1739               	.LVL144:
 1740 04d0 00D0      		rcall gb_flash_read_byte
 1741               	.LVL145:
 1742               	.LBB96:
 1743               	.LBB97:
 1744               		.loc 2 276 0
 1745 04d2 95E3      		ldi r25,lo8(53)
 1746 04d4 9A95      	1:	dec r25
 1747 04d6 01F4      		brne 1b
 1748 04d8 0000      		nop
 1749 04da 00C0      		rjmp .L76
 1750               	.LVL146:
 1751               	.L78:
 1752               	/* epilogue start */
 1753               	.LBE97:
 1754               	.LBE96:
 691:setup.c       **** 
 1755               		.loc 1 691 0
 1756 04dc DF91      		pop r29
 1757 04de CF91      		pop r28
 1758               	.LVL147:
 1759 04e0 1F91      		pop r17
 1760               	.LVL148:
 1761 04e2 0895      		ret
 1762               		.cfi_endproc
 1763               	.LFE41:
 1765               	.global	gb_wr_flash_write_byte
 1767               	gb_wr_flash_write_byte:
 1768               	.LFB40:
 662:setup.c       **** 	gb_wr_flash_write_bus_cycle(0x555, 0xAA);
 1769               		.loc 1 662 0
 1770               		.cfi_startproc
 1771               	.LVL149:
 1772 04e4 1F93      		push r17
 1773               	.LCFI32:
 1774               		.cfi_def_cfa_offset 3
 1775               		.cfi_offset 17, -2
 1776 04e6 CF93      		push r28
 1777               	.LCFI33:
 1778               		.cfi_def_cfa_offset 4
 1779               		.cfi_offset 28, -3
 1780 04e8 DF93      		push r29
 1781               	.LCFI34:
 1782               		.cfi_def_cfa_offset 5
 1783               		.cfi_offset 29, -4
 1784               	/* prologue: function */
 1785               	/* frame size = 0 */
 1786               	/* stack size = 3 */
 1787               	.L__stack_usage = 3
 1788 04ea EC01      		movw r28,r24
 1789 04ec 162F      		mov r17,r22
 663:setup.c       **** 	gb_wr_flash_write_bus_cycle(0x2AA, 0x55);
 1790               		.loc 1 663 0
 1791 04ee 6AEA      		ldi r22,lo8(-86)
 1792               	.LVL150:
 1793 04f0 85E5      		ldi r24,lo8(85)
 1794 04f2 95E0      		ldi r25,lo8(5)
 1795               	.LVL151:
 1796 04f4 00D0      		rcall bv5_flash_write_bus_cycle
 1797               	.LVL152:
 664:setup.c       **** 	gb_wr_flash_write_bus_cycle(0x555, 0xA0);
 1798               		.loc 1 664 0
 1799 04f6 65E5      		ldi r22,lo8(85)
 1800 04f8 8AEA      		ldi r24,lo8(-86)
 1801 04fa 92E0      		ldi r25,lo8(2)
 1802 04fc 00D0      		rcall bv5_flash_write_bus_cycle
 1803               	.LVL153:
 665:setup.c       **** 	gb_wr_flash_write_bus_cycle(address, data);
 1804               		.loc 1 665 0
 1805 04fe 60EA      		ldi r22,lo8(-96)
 1806 0500 85E5      		ldi r24,lo8(85)
 1807 0502 95E0      		ldi r25,lo8(5)
 1808 0504 00D0      		rcall bv5_flash_write_bus_cycle
 1809               	.LVL154:
 666:setup.c       **** 	_delay_us(20); // Wait byte program time
 1810               		.loc 1 666 0
 1811 0506 612F      		mov r22,r17
 1812 0508 CE01      		movw r24,r28
 1813 050a 00D0      		rcall bv5_flash_write_bus_cycle
 1814               	.LVL155:
 1815               	.LBB98:
 1816               	.LBB99:
 1817               		.loc 2 276 0
 1818 050c 85E3      		ldi r24,lo8(53)
 1819 050e 8A95      	1:	dec r24
 1820 0510 01F4      		brne 1b
 1821 0512 0000      		nop
 1822               	.LVL156:
 1823               	.LBE99:
 1824               	.LBE98:
 670:setup.c       **** 	while (data != dataVerify) {
 1825               		.loc 1 670 0
 1826 0514 CE01      		movw r24,r28
 1827 0516 00D0      		rcall gb_flash_read_byte
 1828               	.LVL157:
 1829               	.L80:
 671:setup.c       **** 		dataVerify = gb_flash_read_byte(address);
 1830               		.loc 1 671 0
 1831 0518 8117      		cp r24,r17
 1832 051a 01F0      		breq .L82
 672:setup.c       **** 		_delay_us(20);
 1833               		.loc 1 672 0
 1834 051c CE01      		movw r24,r28
 1835               	.LVL158:
 1836 051e 00D0      		rcall gb_flash_read_byte
 1837               	.LVL159:
 1838               	.LBB100:
 1839               	.LBB101:
 1840               		.loc 2 276 0
 1841 0520 95E3      		ldi r25,lo8(53)
 1842 0522 9A95      	1:	dec r25
 1843 0524 01F4      		brne 1b
 1844 0526 0000      		nop
 1845 0528 00C0      		rjmp .L80
 1846               	.LVL160:
 1847               	.L82:
 1848               	/* epilogue start */
 1849               	.LBE101:
 1850               	.LBE100:
 675:setup.c       **** 
 1851               		.loc 1 675 0
 1852 052a DF91      		pop r29
 1853 052c CF91      		pop r28
 1854               	.LVL161:
 1855 052e 1F91      		pop r17
 1856               	.LVL162:
 1857 0530 0895      		ret
 1858               		.cfi_endproc
 1859               	.LFE40:
 1861               	.global	gb_wr_flash_write_bus_cycle
 1863               	gb_wr_flash_write_bus_cycle:
 1864               	.LFB50:
 1865               		.cfi_startproc
 1866               	/* prologue: function */
 1867               	/* frame size = 0 */
 1868               	/* stack size = 0 */
 1869               	.L__stack_usage = 0
 1870 0532 00C0      		rjmp bv5_flash_write_bus_cycle
 1871               		.cfi_endproc
 1872               	.LFE50:
 1874               	.global	bv5_flash_write_byte
 1876               	bv5_flash_write_byte:
 1877               	.LFB43:
 706:setup.c       **** 
 707:setup.c       **** // BV5 - Write a single byte to the Flash address. Time to wait depends on Flash.
 708:setup.c       **** // Data byte's bit 0 & 1 are swapped for chip commands as D0 & D1 lines are swapped
 709:setup.c       **** void bv5_flash_write_byte(uint16_t address, uint8_t data) {
 1878               		.loc 1 709 0
 1879               		.cfi_startproc
 1880               	.LVL163:
 1881               		.loc 1 709 0
 1882 0534 1F93      		push r17
 1883               	.LCFI35:
 1884               		.cfi_def_cfa_offset 3
 1885               		.cfi_offset 17, -2
 1886 0536 CF93      		push r28
 1887               	.LCFI36:
 1888               		.cfi_def_cfa_offset 4
 1889               		.cfi_offset 28, -3
 1890 0538 DF93      		push r29
 1891               	.LCFI37:
 1892               		.cfi_def_cfa_offset 5
 1893               		.cfi_offset 29, -4
 1894               	/* prologue: function */
 1895               	/* frame size = 0 */
 1896               	/* stack size = 3 */
 1897               	.L__stack_usage = 3
 1898 053a EC01      		movw r28,r24
 1899 053c 162F      		mov r17,r22
 710:setup.c       **** 	bv5_flash_write_bus_cycle(0xAAA, 0xA9);
 1900               		.loc 1 710 0
 1901 053e 69EA      		ldi r22,lo8(-87)
 1902               	.LVL164:
 1903 0540 8AEA      		ldi r24,lo8(-86)
 1904 0542 9AE0      		ldi r25,lo8(10)
 1905               	.LVL165:
 1906 0544 00D0      		rcall bv5_flash_write_bus_cycle
 1907               	.LVL166:
 711:setup.c       **** 	bv5_flash_write_bus_cycle(0x555, 0x56);
 1908               		.loc 1 711 0
 1909 0546 66E5      		ldi r22,lo8(86)
 1910 0548 85E5      		ldi r24,lo8(85)
 1911 054a 95E0      		ldi r25,lo8(5)
 1912 054c 00D0      		rcall bv5_flash_write_bus_cycle
 1913               	.LVL167:
 712:setup.c       **** 	bv5_flash_write_bus_cycle(0xAAA, 0xA0);
 1914               		.loc 1 712 0
 1915 054e 60EA      		ldi r22,lo8(-96)
 1916 0550 8AEA      		ldi r24,lo8(-86)
 1917 0552 9AE0      		ldi r25,lo8(10)
 1918 0554 00D0      		rcall bv5_flash_write_bus_cycle
 1919               	.LVL168:
 713:setup.c       **** 	bv5_flash_write_bus_cycle(address, data);
 1920               		.loc 1 713 0
 1921 0556 612F      		mov r22,r17
 1922 0558 CE01      		movw r24,r28
 1923 055a 00D0      		rcall bv5_flash_write_bus_cycle
 1924               	.LVL169:
 1925               	.LBB102:
 1926               	.LBB103:
 1927               		.loc 2 276 0
 1928 055c 85E3      		ldi r24,lo8(53)
 1929 055e 8A95      	1:	dec r24
 1930 0560 01F4      		brne 1b
 1931 0562 0000      		nop
 1932               	.LVL170:
 1933               	.LBE103:
 1934               	.LBE102:
 714:setup.c       **** 	_delay_us(20); // Wait byte program time
 715:setup.c       **** 	
 716:setup.c       **** 	// Verify data
 717:setup.c       **** 	uint8_t dataVerify = gb_flash_read_byte(address);
 1935               		.loc 1 717 0
 1936 0564 CE01      		movw r24,r28
 1937 0566 00D0      		rcall gb_flash_read_byte
 1938               	.LVL171:
 1939               	.L85:
 718:setup.c       **** 	while (data != dataVerify) {
 1940               		.loc 1 718 0
 1941 0568 8117      		cp r24,r17
 1942 056a 01F0      		breq .L87
 719:setup.c       **** 		dataVerify = gb_flash_read_byte(address);
 1943               		.loc 1 719 0
 1944 056c CE01      		movw r24,r28
 1945               	.LVL172:
 1946 056e 00D0      		rcall gb_flash_read_byte
 1947               	.LVL173:
 1948               	.LBB104:
 1949               	.LBB105:
 1950               		.loc 2 276 0
 1951 0570 95E3      		ldi r25,lo8(53)
 1952 0572 9A95      	1:	dec r25
 1953 0574 01F4      		brne 1b
 1954 0576 0000      		nop
 1955 0578 00C0      		rjmp .L85
 1956               	.LVL174:
 1957               	.L87:
 1958               	/* epilogue start */
 1959               	.LBE105:
 1960               	.LBE104:
 720:setup.c       **** 		_delay_us(20);
 721:setup.c       **** 	}
 722:setup.c       **** }
 1961               		.loc 1 722 0
 1962 057a DF91      		pop r29
 1963 057c CF91      		pop r28
 1964               	.LVL175:
 1965 057e 1F91      		pop r17
 1966               	.LVL176:
 1967 0580 0895      		ret
 1968               		.cfi_endproc
 1969               	.LFE43:
 1971               	.global	gb_word_flash_write_byte
 1973               	gb_word_flash_write_byte:
 1974               	.LFB44:
 723:setup.c       **** 
 724:setup.c       **** 
 725:setup.c       **** // GB (Word) - Write a single byte to the Flash address. Time to wait depends on Flash.
 726:setup.c       **** // Data byte's bit 0 & 1 are swapped for chip commands as D0 & D1 lines are swapped
 727:setup.c       **** void gb_word_flash_write_byte(uint16_t address, uint8_t data) {
 1975               		.loc 1 727 0
 1976               		.cfi_startproc
 1977               	.LVL177:
 1978 0582 1F93      		push r17
 1979               	.LCFI38:
 1980               		.cfi_def_cfa_offset 3
 1981               		.cfi_offset 17, -2
 1982 0584 CF93      		push r28
 1983               	.LCFI39:
 1984               		.cfi_def_cfa_offset 4
 1985               		.cfi_offset 28, -3
 1986 0586 DF93      		push r29
 1987               	.LCFI40:
 1988               		.cfi_def_cfa_offset 5
 1989               		.cfi_offset 29, -4
 1990               	/* prologue: function */
 1991               	/* frame size = 0 */
 1992               	/* stack size = 3 */
 1993               	.L__stack_usage = 3
 1994 0588 EC01      		movw r28,r24
 1995 058a 162F      		mov r17,r22
 728:setup.c       **** 	bv5_flash_write_bus_cycle(0x555, 0xA9);
 1996               		.loc 1 728 0
 1997 058c 69EA      		ldi r22,lo8(-87)
 1998               	.LVL178:
 1999 058e 85E5      		ldi r24,lo8(85)
 2000 0590 95E0      		ldi r25,lo8(5)
 2001               	.LVL179:
 2002 0592 00D0      		rcall bv5_flash_write_bus_cycle
 2003               	.LVL180:
 729:setup.c       **** 	bv5_flash_write_bus_cycle(0x2AA, 0x56);
 2004               		.loc 1 729 0
 2005 0594 66E5      		ldi r22,lo8(86)
 2006 0596 8AEA      		ldi r24,lo8(-86)
 2007 0598 92E0      		ldi r25,lo8(2)
 2008 059a 00D0      		rcall bv5_flash_write_bus_cycle
 2009               	.LVL181:
 730:setup.c       **** 	bv5_flash_write_bus_cycle(0x555, 0xA0);
 2010               		.loc 1 730 0
 2011 059c 60EA      		ldi r22,lo8(-96)
 2012 059e 85E5      		ldi r24,lo8(85)
 2013 05a0 95E0      		ldi r25,lo8(5)
 2014 05a2 00D0      		rcall bv5_flash_write_bus_cycle
 2015               	.LVL182:
 731:setup.c       **** 	bv5_flash_write_bus_cycle(address, data);
 2016               		.loc 1 731 0
 2017 05a4 612F      		mov r22,r17
 2018 05a6 CE01      		movw r24,r28
 2019 05a8 00D0      		rcall bv5_flash_write_bus_cycle
 2020               	.LVL183:
 2021               	.LBB106:
 2022               	.LBB107:
 2023               		.loc 2 276 0
 2024 05aa 85E3      		ldi r24,lo8(53)
 2025 05ac 8A95      	1:	dec r24
 2026 05ae 01F4      		brne 1b
 2027 05b0 0000      		nop
 2028               	.LVL184:
 2029               	.LBE107:
 2030               	.LBE106:
 732:setup.c       **** 	_delay_us(20); // Wait byte program time
 733:setup.c       **** 	
 734:setup.c       **** 	// Verify data
 735:setup.c       **** 	uint8_t dataVerify = gb_flash_read_byte(address);
 2031               		.loc 1 735 0
 2032 05b2 CE01      		movw r24,r28
 2033 05b4 00D0      		rcall gb_flash_read_byte
 2034               	.LVL185:
 2035               	.L89:
 736:setup.c       **** 	while (data != dataVerify) {
 2036               		.loc 1 736 0
 2037 05b6 8117      		cp r24,r17
 2038 05b8 01F0      		breq .L91
 737:setup.c       **** 		dataVerify = gb_flash_read_byte(address);
 2039               		.loc 1 737 0
 2040 05ba CE01      		movw r24,r28
 2041               	.LVL186:
 2042 05bc 00D0      		rcall gb_flash_read_byte
 2043               	.LVL187:
 2044               	.LBB108:
 2045               	.LBB109:
 2046               		.loc 2 276 0
 2047 05be 95E3      		ldi r25,lo8(53)
 2048 05c0 9A95      	1:	dec r25
 2049 05c2 01F4      		brne 1b
 2050 05c4 0000      		nop
 2051 05c6 00C0      		rjmp .L89
 2052               	.LVL188:
 2053               	.L91:
 2054               	/* epilogue start */
 2055               	.LBE109:
 2056               	.LBE108:
 738:setup.c       **** 		_delay_us(20);
 739:setup.c       **** 	}
 740:setup.c       **** }
 2057               		.loc 1 740 0
 2058 05c8 DF91      		pop r29
 2059 05ca CF91      		pop r28
 2060               	.LVL189:
 2061 05cc 1F91      		pop r17
 2062               	.LVL190:
 2063 05ce 0895      		ret
 2064               		.cfi_endproc
 2065               	.LFE44:
 2067               	.global	gba_flash_write_bus_cycle
 2069               	gba_flash_write_bus_cycle:
 2070               	.LFB45:
 741:setup.c       **** 
 742:setup.c       **** 
 743:setup.c       **** // ---------- GBA FLASH CARTS ----------
 744:setup.c       **** 
 745:setup.c       **** // Set the 24 bit address and 16 bit data for the write byte cycle to the flash (pulse WR pin)
 746:setup.c       **** void gba_flash_write_bus_cycle(uint32_t address, uint16_t data) {
 2071               		.loc 1 746 0
 2072               		.cfi_startproc
 2073               	.LVL191:
 2074 05d0 CF93      		push r28
 2075               	.LCFI41:
 2076               		.cfi_def_cfa_offset 3
 2077               		.cfi_offset 28, -2
 2078 05d2 DF93      		push r29
 2079               	.LCFI42:
 2080               		.cfi_def_cfa_offset 4
 2081               		.cfi_offset 29, -3
 2082               	/* prologue: function */
 2083               	/* frame size = 0 */
 2084               	/* stack size = 2 */
 2085               	.L__stack_usage = 2
 2086 05d4 EA01      		movw r28,r20
 747:setup.c       **** 	gba_set_24bit_address(address);
 2087               		.loc 1 747 0
 2088 05d6 00D0      		rcall gba_set_24bit_address
 2089               	.LVL192:
 748:setup.c       **** 	
 749:setup.c       **** 	cs_mreqPin_low;
 2090               		.loc 1 749 0
 2091 05d8 9498      		cbi 0x12,4
 750:setup.c       **** 	
 751:setup.c       **** 	GBA_DDR_ROM_ADDR15_8 = 0xFF; // Set data pins as outputs
 2092               		.loc 1 751 0
 2093 05da 8FEF      		ldi r24,lo8(-1)
 2094 05dc 8ABB      		out 0x1a,r24
 752:setup.c       **** 	GBA_DDR_ROM_ADDR7_0 = 0xFF;
 2095               		.loc 1 752 0
 2096 05de 87BB      		out 0x17,r24
 753:setup.c       **** 	GBA_PORT_ROM_DATA15_8 = data >> 8; // Set data
 2097               		.loc 1 753 0
 2098 05e0 DBBB      		out 0x1b,r29
 754:setup.c       **** 	GBA_PORT_ROM_DATA7_0 = data & 0xFF;
 2099               		.loc 1 754 0
 2100 05e2 C8BB      		out 0x18,r28
 755:setup.c       **** 	
 756:setup.c       **** 	wrPin_low;
 2101               		.loc 1 756 0
 2102 05e4 9698      		cbi 0x12,6
 757:setup.c       **** 	asm volatile("nop");
 2103               		.loc 1 757 0
 2104               	/* #APP */
 2105               	 ;  757 "setup.c" 1
 2106 05e6 0000      		nop
 2107               	 ;  0 "" 2
 758:setup.c       **** 	asm volatile("nop");
 2108               		.loc 1 758 0
 2109               	 ;  758 "setup.c" 1
 2110 05e8 0000      		nop
 2111               	 ;  0 "" 2
 759:setup.c       **** 	asm volatile("nop");
 2112               		.loc 1 759 0
 2113               	 ;  759 "setup.c" 1
 2114 05ea 0000      		nop
 2115               	 ;  0 "" 2
 760:setup.c       **** 	wrPin_high;
 2116               		.loc 1 760 0
 2117               	/* #NOAPP */
 2118 05ec 969A      		sbi 0x12,6
 761:setup.c       **** 	cs_mreqPin_high;
 2119               		.loc 1 761 0
 2120 05ee 949A      		sbi 0x12,4
 2121               	/* epilogue start */
 762:setup.c       **** }
 2122               		.loc 1 762 0
 2123 05f0 DF91      		pop r29
 2124 05f2 CF91      		pop r28
 2125               	.LVL193:
 2126 05f4 0895      		ret
 2127               		.cfi_endproc
 2128               	.LFE45:
 2130               	.global	gba_flash_write_byte_swapped
 2132               	gba_flash_write_byte_swapped:
 2133               	.LFB46:
 763:setup.c       **** 
 764:setup.c       **** // Write 2 bytes to the Flash address. Time to wait depends on Flash, we will query it to verify th
 765:setup.c       **** // Address is divided by 2 as we are in GBA mode. 
 766:setup.c       **** // Data byte's bit 0 & 1 are swapped for chip commands as D0 & D1 lines are swapped
 767:setup.c       **** void gba_flash_write_byte_swapped(uint32_t address, uint16_t data) {
 2134               		.loc 1 767 0
 2135               		.cfi_startproc
 2136               	.LVL194:
 2137 05f6 CF92      		push r12
 2138               	.LCFI43:
 2139               		.cfi_def_cfa_offset 3
 2140               		.cfi_offset 12, -2
 2141 05f8 DF92      		push r13
 2142               	.LCFI44:
 2143               		.cfi_def_cfa_offset 4
 2144               		.cfi_offset 13, -3
 2145 05fa EF92      		push r14
 2146               	.LCFI45:
 2147               		.cfi_def_cfa_offset 5
 2148               		.cfi_offset 14, -4
 2149 05fc FF92      		push r15
 2150               	.LCFI46:
 2151               		.cfi_def_cfa_offset 6
 2152               		.cfi_offset 15, -5
 2153 05fe CF93      		push r28
 2154               	.LCFI47:
 2155               		.cfi_def_cfa_offset 7
 2156               		.cfi_offset 28, -6
 2157 0600 DF93      		push r29
 2158               	.LCFI48:
 2159               		.cfi_def_cfa_offset 8
 2160               		.cfi_offset 29, -7
 2161               	/* prologue: function */
 2162               	/* frame size = 0 */
 2163               	/* stack size = 6 */
 2164               	.L__stack_usage = 6
 2165 0602 6B01      		movw r12,r22
 2166 0604 7C01      		movw r14,r24
 2167 0606 EA01      		movw r28,r20
 768:setup.c       **** 	gba_flash_write_bus_cycle(0xAAA / 2, 0xA9);
 2168               		.loc 1 768 0
 2169 0608 49EA      		ldi r20,lo8(-87)
 2170 060a 50E0      		ldi r21,0
 2171               	.LVL195:
 2172 060c 65E5      		ldi r22,lo8(85)
 2173 060e 75E0      		ldi r23,lo8(5)
 2174 0610 80E0      		ldi r24,0
 2175 0612 90E0      		ldi r25,0
 2176               	.LVL196:
 2177 0614 00D0      		rcall gba_flash_write_bus_cycle
 2178               	.LVL197:
 769:setup.c       **** 	gba_flash_write_bus_cycle(0x555 / 2, 0x56);
 2179               		.loc 1 769 0
 2180 0616 46E5      		ldi r20,lo8(86)
 2181 0618 50E0      		ldi r21,0
 2182 061a 6AEA      		ldi r22,lo8(-86)
 2183 061c 72E0      		ldi r23,lo8(2)
 2184 061e 80E0      		ldi r24,0
 2185 0620 90E0      		ldi r25,0
 2186 0622 00D0      		rcall gba_flash_write_bus_cycle
 2187               	.LVL198:
 770:setup.c       **** 	gba_flash_write_bus_cycle(0xAAA / 2, 0xA0);
 2188               		.loc 1 770 0
 2189 0624 40EA      		ldi r20,lo8(-96)
 2190 0626 50E0      		ldi r21,0
 2191 0628 65E5      		ldi r22,lo8(85)
 2192 062a 75E0      		ldi r23,lo8(5)
 2193 062c 80E0      		ldi r24,0
 2194 062e 90E0      		ldi r25,0
 2195 0630 00D0      		rcall gba_flash_write_bus_cycle
 2196               	.LVL199:
 771:setup.c       **** 	gba_flash_write_bus_cycle(address, data);
 2197               		.loc 1 771 0
 2198 0632 AE01      		movw r20,r28
 2199 0634 C701      		movw r24,r14
 2200 0636 B601      		movw r22,r12
 2201 0638 00D0      		rcall gba_flash_write_bus_cycle
 2202               	.LVL200:
 2203               	.LBB110:
 2204               	.LBB111:
 2205               		.loc 2 276 0
 2206 063a 25E3      		ldi r18,lo8(53)
 2207 063c 2A95      	1:	dec r18
 2208 063e 01F4      		brne 1b
 2209 0640 0000      		nop
 2210               	.LVL201:
 2211               	.LBE111:
 2212               	.LBE110:
 772:setup.c       **** 	_delay_us(20); // Wait byte program time
 773:setup.c       **** 	
 774:setup.c       **** 	// Verify data
 775:setup.c       **** 	uint16_t dataVerify = gba_read_16bit_data(address);
 2213               		.loc 1 775 0
 2214 0642 C701      		movw r24,r14
 2215 0644 B601      		movw r22,r12
 2216 0646 00D0      		rcall gba_read_16bit_data
 2217               	.LVL202:
 2218               	.L94:
 776:setup.c       **** 	while (data != dataVerify) {
 2219               		.loc 1 776 0
 2220 0648 8C17      		cp r24,r28
 2221 064a 9D07      		cpc r25,r29
 2222 064c 01F0      		breq .L96
 777:setup.c       **** 		dataVerify = gba_read_16bit_data(address);
 2223               		.loc 1 777 0
 2224 064e C701      		movw r24,r14
 2225 0650 B601      		movw r22,r12
 2226 0652 00D0      		rcall gba_read_16bit_data
 2227               	.LVL203:
 2228               	.LBB112:
 2229               	.LBB113:
 2230               		.loc 2 276 0
 2231 0654 25E3      		ldi r18,lo8(53)
 2232 0656 2A95      	1:	dec r18
 2233 0658 01F4      		brne 1b
 2234 065a 0000      		nop
 2235 065c 00C0      		rjmp .L94
 2236               	.LVL204:
 2237               	.L96:
 2238               	/* epilogue start */
 2239               	.LBE113:
 2240               	.LBE112:
 778:setup.c       **** 		_delay_us(20);
 779:setup.c       **** 	}
 780:setup.c       **** }
 2241               		.loc 1 780 0
 2242 065e DF91      		pop r29
 2243 0660 CF91      		pop r28
 2244               	.LVL205:
 2245 0662 FF90      		pop r15
 2246 0664 EF90      		pop r14
 2247 0666 DF90      		pop r13
 2248 0668 CF90      		pop r12
 2249               	.LVL206:
 2250 066a 0895      		ret
 2251               		.cfi_endproc
 2252               	.LFE46:
 2254               	.global	setup
 2256               	setup:
 2257               	.LFB47:
 781:setup.c       **** 
 782:setup.c       **** 
 783:setup.c       **** // Setup
 784:setup.c       **** void setup(void) {
 2258               		.loc 1 784 0
 2259               		.cfi_startproc
 2260               	/* prologue: function */
 2261               	/* frame size = 0 */
 2262               	/* stack size = 0 */
 2263               	.L__stack_usage = 0
 785:setup.c       **** 	// Turn off watchdog
 786:setup.c       **** 	MCUCSR &= ~(1<<WDRF);
 2264               		.loc 1 786 0
 2265 066c 84B7      		in r24,0x34
 2266 066e 877F      		andi r24,lo8(-9)
 2267 0670 84BF      		out 0x34,r24
 787:setup.c       **** 	WDTCR = (1<<WDCE) | (1<<WDE);
 2268               		.loc 1 787 0
 2269 0672 88E1      		ldi r24,lo8(24)
 2270 0674 81BD      		out 0x21,r24
 788:setup.c       **** 	WDTCR = 0;
 2271               		.loc 1 788 0
 2272 0676 11BC      		out 0x21,__zero_reg__
 789:setup.c       **** 	
 790:setup.c       **** 	// Reset common lines
 791:setup.c       **** 	rd_wr_csmreq_cs2_reset();
 2273               		.loc 1 791 0
 2274 0678 00D0      		rcall rd_wr_csmreq_cs2_reset
 2275               	.LVL207:
 792:setup.c       **** 	
 793:setup.c       **** 	// Set outputs
 794:setup.c       **** 	DDRD |= (1<<ACTIVITY_LED) | (1<<WR_PIN) | (1<<RD_PIN) | (1<<CS_MREQ_PIN) | (1<<LED_5V);
 2276               		.loc 1 794 0
 2277 067a 81B3      		in r24,0x11
 2278 067c 886F      		ori r24,lo8(-8)
 2279 067e 81BB      		out 0x11,r24
 795:setup.c       **** 	DDRE |= (1<<CS2_PIN) | (1<<LED_3V);
 2280               		.loc 1 795 0
 2281 0680 86B1      		in r24,0x6
 2282 0682 8560      		ori r24,lo8(5)
 2283 0684 86B9      		out 0x6,r24
 796:setup.c       **** 	
 797:setup.c       **** 	// Set all pins as inputs
 798:setup.c       **** 	PORT_DATA7_0 = 0;
 2284               		.loc 1 798 0
 2285 0686 15BA      		out 0x15,__zero_reg__
 799:setup.c       **** 	DDR_DATA7_0 = 0;
 2286               		.loc 1 799 0
 2287 0688 14BA      		out 0x14,__zero_reg__
 800:setup.c       **** 	PORT_ADDR7_0 = 0;
 2288               		.loc 1 800 0
 2289 068a 18BA      		out 0x18,__zero_reg__
 801:setup.c       **** 	DDR_ADDR7_0 = 0;
 2290               		.loc 1 801 0
 2291 068c 17BA      		out 0x17,__zero_reg__
 802:setup.c       **** 	PORT_ADDR15_8 = 0;
 2292               		.loc 1 802 0
 2293 068e 1BBA      		out 0x1b,__zero_reg__
 803:setup.c       **** 	DDR_ADDR15_8 = 0;
 2294               		.loc 1 803 0
 2295 0690 1ABA      		out 0x1a,__zero_reg__
 804:setup.c       **** 	
 805:setup.c       **** 	// Light up 3.3V or 5V
 806:setup.c       **** 	if (PIND & (1<<SWITCH_DETECT)) {
 2296               		.loc 1 806 0
 2297 0692 829B      		sbis 0x10,2
 2298 0694 00C0      		rjmp .L98
 807:setup.c       **** 		PORTD |= (1<<LED_5V);
 2299               		.loc 1 807 0
 2300 0696 979A      		sbi 0x12,7
 808:setup.c       **** 		PORTE &= ~(1<<LED_3V);
 2301               		.loc 1 808 0
 2302 0698 3898      		cbi 0x7,0
 2303 069a 00C0      		rjmp .L99
 2304               	.L98:
 809:setup.c       **** 	}
 810:setup.c       **** 	else {
 811:setup.c       **** 		PORTE |= (1<<LED_3V);
 2305               		.loc 1 811 0
 2306 069c 389A      		sbi 0x7,0
 812:setup.c       **** 		PORTD &= ~(1<<LED_5V);
 2307               		.loc 1 812 0
 2308 069e 9798      		cbi 0x12,7
 2309               	.L99:
 813:setup.c       **** 	}
 814:setup.c       **** 	
 815:setup.c       **** 	// Light LED
 816:setup.c       **** 	PORTD |= (1<<ACTIVITY_LED);
 2310               		.loc 1 816 0
 2311 06a0 939A      		sbi 0x12,3
 2312               	.LVL208:
 2313               	.LBB114:
 2314               	.LBB115:
 187:c:\winavr-20100110\avr\include\util\delay.h **** 
 2315               		.loc 2 187 0
 2316 06a2 2FEF      		ldi r18,lo8(799999)
 2317 06a4 84E3      		ldi r24,hi8(799999)
 2318 06a6 9CE0      		ldi r25,hlo8(799999)
 2319 06a8 2150      	1:	subi r18,1
 2320 06aa 8040      		sbci r24,0
 2321 06ac 9040      		sbci r25,0
 2322 06ae 01F4      		brne 1b
 2323 06b0 00C0      		rjmp .
 2324 06b2 0000      		nop
 2325               	.LVL209:
 2326               	.LBE115:
 2327               	.LBE114:
 817:setup.c       **** 	_delay_ms(500);
 818:setup.c       **** 	PORTD &= ~(1<<ACTIVITY_LED);
 2328               		.loc 1 818 0
 2329 06b4 9398      		cbi 0x12,3
 819:setup.c       **** 	
 820:setup.c       **** 	// Setup USART
 821:setup.c       **** 	UBRRL = 0; // 1Mbps Baud rate
 2330               		.loc 1 821 0
 2331 06b6 19B8      		out 0x9,__zero_reg__
 822:setup.c       **** 	sbi(UCSRA, U2X); // Double rate
 2332               		.loc 1 822 0
 2333 06b8 599A      		sbi 0xb,1
 823:setup.c       **** 	sbi(UCSRB, TXEN); // Transmitter enable
 2334               		.loc 1 823 0
 2335 06ba 539A      		sbi 0xa,3
 824:setup.c       **** 	sbi(UCSRB, RXEN); // Receiver enable
 2336               		.loc 1 824 0
 2337 06bc 549A      		sbi 0xa,4
 825:setup.c       **** 	
 826:setup.c       **** 	// Turn on interrupts
 827:setup.c       **** 	sei();
 2338               		.loc 1 827 0
 2339               	/* #APP */
 2340               	 ;  827 "setup.c" 1
 2341 06be 7894      		sei
 2342               	 ;  0 "" 2
 2343               	/* #NOAPP */
 2344 06c0 0895      		ret
 2345               		.cfi_endproc
 2346               	.LFE47:
 2348               		.section	.text.startup,"ax",@progbits
 2349               	.global	main
 2351               	main:
 2352               	.LFB48:
 2353               		.file 3 "main.c"
   1:main.c        **** /*
   2:main.c        ****  GBxCart RW
   3:main.c        ****  PCB version: 1.1 or 1.2
   4:main.c        ****  Firmware version: R8
   5:main.c        ****  Author: Alex from insideGadgets (www.insidegadgets.com)
   6:main.c        ****  Created: 7/11/2016
   7:main.c        ****  Last Modified: 15/02/2018
   8:main.c        ****  
   9:main.c        ****  GBxCart RW allows you to dump your Gameboy/Gameboy Colour/Gameboy Advance games ROM, save the RAM 
  10:main.c        ****  
  11:main.c        ****  The ATmega8515L talks to the cartridge and interfaces with the CH340G serial to USB converter with
  12:main.c        ****  
  13:main.c        ****  
  14:main.c        ****  Set fuse bits: External 8MHz crystal, divide clock by 8 is off, boot loader is on (512 bytes), BOD
  15:main.c        ****  avrdude -p atmega8515 -c usbasp -U lfuse:w:0xaf:m -U hfuse:w:0xda:m
  16:main.c        ****  
  17:main.c        ****  Program the TinySafeBoot boot loader (modified ASM code, watchdog reset will act as a hardware res
  18:main.c        ****  avrdude -p atmega8515 -c usbasp -U flash:w:GBxCart_RW_v1.1_Rx\tsb\tsb_m8515_d0d1_resetwdt.hex
  19:main.c        ****  
  20:main.c        ****  Program GBxCart RW through TinySafeBoot
  21:main.c        ****  tsb com16:57600 fw GBxCart_RW_v1.1_Rx\main.hex
  22:main.c        ****  
  23:main.c        ****  Set TinySafeBoot delay time to 25 (T 25), gives ~0.5s in bootloader
  24:main.c        ****  tsb com16:9600 T 25
  25:main.c        ****  
  26:main.c        ****  
  27:main.c        ****  Programming shortcuts (if added in Programmers Notepad):
  28:main.c        ****  Alt + W - Program fuse
  29:main.c        ****  Alt + B - Burn bootloader
  30:main.c        ****  
  31:main.c        ****  Plug in USB then
  32:main.c        ****  Alt + T - Program
  33:main.c        ****  Alt + N - Program delay settings
  34:main.c        ****  
  35:main.c        ****  
  36:main.c        ****  */
  37:main.c        **** 
  38:main.c        **** // ATmega8515L Pin Map
  39:main.c        **** //
  40:main.c        **** // VCC (5)			GND (6)			XTAL (7 ,8)		Activity LED PD3 (9)				Switch sense PD2 (8)
  41:main.c        **** // SCK PB7 (3)		MOSI PB5 (1)	MISO PB6 (2)	RST (4)		RXD PD0 (5)			TXD PD1 (7)
  42:main.c        **** // 
  43:main.c        **** // Gameboy / Gameboy Colour
  44:main.c        **** // A0-A7 PB0-7 (40-44, 1-3) 		A8-A15 PA0-7 (37-30)			D0-D7 PC0-7 (18-25)		Audio PE1 (27)
  45:main.c        **** // 
  46:main.c        **** // Gameboy Advance
  47:main.c        **** // AD0-AD7 PB0-7 (40-44, 1-3) 	AD8-AD15 PA0-7 (37-30)		A16-23 / D0-D7 PC0-7 (19-26)
  48:main.c        **** // *WR PD6 (13)						*RD PD5 (14)					*MREQ/CS PD4 (15)			CS2/RST PE2 (16)
  49:main.c        **** 
  50:main.c        **** #define F_CPU 8000000 // 8 MHz
  51:main.c        **** #define PCB_VERSION 2
  52:main.c        **** #define FIRMWARE_VERSION 8
  53:main.c        **** 
  54:main.c        **** #include <avr/io.h>
  55:main.c        **** #include <avr/wdt.h>
  56:main.c        **** #include <avr/eeprom.h>
  57:main.c        **** #include <avr/interrupt.h>
  58:main.c        **** #include <avr/sleep.h>
  59:main.c        **** #include <util/delay.h>
  60:main.c        **** #include <stdlib.h>
  61:main.c        **** #include <string.h>
  62:main.c        **** #include "setup.c" // See defines, variables, constants, functions here
  63:main.c        **** 
  64:main.c        **** 
  65:main.c        **** int main(void) {
 2354               		.loc 3 65 0
 2355               		.cfi_startproc
 2356               	/* prologue: function */
 2357               	/* frame size = 0 */
 2358               	/* stack size = 0 */
 2359               	.L__stack_usage = 0
  66:main.c        **** 	setup();
 2360               		.loc 3 66 0
 2361 0000 00D0      		rcall setup
 2362               	.LVL210:
  67:main.c        **** 	
  68:main.c        **** 	uint32_t address = 0;
  69:main.c        **** 	uint8_t eepromSize = EEPROM_4KBIT;
  70:main.c        **** 	uint8_t cartMode = GB_MODE;
  71:main.c        **** 	uint8_t resetCommonLines = 1;
 2363               		.loc 3 71 0
 2364 0002 8824      		clr r8
 2365 0004 8394      		inc r8
  69:main.c        **** 	uint8_t cartMode = GB_MODE;
 2366               		.loc 3 69 0
 2367 0006 9924      		clr r9
 2368 0008 9394      		inc r9
  68:main.c        **** 	uint8_t eepromSize = EEPROM_4KBIT;
 2369               		.loc 3 68 0
 2370 000a C12C      		mov r12,__zero_reg__
 2371 000c D12C      		mov r13,__zero_reg__
 2372 000e 7601      		movw r14,r12
 2373 0010 20E0      		ldi r18,lo8(receivedBuffer+64)
 2374 0012 622E      		mov r6,r18
 2375 0014 20E0      		ldi r18,hi8(receivedBuffer+64)
 2376 0016 722E      		mov r7,r18
 2377 0018 30E0      		ldi r19,lo8(eepromBuffer+8)
 2378 001a A32E      		mov r10,r19
 2379 001c 30E0      		ldi r19,hi8(eepromBuffer+8)
 2380 001e B32E      		mov r11,r19
 2381               	.LVL211:
 2382               	.L101:
  72:main.c        **** 	
  73:main.c        **** 	while(1) {
  74:main.c        **** 		if (resetCommonLines == 1) {
 2383               		.loc 3 74 0
 2384 0020 21E0      		ldi r18,lo8(1)
 2385 0022 8212      		cpse r8,r18
 2386 0024 00C0      		rjmp .L102
 2387               	.LVL212:
 2388               	.L202:
  75:main.c        **** 			rd_wr_csmreq_cs2_reset();
 2389               		.loc 3 75 0
 2390 0026 00D0      		rcall rd_wr_csmreq_cs2_reset
 2391               	.LVL213:
 2392               	.L102:
  76:main.c        **** 		}
  77:main.c        **** 		receivedChar = USART_Receive(); // Wait for 1 byte of data
 2393               		.loc 3 77 0
 2394 0028 00D0      		rcall USART_Receive
 2395               	.LVL214:
 2396 002a 8093 0000 		sts receivedChar,r24
  78:main.c        **** 		
  79:main.c        **** 		// Read the pin to find out which mode we are in, if it reads high, we are powered by 5V
  80:main.c        **** 		if (PIND & (1<<SWITCH_DETECT)) {
 2397               		.loc 3 80 0
 2398 002e 829B      		sbis 0x10,2
 2399 0030 00C0      		rjmp .L103
 2400               	.LVL215:
  81:main.c        **** 			cartMode = GB_MODE;
  82:main.c        **** 			PORTD |= (1<<LED_5V);
 2401               		.loc 3 82 0
 2402 0032 979A      		sbi 0x12,7
  83:main.c        **** 			PORTE &= ~(1<<LED_3V);
 2403               		.loc 3 83 0
 2404 0034 3898      		cbi 0x7,0
  81:main.c        **** 			cartMode = GB_MODE;
 2405               		.loc 3 81 0
 2406 0036 81E0      		ldi r24,lo8(1)
 2407 0038 00C0      		rjmp .L104
 2408               	.LVL216:
 2409               	.L103:
  84:main.c        **** 		}
  85:main.c        **** 		else {
  86:main.c        **** 			cartMode = GBA_MODE;
  87:main.c        **** 			PORTE |= (1<<LED_3V);
 2410               		.loc 3 87 0
 2411 003a 389A      		sbi 0x7,0
  88:main.c        **** 			PORTD &= ~(1<<LED_5V);
 2412               		.loc 3 88 0
 2413 003c 9798      		cbi 0x12,7
  86:main.c        **** 			PORTE |= (1<<LED_3V);
 2414               		.loc 3 86 0
 2415 003e 82E0      		ldi r24,lo8(2)
 2416               	.LVL217:
 2417               	.L104:
  89:main.c        **** 		}
  90:main.c        **** 		
  91:main.c        **** 		// Return the cart mode in use
  92:main.c        **** 		if (receivedChar == CART_MODE) {
 2418               		.loc 3 92 0
 2419 0040 9091 0000 		lds r25,receivedChar
 2420 0044 9334      		cpi r25,lo8(67)
 2421 0046 01F4      		brne .+2
 2422 0048 00C0      		rjmp .L203
  93:main.c        **** 			USART_Transmit(cartMode);
  94:main.c        **** 		}
  95:main.c        **** 		
  96:main.c        **** 		// Change to GB mode or GBA mode if requested
  97:main.c        **** 		else if (receivedChar == GB_CART_MODE) {
 2423               		.loc 3 97 0
 2424 004a 9734      		cpi r25,lo8(71)
 2425 004c 01F4      		brne .L107
  98:main.c        **** 			gb_mode();
 2426               		.loc 3 98 0
 2427 004e 00D0      		rcall gb_mode
 2428               	.LVL218:
 2429 0050 00C0      		rjmp .L101
 2430               	.LVL219:
 2431               	.L107:
  99:main.c        **** 		}
 100:main.c        **** 		else if (receivedChar == GBA_CART_MODE) {
 2432               		.loc 3 100 0
 2433 0052 9736      		cpi r25,lo8(103)
 2434 0054 01F4      		brne .+2
 2435 0056 00C0      		rjmp .L205
 101:main.c        **** 			gba_mode();
 102:main.c        **** 		}
 103:main.c        **** 		
 104:main.c        **** 		// Set address
 105:main.c        **** 		else if (receivedChar == SET_START_ADDRESS) {
 2436               		.loc 3 105 0
 2437 0058 9134      		cpi r25,lo8(65)
 2438 005a 01F4      		brne .L109
 106:main.c        **** 			usart_read_chars(); // Read start address
 2439               		.loc 3 106 0
 2440 005c 00D0      		rcall usart_read_chars
 2441               	.LVL220:
 107:main.c        **** 			address = strtol(receivedBuffer, NULL, 16); // Convert address string in hex to dec
 2442               		.loc 3 107 0
 2443 005e 40E1      		ldi r20,lo8(16)
 2444 0060 50E0      		ldi r21,0
 2445 0062 60E0      		ldi r22,0
 2446 0064 70E0      		ldi r23,0
 2447 0066 80E0      		ldi r24,lo8(receivedBuffer)
 2448 0068 90E0      		ldi r25,hi8(receivedBuffer)
 2449 006a 00D0      		rcall strtol
 2450               	.LVL221:
 2451 006c 6B01      		movw r12,r22
 2452 006e 7C01      		movw r14,r24
 2453               	.LVL222:
 2454 0070 00C0      		rjmp .L101
 2455               	.LVL223:
 2456               	.L109:
 108:main.c        **** 		}
 109:main.c        **** 		
 110:main.c        **** 		
 111:main.c        **** 		// ****** Gameboy / Gameboy Colour ******
 112:main.c        **** 		
 113:main.c        **** 		// Read 64 bytes of ROM/RAM from address (and increment) until anything but 1 is received
 114:main.c        **** 		else if (receivedChar == READ_ROM_RAM) {
 2457               		.loc 3 114 0
 2458 0072 9235      		cpi r25,lo8(82)
 2459 0074 01F4      		brne .L110
 115:main.c        **** 			gb_mode();
 2460               		.loc 3 115 0
 2461 0076 00D0      		rcall gb_mode
 2462               	.LVL224:
 116:main.c        **** 			receivedChar = '1';
 2463               		.loc 3 116 0
 2464 0078 81E3      		ldi r24,lo8(49)
 2465               	.LVL225:
 2466               	.L208:
 117:main.c        **** 			while (receivedChar == '1') {
 118:main.c        **** 				PORTD |= (1<<ACTIVITY_LED);
 119:main.c        **** 				for (uint8_t x = 0; x < 64; x++) {
 120:main.c        **** 					USART_Transmit(read_8bit_data(address));
 121:main.c        **** 					address++;
 122:main.c        **** 				}
 123:main.c        **** 				
 124:main.c        **** 				PORTD &= ~(1<<ACTIVITY_LED);
 125:main.c        **** 				receivedChar = USART_Receive();
 2467               		.loc 3 125 0
 2468 007a 8093 0000 		sts receivedChar,r24
 2469               	.LVL226:
 117:main.c        **** 			while (receivedChar == '1') {
 2470               		.loc 3 117 0
 2471 007e 8091 0000 		lds r24,receivedChar
 2472 0082 8133      		cpi r24,lo8(49)
 2473 0084 01F4      		brne .L101
 118:main.c        **** 				for (uint8_t x = 0; x < 64; x++) {
 2474               		.loc 3 118 0
 2475 0086 939A      		sbi 0x12,3
 2476               	.LVL227:
 2477 0088 C0E0      		ldi r28,0
 2478 008a D0E0      		ldi r29,0
 2479               	.LVL228:
 2480               	.L112:
 2481               	.LBB116:
 120:main.c        **** 					address++;
 2482               		.loc 3 120 0 discriminator 3
 2483 008c CE01      		movw r24,r28
 2484 008e 8C0D      		add r24,r12
 2485 0090 9D1D      		adc r25,r13
 2486 0092 00D0      		rcall read_8bit_data
 2487               	.LVL229:
 2488 0094 00D0      		rcall USART_Transmit
 2489               	.LVL230:
 2490 0096 2196      		adiw r28,1
 2491               	.LVL231:
 119:main.c        **** 					USART_Transmit(read_8bit_data(address));
 2492               		.loc 3 119 0 discriminator 3
 2493 0098 C034      		cpi r28,64
 2494 009a D105      		cpc r29,__zero_reg__
 2495 009c 01F4      		brne .L112
 2496 009e 80E4      		ldi r24,64
 2497 00a0 C80E      		add r12,r24
 2498 00a2 D11C      		adc r13,__zero_reg__
 2499 00a4 E11C      		adc r14,__zero_reg__
 2500 00a6 F11C      		adc r15,__zero_reg__
 2501               	.LBE116:
 124:main.c        **** 				receivedChar = USART_Receive();
 2502               		.loc 3 124 0
 2503 00a8 9398      		cbi 0x12,3
 2504               		.loc 3 125 0
 2505 00aa 00D0      		rcall USART_Receive
 2506               	.LVL232:
 2507 00ac 00C0      		rjmp .L208
 2508               	.LVL233:
 2509               	.L110:
 126:main.c        **** 			}
 127:main.c        **** 		}
 128:main.c        **** 		
 129:main.c        **** 		// Write 64 bytes to RAM on address (and increment)
 130:main.c        **** 		else if (receivedChar == WRITE_RAM) {
 2510               		.loc 3 130 0
 2511 00ae 9735      		cpi r25,lo8(87)
 2512 00b0 01F4      		brne .L114
 131:main.c        **** 			gb_mode();
 2513               		.loc 3 131 0
 2514 00b2 00D0      		rcall gb_mode
 2515               	.LVL234:
 132:main.c        **** 			
 133:main.c        **** 			// Read 64 bytes first as CH340G sends them all at once
 134:main.c        **** 			usart_read_bytes(64);
 2516               		.loc 3 134 0
 2517 00b4 80E4      		ldi r24,lo8(64)
 2518 00b6 00D0      		rcall usart_read_bytes
 2519               	.LVL235:
 135:main.c        **** 			
 136:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 2520               		.loc 3 136 0
 2521 00b8 939A      		sbi 0x12,3
 2522               	.LVL236:
 2523 00ba C0E0      		ldi r28,lo8(receivedBuffer)
 2524 00bc D0E0      		ldi r29,hi8(receivedBuffer)
 2525 00be 00E0      		ldi r16,0
 2526 00c0 10E0      		ldi r17,0
 2527               	.LVL237:
 2528               	.L115:
 2529               	.LBB117:
 137:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 138:main.c        **** 				write_8bit_data(address, receivedBuffer[x], MEMORY_WRITE);
 2530               		.loc 3 138 0 discriminator 3
 2531 00c2 6991      		ld r22,Y+
 2532 00c4 C801      		movw r24,r16
 2533 00c6 8C0D      		add r24,r12
 2534 00c8 9D1D      		adc r25,r13
 2535 00ca 41E0      		ldi r20,lo8(1)
 2536 00cc 00D0      		rcall write_8bit_data
 2537               	.LVL238:
 2538 00ce 0F5F      		subi r16,-1
 2539 00d0 1F4F      		sbci r17,-1
 2540               	.LVL239:
 137:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 2541               		.loc 3 137 0 discriminator 3
 2542 00d2 0034      		cpi r16,64
 2543 00d4 1105      		cpc r17,__zero_reg__
 2544 00d6 01F4      		brne .L115
 2545 00d8 90E4      		ldi r25,64
 2546 00da C90E      		add r12,r25
 2547 00dc D11C      		adc r13,__zero_reg__
 2548 00de E11C      		adc r14,__zero_reg__
 2549 00e0 F11C      		adc r15,__zero_reg__
 2550 00e2 00C0      		rjmp .L226
 2551               	.LVL240:
 2552               	.L114:
 2553               	.LBE117:
 139:main.c        **** 				address++;
 140:main.c        **** 			}
 141:main.c        **** 			
 142:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 143:main.c        **** 			USART_Transmit('1'); // Send back acknowledgement
 144:main.c        **** 		}
 145:main.c        **** 		
 146:main.c        **** 		// Set bank address and write a byte
 147:main.c        **** 		else if (receivedChar == SET_BANK) {
 2554               		.loc 3 147 0
 2555 00e4 9234      		cpi r25,lo8(66)
 2556 00e6 01F4      		brne .L116
 2557               	.LBB118:
 148:main.c        **** 			gb_mode();
 2558               		.loc 3 148 0
 2559 00e8 00D0      		rcall gb_mode
 2560               	.LVL241:
 149:main.c        **** 			
 150:main.c        **** 			usart_read_chars(); // Read start address
 2561               		.loc 3 150 0
 2562 00ea 00D0      		rcall usart_read_chars
 2563               	.LVL242:
 151:main.c        **** 			uint16_t bankaddress = strtol(receivedBuffer, NULL, 16); // Convert address string in hex to dec
 2564               		.loc 3 151 0
 2565 00ec 40E1      		ldi r20,lo8(16)
 2566 00ee 50E0      		ldi r21,0
 2567 00f0 60E0      		ldi r22,0
 2568 00f2 70E0      		ldi r23,0
 2569 00f4 80E0      		ldi r24,lo8(receivedBuffer)
 2570 00f6 90E0      		ldi r25,hi8(receivedBuffer)
 2571 00f8 00D0      		rcall strtol
 2572               	.LVL243:
 2573 00fa 1B01      		movw r2,r22
 2574 00fc 2C01      		movw r4,r24
 2575               	.LVL244:
 152:main.c        **** 			
 153:main.c        **** 			receivedChar = USART_Receive(); // Wait for bank number
 2576               		.loc 3 153 0
 2577 00fe 00D0      		rcall USART_Receive
 2578               	.LVL245:
 2579 0100 8093 0000 		sts receivedChar,r24
 154:main.c        **** 			if (receivedChar == 'B') {
 2580               		.loc 3 154 0
 2581 0104 8234      		cpi r24,lo8(66)
 2582 0106 01F0      		breq .+2
 2583 0108 00C0      		rjmp .L101
 2584               	.LBB119:
 155:main.c        **** 				usart_read_chars(); // Read data
 2585               		.loc 3 155 0
 2586 010a 00D0      		rcall usart_read_chars
 2587               	.LVL246:
 156:main.c        **** 				uint8_t data = atoi(receivedBuffer); // Convert data string to dec
 2588               		.loc 3 156 0
 2589 010c 80E0      		ldi r24,lo8(receivedBuffer)
 2590 010e 90E0      		ldi r25,hi8(receivedBuffer)
 2591 0110 00D0      		rcall atoi
 2592               	.LVL247:
 157:main.c        **** 				
 158:main.c        **** 				write_8bit_data(bankaddress, data, BANK_WRITE);
 2593               		.loc 3 158 0
 2594 0112 40E0      		ldi r20,0
 2595 0114 682F      		mov r22,r24
 2596 0116 C101      		movw r24,r2
 2597               	.LVL248:
 2598 0118 00D0      		rcall write_8bit_data
 2599               	.LVL249:
 2600 011a 00C0      		rjmp .L101
 2601               	.LVL250:
 2602               	.L116:
 2603               	.LBE119:
 2604               	.LBE118:
 159:main.c        **** 			}
 160:main.c        **** 		}
 161:main.c        **** 		
 162:main.c        **** 		
 163:main.c        **** 		// ****** Gameboy Advance ******
 164:main.c        **** 		
 165:main.c        **** 		// ---------- ROM ----------
 166:main.c        **** 		// Read one 16bit byte from ROM using address (and increment) until anything but 1 is received
 167:main.c        **** 		else if (receivedChar == GBA_READ_ROM) {
 2605               		.loc 3 167 0
 2606 011c 9237      		cpi r25,lo8(114)
 2607 011e 01F4      		brne .L117
 168:main.c        **** 			gba_mode(); 
 2608               		.loc 3 168 0
 2609 0120 00D0      		rcall gba_mode
 2610               	.LVL251:
 169:main.c        **** 			
 170:main.c        **** 			receivedChar = '1';
 2611               		.loc 3 170 0
 2612 0122 81E3      		ldi r24,lo8(49)
 2613               	.LVL252:
 2614               	.L209:
 171:main.c        **** 			while (receivedChar == '1') {
 172:main.c        **** 				PORTD |= (1<<ACTIVITY_LED);
 173:main.c        **** 				for (uint8_t x = 0; x < 32; x++) {
 174:main.c        **** 					uint16_t dataRead = gba_read_16bit_data(address);
 175:main.c        **** 					
 176:main.c        **** 					// Low byte & High byte
 177:main.c        **** 					USART_Transmit(dataRead & 0xFF);
 178:main.c        **** 					USART_Transmit(dataRead >> 8);
 179:main.c        **** 					
 180:main.c        **** 					address++;
 181:main.c        **** 				}
 182:main.c        **** 				
 183:main.c        **** 				PORTD &= ~(1<<ACTIVITY_LED);
 184:main.c        **** 				receivedChar = USART_Receive();
 2615               		.loc 3 184 0
 2616 0124 8093 0000 		sts receivedChar,r24
 2617               	.LVL253:
 171:main.c        **** 			while (receivedChar == '1') {
 2618               		.loc 3 171 0
 2619 0128 8091 0000 		lds r24,receivedChar
 2620 012c 8133      		cpi r24,lo8(49)
 2621 012e 01F0      		breq .+2
 2622 0130 00C0      		rjmp .L101
 172:main.c        **** 				for (uint8_t x = 0; x < 32; x++) {
 2623               		.loc 3 172 0
 2624 0132 939A      		sbi 0x12,3
 2625               	.LVL254:
 2626 0134 1601      		movw r2,r12
 2627 0136 2701      		movw r4,r14
 2628               	.LBB120:
 173:main.c        **** 					uint16_t dataRead = gba_read_16bit_data(address);
 2629               		.loc 3 173 0
 2630 0138 C0E0      		ldi r28,0
 2631               	.LVL255:
 2632               	.L119:
 2633               	.LBB121:
 174:main.c        **** 					
 2634               		.loc 3 174 0 discriminator 3
 2635 013a C201      		movw r24,r4
 2636 013c B101      		movw r22,r2
 2637 013e 00D0      		rcall gba_read_16bit_data
 2638               	.LVL256:
 2639 0140 D92F      		mov r29,r25
 2640               	.LVL257:
 177:main.c        **** 					USART_Transmit(dataRead >> 8);
 2641               		.loc 3 177 0 discriminator 3
 2642 0142 00D0      		rcall USART_Transmit
 2643               	.LVL258:
 178:main.c        **** 					
 2644               		.loc 3 178 0 discriminator 3
 2645 0144 8D2F      		mov r24,r29
 2646 0146 00D0      		rcall USART_Transmit
 2647               	.LVL259:
 180:main.c        **** 				}
 2648               		.loc 3 180 0 discriminator 3
 2649 0148 EFEF      		ldi r30,-1
 2650 014a 2E1A      		sub r2,r30
 2651 014c 3E0A      		sbc r3,r30
 2652 014e 4E0A      		sbc r4,r30
 2653 0150 5E0A      		sbc r5,r30
 2654               	.LVL260:
 2655               	.LBE121:
 173:main.c        **** 					uint16_t dataRead = gba_read_16bit_data(address);
 2656               		.loc 3 173 0 discriminator 3
 2657 0152 CF5F      		subi r28,lo8(-(1))
 2658               	.LVL261:
 2659 0154 C032      		cpi r28,lo8(32)
 2660 0156 01F4      		brne .L119
 2661 0158 F0E2      		ldi r31,32
 2662 015a CF0E      		add r12,r31
 2663 015c D11C      		adc r13,__zero_reg__
 2664 015e E11C      		adc r14,__zero_reg__
 2665 0160 F11C      		adc r15,__zero_reg__
 2666               	.LBE120:
 183:main.c        **** 				receivedChar = USART_Receive();
 2667               		.loc 3 183 0
 2668 0162 9398      		cbi 0x12,3
 2669               		.loc 3 184 0
 2670 0164 00D0      		rcall USART_Receive
 2671               	.LVL262:
 2672 0166 00C0      		rjmp .L209
 2673               	.LVL263:
 2674               	.L117:
 185:main.c        **** 			}
 186:main.c        **** 		}
 187:main.c        **** 		
 188:main.c        **** 		
 189:main.c        **** 		// ---------- SRAM ----------
 190:main.c        **** 		// Read RAM from address (and increment) until anything but 1 is received
 191:main.c        **** 		else if (receivedChar == GBA_READ_SRAM) {
 2675               		.loc 3 191 0
 2676 0168 9D36      		cpi r25,lo8(109)
 2677 016a 01F4      		brne .L121
 192:main.c        **** 			gb_mode(); // Set GB mode as it uses 16 bit address with 8 bit data
 2678               		.loc 3 192 0
 2679 016c 00D0      		rcall gb_mode
 2680               	.LVL264:
 193:main.c        **** 			
 194:main.c        **** 			receivedChar = '1';
 2681               		.loc 3 194 0
 2682 016e 81E3      		ldi r24,lo8(49)
 2683               	.LVL265:
 2684               	.L210:
 195:main.c        **** 			while (receivedChar == '1') {
 196:main.c        **** 				PORTD |= (1<<ACTIVITY_LED);
 197:main.c        **** 				for (uint8_t x = 0; x < 64; x++) {
 198:main.c        **** 					USART_Transmit(gba_read_ram_8bit_data(address));
 199:main.c        **** 					address++;
 200:main.c        **** 				}
 201:main.c        **** 				
 202:main.c        **** 				PORTD &= ~(1<<ACTIVITY_LED);
 203:main.c        **** 				receivedChar = USART_Receive();
 2685               		.loc 3 203 0
 2686 0170 8093 0000 		sts receivedChar,r24
 2687               	.LVL266:
 195:main.c        **** 			while (receivedChar == '1') {
 2688               		.loc 3 195 0
 2689 0174 8091 0000 		lds r24,receivedChar
 2690 0178 8133      		cpi r24,lo8(49)
 2691 017a 01F4      		brne .L205
 196:main.c        **** 				for (uint8_t x = 0; x < 64; x++) {
 2692               		.loc 3 196 0
 2693 017c 939A      		sbi 0x12,3
 2694               	.LVL267:
 2695 017e C0E0      		ldi r28,0
 2696 0180 D0E0      		ldi r29,0
 2697               	.LVL268:
 2698               	.L123:
 2699               	.LBB122:
 198:main.c        **** 					address++;
 2700               		.loc 3 198 0 discriminator 3
 2701 0182 CE01      		movw r24,r28
 2702 0184 8C0D      		add r24,r12
 2703 0186 9D1D      		adc r25,r13
 2704 0188 00D0      		rcall gba_read_ram_8bit_data
 2705               	.LVL269:
 2706 018a 00D0      		rcall USART_Transmit
 2707               	.LVL270:
 2708 018c 2196      		adiw r28,1
 2709               	.LVL271:
 197:main.c        **** 					USART_Transmit(gba_read_ram_8bit_data(address));
 2710               		.loc 3 197 0 discriminator 3
 2711 018e C034      		cpi r28,64
 2712 0190 D105      		cpc r29,__zero_reg__
 2713 0192 01F4      		brne .L123
 2714 0194 20E4      		ldi r18,64
 2715 0196 C20E      		add r12,r18
 2716 0198 D11C      		adc r13,__zero_reg__
 2717 019a E11C      		adc r14,__zero_reg__
 2718 019c F11C      		adc r15,__zero_reg__
 2719               	.LBE122:
 202:main.c        **** 				receivedChar = USART_Receive();
 2720               		.loc 3 202 0
 2721 019e 9398      		cbi 0x12,3
 2722               		.loc 3 203 0
 2723 01a0 00D0      		rcall USART_Receive
 2724               	.LVL272:
 2725 01a2 00C0      		rjmp .L210
 2726               	.LVL273:
 2727               	.L121:
 204:main.c        **** 			}
 205:main.c        **** 			
 206:main.c        **** 			gba_mode(); // Set back
 207:main.c        **** 		}
 208:main.c        **** 		
 209:main.c        **** 		// Write to RAM on address (and increment) with 64 bytes of data
 210:main.c        **** 		else if (receivedChar == GBA_WRITE_SRAM) {
 2728               		.loc 3 210 0
 2729 01a4 9737      		cpi r25,lo8(119)
 2730 01a6 01F4      		brne .L125
 211:main.c        **** 			gb_mode();
 2731               		.loc 3 211 0
 2732 01a8 00D0      		rcall gb_mode
 2733               	.LVL274:
 212:main.c        **** 			
 213:main.c        **** 			usart_read_bytes(64);
 2734               		.loc 3 213 0
 2735 01aa 80E4      		ldi r24,lo8(64)
 2736 01ac 00D0      		rcall usart_read_bytes
 2737               	.LVL275:
 214:main.c        **** 			
 215:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 2738               		.loc 3 215 0
 2739 01ae 939A      		sbi 0x12,3
 2740               	.LVL276:
 2741 01b0 C0E0      		ldi r28,lo8(receivedBuffer)
 2742 01b2 D0E0      		ldi r29,hi8(receivedBuffer)
 2743 01b4 00E0      		ldi r16,0
 2744 01b6 10E0      		ldi r17,0
 2745               	.LVL277:
 2746               	.L126:
 2747               	.LBB123:
 216:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 217:main.c        **** 				gba_write_ram_8bit_data(address, receivedBuffer[x]);
 2748               		.loc 3 217 0 discriminator 3
 2749 01b8 6991      		ld r22,Y+
 2750 01ba C801      		movw r24,r16
 2751 01bc 8C0D      		add r24,r12
 2752 01be 9D1D      		adc r25,r13
 2753 01c0 00D0      		rcall gba_write_ram_8bit_data
 2754               	.LVL278:
 2755 01c2 0F5F      		subi r16,-1
 2756 01c4 1F4F      		sbci r17,-1
 2757               	.LVL279:
 216:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 2758               		.loc 3 216 0 discriminator 3
 2759 01c6 0034      		cpi r16,64
 2760 01c8 1105      		cpc r17,__zero_reg__
 2761 01ca 01F4      		brne .L126
 2762 01cc 80E4      		ldi r24,64
 2763 01ce C80E      		add r12,r24
 2764 01d0 D11C      		adc r13,__zero_reg__
 2765 01d2 E11C      		adc r14,__zero_reg__
 2766 01d4 F11C      		adc r15,__zero_reg__
 2767               	.LVL280:
 2768               	.L207:
 2769               	.LBE123:
 218:main.c        **** 				address++;
 219:main.c        **** 			}
 220:main.c        **** 			USART_Transmit('1'); // Send back acknowledgement
 2770               		.loc 3 220 0
 2771 01d6 81E3      		ldi r24,lo8(49)
 2772 01d8 00D0      		rcall USART_Transmit
 2773               	.LVL281:
 221:main.c        **** 			
 222:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 2774               		.loc 3 222 0
 2775 01da 9398      		cbi 0x12,3
 2776               	.L205:
 223:main.c        **** 			gba_mode(); // Set back
 2777               		.loc 3 223 0
 2778 01dc 00D0      		rcall gba_mode
 2779               	.LVL282:
 2780 01de 00C0      		rjmp .L101
 2781               	.LVL283:
 2782               	.L125:
 224:main.c        **** 		}
 225:main.c        **** 		
 226:main.c        **** 		// Write 1 byte to SRAM address
 227:main.c        **** 		else if (receivedChar == GBA_WRITE_ONE_BYTE_SRAM) {
 2783               		.loc 3 227 0
 2784 01e0 9F36      		cpi r25,lo8(111)
 2785 01e2 01F4      		brne .L127
 2786               	.LBB124:
 228:main.c        **** 			gb_mode();
 2787               		.loc 3 228 0
 2788 01e4 00D0      		rcall gb_mode
 2789               	.LVL284:
 229:main.c        **** 			
 230:main.c        **** 			uint8_t data = USART_Receive();
 2790               		.loc 3 230 0
 2791 01e6 00D0      		rcall USART_Receive
 2792               	.LVL285:
 231:main.c        **** 			gba_write_ram_8bit_data(address, data);
 2793               		.loc 3 231 0
 2794 01e8 682F      		mov r22,r24
 2795 01ea C601      		movw r24,r12
 2796               	.LVL286:
 2797 01ec 00D0      		rcall gba_write_ram_8bit_data
 2798               	.LVL287:
 2799 01ee 00C0      		rjmp .L212
 2800               	.LVL288:
 2801               	.L127:
 2802               	.LBE124:
 232:main.c        **** 			USART_Transmit('1'); // Send back acknowledgement
 233:main.c        **** 			
 234:main.c        **** 			gba_mode(); // Set back
 235:main.c        **** 		}
 236:main.c        **** 		
 237:main.c        **** 		
 238:main.c        **** 		// ---------- FLASH ----------
 239:main.c        **** 		// Read the Flash Manufacturer and Device ID
 240:main.c        **** 		else if (receivedChar == GBA_FLASH_READ_ID) {
 2803               		.loc 3 240 0
 2804 01f0 9936      		cpi r25,lo8(105)
 2805 01f2 01F4      		brne .L128
 241:main.c        **** 			gb_mode();
 2806               		.loc 3 241 0
 2807 01f4 00D0      		rcall gb_mode
 2808               	.LVL289:
 242:main.c        **** 			
 243:main.c        **** 			flash_read_chip_id();
 2809               		.loc 3 243 0
 2810 01f6 00D0      		rcall flash_read_chip_id
 2811               	.LVL290:
 244:main.c        **** 			USART_Transmit(flashChipIdBuffer[0]);
 2812               		.loc 3 244 0
 2813 01f8 8091 0000 		lds r24,flashChipIdBuffer
 2814 01fc 00D0      		rcall USART_Transmit
 2815               	.LVL291:
 245:main.c        **** 			USART_Transmit(flashChipIdBuffer[1]);
 2816               		.loc 3 245 0
 2817 01fe 8091 0000 		lds r24,flashChipIdBuffer+1
 2818               	.L211:
 2819 0202 00D0      		rcall USART_Transmit
 2820               	.LVL292:
 2821 0204 00C0      		rjmp .L205
 2822               	.LVL293:
 2823               	.L128:
 246:main.c        **** 			
 247:main.c        **** 			gba_mode(); // Set back
 248:main.c        **** 		}
 249:main.c        **** 		
 250:main.c        **** 		// Change bank
 251:main.c        **** 		else if (receivedChar == GBA_FLASH_SET_BANK) {
 2824               		.loc 3 251 0
 2825 0206 9B36      		cpi r25,lo8(107)
 2826 0208 01F4      		brne .L129
 2827               	.LBB125:
 252:main.c        **** 			usart_read_chars(); // Read data
 2828               		.loc 3 252 0
 2829 020a 00D0      		rcall usart_read_chars
 2830               	.LVL294:
 253:main.c        **** 			uint8_t bank = atoi(receivedBuffer); // Convert data string to dec
 2831               		.loc 3 253 0
 2832 020c 80E0      		ldi r24,lo8(receivedBuffer)
 2833 020e 90E0      		ldi r25,hi8(receivedBuffer)
 2834 0210 00D0      		rcall atoi
 2835               	.LVL295:
 2836 0212 C82F      		mov r28,r24
 2837               	.LVL296:
 254:main.c        **** 			
 255:main.c        **** 			gb_mode();
 2838               		.loc 3 255 0
 2839 0214 00D0      		rcall gb_mode
 2840               	.LVL297:
 256:main.c        **** 			flash_switch_bank(bank);
 2841               		.loc 3 256 0
 2842 0216 8C2F      		mov r24,r28
 2843 0218 00D0      		rcall flash_switch_bank
 2844               	.LVL298:
 2845 021a 00C0      		rjmp .L205
 2846               	.LVL299:
 2847               	.L129:
 2848               	.LBE125:
 257:main.c        **** 			
 258:main.c        **** 			gba_mode(); // Set back
 259:main.c        **** 		}
 260:main.c        **** 		
 261:main.c        **** 		// Erase 4K sector on Flash (sector 0 to 15 for 512Kbit)
 262:main.c        **** 		else if (receivedChar == GBA_FLASH_4K_SECTOR_ERASE) {
 2849               		.loc 3 262 0
 2850 021c 9337      		cpi r25,lo8(115)
 2851 021e 01F4      		brne .L130
 2852               	.LBB126:
 263:main.c        **** 			gb_mode();
 2853               		.loc 3 263 0
 2854 0220 00D0      		rcall gb_mode
 2855               	.LVL300:
 264:main.c        **** 			
 265:main.c        **** 			usart_read_chars(); // Read sector
 2856               		.loc 3 265 0
 2857 0222 00D0      		rcall usart_read_chars
 2858               	.LVL301:
 266:main.c        **** 			uint8_t sectorAddress = strtol(receivedBuffer, NULL, 16); // Convert address string in hex to de
 2859               		.loc 3 266 0
 2860 0224 40E1      		ldi r20,lo8(16)
 2861 0226 50E0      		ldi r21,0
 2862 0228 60E0      		ldi r22,0
 2863 022a 70E0      		ldi r23,0
 2864 022c 80E0      		ldi r24,lo8(receivedBuffer)
 2865 022e 90E0      		ldi r25,hi8(receivedBuffer)
 2866 0230 00D0      		rcall strtol
 2867               	.LVL302:
 2868 0232 862F      		mov r24,r22
 2869               	.LVL303:
 267:main.c        **** 			
 268:main.c        **** 			flash_erase_4k_sector(sectorAddress);
 2870               		.loc 3 268 0
 2871 0234 00D0      		rcall flash_erase_4k_sector
 2872               	.LVL304:
 2873               	.L212:
 269:main.c        **** 			USART_Transmit('1'); // Send back acknowledgement
 2874               		.loc 3 269 0
 2875 0236 81E3      		ldi r24,lo8(49)
 2876 0238 00C0      		rjmp .L211
 2877               	.LVL305:
 2878               	.L130:
 2879               	.LBE126:
 270:main.c        **** 			
 271:main.c        **** 			gba_mode(); // Set back
 272:main.c        **** 		}
 273:main.c        **** 		
 274:main.c        **** 		// Write 64 bytes to Flash address one byte write at a time (and increment)
 275:main.c        **** 		else if (receivedChar == GBA_FLASH_WRITE_BYTE) {
 2880               		.loc 3 275 0
 2881 023a 9236      		cpi r25,lo8(98)
 2882 023c 01F4      		brne .L131
 276:main.c        **** 			gb_mode();
 2883               		.loc 3 276 0
 2884 023e 00D0      		rcall gb_mode
 2885               	.LVL306:
 277:main.c        **** 			
 278:main.c        **** 			usart_read_bytes(64);
 2886               		.loc 3 278 0
 2887 0240 80E4      		ldi r24,lo8(64)
 2888 0242 00D0      		rcall usart_read_bytes
 2889               	.LVL307:
 279:main.c        **** 			
 280:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 2890               		.loc 3 280 0
 2891 0244 939A      		sbi 0x12,3
 2892               	.LVL308:
 2893 0246 00E0      		ldi r16,lo8(receivedBuffer)
 2894 0248 10E0      		ldi r17,hi8(receivedBuffer)
 2895 024a C0E0      		ldi r28,0
 2896 024c D0E0      		ldi r29,0
 2897               	.LVL309:
 2898               	.L132:
 2899               	.LBB127:
 281:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 282:main.c        **** 				flash_write_byte(address, receivedBuffer[x]);
 2900               		.loc 3 282 0 discriminator 3
 2901 024e F801      		movw r30,r16
 2902 0250 6191      		ld r22,Z+
 2903 0252 8F01      		movw r16,r30
 2904 0254 CE01      		movw r24,r28
 2905 0256 8C0D      		add r24,r12
 2906 0258 9D1D      		adc r25,r13
 2907 025a 00D0      		rcall flash_write_byte
 2908               	.LVL310:
 2909 025c 2196      		adiw r28,1
 2910               	.LVL311:
 281:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 2911               		.loc 3 281 0 discriminator 3
 2912 025e C034      		cpi r28,64
 2913 0260 D105      		cpc r29,__zero_reg__
 2914 0262 01F4      		brne .L132
 2915 0264 F0E4      		ldi r31,64
 2916 0266 CF0E      		add r12,r31
 2917 0268 D11C      		adc r13,__zero_reg__
 2918 026a E11C      		adc r14,__zero_reg__
 2919 026c F11C      		adc r15,__zero_reg__
 2920 026e 00C0      		rjmp .L207
 2921               	.LVL312:
 2922               	.L131:
 2923               	.LBE127:
 283:main.c        **** 				address++;
 284:main.c        **** 			}
 285:main.c        **** 			USART_Transmit('1'); // Send back acknowledgement
 286:main.c        **** 			
 287:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 288:main.c        **** 			gba_mode(); // Set back
 289:main.c        **** 		}
 290:main.c        **** 		
 291:main.c        **** 		// Write 128 bytes to flash sector for Atmel flash (and increment)
 292:main.c        **** 		else if (receivedChar == GBA_FLASH_WRITE_ATMEL) {
 2924               		.loc 3 292 0
 2925 0270 9136      		cpi r25,lo8(97)
 2926 0272 01F4      		brne .L133
 293:main.c        **** 			gb_mode();
 2927               		.loc 3 293 0
 2928 0274 00D0      		rcall gb_mode
 2929               	.LVL313:
 294:main.c        **** 			
 295:main.c        **** 			usart_read_bytes(128);
 2930               		.loc 3 295 0
 2931 0276 80E8      		ldi r24,lo8(-128)
 2932 0278 00D0      		rcall usart_read_bytes
 2933               	.LVL314:
 296:main.c        **** 			
 297:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 2934               		.loc 3 297 0
 2935 027a 939A      		sbi 0x12,3
 298:main.c        **** 			flash_write_sector(address); // Address used as sector number
 2936               		.loc 3 298 0
 2937 027c C601      		movw r24,r12
 2938 027e 00D0      		rcall flash_write_sector
 2939               	.LVL315:
 299:main.c        **** 			address++;
 2940               		.loc 3 299 0
 2941 0280 2FEF      		ldi r18,-1
 2942 0282 C21A      		sub r12,r18
 2943 0284 D20A      		sbc r13,r18
 2944 0286 E20A      		sbc r14,r18
 2945 0288 F20A      		sbc r15,r18
 2946               	.LVL316:
 2947 028a 00C0      		rjmp .L207
 2948               	.LVL317:
 2949               	.L133:
 300:main.c        **** 			USART_Transmit('1'); // Send back acknowledgement
 301:main.c        **** 			
 302:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 303:main.c        **** 			gba_mode(); // Set back
 304:main.c        **** 		}
 305:main.c        **** 		
 306:main.c        **** 		
 307:main.c        **** 		// ---------- EEPROM ----------
 308:main.c        **** 		// Set EEPROM size
 309:main.c        **** 		else if (receivedChar == GBA_SET_EEPROM_SIZE) {
 2950               		.loc 3 309 0
 2951 028c 9335      		cpi r25,lo8(83)
 2952 028e 01F4      		brne .L134
 310:main.c        **** 			usart_read_chars(); // Read size
 2953               		.loc 3 310 0
 2954 0290 00D0      		rcall usart_read_chars
 2955               	.LVL318:
 311:main.c        **** 			eepromSize = strtol(receivedBuffer, NULL, 16); // Convert size to dec
 2956               		.loc 3 311 0
 2957 0292 40E1      		ldi r20,lo8(16)
 2958 0294 50E0      		ldi r21,0
 2959 0296 60E0      		ldi r22,0
 2960 0298 70E0      		ldi r23,0
 2961 029a 80E0      		ldi r24,lo8(receivedBuffer)
 2962 029c 90E0      		ldi r25,hi8(receivedBuffer)
 2963 029e 00D0      		rcall strtol
 2964               	.LVL319:
 2965 02a0 962E      		mov r9,r22
 2966               	.LVL320:
 2967 02a2 00C0      		rjmp .L101
 2968               	.LVL321:
 2969               	.L134:
 312:main.c        **** 		}
 313:main.c        **** 		
 314:main.c        **** 		// Read the EEPROM on address (and increment) until anything but 1 is received
 315:main.c        **** 		else if (receivedChar == GBA_READ_EEPROM) {
 2970               		.loc 3 315 0
 2971 02a4 9536      		cpi r25,lo8(101)
 2972 02a6 01F4      		brne .L135
 316:main.c        **** 			gba_eeprom_mode();
 2973               		.loc 3 316 0
 2974 02a8 00D0      		rcall gba_eeprom_mode
 2975               	.LVL322:
 317:main.c        **** 			
 318:main.c        **** 			receivedChar = '1';
 2976               		.loc 3 318 0
 2977 02aa 81E3      		ldi r24,lo8(49)
 2978               	.L213:
 319:main.c        **** 			while (receivedChar == '1') {
 320:main.c        **** 				PORTD |= (1<<ACTIVITY_LED);
 321:main.c        **** 				gba_eeprom_read(address, eepromSize);
 322:main.c        **** 				
 323:main.c        **** 				// Send back the 8 bytes of data
 324:main.c        **** 				for (uint8_t c = 0; c < 8; c++) {
 325:main.c        **** 					USART_Transmit(eepromBuffer[c]);
 326:main.c        **** 				}
 327:main.c        **** 				address++; // Increment to next 8 bytes
 328:main.c        **** 				
 329:main.c        **** 				PORTD &= ~(1<<ACTIVITY_LED);
 330:main.c        **** 				receivedChar = USART_Receive();
 2979               		.loc 3 330 0
 2980 02ac 8093 0000 		sts receivedChar,r24
 319:main.c        **** 			while (receivedChar == '1') {
 2981               		.loc 3 319 0
 2982 02b0 8091 0000 		lds r24,receivedChar
 2983 02b4 8133      		cpi r24,lo8(49)
 2984 02b6 01F0      		breq .+2
 2985 02b8 00C0      		rjmp .L205
 320:main.c        **** 				gba_eeprom_read(address, eepromSize);
 2986               		.loc 3 320 0
 2987 02ba 939A      		sbi 0x12,3
 321:main.c        **** 				
 2988               		.loc 3 321 0
 2989 02bc 692D      		mov r22,r9
 2990 02be C601      		movw r24,r12
 2991 02c0 00D0      		rcall gba_eeprom_read
 2992               	.LVL323:
 2993 02c2 C0E0      		ldi r28,lo8(eepromBuffer)
 2994 02c4 D0E0      		ldi r29,hi8(eepromBuffer)
 2995               	.LVL324:
 2996               	.L137:
 2997               	.LBB128:
 325:main.c        **** 				}
 2998               		.loc 3 325 0 discriminator 3
 2999 02c6 8991      		ld r24,Y+
 3000               	.LVL325:
 3001 02c8 00D0      		rcall USART_Transmit
 3002               	.LVL326:
 324:main.c        **** 					USART_Transmit(eepromBuffer[c]);
 3003               		.loc 3 324 0 discriminator 3
 3004 02ca AC16      		cp r10,r28
 3005 02cc BD06      		cpc r11,r29
 3006 02ce 01F4      		brne .L137
 3007               	.LBE128:
 327:main.c        **** 				
 3008               		.loc 3 327 0
 3009 02d0 8FEF      		ldi r24,-1
 3010 02d2 C81A      		sub r12,r24
 3011 02d4 D80A      		sbc r13,r24
 3012 02d6 E80A      		sbc r14,r24
 3013 02d8 F80A      		sbc r15,r24
 3014               	.LVL327:
 329:main.c        **** 				receivedChar = USART_Receive();
 3015               		.loc 3 329 0
 3016 02da 9398      		cbi 0x12,3
 3017               		.loc 3 330 0
 3018 02dc 00D0      		rcall USART_Receive
 3019               	.LVL328:
 3020 02de 00C0      		rjmp .L213
 3021               	.LVL329:
 3022               	.L135:
 331:main.c        **** 			}
 332:main.c        **** 			
 333:main.c        **** 			gba_mode(); // Set back
 334:main.c        **** 		}
 335:main.c        **** 		
 336:main.c        **** 		// Write 8 bytes to the EEPROM address (and increment)
 337:main.c        **** 		else if (receivedChar == GBA_WRITE_EEPROM) {
 3023               		.loc 3 337 0
 3024 02e0 9037      		cpi r25,lo8(112)
 3025 02e2 01F4      		brne .L139
 338:main.c        **** 			gba_eeprom_mode();
 3026               		.loc 3 338 0
 3027 02e4 00D0      		rcall gba_eeprom_mode
 3028               	.LVL330:
 3029 02e6 C0E0      		ldi r28,lo8(eepromBuffer)
 3030 02e8 D0E0      		ldi r29,hi8(eepromBuffer)
 3031               	.LVL331:
 3032               	.L140:
 3033               	.LBB129:
 339:main.c        **** 			
 340:main.c        **** 			// Read 8 bytes from USART and place in buffer
 341:main.c        **** 			for (uint8_t x = 0; x < 8; x++) {
 342:main.c        **** 				eepromBuffer[x] = USART_Receive();
 3034               		.loc 3 342 0 discriminator 3
 3035 02ea 00D0      		rcall USART_Receive
 3036               	.LVL332:
 3037 02ec 8993      		st Y+,r24
 3038               	.LVL333:
 341:main.c        **** 				eepromBuffer[x] = USART_Receive();
 3039               		.loc 3 341 0 discriminator 3
 3040 02ee AC16      		cp r10,r28
 3041 02f0 BD06      		cpc r11,r29
 3042 02f2 01F4      		brne .L140
 3043               	.LBE129:
 343:main.c        **** 			}
 344:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 3044               		.loc 3 344 0
 3045 02f4 939A      		sbi 0x12,3
 345:main.c        **** 			
 346:main.c        **** 			gba_eeprom_write(address, eepromSize);
 3046               		.loc 3 346 0
 3047 02f6 692D      		mov r22,r9
 3048 02f8 C601      		movw r24,r12
 3049 02fa 00D0      		rcall gba_eeprom_write
 3050               	.LVL334:
 347:main.c        **** 			address++;
 3051               		.loc 3 347 0
 3052 02fc 9FEF      		ldi r25,-1
 3053 02fe C91A      		sub r12,r25
 3054 0300 D90A      		sbc r13,r25
 3055 0302 E90A      		sbc r14,r25
 3056 0304 F90A      		sbc r15,r25
 3057               	.LVL335:
 3058               	.LBB130:
 3059               	.LBB131:
 187:c:\winavr-20100110\avr\include\util\delay.h **** 
 3060               		.loc 2 187 0
 3061 0306 EFE7      		ldi r30,lo8(15999)
 3062 0308 FEE3      		ldi r31,hi8(15999)
 3063 030a 3197      	1:	sbiw r30,1
 3064 030c 01F4      		brne 1b
 3065 030e 00C0      		rjmp .
 3066 0310 0000      		nop
 3067               	.LVL336:
 3068 0312 00C0      		rjmp .L207
 3069               	.LVL337:
 3070               	.L139:
 3071               	.LBE131:
 3072               	.LBE130:
 348:main.c        **** 			
 349:main.c        **** 			_delay_ms(8); // Wait for EEPROM to write data (8ms)
 350:main.c        **** 			USART_Transmit('1'); // Send back acknowledgement
 351:main.c        **** 			
 352:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 353:main.c        **** 			gba_mode(); // Set back
 354:main.c        **** 		}
 355:main.c        **** 		
 356:main.c        **** 		
 357:main.c        **** 		// ---------- GB FLASH CARTS ----------
 358:main.c        **** 		// Write address, one byte and pulse a pin
 359:main.c        **** 		else if (receivedChar == GB_FLASH_WRITE_BYTE) {
 3073               		.loc 3 359 0
 3074 0314 9634      		cpi r25,lo8(70)
 3075 0316 01F4      		brne .L141
 3076               	.LBB132:
 360:main.c        **** 			usart_read_chars(); // Read address
 3077               		.loc 3 360 0
 3078 0318 00D0      		rcall usart_read_chars
 3079               	.LVL338:
 361:main.c        **** 			uint16_t flashAddress = strtol(receivedBuffer, NULL, 16); // Convert address string in hex to de
 3080               		.loc 3 361 0
 3081 031a 40E1      		ldi r20,lo8(16)
 3082 031c 50E0      		ldi r21,0
 3083 031e 60E0      		ldi r22,0
 3084 0320 70E0      		ldi r23,0
 3085 0322 80E0      		ldi r24,lo8(receivedBuffer)
 3086 0324 90E0      		ldi r25,hi8(receivedBuffer)
 3087 0326 00D0      		rcall strtol
 3088               	.LVL339:
 3089 0328 1B01      		movw r2,r22
 3090 032a 2C01      		movw r4,r24
 3091               	.LVL340:
 362:main.c        **** 			
 363:main.c        **** 			receivedChar = USART_Receive(); // Wait for byte to say which flash cart write method
 3092               		.loc 3 363 0
 3093 032c 00D0      		rcall USART_Receive
 3094               	.LVL341:
 3095 032e 8093 0000 		sts receivedChar,r24
 364:main.c        **** 			usart_read_chars(); // Read data
 3096               		.loc 3 364 0
 3097 0332 00D0      		rcall usart_read_chars
 3098               	.LVL342:
 365:main.c        **** 			uint8_t flashByte = strtol(receivedBuffer, NULL, 16); // Convert data byte in hex to dec
 3099               		.loc 3 365 0
 3100 0334 40E1      		ldi r20,lo8(16)
 3101 0336 50E0      		ldi r21,0
 3102 0338 60E0      		ldi r22,0
 3103 033a 70E0      		ldi r23,0
 3104 033c 80E0      		ldi r24,lo8(receivedBuffer)
 3105 033e 90E0      		ldi r25,hi8(receivedBuffer)
 3106 0340 00D0      		rcall strtol
 3107               	.LVL343:
 366:main.c        **** 			
 367:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 3108               		.loc 3 367 0
 3109 0342 939A      		sbi 0x12,3
 368:main.c        **** 			if (receivedChar == GB_AUDIO_FLASH_WRITE) { // Pulse audio pin
 3110               		.loc 3 368 0
 3111 0344 8091 0000 		lds r24,receivedChar
 3112 0348 8535      		cpi r24,lo8(85)
 3113 034a 01F4      		brne .L142
 369:main.c        **** 				audio_flash_write_bus_cycle(flashAddress, flashByte);
 3114               		.loc 3 369 0
 3115 034c C101      		movw r24,r2
 3116 034e 00D0      		rcall audio_flash_write_bus_cycle
 3117               	.LVL344:
 3118 0350 00C0      		rjmp .L226
 3119               	.LVL345:
 3120               	.L142:
 370:main.c        **** 			}
 371:main.c        **** 			else if (receivedChar == GB_WR_FLASH_WRITE) { // Pulse WR pin
 3121               		.loc 3 371 0
 3122 0352 8534      		cpi r24,lo8(69)
 3123 0354 01F0      		breq .L214
 372:main.c        **** 				gb_wr_flash_write_bus_cycle(flashAddress, flashByte);
 373:main.c        **** 			}
 374:main.c        **** 			else if (receivedChar == GB_BV5_FLASH_WRITE) { // Pulse WR pin
 3124               		.loc 3 374 0
 3125 0356 8533      		cpi r24,lo8(53)
 3126 0358 01F0      		breq .+2
 3127 035a 00C0      		rjmp .L226
 3128               	.L214:
 375:main.c        **** 				bv5_flash_write_bus_cycle(flashAddress, flashByte);
 3129               		.loc 3 375 0
 3130 035c C101      		movw r24,r2
 3131 035e 00D0      		rcall bv5_flash_write_bus_cycle
 3132               	.LVL346:
 3133 0360 00C0      		rjmp .L226
 3134               	.LVL347:
 3135               	.L141:
 3136               	.LBE132:
 376:main.c        **** 			}
 377:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 378:main.c        **** 			
 379:main.c        **** 			USART_Transmit('1'); // Send back acknowledgement
 380:main.c        **** 		}
 381:main.c        **** 		
 382:main.c        **** 		// Write 64 bytes to Flash address one byte write at a time (and increment), pulse a pin
 383:main.c        **** 		else if (receivedChar == GB_FLASH_WRITE_64BYTE) {
 3137               		.loc 3 383 0
 3138 0362 9435      		cpi r25,lo8(84)
 3139 0364 01F4      		brne .L145
 384:main.c        **** 			receivedChar = USART_Receive(); // Wait for byte
 3140               		.loc 3 384 0
 3141 0366 00D0      		rcall USART_Receive
 3142               	.LVL348:
 3143 0368 8093 0000 		sts receivedChar,r24
 385:main.c        **** 			usart_read_bytes(64);
 3144               		.loc 3 385 0
 3145 036c 80E4      		ldi r24,lo8(64)
 3146 036e 00D0      		rcall usart_read_bytes
 3147               	.LVL349:
 386:main.c        **** 			
 387:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 3148               		.loc 3 387 0
 3149 0370 939A      		sbi 0x12,3
 3150               	.LVL350:
 3151 0372 00E0      		ldi r16,lo8(receivedBuffer)
 3152 0374 10E0      		ldi r17,hi8(receivedBuffer)
 3153 0376 E601      		movw r28,r12
 3154 0378 90E4      		ldi r25,lo8(64)
 3155 037a 592E      		mov r5,r25
 3156               	.LVL351:
 3157               	.L151:
 3158               	.LBB133:
 388:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 389:main.c        **** 				if (receivedChar == GB_AUDIO_FLASH_WRITE) { // Pulse audio pin
 3159               		.loc 3 389 0
 3160 037c 8091 0000 		lds r24,receivedChar
 3161 0380 8535      		cpi r24,lo8(85)
 3162 0382 01F4      		brne .L146
 390:main.c        **** 					audio_flash_write_byte(address, receivedBuffer[x]);
 3163               		.loc 3 390 0
 3164 0384 F801      		movw r30,r16
 3165 0386 6081      		ld r22,Z
 3166 0388 CE01      		movw r24,r28
 3167 038a 00D0      		rcall audio_flash_write_byte
 3168               	.LVL352:
 3169 038c 00C0      		rjmp .L147
 3170               	.L146:
 391:main.c        **** 				}
 392:main.c        **** 				else if (receivedChar == GB_WR_FLASH_WRITE) { // Pulse WR pin
 3171               		.loc 3 392 0
 3172 038e 8534      		cpi r24,lo8(69)
 3173 0390 01F4      		brne .L148
 393:main.c        **** 					gb_wr_flash_write_byte(address, receivedBuffer[x]);
 3174               		.loc 3 393 0
 3175 0392 F801      		movw r30,r16
 3176 0394 6081      		ld r22,Z
 3177 0396 CE01      		movw r24,r28
 3178 0398 00D0      		rcall gb_wr_flash_write_byte
 3179               	.LVL353:
 3180 039a 00C0      		rjmp .L147
 3181               	.L148:
 394:main.c        **** 				}
 395:main.c        **** 				else if (receivedChar == GB_WR_FLASH_BYTE_WRITE) { 
 3182               		.loc 3 395 0
 3183 039c 8E34      		cpi r24,lo8(78)
 3184 039e 01F4      		brne .L149
 396:main.c        **** 					gb_wr_flash_byte_write_byte(address, receivedBuffer[x]);
 3185               		.loc 3 396 0
 3186 03a0 F801      		movw r30,r16
 3187 03a2 6081      		ld r22,Z
 3188 03a4 CE01      		movw r24,r28
 3189 03a6 00D0      		rcall gb_wr_flash_byte_write_byte
 3190               	.LVL354:
 3191 03a8 00C0      		rjmp .L147
 3192               	.L149:
 397:main.c        **** 				}
 398:main.c        **** 				else if (receivedChar == GB_WORD_FLASH_WRITE) {
 3193               		.loc 3 398 0
 3194 03aa 8935      		cpi r24,lo8(89)
 3195 03ac 01F4      		brne .L150
 399:main.c        **** 					gb_word_flash_write_byte(address, receivedBuffer[x]);
 3196               		.loc 3 399 0
 3197 03ae F801      		movw r30,r16
 3198 03b0 6081      		ld r22,Z
 3199 03b2 CE01      		movw r24,r28
 3200 03b4 00D0      		rcall gb_word_flash_write_byte
 3201               	.LVL355:
 3202 03b6 00C0      		rjmp .L147
 3203               	.L150:
 400:main.c        **** 				}
 401:main.c        **** 				else if (receivedChar == GB_BV5_FLASH_WRITE) { 
 3204               		.loc 3 401 0
 3205 03b8 8533      		cpi r24,lo8(53)
 3206 03ba 01F4      		brne .L147
 402:main.c        **** 					bv5_flash_write_byte(address, receivedBuffer[x]);
 3207               		.loc 3 402 0
 3208 03bc F801      		movw r30,r16
 3209 03be 6081      		ld r22,Z
 3210 03c0 CE01      		movw r24,r28
 3211 03c2 00D0      		rcall bv5_flash_write_byte
 3212               	.LVL356:
 3213               	.L147:
 3214 03c4 5A94      		dec r5
 3215 03c6 0F5F      		subi r16,-1
 3216 03c8 1F4F      		sbci r17,-1
 3217               	.LVL357:
 3218 03ca 2196      		adiw r28,1
 388:main.c        **** 				if (receivedChar == GB_AUDIO_FLASH_WRITE) { // Pulse audio pin
 3219               		.loc 3 388 0 discriminator 2
 3220 03cc 5110      		cpse r5,__zero_reg__
 3221 03ce 00C0      		rjmp .L151
 3222 03d0 F0E4      		ldi r31,64
 3223 03d2 CF0E      		add r12,r31
 3224 03d4 D11C      		adc r13,__zero_reg__
 3225 03d6 E11C      		adc r14,__zero_reg__
 3226 03d8 F11C      		adc r15,__zero_reg__
 3227 03da 00C0      		rjmp .L215
 3228               	.LVL358:
 3229               	.L145:
 3230               	.LBE133:
 403:main.c        **** 				}
 404:main.c        **** 				
 405:main.c        **** 				address++;
 406:main.c        **** 			}
 407:main.c        **** 			USART_Transmit('1'); // Send back acknowledgement
 408:main.c        **** 			
 409:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 410:main.c        **** 		}
 411:main.c        **** 		
 412:main.c        **** 		
 413:main.c        **** 		// ---------- GBA FLASH CARTS ----------
 414:main.c        **** 		// Write 24 bit address, 16 bit data and pulse a pin
 415:main.c        **** 		else if (receivedChar == GBA_FLASH_CART_WRITE_BYTE) {
 3231               		.loc 3 415 0
 3232 03dc 9E36      		cpi r25,lo8(110)
 3233 03de 01F4      		brne .L152
 3234               	.LBB134:
 416:main.c        **** 			usart_read_chars(); // Read address
 3235               		.loc 3 416 0
 3236 03e0 00D0      		rcall usart_read_chars
 3237               	.LVL359:
 417:main.c        **** 			uint32_t flashAddress = strtol(receivedBuffer, NULL, 16); // Convert address string in hex to de
 3238               		.loc 3 417 0
 3239 03e2 40E1      		ldi r20,lo8(16)
 3240 03e4 50E0      		ldi r21,0
 3241 03e6 60E0      		ldi r22,0
 3242 03e8 70E0      		ldi r23,0
 3243 03ea 80E0      		ldi r24,lo8(receivedBuffer)
 3244 03ec 90E0      		ldi r25,hi8(receivedBuffer)
 3245 03ee 00D0      		rcall strtol
 3246               	.LVL360:
 3247 03f0 1B01      		movw r2,r22
 3248 03f2 2C01      		movw r4,r24
 3249               	.LVL361:
 418:main.c        **** 			
 419:main.c        **** 			receivedChar = USART_Receive(); // Wait for byte
 3250               		.loc 3 419 0
 3251 03f4 00D0      		rcall USART_Receive
 3252               	.LVL362:
 3253 03f6 8093 0000 		sts receivedChar,r24
 420:main.c        **** 			if (receivedChar == GBA_FLASH_CART_WRITE_BYTE) {
 3254               		.loc 3 420 0
 3255 03fa 8E36      		cpi r24,lo8(110)
 3256 03fc 01F0      		breq .+2
 3257 03fe 00C0      		rjmp .L101
 3258               	.LBB135:
 421:main.c        **** 				usart_read_chars(); // Read data
 3259               		.loc 3 421 0
 3260 0400 00D0      		rcall usart_read_chars
 3261               	.LVL363:
 422:main.c        **** 				uint16_t flashByte = strtol(receivedBuffer, NULL, 16); // Convert data byte in hex to dec
 3262               		.loc 3 422 0
 3263 0402 40E1      		ldi r20,lo8(16)
 3264 0404 50E0      		ldi r21,0
 3265 0406 60E0      		ldi r22,0
 3266 0408 70E0      		ldi r23,0
 3267 040a 80E0      		ldi r24,lo8(receivedBuffer)
 3268 040c 90E0      		ldi r25,hi8(receivedBuffer)
 3269 040e 00D0      		rcall strtol
 3270               	.LVL364:
 423:main.c        **** 				
 424:main.c        **** 				PORTD |= (1<<ACTIVITY_LED);
 3271               		.loc 3 424 0
 3272 0410 939A      		sbi 0x12,3
 425:main.c        **** 				gba_flash_write_bus_cycle(flashAddress, flashByte);
 3273               		.loc 3 425 0
 3274 0412 AB01      		movw r20,r22
 3275 0414 C201      		movw r24,r4
 3276 0416 B101      		movw r22,r2
 3277               	.LVL365:
 3278 0418 00D0      		rcall gba_flash_write_bus_cycle
 3279               	.LVL366:
 3280               	.L226:
 426:main.c        **** 				PORTD &= ~(1<<ACTIVITY_LED);
 3281               		.loc 3 426 0
 3282 041a 9398      		cbi 0x12,3
 427:main.c        **** 				
 428:main.c        **** 				USART_Transmit('1'); // Send back acknowledgement
 3283               		.loc 3 428 0
 3284 041c 81E3      		ldi r24,lo8(49)
 3285 041e 00C0      		rjmp .L203
 3286               	.LVL367:
 3287               	.L152:
 3288               	.LBE135:
 3289               	.LBE134:
 429:main.c        **** 			}
 430:main.c        **** 		}
 431:main.c        **** 		
 432:main.c        **** 		// Write 64 bytes to Flash address, combine 2 bytes and write at a time (and increment address by
 433:main.c        **** 		else if (receivedChar == GBA_FLASH_WRITE_64BYTE) {
 3290               		.loc 3 433 0
 3291 0420 9137      		cpi r25,lo8(113)
 3292 0422 01F4      		brne .L153
 434:main.c        **** 			usart_read_bytes(64);
 3293               		.loc 3 434 0
 3294 0424 80E4      		ldi r24,lo8(64)
 3295               	.LVL368:
 3296 0426 00D0      		rcall usart_read_bytes
 3297               	.LVL369:
 435:main.c        **** 			
 436:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 3298               		.loc 3 436 0
 3299 0428 939A      		sbi 0x12,3
 3300               	.LVL370:
 3301 042a C0E0      		ldi r28,lo8(receivedBuffer)
 3302 042c D0E0      		ldi r29,hi8(receivedBuffer)
 3303 042e 1601      		movw r2,r12
 3304 0430 2701      		movw r4,r14
 3305               	.LVL371:
 3306               	.L154:
 3307               	.LBB136:
 3308               	.LBB137:
 437:main.c        **** 			for (uint8_t x = 0; x < 64; x += 2) {
 438:main.c        **** 				uint16_t combinedBytes = (uint16_t) receivedBuffer[x+1] << 8 | (uint16_t) receivedBuffer[x];
 439:main.c        **** 				gba_flash_write_byte_swapped(address, combinedBytes);
 3309               		.loc 3 439 0 discriminator 3
 3310 0432 4981      		ldd r20,Y+1
 3311 0434 50E0      		ldi r21,0
 3312 0436 542F      		mov r21,r20
 3313 0438 4427      		clr r20
 3314 043a 8881      		ld r24,Y
 3315 043c 482B      		or r20,r24
 3316 043e C201      		movw r24,r4
 3317 0440 B101      		movw r22,r2
 3318 0442 00D0      		rcall gba_flash_write_byte_swapped
 3319               	.LVL372:
 440:main.c        **** 				address++;
 3320               		.loc 3 440 0 discriminator 3
 3321 0444 2FEF      		ldi r18,-1
 3322 0446 221A      		sub r2,r18
 3323 0448 320A      		sbc r3,r18
 3324 044a 420A      		sbc r4,r18
 3325 044c 520A      		sbc r5,r18
 3326               	.LVL373:
 3327 044e 2296      		adiw r28,2
 3328               	.LVL374:
 3329               	.LBE137:
 437:main.c        **** 			for (uint8_t x = 0; x < 64; x += 2) {
 3330               		.loc 3 437 0 discriminator 3
 3331 0450 6C16      		cp r6,r28
 3332 0452 7D06      		cpc r7,r29
 3333 0454 01F4      		brne .L154
 3334 0456 80E2      		ldi r24,32
 3335 0458 C80E      		add r12,r24
 3336 045a D11C      		adc r13,__zero_reg__
 3337 045c E11C      		adc r14,__zero_reg__
 3338 045e F11C      		adc r15,__zero_reg__
 3339               	.LVL375:
 3340               	.L215:
 3341               	.LBE136:
 441:main.c        **** 			}
 442:main.c        **** 			USART_Transmit('1'); // Send back acknowledgement
 3342               		.loc 3 442 0
 3343 0460 81E3      		ldi r24,lo8(49)
 3344 0462 00C0      		rjmp .L206
 3345               	.LVL376:
 3346               	.L153:
 443:main.c        **** 			
 444:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 445:main.c        **** 		}
 446:main.c        **** 		
 447:main.c        **** 		
 448:main.c        **** 		// ---------- General commands ----------
 449:main.c        **** 		// Set any pin as input/output
 450:main.c        **** 		// Reads the DDR/PORT (e.g. DDRB/PORTB is 'B') and the hex value that represents pins to set to a
 451:main.c        **** 		else if (receivedChar == SET_INPUT || receivedChar == SET_OUTPUT) {
 3347               		.loc 3 451 0
 3348 0464 9934      		cpi r25,lo8(73)
 3349 0466 01F0      		breq .L155
 3350               		.loc 3 451 0 is_stmt 0 discriminator 1
 3351 0468 9F34      		cpi r25,lo8(79)
 3352 046a 01F0      		breq .+2
 3353 046c 00C0      		rjmp .L156
 3354               	.L155:
 3355               	.LBB138:
 452:main.c        **** 			char portChar = USART_Receive();
 3356               		.loc 3 452 0 is_stmt 1
 3357 046e 00D0      		rcall USART_Receive
 3358               	.LVL377:
 3359 0470 C82F      		mov r28,r24
 3360               	.LVL378:
 453:main.c        **** 			usart_read_chars();
 3361               		.loc 3 453 0
 3362 0472 00D0      		rcall usart_read_chars
 3363               	.LVL379:
 454:main.c        **** 			uint8_t setValue = strtol(receivedBuffer, NULL, 16);
 3364               		.loc 3 454 0
 3365 0474 40E1      		ldi r20,lo8(16)
 3366 0476 50E0      		ldi r21,0
 3367 0478 60E0      		ldi r22,0
 3368 047a 70E0      		ldi r23,0
 3369 047c 80E0      		ldi r24,lo8(receivedBuffer)
 3370 047e 90E0      		ldi r25,hi8(receivedBuffer)
 3371 0480 00D0      		rcall strtol
 3372               	.LVL380:
 455:main.c        **** 			
 456:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 3373               		.loc 3 456 0
 3374 0482 939A      		sbi 0x12,3
 457:main.c        **** 			if (receivedChar == SET_INPUT) {
 3375               		.loc 3 457 0
 3376 0484 8091 0000 		lds r24,receivedChar
 3377 0488 8934      		cpi r24,lo8(73)
 3378 048a 01F4      		brne .L157
 458:main.c        **** 				if (portChar == 'A') {
 3379               		.loc 3 458 0
 3380 048c C134      		cpi r28,lo8(65)
 3381 048e 01F4      		brne .L158
 459:main.c        **** 					DDRA &= ~(setValue);
 3382               		.loc 3 459 0
 3383 0490 8AB3      		in r24,0x1a
 3384 0492 6095      		com r22
 3385               	.LVL381:
 3386 0494 6823      		and r22,r24
 3387               	.LVL382:
 3388 0496 00C0      		rjmp .L217
 3389               	.LVL383:
 3390               	.L158:
 460:main.c        **** 				}
 461:main.c        **** 				else if (portChar == 'B') {
 3391               		.loc 3 461 0
 3392 0498 C234      		cpi r28,lo8(66)
 3393 049a 01F4      		brne .L160
 462:main.c        **** 					DDRB &= ~(setValue);
 3394               		.loc 3 462 0
 3395 049c 87B3      		in r24,0x17
 3396 049e 6095      		com r22
 3397               	.LVL384:
 3398 04a0 6823      		and r22,r24
 3399               	.LVL385:
 3400 04a2 00C0      		rjmp .L218
 3401               	.LVL386:
 3402               	.L160:
 463:main.c        **** 				}
 464:main.c        **** 				else if (portChar == 'C') {
 3403               		.loc 3 464 0
 3404 04a4 C334      		cpi r28,lo8(67)
 3405 04a6 01F4      		brne .L161
 465:main.c        **** 					DDRC &= ~(setValue);
 3406               		.loc 3 465 0
 3407 04a8 84B3      		in r24,0x14
 3408 04aa 6095      		com r22
 3409               	.LVL387:
 3410 04ac 6823      		and r22,r24
 3411               	.LVL388:
 3412 04ae 00C0      		rjmp .L223
 3413               	.LVL389:
 3414               	.L161:
 466:main.c        **** 				}
 467:main.c        **** 				else if (portChar == 'D') {
 3415               		.loc 3 467 0
 3416 04b0 C434      		cpi r28,lo8(68)
 3417 04b2 01F4      		brne .L162
 468:main.c        **** 					DDRD &= ~(setValue);
 3418               		.loc 3 468 0
 3419 04b4 81B3      		in r24,0x11
 3420 04b6 6095      		com r22
 3421               	.LVL390:
 3422 04b8 6823      		and r22,r24
 3423               	.LVL391:
 3424 04ba 00C0      		rjmp .L224
 3425               	.LVL392:
 3426               	.L162:
 469:main.c        **** 				}
 470:main.c        **** 				else if (portChar == 'E') {
 3427               		.loc 3 470 0
 3428 04bc C534      		cpi r28,lo8(69)
 3429 04be 01F0      		breq .+2
 3430 04c0 00C0      		rjmp .L181
 471:main.c        **** 					DDRE &= ~(setValue);
 3431               		.loc 3 471 0
 3432 04c2 86B1      		in r24,0x6
 3433 04c4 6095      		com r22
 3434               	.LVL393:
 3435 04c6 6823      		and r22,r24
 3436               	.LVL394:
 3437 04c8 00C0      		rjmp .L225
 3438               	.LVL395:
 3439               	.L157:
 472:main.c        **** 				}
 473:main.c        **** 			}
 474:main.c        **** 			else if (receivedChar == SET_OUTPUT) {
 3440               		.loc 3 474 0
 3441 04ca 8F34      		cpi r24,lo8(79)
 3442 04cc 01F0      		breq .+2
 3443 04ce 00C0      		rjmp .L181
 475:main.c        **** 				if (portChar == 'A') {
 3444               		.loc 3 475 0
 3445 04d0 C134      		cpi r28,lo8(65)
 3446 04d2 01F4      		brne .L163
 476:main.c        **** 					DDRA |= (setValue);
 3447               		.loc 3 476 0
 3448 04d4 8AB3      		in r24,0x1a
 3449 04d6 682B      		or r22,r24
 3450               	.LVL396:
 3451               	.L217:
 3452 04d8 6ABB      		out 0x1a,r22
 3453 04da 00C0      		rjmp .L181
 3454               	.LVL397:
 3455               	.L163:
 477:main.c        **** 				}
 478:main.c        **** 				else if (portChar == 'B') {
 3456               		.loc 3 478 0
 3457 04dc C234      		cpi r28,lo8(66)
 3458 04de 01F4      		brne .L164
 479:main.c        **** 					DDRB |= (setValue);
 3459               		.loc 3 479 0
 3460 04e0 87B3      		in r24,0x17
 3461 04e2 682B      		or r22,r24
 3462               	.LVL398:
 3463               	.L218:
 3464 04e4 67BB      		out 0x17,r22
 3465 04e6 00C0      		rjmp .L181
 3466               	.LVL399:
 3467               	.L164:
 480:main.c        **** 				}
 481:main.c        **** 				else if (portChar == 'C') {
 3468               		.loc 3 481 0
 3469 04e8 C334      		cpi r28,lo8(67)
 3470 04ea 01F4      		brne .L165
 482:main.c        **** 					DDRC |= (setValue);
 3471               		.loc 3 482 0
 3472 04ec 84B3      		in r24,0x14
 3473 04ee 682B      		or r22,r24
 3474               	.LVL400:
 3475               	.L223:
 3476 04f0 64BB      		out 0x14,r22
 3477 04f2 00C0      		rjmp .L181
 3478               	.LVL401:
 3479               	.L165:
 483:main.c        **** 				}
 484:main.c        **** 				else if (portChar == 'D') {
 3480               		.loc 3 484 0
 3481 04f4 C434      		cpi r28,lo8(68)
 3482 04f6 01F4      		brne .L166
 485:main.c        **** 					DDRD |= (setValue);
 3483               		.loc 3 485 0
 3484 04f8 81B3      		in r24,0x11
 3485 04fa 682B      		or r22,r24
 3486               	.LVL402:
 3487               	.L224:
 3488 04fc 61BB      		out 0x11,r22
 3489 04fe 00C0      		rjmp .L181
 3490               	.LVL403:
 3491               	.L166:
 486:main.c        **** 				}
 487:main.c        **** 				else if (portChar == 'E') {
 3492               		.loc 3 487 0
 3493 0500 C534      		cpi r28,lo8(69)
 3494 0502 01F0      		breq .+2
 3495 0504 00C0      		rjmp .L181
 488:main.c        **** 					DDRE |= (setValue);
 3496               		.loc 3 488 0
 3497 0506 86B1      		in r24,0x6
 3498 0508 682B      		or r22,r24
 3499               	.LVL404:
 3500               	.L225:
 3501 050a 66B9      		out 0x6,r22
 3502 050c 00C0      		rjmp .L181
 3503               	.LVL405:
 3504               	.L156:
 3505               	.LBE138:
 489:main.c        **** 				}
 490:main.c        **** 			}
 491:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 492:main.c        **** 		}
 493:main.c        **** 		
 494:main.c        **** 		// Set pin output as low
 495:main.c        **** 		else if (receivedChar == SET_OUTPUT_LOW) {
 3506               		.loc 3 495 0
 3507 050e 9C34      		cpi r25,lo8(76)
 3508 0510 01F4      		brne .L167
 3509               	.LBB139:
 496:main.c        **** 			char portChar = USART_Receive();			
 3510               		.loc 3 496 0
 3511 0512 00D0      		rcall USART_Receive
 3512               	.LVL406:
 3513 0514 C82F      		mov r28,r24
 3514               	.LVL407:
 497:main.c        **** 			usart_read_chars();
 3515               		.loc 3 497 0
 3516 0516 00D0      		rcall usart_read_chars
 3517               	.LVL408:
 498:main.c        **** 			uint8_t setValue = strtol(receivedBuffer, NULL, 16);
 3518               		.loc 3 498 0
 3519 0518 40E1      		ldi r20,lo8(16)
 3520 051a 50E0      		ldi r21,0
 3521 051c 60E0      		ldi r22,0
 3522 051e 70E0      		ldi r23,0
 3523 0520 80E0      		ldi r24,lo8(receivedBuffer)
 3524 0522 90E0      		ldi r25,hi8(receivedBuffer)
 3525 0524 00D0      		rcall strtol
 3526               	.LVL409:
 499:main.c        **** 			
 500:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 3527               		.loc 3 500 0
 3528 0526 939A      		sbi 0x12,3
 501:main.c        **** 			if (portChar == 'A') {
 3529               		.loc 3 501 0
 3530 0528 C134      		cpi r28,lo8(65)
 3531 052a 01F4      		brne .L168
 502:main.c        **** 				PORTA &= ~(setValue);
 3532               		.loc 3 502 0
 3533 052c 8BB3      		in r24,0x1b
 3534 052e 6095      		com r22
 3535               	.LVL410:
 3536 0530 6823      		and r22,r24
 3537               	.LVL411:
 3538 0532 00C0      		rjmp .L222
 3539               	.LVL412:
 3540               	.L168:
 503:main.c        **** 			}
 504:main.c        **** 			else if (portChar == 'B') {
 3541               		.loc 3 504 0
 3542 0534 C234      		cpi r28,lo8(66)
 3543 0536 01F4      		brne .L170
 505:main.c        **** 				PORTB &= ~(setValue);
 3544               		.loc 3 505 0
 3545 0538 88B3      		in r24,0x18
 3546 053a 6095      		com r22
 3547               	.LVL413:
 3548 053c 6823      		and r22,r24
 3549               	.LVL414:
 3550 053e 00C0      		rjmp .L221
 3551               	.LVL415:
 3552               	.L170:
 506:main.c        **** 			}
 507:main.c        **** 			else if (portChar == 'C') {
 3553               		.loc 3 507 0
 3554 0540 C334      		cpi r28,lo8(67)
 3555 0542 01F4      		brne .L171
 508:main.c        **** 				PORTC &= ~(setValue);
 3556               		.loc 3 508 0
 3557 0544 85B3      		in r24,0x15
 3558 0546 6095      		com r22
 3559               	.LVL416:
 3560 0548 6823      		and r22,r24
 3561               	.LVL417:
 3562 054a 00C0      		rjmp .L220
 3563               	.LVL418:
 3564               	.L171:
 509:main.c        **** 			}
 510:main.c        **** 			else if (portChar == 'D') {
 3565               		.loc 3 510 0
 3566 054c C434      		cpi r28,lo8(68)
 3567 054e 01F4      		brne .L172
 511:main.c        **** 				PORTD &= ~(setValue);
 3568               		.loc 3 511 0
 3569 0550 82B3      		in r24,0x12
 3570 0552 6095      		com r22
 3571               	.LVL419:
 3572 0554 6823      		and r22,r24
 3573               	.LVL420:
 3574 0556 00C0      		rjmp .L219
 3575               	.LVL421:
 3576               	.L172:
 512:main.c        **** 			}
 513:main.c        **** 			else if (portChar == 'E') {
 3577               		.loc 3 513 0
 3578 0558 C534      		cpi r28,lo8(69)
 3579 055a 01F0      		breq .+2
 3580 055c 00C0      		rjmp .L181
 514:main.c        **** 				PORTE &= ~(setValue);
 3581               		.loc 3 514 0
 3582 055e 87B1      		in r24,0x7
 3583 0560 6095      		com r22
 3584               	.LVL422:
 3585 0562 6823      		and r22,r24
 3586               	.LVL423:
 3587 0564 00C0      		rjmp .L216
 3588               	.LVL424:
 3589               	.L167:
 3590               	.LBE139:
 515:main.c        **** 			}
 516:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 517:main.c        **** 		}
 518:main.c        **** 		
 519:main.c        **** 		// Set pin output as high
 520:main.c        **** 		else if (receivedChar == SET_OUTPUT_HIGH) {
 3591               		.loc 3 520 0
 3592 0566 9834      		cpi r25,lo8(72)
 3593 0568 01F4      		brne .L173
 3594               	.LBB140:
 521:main.c        **** 			char portChar = USART_Receive();			
 3595               		.loc 3 521 0
 3596 056a 00D0      		rcall USART_Receive
 3597               	.LVL425:
 3598 056c C82F      		mov r28,r24
 3599               	.LVL426:
 522:main.c        **** 			usart_read_chars();
 3600               		.loc 3 522 0
 3601 056e 00D0      		rcall usart_read_chars
 3602               	.LVL427:
 523:main.c        **** 			uint8_t setValue = strtol(receivedBuffer, NULL, 16);
 3603               		.loc 3 523 0
 3604 0570 40E1      		ldi r20,lo8(16)
 3605 0572 50E0      		ldi r21,0
 3606 0574 60E0      		ldi r22,0
 3607 0576 70E0      		ldi r23,0
 3608 0578 80E0      		ldi r24,lo8(receivedBuffer)
 3609 057a 90E0      		ldi r25,hi8(receivedBuffer)
 3610 057c 00D0      		rcall strtol
 3611               	.LVL428:
 524:main.c        **** 			
 525:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 3612               		.loc 3 525 0
 3613 057e 939A      		sbi 0x12,3
 526:main.c        **** 			if (portChar == 'A') {
 3614               		.loc 3 526 0
 3615 0580 C134      		cpi r28,lo8(65)
 3616 0582 01F4      		brne .L174
 527:main.c        **** 				PORTA |= (setValue);
 3617               		.loc 3 527 0
 3618 0584 8BB3      		in r24,0x1b
 3619 0586 682B      		or r22,r24
 3620               	.LVL429:
 3621               	.L222:
 3622 0588 6BBB      		out 0x1b,r22
 3623 058a 00C0      		rjmp .L181
 3624               	.LVL430:
 3625               	.L174:
 528:main.c        **** 			}
 529:main.c        **** 			else if (portChar == 'B') {
 3626               		.loc 3 529 0
 3627 058c C234      		cpi r28,lo8(66)
 3628 058e 01F4      		brne .L176
 530:main.c        **** 				PORTB |= (setValue);
 3629               		.loc 3 530 0
 3630 0590 88B3      		in r24,0x18
 3631 0592 682B      		or r22,r24
 3632               	.LVL431:
 3633               	.L221:
 3634 0594 68BB      		out 0x18,r22
 3635 0596 00C0      		rjmp .L181
 3636               	.LVL432:
 3637               	.L176:
 531:main.c        **** 			}
 532:main.c        **** 			else if (portChar == 'C') {
 3638               		.loc 3 532 0
 3639 0598 C334      		cpi r28,lo8(67)
 3640 059a 01F4      		brne .L177
 533:main.c        **** 				PORTC |= (setValue);
 3641               		.loc 3 533 0
 3642 059c 85B3      		in r24,0x15
 3643 059e 682B      		or r22,r24
 3644               	.LVL433:
 3645               	.L220:
 3646 05a0 65BB      		out 0x15,r22
 3647 05a2 00C0      		rjmp .L181
 3648               	.LVL434:
 3649               	.L177:
 534:main.c        **** 			}
 535:main.c        **** 			else if (portChar == 'D') {
 3650               		.loc 3 535 0
 3651 05a4 C434      		cpi r28,lo8(68)
 3652 05a6 01F4      		brne .L178
 536:main.c        **** 				PORTD |= (setValue);
 3653               		.loc 3 536 0
 3654 05a8 82B3      		in r24,0x12
 3655 05aa 682B      		or r22,r24
 3656               	.LVL435:
 3657               	.L219:
 3658 05ac 62BB      		out 0x12,r22
 3659 05ae 00C0      		rjmp .L181
 3660               	.LVL436:
 3661               	.L178:
 537:main.c        **** 			}
 538:main.c        **** 			else if (portChar == 'E') {
 3662               		.loc 3 538 0
 3663 05b0 C534      		cpi r28,lo8(69)
 3664 05b2 01F4      		brne .L181
 539:main.c        **** 				PORTE |= (setValue);
 3665               		.loc 3 539 0
 3666 05b4 87B1      		in r24,0x7
 3667 05b6 682B      		or r22,r24
 3668               	.LVL437:
 3669               	.L216:
 3670 05b8 67B9      		out 0x7,r22
 3671 05ba 00C0      		rjmp .L181
 3672               	.LVL438:
 3673               	.L173:
 3674               	.LBE140:
 540:main.c        **** 			}
 541:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 542:main.c        **** 		}
 543:main.c        **** 		
 544:main.c        **** 		// Read all pins of a PORT and return the value
 545:main.c        **** 		else if (receivedChar == READ_INPUT) {
 3675               		.loc 3 545 0
 3676 05bc 9434      		cpi r25,lo8(68)
 3677 05be 01F4      		brne .L179
 3678               	.LBB141:
 546:main.c        **** 			char portChar = USART_Receive();			
 3679               		.loc 3 546 0
 3680 05c0 00D0      		rcall USART_Receive
 3681               	.LVL439:
 547:main.c        **** 			
 548:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 3682               		.loc 3 548 0
 3683 05c2 939A      		sbi 0x12,3
 549:main.c        **** 			if (portChar == 'A') {
 3684               		.loc 3 549 0
 3685 05c4 8134      		cpi r24,lo8(65)
 3686 05c6 01F4      		brne .L180
 550:main.c        **** 				USART_Transmit(PINA);
 3687               		.loc 3 550 0
 3688 05c8 89B3      		in r24,0x19
 3689               	.LVL440:
 3690 05ca 00C0      		rjmp .L206
 3691               	.LVL441:
 3692               	.L180:
 551:main.c        **** 			}
 552:main.c        **** 			else if (portChar == 'B') {
 3693               		.loc 3 552 0
 3694 05cc 8234      		cpi r24,lo8(66)
 3695 05ce 01F4      		brne .L182
 553:main.c        **** 				USART_Transmit(PINB);
 3696               		.loc 3 553 0
 3697 05d0 86B3      		in r24,0x16
 3698               	.LVL442:
 3699 05d2 00C0      		rjmp .L206
 3700               	.LVL443:
 3701               	.L182:
 554:main.c        **** 			}
 555:main.c        **** 			else if (portChar == 'C') {
 3702               		.loc 3 555 0
 3703 05d4 8334      		cpi r24,lo8(67)
 3704 05d6 01F4      		brne .L183
 556:main.c        **** 				USART_Transmit(PINC);
 3705               		.loc 3 556 0
 3706 05d8 83B3      		in r24,0x13
 3707               	.LVL444:
 3708 05da 00C0      		rjmp .L206
 3709               	.LVL445:
 3710               	.L183:
 557:main.c        **** 			}
 558:main.c        **** 			else if (portChar == 'D') {
 3711               		.loc 3 558 0
 3712 05dc 8434      		cpi r24,lo8(68)
 3713 05de 01F4      		brne .L184
 559:main.c        **** 				USART_Transmit(PIND);
 3714               		.loc 3 559 0
 3715 05e0 80B3      		in r24,0x10
 3716               	.LVL446:
 3717 05e2 00C0      		rjmp .L206
 3718               	.LVL447:
 3719               	.L184:
 560:main.c        **** 			}
 561:main.c        **** 			else if (portChar == 'E') {
 3720               		.loc 3 561 0
 3721 05e4 8534      		cpi r24,lo8(69)
 3722 05e6 01F4      		brne .L181
 562:main.c        **** 				USART_Transmit(PINE);
 3723               		.loc 3 562 0
 3724 05e8 85B1      		in r24,0x5
 3725               	.LVL448:
 3726               	.L206:
 3727 05ea 00D0      		rcall USART_Transmit
 3728               	.LVL449:
 3729               	.L181:
 563:main.c        **** 			}
 564:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 3730               		.loc 3 564 0
 3731 05ec 9398      		cbi 0x12,3
 3732               	.LBE141:
 3733 05ee 00C0      		rjmp .L101
 3734               	.LVL450:
 3735               	.L179:
 565:main.c        **** 		}
 566:main.c        **** 		
 567:main.c        **** 		// Set the reset common lines variable on or off, useful if you are controlling all the pins dire
 568:main.c        **** 		else if (receivedChar == RESET_COMMON_LINES) {
 3736               		.loc 3 568 0
 3737 05f0 9D34      		cpi r25,lo8(77)
 3738 05f2 01F4      		brne .L185
 3739               	.LBB142:
 569:main.c        **** 			char commonChar = USART_Receive();
 3740               		.loc 3 569 0
 3741 05f4 00D0      		rcall USART_Receive
 3742               	.LVL451:
 570:main.c        **** 			if (commonChar == '1') {
 3743               		.loc 3 570 0
 3744 05f6 8133      		cpi r24,lo8(49)
 3745 05f8 01F4      		brne .L227
 571:main.c        **** 				resetCommonLines = 1;
 3746               		.loc 3 571 0
 3747 05fa 8824      		clr r8
 3748 05fc 8394      		inc r8
 3749 05fe 00C0      		rjmp .L202
 3750               	.L227:
 572:main.c        **** 			}
 573:main.c        **** 			else if (commonChar == '0') {
 3751               		.loc 3 573 0
 3752 0600 8033      		cpi r24,lo8(48)
 3753 0602 01F0      		breq .+2
 3754 0604 00C0      		rjmp .L101
 574:main.c        **** 				resetCommonLines = 0;
 3755               		.loc 3 574 0
 3756 0606 812C      		mov r8,__zero_reg__
 3757 0608 00C0      		rjmp .L102
 3758               	.LVL452:
 3759               	.L185:
 3760               	.LBE142:
 575:main.c        **** 			}
 576:main.c        **** 		}
 577:main.c        **** 		
 578:main.c        **** 		// Send back the PCB version number
 579:main.c        **** 		else if (receivedChar == READ_PCB_VERSION) {
 3761               		.loc 3 579 0
 3762 060a 9836      		cpi r25,lo8(104)
 3763 060c 01F4      		brne .L186
 580:main.c        **** 			USART_Transmit(PCB_VERSION);
 3764               		.loc 3 580 0
 3765 060e 82E0      		ldi r24,lo8(2)
 3766               	.LVL453:
 3767 0610 00C0      		rjmp .L203
 3768               	.LVL454:
 3769               	.L186:
 581:main.c        **** 		}
 582:main.c        **** 		
 583:main.c        **** 		// Send back the firmware version number
 584:main.c        **** 		else if (receivedChar == READ_FIRMWARE_VERSION) {
 3770               		.loc 3 584 0
 3771 0612 9635      		cpi r25,lo8(86)
 3772 0614 01F4      		brne .L187
 585:main.c        **** 			USART_Transmit(FIRMWARE_VERSION);
 3773               		.loc 3 585 0
 3774 0616 88E0      		ldi r24,lo8(8)
 3775               	.LVL455:
 3776               	.L203:
 3777 0618 00D0      		rcall USART_Transmit
 3778               	.LVL456:
 3779 061a 00C0      		rjmp .L101
 3780               	.LVL457:
 3781               	.L187:
 586:main.c        **** 		}
 587:main.c        **** 		
 588:main.c        **** 		// Reset the AVR if it matches the number
 589:main.c        **** 		else if (receivedChar == RESET_AVR) {
 3782               		.loc 3 589 0
 3783 061c 9A32      		cpi r25,lo8(42)
 3784 061e 01F0      		breq .+2
 3785 0620 00C0      		rjmp .L101
 3786               	.LBB143:
 590:main.c        **** 			usart_read_chars();
 3787               		.loc 3 590 0
 3788 0622 00D0      		rcall usart_read_chars
 3789               	.LVL458:
 591:main.c        **** 			uint32_t resetValue = strtol(receivedBuffer, NULL, 16);
 3790               		.loc 3 591 0
 3791 0624 40E1      		ldi r20,lo8(16)
 3792 0626 50E0      		ldi r21,0
 3793 0628 60E0      		ldi r22,0
 3794 062a 70E0      		ldi r23,0
 3795 062c 80E0      		ldi r24,lo8(receivedBuffer)
 3796 062e 90E0      		ldi r25,hi8(receivedBuffer)
 3797 0630 00D0      		rcall strtol
 3798               	.LVL459:
 592:main.c        **** 			if (resetValue == RESET_VALUE) {
 3799               		.loc 3 592 0
 3800 0632 613E      		cpi r22,-31
 3801 0634 754E      		sbci r23,-27
 3802 0636 8740      		sbci r24,7
 3803 0638 9105      		cpc r25,__zero_reg__
 3804 063a 01F0      		breq .+2
 3805 063c 00C0      		rjmp .L101
 593:main.c        **** 				// Clear watchdog flag
 594:main.c        **** 				MCUCSR &= ~(1<<WDRF);
 3806               		.loc 3 594 0
 3807 063e 84B7      		in r24,0x34
 3808 0640 877F      		andi r24,lo8(-9)
 3809 0642 84BF      		out 0x34,r24
 595:main.c        **** 				
 596:main.c        **** 				// Start timed sequence
 597:main.c        **** 				WDTCR = (1<<WDCE) | (1<<WDE);
 3810               		.loc 3 597 0
 3811 0644 F8E1      		ldi r31,lo8(24)
 3812 0646 F1BD      		out 0x21,r31
 598:main.c        **** 				
 599:main.c        **** 				// Reset in 250 ms
 600:main.c        **** 				WDTCR = (1<<WDP2) | (1<<WDE);
 3813               		.loc 3 600 0
 3814 0648 2CE0      		ldi r18,lo8(12)
 3815 064a 21BD      		out 0x21,r18
 3816               	.LVL460:
 3817               	.LBB144:
 3818               	.LBB145:
 3819               		.file 4 "c:\\winavr-20100110\\avr\\include\\util\\delay_basic.h"
   1:c:\winavr-20100110\avr\include\util\delay_basic.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:c:\winavr-20100110\avr\include\util\delay_basic.h ****    Copyright (c) 2007 Joerg Wunsch
   3:c:\winavr-20100110\avr\include\util\delay_basic.h ****    All rights reserved.
   4:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
   5:c:\winavr-20100110\avr\include\util\delay_basic.h ****    Redistribution and use in source and binary forms, with or without
   6:c:\winavr-20100110\avr\include\util\delay_basic.h ****    modification, are permitted provided that the following conditions are met:
   7:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
   8:c:\winavr-20100110\avr\include\util\delay_basic.h ****    * Redistributions of source code must retain the above copyright
   9:c:\winavr-20100110\avr\include\util\delay_basic.h ****      notice, this list of conditions and the following disclaimer.
  10:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  11:c:\winavr-20100110\avr\include\util\delay_basic.h ****    * Redistributions in binary form must reproduce the above copyright
  12:c:\winavr-20100110\avr\include\util\delay_basic.h ****      notice, this list of conditions and the following disclaimer in
  13:c:\winavr-20100110\avr\include\util\delay_basic.h ****      the documentation and/or other materials provided with the
  14:c:\winavr-20100110\avr\include\util\delay_basic.h ****      distribution.
  15:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  16:c:\winavr-20100110\avr\include\util\delay_basic.h ****    * Neither the name of the copyright holders nor the names of
  17:c:\winavr-20100110\avr\include\util\delay_basic.h ****      contributors may be used to endorse or promote products derived
  18:c:\winavr-20100110\avr\include\util\delay_basic.h ****      from this software without specific prior written permission.
  19:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  20:c:\winavr-20100110\avr\include\util\delay_basic.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  21:c:\winavr-20100110\avr\include\util\delay_basic.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  22:c:\winavr-20100110\avr\include\util\delay_basic.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  23:c:\winavr-20100110\avr\include\util\delay_basic.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  24:c:\winavr-20100110\avr\include\util\delay_basic.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  25:c:\winavr-20100110\avr\include\util\delay_basic.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  26:c:\winavr-20100110\avr\include\util\delay_basic.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  27:c:\winavr-20100110\avr\include\util\delay_basic.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  28:c:\winavr-20100110\avr\include\util\delay_basic.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  29:c:\winavr-20100110\avr\include\util\delay_basic.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  30:c:\winavr-20100110\avr\include\util\delay_basic.h ****   POSSIBILITY OF SUCH DAMAGE. */
  31:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  32:c:\winavr-20100110\avr\include\util\delay_basic.h **** /* $Id$ */
  33:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  34:c:\winavr-20100110\avr\include\util\delay_basic.h **** #ifndef _UTIL_DELAY_BASIC_H_
  35:c:\winavr-20100110\avr\include\util\delay_basic.h **** #define _UTIL_DELAY_BASIC_H_ 1
  36:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  37:c:\winavr-20100110\avr\include\util\delay_basic.h **** #include <inttypes.h>
  38:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  39:c:\winavr-20100110\avr\include\util\delay_basic.h **** #if !defined(__DOXYGEN__)
  40:c:\winavr-20100110\avr\include\util\delay_basic.h **** static __inline__ void _delay_loop_1(uint8_t __count) __attribute__((__always_inline__));
  41:c:\winavr-20100110\avr\include\util\delay_basic.h **** static __inline__ void _delay_loop_2(uint16_t __count) __attribute__((__always_inline__));
  42:c:\winavr-20100110\avr\include\util\delay_basic.h **** #endif
  43:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  44:c:\winavr-20100110\avr\include\util\delay_basic.h **** /** \file */
  45:c:\winavr-20100110\avr\include\util\delay_basic.h **** /** \defgroup util_delay_basic <util/delay_basic.h>: Basic busy-wait delay loops
  46:c:\winavr-20100110\avr\include\util\delay_basic.h ****     \code
  47:c:\winavr-20100110\avr\include\util\delay_basic.h ****     #include <util/delay_basic.h>
  48:c:\winavr-20100110\avr\include\util\delay_basic.h ****     \endcode
  49:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  50:c:\winavr-20100110\avr\include\util\delay_basic.h ****     The functions in this header file implement simple delay loops
  51:c:\winavr-20100110\avr\include\util\delay_basic.h ****     that perform a busy-waiting.  They are typically used to
  52:c:\winavr-20100110\avr\include\util\delay_basic.h ****     facilitate short delays in the program execution.  They are
  53:c:\winavr-20100110\avr\include\util\delay_basic.h ****     implemented as count-down loops with a well-known CPU cycle
  54:c:\winavr-20100110\avr\include\util\delay_basic.h ****     count per loop iteration.  As such, no other processing can
  55:c:\winavr-20100110\avr\include\util\delay_basic.h ****     occur simultaneously.  It should be kept in mind that the
  56:c:\winavr-20100110\avr\include\util\delay_basic.h ****     functions described here do not disable interrupts.
  57:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  58:c:\winavr-20100110\avr\include\util\delay_basic.h ****     In general, for long delays, the use of hardware timers is
  59:c:\winavr-20100110\avr\include\util\delay_basic.h ****     much preferrable, as they free the CPU, and allow for
  60:c:\winavr-20100110\avr\include\util\delay_basic.h ****     concurrent processing of other events while the timer is
  61:c:\winavr-20100110\avr\include\util\delay_basic.h ****     running.  However, in particular for very short delays, the
  62:c:\winavr-20100110\avr\include\util\delay_basic.h ****     overhead of setting up a hardware timer is too much compared
  63:c:\winavr-20100110\avr\include\util\delay_basic.h ****     to the overall delay time.
  64:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  65:c:\winavr-20100110\avr\include\util\delay_basic.h ****     Two inline functions are provided for the actual delay algorithms.
  66:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  67:c:\winavr-20100110\avr\include\util\delay_basic.h **** */
  68:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  69:c:\winavr-20100110\avr\include\util\delay_basic.h **** /** \ingroup util_delay_basic
  70:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  71:c:\winavr-20100110\avr\include\util\delay_basic.h ****     Delay loop using an 8-bit counter \c __count, so up to 256
  72:c:\winavr-20100110\avr\include\util\delay_basic.h ****     iterations are possible.  (The value 256 would have to be passed
  73:c:\winavr-20100110\avr\include\util\delay_basic.h ****     as 0.)  The loop executes three CPU cycles per iteration, not
  74:c:\winavr-20100110\avr\include\util\delay_basic.h ****     including the overhead the compiler needs to setup the counter
  75:c:\winavr-20100110\avr\include\util\delay_basic.h ****     register.
  76:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  77:c:\winavr-20100110\avr\include\util\delay_basic.h ****     Thus, at a CPU speed of 1 MHz, delays of up to 768 microseconds
  78:c:\winavr-20100110\avr\include\util\delay_basic.h ****     can be achieved.
  79:c:\winavr-20100110\avr\include\util\delay_basic.h **** */
  80:c:\winavr-20100110\avr\include\util\delay_basic.h **** void
  81:c:\winavr-20100110\avr\include\util\delay_basic.h **** _delay_loop_1(uint8_t __count)
  82:c:\winavr-20100110\avr\include\util\delay_basic.h **** {
  83:c:\winavr-20100110\avr\include\util\delay_basic.h **** 	__asm__ volatile (
  84:c:\winavr-20100110\avr\include\util\delay_basic.h **** 		"1: dec %0" "\n\t"
  85:c:\winavr-20100110\avr\include\util\delay_basic.h **** 		"brne 1b"
  86:c:\winavr-20100110\avr\include\util\delay_basic.h **** 		: "=r" (__count)
  87:c:\winavr-20100110\avr\include\util\delay_basic.h **** 		: "0" (__count)
  88:c:\winavr-20100110\avr\include\util\delay_basic.h **** 	);
  89:c:\winavr-20100110\avr\include\util\delay_basic.h **** }
  90:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  91:c:\winavr-20100110\avr\include\util\delay_basic.h **** /** \ingroup util_delay_basic
  92:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  93:c:\winavr-20100110\avr\include\util\delay_basic.h ****     Delay loop using a 16-bit counter \c __count, so up to 65536
  94:c:\winavr-20100110\avr\include\util\delay_basic.h ****     iterations are possible.  (The value 65536 would have to be
  95:c:\winavr-20100110\avr\include\util\delay_basic.h ****     passed as 0.)  The loop executes four CPU cycles per iteration,
  96:c:\winavr-20100110\avr\include\util\delay_basic.h ****     not including the overhead the compiler requires to setup the
  97:c:\winavr-20100110\avr\include\util\delay_basic.h ****     counter register pair.
  98:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  99:c:\winavr-20100110\avr\include\util\delay_basic.h ****     Thus, at a CPU speed of 1 MHz, delays of up to about 262.1
 100:c:\winavr-20100110\avr\include\util\delay_basic.h ****     milliseconds can be achieved.
 101:c:\winavr-20100110\avr\include\util\delay_basic.h ****  */
 102:c:\winavr-20100110\avr\include\util\delay_basic.h **** void
 103:c:\winavr-20100110\avr\include\util\delay_basic.h **** _delay_loop_2(uint16_t __count)
 104:c:\winavr-20100110\avr\include\util\delay_basic.h **** {
 105:c:\winavr-20100110\avr\include\util\delay_basic.h **** 	__asm__ volatile (
 3820               		.loc 4 105 0
 3821 064c 8FEF      		ldi r24,lo8(-1)
 3822 064e 9FEF      		ldi r25,lo8(-1)
 3823               	/* #APP */
 3824               	 ;  105 "c:\winavr-20100110\avr\include\util\delay_basic.h" 1
 3825 0650 0197      		1: sbiw r24,1
 3826 0652 01F4      		brne 1b
 3827               	 ;  0 "" 2
 3828               	.LVL461:
 3829               	/* #NOAPP */
 3830 0654 00C0      		rjmp .L101
 3831               	.LBE145:
 3832               	.LBE144:
 3833               	.LBE143:
 3834               		.cfi_endproc
 3835               	.LFE48:
 3837               		.comm	flashChipIdBuffer,2,1
 3838               		.comm	eepromBuffer,8,1
 3839               		.comm	receivedChar,1,1
 3840               		.comm	receivedBuffer,129,1
 3841               		.text
 3842               	.Letext0:
 3843               		.file 5 "c:\\winavr-20100110\\avr\\include\\stdint.h"
 3844               		.file 6 "c:\\winavr-20100110\\avr\\include\\stdlib.h"
DEFINED SYMBOLS
                            *ABS*:00000000 main.c
C:\Users\Alex\AppData\Local\Temp\ccqqVkb8.s:2      *ABS*:0000003e __SP_H__
C:\Users\Alex\AppData\Local\Temp\ccqqVkb8.s:3      *ABS*:0000003d __SP_L__
C:\Users\Alex\AppData\Local\Temp\ccqqVkb8.s:4      *ABS*:0000003f __SREG__
C:\Users\Alex\AppData\Local\Temp\ccqqVkb8.s:5      *ABS*:00000000 __tmp_reg__
C:\Users\Alex\AppData\Local\Temp\ccqqVkb8.s:6      *ABS*:00000001 __zero_reg__
C:\Users\Alex\AppData\Local\Temp\ccqqVkb8.s:12     .text:00000000 USART_Receive
C:\Users\Alex\AppData\Local\Temp\ccqqVkb8.s:34     .text:00000008 USART_Transmit
C:\Users\Alex\AppData\Local\Temp\ccqqVkb8.s:55     .text:00000010 usart_read_bytes
                            *COM*:00000081 receivedBuffer
C:\Users\Alex\AppData\Local\Temp\ccqqVkb8.s:118    .text:0000003a usart_read_chars
C:\Users\Alex\AppData\Local\Temp\ccqqVkb8.s:162    .text:00000056 rd_wr_csmreq_cs2_reset
C:\Users\Alex\AppData\Local\Temp\ccqqVkb8.s:184    .text:00000060 gb_mode
C:\Users\Alex\AppData\Local\Temp\ccqqVkb8.s:211    .text:00000070 set_16bit_address
C:\Users\Alex\AppData\Local\Temp\ccqqVkb8.s:230    .text:00000076 read_8bit_data
C:\Users\Alex\AppData\Local\Temp\ccqqVkb8.s:270    .text:00000088 write_8bit_data
C:\Users\Alex\AppData\Local\Temp\ccqqVkb8.s:335    .text:000000b4 gba_mode
C:\Users\Alex\AppData\Local\Temp\ccqqVkb8.s:362    .text:000000c4 gba_set_24bit_address
C:\Users\Alex\AppData\Local\Temp\ccqqVkb8.s:415    .text:000000f0 gba_read_16bit_data
C:\Users\Alex\AppData\Local\Temp\ccqqVkb8.s:463    .text:0000010e gba_read_ram_8bit_data
C:\Users\Alex\AppData\Local\Temp\ccqqVkb8.s:503    .text:00000120 gba_write_ram_8bit_data
C:\Users\Alex\AppData\Local\Temp\ccqqVkb8.s:557    .text:00000140 gba_eeprom_mode
C:\Users\Alex\AppData\Local\Temp\ccqqVkb8.s:585    .text:00000152 gba_eeprom_set_address
C:\Users\Alex\AppData\Local\Temp\ccqqVkb8.s:724    .text:000001ba gba_eeprom_read
                            *COM*:00000008 eepromBuffer
C:\Users\Alex\AppData\Local\Temp\ccqqVkb8.s:856    .text:00000214 gba_eeprom_write
C:\Users\Alex\AppData\Local\Temp\ccqqVkb8.s:972    .text:00000268 flash_write_bus_cycle
C:\Users\Alex\AppData\Local\Temp\ccqqVkb8.s:1018   .text:00000282 flash_read_chip_id
                            *COM*:00000002 flashChipIdBuffer
C:\Users\Alex\AppData\Local\Temp\ccqqVkb8.s:1123   .text:000002ec flash_switch_bank
C:\Users\Alex\AppData\Local\Temp\ccqqVkb8.s:1172   .text:00000312 flash_erase_4k_sector
C:\Users\Alex\AppData\Local\Temp\ccqqVkb8.s:1247   .text:0000035a flash_write_byte
C:\Users\Alex\AppData\Local\Temp\ccqqVkb8.s:1318   .text:00000392 flash_write_sector
C:\Users\Alex\AppData\Local\Temp\ccqqVkb8.s:1431   .text:000003fe gb_flash_read_byte
C:\Users\Alex\AppData\Local\Temp\ccqqVkb8.s:1471   .text:00000410 audio_flash_write_bus_cycle
C:\Users\Alex\AppData\Local\Temp\ccqqVkb8.s:1521   .text:0000042a audio_flash_write_byte
C:\Users\Alex\AppData\Local\Temp\ccqqVkb8.s:1621   .text:0000047c bv5_flash_write_bus_cycle
C:\Users\Alex\AppData\Local\Temp\ccqqVkb8.s:1671   .text:00000496 gb_wr_flash_byte_write_byte
C:\Users\Alex\AppData\Local\Temp\ccqqVkb8.s:1767   .text:000004e4 gb_wr_flash_write_byte
C:\Users\Alex\AppData\Local\Temp\ccqqVkb8.s:1863   .text:00000532 gb_wr_flash_write_bus_cycle
C:\Users\Alex\AppData\Local\Temp\ccqqVkb8.s:1876   .text:00000534 bv5_flash_write_byte
C:\Users\Alex\AppData\Local\Temp\ccqqVkb8.s:1973   .text:00000582 gb_word_flash_write_byte
C:\Users\Alex\AppData\Local\Temp\ccqqVkb8.s:2069   .text:000005d0 gba_flash_write_bus_cycle
C:\Users\Alex\AppData\Local\Temp\ccqqVkb8.s:2132   .text:000005f6 gba_flash_write_byte_swapped
C:\Users\Alex\AppData\Local\Temp\ccqqVkb8.s:2256   .text:0000066c setup
C:\Users\Alex\AppData\Local\Temp\ccqqVkb8.s:2351   .text.startup:00000000 main
                            *COM*:00000001 receivedChar

UNDEFINED SYMBOLS
strtol
atoi
__do_clear_bss
