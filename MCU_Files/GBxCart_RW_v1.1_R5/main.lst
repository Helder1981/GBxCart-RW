   1               		.file	"main.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               	.global	USART_Receive
  12               	USART_Receive:
  13               	.LFB12:
  14               		.file 1 "setup.c"
   1:setup.c       **** /*
   2:setup.c       ****  GBxCart RW
   3:setup.c       ****  PCB version: 1.1
   4:setup.c       ****  Firmware version: R5
   5:setup.c       ****  Author: Alex from insideGadgets (www.insidegadgets.com)
   6:setup.c       ****  Created: 7/11/2016
   7:setup.c       ****  Last Modified: 5/12/2017
   8:setup.c       ****  
   9:setup.c       ****  */
  10:setup.c       ****  
  11:setup.c       **** #ifndef cbi
  12:setup.c       **** #define cbi(sfr, bit) (_SFR_BYTE(sfr) &= ~_BV(bit))
  13:setup.c       **** #endif
  14:setup.c       **** #ifndef sbi
  15:setup.c       **** #define sbi(sfr, bit) (_SFR_BYTE(sfr) |= _BV(bit))
  16:setup.c       **** #endif
  17:setup.c       **** 
  18:setup.c       **** #ifndef NULL
  19:setup.c       **** #define NULL ((void *)0)
  20:setup.c       **** #endif
  21:setup.c       **** 
  22:setup.c       **** #define LOW 0
  23:setup.c       **** #define HIGH 1
  24:setup.c       **** #define false 0
  25:setup.c       **** #define true 1
  26:setup.c       **** 
  27:setup.c       **** #define SWITCH_DETECT PD2
  28:setup.c       **** #define ACTIVITY_LED PD3
  29:setup.c       **** #define LED_5V PD7
  30:setup.c       **** #define LED_3V PE0
  31:setup.c       **** 
  32:setup.c       **** #define WR_PIN PD6
  33:setup.c       **** #define RD_PIN PD5
  34:setup.c       **** #define CS_MREQ_PIN PD4
  35:setup.c       **** #define CS2_PIN PE2
  36:setup.c       **** #define AUDIO_PIN PE1
  37:setup.c       **** 
  38:setup.c       **** #define wrPin_high	PORTD |= (1<<WR_PIN);
  39:setup.c       **** #define wrPin_low		PORTD &= ~(1<<WR_PIN);
  40:setup.c       **** #define rdPin_high	PORTD |= (1<<RD_PIN);
  41:setup.c       **** #define rdPin_low		PORTD &= ~(1<<RD_PIN);
  42:setup.c       **** #define cs_mreqPin_high		PORTD |= (1<<CS_MREQ_PIN);
  43:setup.c       **** #define cs_mreqPin_low		PORTD &= ~(1<<CS_MREQ_PIN);
  44:setup.c       **** #define cs2Pin_high		PORTE |= (1<<CS2_PIN);
  45:setup.c       **** #define cs2Pin_low		PORTE &= ~(1<<CS2_PIN);
  46:setup.c       **** #define audioPin_high		PORTE |= (1<<AUDIO_PIN);
  47:setup.c       **** #define audioPin_low		PORTE &= ~(1<<AUDIO_PIN);
  48:setup.c       **** 
  49:setup.c       **** #define GB_MODE 1
  50:setup.c       **** #define GBA_MODE 2
  51:setup.c       **** 
  52:setup.c       **** // GB/GBC
  53:setup.c       **** #define PORT_ADDR7_0 PORTB
  54:setup.c       **** #define PORT_ADDR15_8 PORTA
  55:setup.c       **** #define PORT_DATA7_0 PORTC
  56:setup.c       **** 
  57:setup.c       **** #define DDR_ADDR7_0 DDRB
  58:setup.c       **** #define DDR_ADDR15_8 DDRA
  59:setup.c       **** #define DDR_DATA7_0 DDRC
  60:setup.c       **** 
  61:setup.c       **** #define PIN_ADDR7_0 PINB
  62:setup.c       **** #define PIN_ADDR15_8 PINA
  63:setup.c       **** #define PIN_DATA7_0 PINC
  64:setup.c       **** 
  65:setup.c       **** #define BANK_WRITE 0
  66:setup.c       **** #define MEMORY_WRITE 1
  67:setup.c       **** 
  68:setup.c       **** // GBA
  69:setup.c       **** #define EEPROM_WRITE 1
  70:setup.c       **** #define EEPROM_READ 0
  71:setup.c       **** 
  72:setup.c       **** #define EEPROM_NONE 0
  73:setup.c       **** #define EEPROM_4KBIT 1
  74:setup.c       **** #define EEPROM_64KBIT 2
  75:setup.c       **** 
  76:setup.c       **** #define AD0 PB0
  77:setup.c       **** #define ad0Pin_high		PORTB |= (1<<AD0);
  78:setup.c       **** #define ad0Pin_low		PORTB &= ~(1<<AD0);
  79:setup.c       **** 
  80:setup.c       **** #define A23 PC7
  81:setup.c       **** #define a23Pin_high		PORTC |= (1<<A23);
  82:setup.c       **** #define a23Pin_low		PORTC &= ~(1<<A23);
  83:setup.c       **** 
  84:setup.c       **** #define GBA_DDR_ROM_ADDR7_0 DDRB
  85:setup.c       **** #define GBA_DDR_ROM_ADDR15_8 DDRA
  86:setup.c       **** #define GBA_DDR_ROM_ADDR23_16 DDRC
  87:setup.c       **** #define GBA_DDR_ROM_DATA7_0 DDRB
  88:setup.c       **** #define GBA_DDR_ROM_DATA15_8 DDRA
  89:setup.c       **** #define GBA_DDR_RAM_DATA7_0 DDRC
  90:setup.c       **** #define GBA_DDR_EEPROM_DATA7_0 DDRB
  91:setup.c       **** 
  92:setup.c       **** #define GBA_PORT_ROM_ADDR7_0 PORTB
  93:setup.c       **** #define GBA_PORT_ROM_ADDR15_8 PORTA
  94:setup.c       **** #define GBA_PORT_ROM_ADDR23_16 PORTC
  95:setup.c       **** #define GBA_PORT_ROM_DATA7_0 PORTB
  96:setup.c       **** #define GBA_PORT_ROM_DATA15_8 PORTA
  97:setup.c       **** #define GBA_PORT_RAM_DATA7_0 PORTC
  98:setup.c       **** #define GBA_PORT_EEPROM_DATA7_0 PORTB
  99:setup.c       **** 
 100:setup.c       **** #define GBA_PIN_ROM_DATA7_0 PINB
 101:setup.c       **** #define GBA_PIN_ROM_DATA15_8 PINA
 102:setup.c       **** #define GBA_PIN_RAM_DATA7_0 PINC
 103:setup.c       **** #define GBA_PIN_EEPROM_DATA7_0 PINB
 104:setup.c       **** 
 105:setup.c       **** // GB/GBC commands
 106:setup.c       **** #define SET_START_ADDRESS 'A'
 107:setup.c       **** #define READ_ROM_RAM 'R'
 108:setup.c       **** #define WRITE_RAM 'W'
 109:setup.c       **** #define SET_BANK 'B'
 110:setup.c       **** #define GB_CART_MODE 'G'
 111:setup.c       **** 
 112:setup.c       **** // GBA commands
 113:setup.c       **** #define GBA_READ_ROM 'r'
 114:setup.c       **** #define GBA_READ_SRAM 'm'
 115:setup.c       **** #define GBA_WRITE_SRAM 'w'
 116:setup.c       **** #define GBA_WRITE_ONE_BYTE_SRAM 'o'
 117:setup.c       **** #define GBA_CART_MODE 'g'
 118:setup.c       **** 
 119:setup.c       **** #define GBA_FLASH_READ_ID 'i'
 120:setup.c       **** #define GBA_FLASH_SET_BANK 'k'
 121:setup.c       **** #define GBA_FLASH_4K_SECTOR_ERASE 's'
 122:setup.c       **** #define GBA_FLASH_WRITE_BYTE 'b'
 123:setup.c       **** #define GBA_FLASH_WRITE_ATMEL 'a'
 124:setup.c       **** 
 125:setup.c       **** #define GBA_SET_EEPROM_SIZE 'S'
 126:setup.c       **** #define GBA_READ_EEPROM 'e'
 127:setup.c       **** #define GBA_WRITE_EEPROM 'p'
 128:setup.c       **** 
 129:setup.c       **** // Flash Cart commands
 130:setup.c       **** #define GB_FLASH_WRITE_BYTE 'F'
 131:setup.c       **** #define GB_FLASH_WRITE_64BYTE 'T'
 132:setup.c       **** #define GB_AUDIO_FLASH_WRITE 'U'
 133:setup.c       **** #define GB_BV5_FLASH_WRITE '5'
 134:setup.c       **** 
 135:setup.c       **** #define GBA_FLASH_CART_WRITE_BYTE 'n'
 136:setup.c       **** #define GBA_FLASH_WRITE_64BYTE 'q'
 137:setup.c       **** 
 138:setup.c       **** // General commands
 139:setup.c       **** #define CART_MODE 'C'
 140:setup.c       **** #define SET_INPUT 'I'
 141:setup.c       **** #define SET_OUTPUT 'O'
 142:setup.c       **** #define SET_OUTPUT_LOW 'L'
 143:setup.c       **** #define SET_OUTPUT_HIGH 'H'
 144:setup.c       **** #define READ_INPUT 'D'
 145:setup.c       **** #define RESET_COMMON_LINES 'M'
 146:setup.c       **** #define READ_FIRMWARE_VERSION 'V'
 147:setup.c       **** #define READ_PCB_VERSION 'h'
 148:setup.c       **** 
 149:setup.c       **** #define RESET_AVR '*'
 150:setup.c       **** #define RESET_VALUE 0x7E5E1
 151:setup.c       **** 
 152:setup.c       **** 
 153:setup.c       **** char receivedBuffer[129];
 154:setup.c       **** char receivedChar;
 155:setup.c       **** uint8_t eepromBuffer[8];
 156:setup.c       **** uint8_t flashChipIdBuffer[2];
 157:setup.c       **** 
 158:setup.c       **** // Receive USART data
 159:setup.c       **** uint8_t USART_Receive(void) {
  15               		.loc 1 159 0
  16               		.cfi_startproc
  17               	/* prologue: function */
  18               	/* frame size = 0 */
  19               	/* stack size = 0 */
  20               	.L__stack_usage = 0
  21               	.L2:
 160:setup.c       **** 	while ( !(UCSRA & (1<<RXC)) ); // Wait for data to be received
  22               		.loc 1 160 0 discriminator 1
  23 0000 5F9B      		sbis 0xb,7
  24 0002 00C0      		rjmp .L2
 161:setup.c       **** 	return UDR; // Get and return received data from buffer
  25               		.loc 1 161 0
  26 0004 8CB1      		in r24,0xc
 162:setup.c       **** }
  27               		.loc 1 162 0
  28 0006 0895      		ret
  29               		.cfi_endproc
  30               	.LFE12:
  32               	.global	USART_Transmit
  34               	USART_Transmit:
  35               	.LFB13:
 163:setup.c       **** 
 164:setup.c       **** // Transmit USART data
 165:setup.c       **** void USART_Transmit(unsigned char data) {
  36               		.loc 1 165 0
  37               		.cfi_startproc
  38               	/* prologue: function */
  39               	/* frame size = 0 */
  40               	/* stack size = 0 */
  41               	.L__stack_usage = 0
  42               	.LVL0:
  43               	.L6:
 166:setup.c       **** 	while ( !( UCSRA & (1<<UDRE)) ); // Wait for empty transmit buffer
  44               		.loc 1 166 0 discriminator 1
  45 0008 5D9B      		sbis 0xb,5
  46 000a 00C0      		rjmp .L6
 167:setup.c       **** 	UDR = data;
  47               		.loc 1 167 0
  48 000c 8CB9      		out 0xc,r24
  49 000e 0895      		ret
  50               		.cfi_endproc
  51               	.LFE13:
  53               	.global	usart_read_bytes
  55               	usart_read_bytes:
  56               	.LFB14:
 168:setup.c       **** }
 169:setup.c       **** 
 170:setup.c       **** // Read 1-128 bytes from the USART 
 171:setup.c       **** void usart_read_bytes(uint8_t count) {
  57               		.loc 1 171 0
  58               		.cfi_startproc
  59               	.LVL1:
  60 0010 0F93      		push r16
  61               	.LCFI0:
  62               		.cfi_def_cfa_offset 3
  63               		.cfi_offset 16, -2
  64 0012 1F93      		push r17
  65               	.LCFI1:
  66               		.cfi_def_cfa_offset 4
  67               		.cfi_offset 17, -3
  68 0014 CF93      		push r28
  69               	.LCFI2:
  70               		.cfi_def_cfa_offset 5
  71               		.cfi_offset 28, -4
  72 0016 DF93      		push r29
  73               	.LCFI3:
  74               		.cfi_def_cfa_offset 6
  75               		.cfi_offset 29, -5
  76               	/* prologue: function */
  77               	/* frame size = 0 */
  78               	/* stack size = 4 */
  79               	.L__stack_usage = 4
  80 0018 D82F      		mov r29,r24
  81               	.LVL2:
  82 001a 00E0      		ldi r16,lo8(receivedBuffer)
  83 001c 10E0      		ldi r17,hi8(receivedBuffer)
  84               	.LBB52:
 172:setup.c       **** 	for (uint8_t x = 0; x < count; x++) {
  85               		.loc 1 172 0
  86 001e C0E0      		ldi r28,0
  87               	.LVL3:
  88               	.L10:
  89               		.loc 1 172 0 is_stmt 0 discriminator 1
  90 0020 CD17      		cp r28,r29
  91 0022 01F0      		breq .L12
 173:setup.c       **** 		receivedBuffer[x] = USART_Receive();
  92               		.loc 1 173 0 is_stmt 1 discriminator 3
  93 0024 00D0      		rcall USART_Receive
  94               	.LVL4:
  95 0026 F801      		movw r30,r16
  96 0028 8193      		st Z+,r24
  97 002a 8F01      		movw r16,r30
 172:setup.c       **** 	for (uint8_t x = 0; x < count; x++) {
  98               		.loc 1 172 0 discriminator 3
  99 002c CF5F      		subi r28,lo8(-(1))
 100               	.LVL5:
 101 002e 00C0      		rjmp .L10
 102               	.L12:
 103               	/* epilogue start */
 104               	.LBE52:
 174:setup.c       **** 	}
 175:setup.c       **** }
 105               		.loc 1 175 0
 106 0030 DF91      		pop r29
 107               	.LVL6:
 108 0032 CF91      		pop r28
 109               	.LVL7:
 110 0034 1F91      		pop r17
 111 0036 0F91      		pop r16
 112 0038 0895      		ret
 113               		.cfi_endproc
 114               	.LFE14:
 116               	.global	usart_read_chars
 118               	usart_read_chars:
 119               	.LFB15:
 176:setup.c       **** 
 177:setup.c       **** // Read the USART until a 0 (string terminator byte) is received
 178:setup.c       **** void usart_read_chars(void) {
 120               		.loc 1 178 0
 121               		.cfi_startproc
 122 003a CF93      		push r28
 123               	.LCFI4:
 124               		.cfi_def_cfa_offset 3
 125               		.cfi_offset 28, -2
 126               	/* prologue: function */
 127               	/* frame size = 0 */
 128               	/* stack size = 1 */
 129               	.L__stack_usage = 1
 130               	.LVL8:
 179:setup.c       **** 	uint8_t x = 0;
 131               		.loc 1 179 0
 132 003c C0E0      		ldi r28,0
 133               	.LVL9:
 134               	.L15:
 180:setup.c       **** 	while (1) {
 181:setup.c       **** 		receivedBuffer[x] = USART_Receive();
 135               		.loc 1 181 0
 136 003e 00D0      		rcall USART_Receive
 137               	.LVL10:
 138 0040 EC2F      		mov r30,r28
 139 0042 F0E0      		ldi r31,0
 140 0044 E050      		subi r30,lo8(-(receivedBuffer))
 141 0046 F040      		sbci r31,hi8(-(receivedBuffer))
 142 0048 8083      		st Z,r24
 182:setup.c       **** 		if (receivedBuffer[x] == 0) {
 143               		.loc 1 182 0
 144 004a 8823      		tst r24
 145 004c 01F0      		breq .L13
 183:setup.c       **** 			break;
 184:setup.c       **** 		}
 185:setup.c       **** 		x++;
 146               		.loc 1 185 0
 147 004e CF5F      		subi r28,lo8(-(1))
 148               	.LVL11:
 186:setup.c       **** 	}
 149               		.loc 1 186 0
 150 0050 00C0      		rjmp .L15
 151               	.L13:
 152               	/* epilogue start */
 187:setup.c       **** }
 153               		.loc 1 187 0
 154 0052 CF91      		pop r28
 155               	.LVL12:
 156 0054 0895      		ret
 157               		.cfi_endproc
 158               	.LFE15:
 160               	.global	rd_wr_csmreq_cs2_reset
 162               	rd_wr_csmreq_cs2_reset:
 163               	.LFB16:
 188:setup.c       **** 
 189:setup.c       **** // Turn RD, WR, CS/MREQ and CS2 to high so they are deselected (reset state)
 190:setup.c       **** void rd_wr_csmreq_cs2_reset(void) {
 164               		.loc 1 190 0
 165               		.cfi_startproc
 166               	/* prologue: function */
 167               	/* frame size = 0 */
 168               	/* stack size = 0 */
 169               	.L__stack_usage = 0
 191:setup.c       **** 	cs2Pin_high; // CS2 off
 170               		.loc 1 191 0
 171 0056 3A9A      		sbi 0x7,2
 192:setup.c       **** 	cs_mreqPin_high; // CS/MREQ off
 172               		.loc 1 192 0
 173 0058 949A      		sbi 0x12,4
 193:setup.c       **** 	rdPin_high; // RD off
 174               		.loc 1 193 0
 175 005a 959A      		sbi 0x12,5
 194:setup.c       **** 	wrPin_high; // WR off
 176               		.loc 1 194 0
 177 005c 969A      		sbi 0x12,6
 178 005e 0895      		ret
 179               		.cfi_endproc
 180               	.LFE16:
 182               	.global	gb_mode
 184               	gb_mode:
 185               	.LFB17:
 195:setup.c       **** }
 196:setup.c       **** 
 197:setup.c       **** 
 198:setup.c       **** 
 199:setup.c       **** // ****** Gameboy / Gameboy Colour functions ******
 200:setup.c       **** 
 201:setup.c       **** // Set Gameboy mode
 202:setup.c       **** void gb_mode(void) {
 186               		.loc 1 202 0
 187               		.cfi_startproc
 188               	/* prologue: function */
 189               	/* frame size = 0 */
 190               	/* stack size = 0 */
 191               	.L__stack_usage = 0
 203:setup.c       **** 	// Set inputs
 204:setup.c       **** 	PORT_DATA7_0 = 0;
 192               		.loc 1 204 0
 193 0060 15BA      		out 0x15,__zero_reg__
 205:setup.c       **** 	DDR_DATA7_0 = 0;
 194               		.loc 1 205 0
 195 0062 14BA      		out 0x14,__zero_reg__
 206:setup.c       **** 	
 207:setup.c       **** 	// Set outputs
 208:setup.c       **** 	PORT_ADDR7_0 = 0;
 196               		.loc 1 208 0
 197 0064 18BA      		out 0x18,__zero_reg__
 209:setup.c       **** 	PORT_ADDR15_8 = 0;
 198               		.loc 1 209 0
 199 0066 1BBA      		out 0x1b,__zero_reg__
 210:setup.c       **** 	DDR_ADDR7_0 = 0xFF;
 200               		.loc 1 210 0
 201 0068 8FEF      		ldi r24,lo8(-1)
 202 006a 87BB      		out 0x17,r24
 211:setup.c       **** 	DDR_ADDR15_8 = 0xFF;
 203               		.loc 1 211 0
 204 006c 8ABB      		out 0x1a,r24
 205 006e 0895      		ret
 206               		.cfi_endproc
 207               	.LFE17:
 209               	.global	set_16bit_address
 211               	set_16bit_address:
 212               	.LFB18:
 212:setup.c       **** }
 213:setup.c       **** 
 214:setup.c       **** // Set the 16 bit address on A15-0
 215:setup.c       **** void set_16bit_address(uint16_t address) {
 213               		.loc 1 215 0
 214               		.cfi_startproc
 215               	.LVL13:
 216               	/* prologue: function */
 217               	/* frame size = 0 */
 218               	/* stack size = 0 */
 219               	.L__stack_usage = 0
 216:setup.c       **** 	PORT_ADDR15_8 = (address >> 8);
 220               		.loc 1 216 0
 221 0070 9BBB      		out 0x1b,r25
 217:setup.c       **** 	PORT_ADDR7_0 = (address & 0xFF);
 222               		.loc 1 217 0
 223 0072 88BB      		out 0x18,r24
 224 0074 0895      		ret
 225               		.cfi_endproc
 226               	.LFE18:
 228               	.global	read_8bit_data
 230               	read_8bit_data:
 231               	.LFB19:
 218:setup.c       **** }
 219:setup.c       **** 
 220:setup.c       **** // Set the address and read a byte from the 8 bit data line
 221:setup.c       **** uint8_t read_8bit_data(uint16_t address) {
 232               		.loc 1 221 0
 233               		.cfi_startproc
 234               	.LVL14:
 235               	/* prologue: function */
 236               	/* frame size = 0 */
 237               	/* stack size = 0 */
 238               	.L__stack_usage = 0
 222:setup.c       **** 	set_16bit_address(address);
 239               		.loc 1 222 0
 240 0076 00D0      		rcall set_16bit_address
 241               	.LVL15:
 223:setup.c       **** 	
 224:setup.c       **** 	cs_mreqPin_low;
 242               		.loc 1 224 0
 243 0078 9498      		cbi 0x12,4
 225:setup.c       **** 	rdPin_low;
 244               		.loc 1 225 0
 245 007a 9598      		cbi 0x12,5
 226:setup.c       **** 	
 227:setup.c       **** 	asm volatile("nop"); // Delay a little (minimum needed is 1 nops, 2 nops for GB camera)
 246               		.loc 1 227 0
 247               	/* #APP */
 248               	 ;  227 "setup.c" 1
 249 007c 0000      		nop
 250               	 ;  0 "" 2
 228:setup.c       **** 	asm volatile("nop");
 251               		.loc 1 228 0
 252               	 ;  228 "setup.c" 1
 253 007e 0000      		nop
 254               	 ;  0 "" 2
 229:setup.c       **** 	uint8_t data = PIN_DATA7_0; // Read data
 255               		.loc 1 229 0
 256               	/* #NOAPP */
 257 0080 83B3      		in r24,0x13
 258               	.LVL16:
 230:setup.c       **** 	
 231:setup.c       **** 	rdPin_high;
 259               		.loc 1 231 0
 260 0082 959A      		sbi 0x12,5
 232:setup.c       **** 	cs_mreqPin_high;
 261               		.loc 1 232 0
 262 0084 949A      		sbi 0x12,4
 233:setup.c       **** 	
 234:setup.c       **** 	return data;
 235:setup.c       **** }
 263               		.loc 1 235 0
 264 0086 0895      		ret
 265               		.cfi_endproc
 266               	.LFE19:
 268               	.global	write_8bit_data
 270               	write_8bit_data:
 271               	.LFB20:
 236:setup.c       **** 
 237:setup.c       **** // Set the address and write a byte to the 8 bit data line and pulse cs/mREQ if writing to RAM
 238:setup.c       **** void write_8bit_data(uint16_t address, uint8_t data, uint8_t type) {
 272               		.loc 1 238 0
 273               		.cfi_startproc
 274               	.LVL17:
 275 0088 CF93      		push r28
 276               	.LCFI5:
 277               		.cfi_def_cfa_offset 3
 278               		.cfi_offset 28, -2
 279 008a DF93      		push r29
 280               	.LCFI6:
 281               		.cfi_def_cfa_offset 4
 282               		.cfi_offset 29, -3
 283               	/* prologue: function */
 284               	/* frame size = 0 */
 285               	/* stack size = 2 */
 286               	.L__stack_usage = 2
 287 008c D62F      		mov r29,r22
 288 008e C42F      		mov r28,r20
 239:setup.c       **** 	set_16bit_address(address);
 289               		.loc 1 239 0
 290 0090 00D0      		rcall set_16bit_address
 291               	.LVL18:
 240:setup.c       **** 	
 241:setup.c       **** 	DDR_DATA7_0 = 0xFF; // Set data pins as outputs
 292               		.loc 1 241 0
 293 0092 8FEF      		ldi r24,lo8(-1)
 294 0094 84BB      		out 0x14,r24
 242:setup.c       **** 	PORT_DATA7_0 = data; // Set data
 295               		.loc 1 242 0
 296 0096 D5BB      		out 0x15,r29
 243:setup.c       **** 	
 244:setup.c       **** 	// Pulse WR and mREQ if the type matches
 245:setup.c       **** 	wrPin_low;
 297               		.loc 1 245 0
 298 0098 9698      		cbi 0x12,6
 246:setup.c       **** 	if (type == MEMORY_WRITE) {
 299               		.loc 1 246 0
 300 009a C130      		cpi r28,lo8(1)
 301 009c 01F4      		brne .L21
 247:setup.c       **** 		cs_mreqPin_low;
 302               		.loc 1 247 0
 303 009e 9498      		cbi 0x12,4
 304               	.L21:
 248:setup.c       **** 	}
 249:setup.c       **** 	
 250:setup.c       **** 	asm volatile("nop");
 305               		.loc 1 250 0
 306               	/* #APP */
 307               	 ;  250 "setup.c" 1
 308 00a0 0000      		nop
 309               	 ;  0 "" 2
 251:setup.c       **** 	
 252:setup.c       **** 	if (type == MEMORY_WRITE) {
 310               		.loc 1 252 0
 311               	/* #NOAPP */
 312 00a2 C130      		cpi r28,lo8(1)
 313 00a4 01F4      		brne .L22
 253:setup.c       **** 		cs_mreqPin_high;
 314               		.loc 1 253 0
 315 00a6 949A      		sbi 0x12,4
 316               	.L22:
 254:setup.c       **** 	}
 255:setup.c       **** 	wrPin_high;
 317               		.loc 1 255 0
 318 00a8 969A      		sbi 0x12,6
 256:setup.c       **** 	
 257:setup.c       **** 	// Clear data outputs and set data pins as inputs
 258:setup.c       **** 	PORT_DATA7_0 = 0;
 319               		.loc 1 258 0
 320 00aa 15BA      		out 0x15,__zero_reg__
 259:setup.c       **** 	DDR_DATA7_0 = 0;
 321               		.loc 1 259 0
 322 00ac 14BA      		out 0x14,__zero_reg__
 323               	/* epilogue start */
 260:setup.c       **** }
 324               		.loc 1 260 0
 325 00ae DF91      		pop r29
 326               	.LVL19:
 327 00b0 CF91      		pop r28
 328               	.LVL20:
 329 00b2 0895      		ret
 330               		.cfi_endproc
 331               	.LFE20:
 333               	.global	gba_mode
 335               	gba_mode:
 336               	.LFB21:
 261:setup.c       **** 
 262:setup.c       **** 
 263:setup.c       **** 
 264:setup.c       **** // ****** Gameboy Advance functions ****** 
 265:setup.c       **** 
 266:setup.c       **** // Set GBA mode
 267:setup.c       **** void gba_mode(void) {
 337               		.loc 1 267 0
 338               		.cfi_startproc
 339               	/* prologue: function */
 340               	/* frame size = 0 */
 341               	/* stack size = 0 */
 342               	.L__stack_usage = 0
 268:setup.c       **** 	// Set outputs for reading ROM addresses as default
 269:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = 0;
 343               		.loc 1 269 0
 344 00b4 18BA      		out 0x18,__zero_reg__
 270:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = 0;
 345               		.loc 1 270 0
 346 00b6 1BBA      		out 0x1b,__zero_reg__
 271:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = 0;
 347               		.loc 1 271 0
 348 00b8 15BA      		out 0x15,__zero_reg__
 272:setup.c       **** 	GBA_DDR_ROM_ADDR7_0 = 0xFF;
 349               		.loc 1 272 0
 350 00ba 8FEF      		ldi r24,lo8(-1)
 351 00bc 87BB      		out 0x17,r24
 273:setup.c       **** 	GBA_DDR_ROM_ADDR15_8 = 0xFF;
 352               		.loc 1 273 0
 353 00be 8ABB      		out 0x1a,r24
 274:setup.c       **** 	GBA_DDR_ROM_ADDR23_16 = 0xFF;
 354               		.loc 1 274 0
 355 00c0 84BB      		out 0x14,r24
 356 00c2 0895      		ret
 357               		.cfi_endproc
 358               	.LFE21:
 360               	.global	gba_set_24bit_address
 362               	gba_set_24bit_address:
 363               	.LFB22:
 275:setup.c       **** }
 276:setup.c       **** 
 277:setup.c       **** // Set the 24 bit address on A23-0
 278:setup.c       **** void gba_set_24bit_address(uint32_t address) {	
 364               		.loc 1 278 0
 365               		.cfi_startproc
 366               	.LVL21:
 367 00c4 0F93      		push r16
 368               	.LCFI7:
 369               		.cfi_def_cfa_offset 3
 370               		.cfi_offset 16, -2
 371 00c6 1F93      		push r17
 372               	.LCFI8:
 373               		.cfi_def_cfa_offset 4
 374               		.cfi_offset 17, -3
 375               	/* prologue: function */
 376               	/* frame size = 0 */
 377               	/* stack size = 2 */
 378               	.L__stack_usage = 2
 279:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = 0; // Set 0-23 address lines low and set as outputs
 379               		.loc 1 279 0
 380 00c8 15BA      		out 0x15,__zero_reg__
 280:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = 0;
 381               		.loc 1 280 0
 382 00ca 1BBA      		out 0x1b,__zero_reg__
 281:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = 0;
 383               		.loc 1 281 0
 384 00cc 18BA      		out 0x18,__zero_reg__
 282:setup.c       **** 	GBA_DDR_ROM_ADDR23_16 = 0xFF;
 385               		.loc 1 282 0
 386 00ce 2FEF      		ldi r18,lo8(-1)
 387 00d0 24BB      		out 0x14,r18
 283:setup.c       **** 	GBA_DDR_ROM_ADDR15_8 = 0xFF;
 388               		.loc 1 283 0
 389 00d2 2ABB      		out 0x1a,r18
 284:setup.c       **** 	GBA_DDR_ROM_ADDR7_0 = 0xFF;
 390               		.loc 1 284 0
 391 00d4 27BB      		out 0x17,r18
 285:setup.c       **** 	
 286:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = (address >> 16);
 392               		.loc 1 286 0
 393 00d6 8C01      		movw r16,r24
 394 00d8 2227      		clr r18
 395 00da 3327      		clr r19
 396 00dc 05BB      		out 0x15,r16
 287:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = (address >> 8);
 397               		.loc 1 287 0
 398 00de 072F      		mov r16,r23
 399 00e0 182F      		mov r17,r24
 400 00e2 292F      		mov r18,r25
 401 00e4 3327      		clr r19
 402 00e6 0BBB      		out 0x1b,r16
 288:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = (address & 0xFF);
 403               		.loc 1 288 0
 404 00e8 68BB      		out 0x18,r22
 405               	/* epilogue start */
 289:setup.c       **** }
 406               		.loc 1 289 0
 407 00ea 1F91      		pop r17
 408 00ec 0F91      		pop r16
 409 00ee 0895      		ret
 410               		.cfi_endproc
 411               	.LFE22:
 413               	.global	gba_read_16bit_data
 415               	gba_read_16bit_data:
 416               	.LFB23:
 290:setup.c       **** 
 291:setup.c       **** 
 292:setup.c       **** 
 293:setup.c       **** // ---------- ROM/SRAM ----------
 294:setup.c       **** 
 295:setup.c       **** // Read a byte from the 16 bit data line non-sequentially
 296:setup.c       **** uint16_t gba_read_16bit_data(uint32_t address) {
 417               		.loc 1 296 0
 418               		.cfi_startproc
 419               	.LVL22:
 420               	/* prologue: function */
 421               	/* frame size = 0 */
 422               	/* stack size = 0 */
 423               	.L__stack_usage = 0
 297:setup.c       **** 	gba_set_24bit_address(address);
 424               		.loc 1 297 0
 425 00f0 00D0      		rcall gba_set_24bit_address
 426               	.LVL23:
 298:setup.c       **** 	
 299:setup.c       **** 	cs_mreqPin_low;
 427               		.loc 1 299 0
 428 00f2 9498      		cbi 0x12,4
 300:setup.c       **** 	
 301:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = 0; // Set address lines low and set as inputs
 429               		.loc 1 301 0
 430 00f4 1BBA      		out 0x1b,__zero_reg__
 302:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = 0;
 431               		.loc 1 302 0
 432 00f6 18BA      		out 0x18,__zero_reg__
 303:setup.c       **** 	GBA_DDR_ROM_ADDR15_8 = 0;
 433               		.loc 1 303 0
 434 00f8 1ABA      		out 0x1a,__zero_reg__
 304:setup.c       **** 	GBA_DDR_ROM_ADDR7_0 = 0;
 435               		.loc 1 304 0
 436 00fa 17BA      		out 0x17,__zero_reg__
 305:setup.c       **** 	
 306:setup.c       **** 	rdPin_low;
 437               		.loc 1 306 0
 438 00fc 9598      		cbi 0x12,5
 307:setup.c       **** 	asm volatile("nop");
 439               		.loc 1 307 0
 440               	/* #APP */
 441               	 ;  307 "setup.c" 1
 442 00fe 0000      		nop
 443               	 ;  0 "" 2
 308:setup.c       **** 	
 309:setup.c       **** 	uint16_t data = (GBA_PIN_ROM_DATA15_8 << 8) | GBA_PIN_ROM_DATA7_0; // Read data
 444               		.loc 1 309 0
 445               	/* #NOAPP */
 446 0100 29B3      		in r18,0x19
 447 0102 86B3      		in r24,0x16
 448               	.LVL24:
 310:setup.c       **** 	
 311:setup.c       **** 	rdPin_high;
 449               		.loc 1 311 0
 450 0104 959A      		sbi 0x12,5
 312:setup.c       **** 	cs_mreqPin_high;
 451               		.loc 1 312 0
 452 0106 949A      		sbi 0x12,4
 313:setup.c       **** 	
 314:setup.c       **** 	return data;
 453               		.loc 1 314 0
 454 0108 90E0      		ldi r25,0
 315:setup.c       **** }
 455               		.loc 1 315 0
 456 010a 922B      		or r25,r18
 457 010c 0895      		ret
 458               		.cfi_endproc
 459               	.LFE23:
 461               	.global	gba_read_ram_8bit_data
 463               	gba_read_ram_8bit_data:
 464               	.LFB24:
 316:setup.c       **** 
 317:setup.c       **** // Set the address and read a byte from the 8 bit data line
 318:setup.c       **** uint8_t gba_read_ram_8bit_data(uint16_t address) {
 465               		.loc 1 318 0
 466               		.cfi_startproc
 467               	.LVL25:
 468               	/* prologue: function */
 469               	/* frame size = 0 */
 470               	/* stack size = 0 */
 471               	.L__stack_usage = 0
 319:setup.c       **** 	set_16bit_address(address);
 472               		.loc 1 319 0
 473 010e 00D0      		rcall set_16bit_address
 474               	.LVL26:
 320:setup.c       **** 	
 321:setup.c       **** 	rdPin_low;
 475               		.loc 1 321 0
 476 0110 9598      		cbi 0x12,5
 322:setup.c       **** 	cs2Pin_low; // CS2 pin low for SRAM/Flash select
 477               		.loc 1 322 0
 478 0112 3A98      		cbi 0x7,2
 323:setup.c       **** 	
 324:setup.c       **** 	asm volatile("nop"); // Delay a little (minimum needed is 2)
 479               		.loc 1 324 0
 480               	/* #APP */
 481               	 ;  324 "setup.c" 1
 482 0114 0000      		nop
 483               	 ;  0 "" 2
 325:setup.c       **** 	asm volatile("nop");
 484               		.loc 1 325 0
 485               	 ;  325 "setup.c" 1
 486 0116 0000      		nop
 487               	 ;  0 "" 2
 326:setup.c       **** 	
 327:setup.c       **** 	uint8_t data = GBA_PIN_RAM_DATA7_0; // Read data
 488               		.loc 1 327 0
 489               	/* #NOAPP */
 490 0118 83B3      		in r24,0x13
 491               	.LVL27:
 328:setup.c       **** 	
 329:setup.c       **** 	cs2Pin_high;
 492               		.loc 1 329 0
 493 011a 3A9A      		sbi 0x7,2
 330:setup.c       **** 	rdPin_high;
 494               		.loc 1 330 0
 495 011c 959A      		sbi 0x12,5
 331:setup.c       **** 	
 332:setup.c       **** 	return data;
 333:setup.c       **** }
 496               		.loc 1 333 0
 497 011e 0895      		ret
 498               		.cfi_endproc
 499               	.LFE24:
 501               	.global	gba_write_ram_8bit_data
 503               	gba_write_ram_8bit_data:
 504               	.LFB25:
 334:setup.c       **** 
 335:setup.c       **** // Set the address and write a byte to the 8 bit data line 
 336:setup.c       **** void gba_write_ram_8bit_data(uint16_t address, uint8_t data) {
 505               		.loc 1 336 0
 506               		.cfi_startproc
 507               	.LVL28:
 508 0120 CF93      		push r28
 509               	.LCFI9:
 510               		.cfi_def_cfa_offset 3
 511               		.cfi_offset 28, -2
 512               	/* prologue: function */
 513               	/* frame size = 0 */
 514               	/* stack size = 1 */
 515               	.L__stack_usage = 1
 516 0122 C62F      		mov r28,r22
 337:setup.c       **** 	set_16bit_address(address);
 517               		.loc 1 337 0
 518 0124 00D0      		rcall set_16bit_address
 519               	.LVL29:
 338:setup.c       **** 	
 339:setup.c       **** 	GBA_DDR_RAM_DATA7_0 = 0xFF; // Set data pins as outputs
 520               		.loc 1 339 0
 521 0126 8FEF      		ldi r24,lo8(-1)
 522 0128 84BB      		out 0x14,r24
 340:setup.c       **** 	GBA_PORT_RAM_DATA7_0 = data; // Set data
 523               		.loc 1 340 0
 524 012a C5BB      		out 0x15,r28
 341:setup.c       **** 	
 342:setup.c       **** 	// Pulse WR
 343:setup.c       **** 	wrPin_low;
 525               		.loc 1 343 0
 526 012c 9698      		cbi 0x12,6
 344:setup.c       **** 	cs2Pin_low; // CS2 pin low for SRAM/Flash select
 527               		.loc 1 344 0
 528 012e 3A98      		cbi 0x7,2
 345:setup.c       **** 	
 346:setup.c       **** 	asm volatile("nop");
 529               		.loc 1 346 0
 530               	/* #APP */
 531               	 ;  346 "setup.c" 1
 532 0130 0000      		nop
 533               	 ;  0 "" 2
 347:setup.c       **** 	asm volatile("nop");
 534               		.loc 1 347 0
 535               	 ;  347 "setup.c" 1
 536 0132 0000      		nop
 537               	 ;  0 "" 2
 348:setup.c       **** 	
 349:setup.c       **** 	cs2Pin_high;
 538               		.loc 1 349 0
 539               	/* #NOAPP */
 540 0134 3A9A      		sbi 0x7,2
 350:setup.c       **** 	wrPin_high;
 541               		.loc 1 350 0
 542 0136 969A      		sbi 0x12,6
 351:setup.c       **** 	
 352:setup.c       **** 	// Clear data outputs and set data pins as inputs
 353:setup.c       **** 	GBA_PORT_RAM_DATA7_0 = 0;
 543               		.loc 1 353 0
 544 0138 15BA      		out 0x15,__zero_reg__
 354:setup.c       **** 	GBA_DDR_RAM_DATA7_0 = 0;
 545               		.loc 1 354 0
 546 013a 14BA      		out 0x14,__zero_reg__
 547               	/* epilogue start */
 355:setup.c       **** }
 548               		.loc 1 355 0
 549 013c CF91      		pop r28
 550               	.LVL30:
 551 013e 0895      		ret
 552               		.cfi_endproc
 553               	.LFE25:
 555               	.global	gba_eeprom_mode
 557               	gba_eeprom_mode:
 558               	.LFB26:
 356:setup.c       **** 
 357:setup.c       **** 
 358:setup.c       **** 
 359:setup.c       **** // ---------- EEPROM ----------
 360:setup.c       **** 
 361:setup.c       **** // Set address/data all high (includes AD0/A23)
 362:setup.c       **** void gba_eeprom_mode (void) {
 559               		.loc 1 362 0
 560               		.cfi_startproc
 561               	/* prologue: function */
 562               	/* frame size = 0 */
 563               	/* stack size = 0 */
 564               	.L__stack_usage = 0
 363:setup.c       **** 	GBA_DDR_ROM_ADDR7_0 = 0xFF;
 565               		.loc 1 363 0
 566 0140 8FEF      		ldi r24,lo8(-1)
 567 0142 87BB      		out 0x17,r24
 364:setup.c       **** 	GBA_DDR_ROM_ADDR15_8 = 0xFF;
 568               		.loc 1 364 0
 569 0144 8ABB      		out 0x1a,r24
 365:setup.c       **** 	GBA_DDR_ROM_ADDR23_16 = 0xFF;
 570               		.loc 1 365 0
 571 0146 84BB      		out 0x14,r24
 366:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = 0x80;
 572               		.loc 1 366 0
 573 0148 90E8      		ldi r25,lo8(-128)
 574 014a 98BB      		out 0x18,r25
 367:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = 0xFF;
 575               		.loc 1 367 0
 576 014c 8BBB      		out 0x1b,r24
 368:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = 0xFF;
 577               		.loc 1 368 0
 578 014e 85BB      		out 0x15,r24
 579 0150 0895      		ret
 580               		.cfi_endproc
 581               	.LFE26:
 583               	.global	gba_eeprom_set_address
 585               	gba_eeprom_set_address:
 586               	.LFB27:
 369:setup.c       **** }
 370:setup.c       **** 
 371:setup.c       **** // Send out EEPROM address serially (WR clock, AD0 data out)
 372:setup.c       **** void gba_eeprom_set_address(uint16_t address, uint8_t eepromSize, uint8_t command) {
 587               		.loc 1 372 0
 588               		.cfi_startproc
 589               	.LVL31:
 590               	/* prologue: function */
 591               	/* frame size = 0 */
 592               	/* stack size = 0 */
 593               	.L__stack_usage = 0
 373:setup.c       **** 	cs_mreqPin_low;
 594               		.loc 1 373 0
 595 0152 9498      		cbi 0x12,4
 596               	.LVL32:
 374:setup.c       **** 	
 375:setup.c       **** 	int8_t x = 0;
 376:setup.c       **** 	if (eepromSize == EEPROM_64KBIT) {
 597               		.loc 1 376 0
 598 0154 6230      		cpi r22,lo8(2)
 599 0156 01F4      		brne .L30
 377:setup.c       **** 		if (command == EEPROM_READ) {
 600               		.loc 1 377 0
 601 0158 4111      		cpse r20,__zero_reg__
 602 015a 00C0      		rjmp .L31
 378:setup.c       **** 			address |= (1<<15) | (1<<14); // Set upper 2 bits high for read request
 603               		.loc 1 378 0
 604 015c 906C      		ori r25,192
 605               	.LVL33:
 606               	.L40:
 379:setup.c       **** 		}
 380:setup.c       **** 		else {
 381:setup.c       **** 			address |= (1<<15); // Set upper 1 bit high for write request
 382:setup.c       **** 		}
 383:setup.c       **** 		x = 15;
 607               		.loc 1 383 0
 608 015e 2FE0      		ldi r18,lo8(15)
 609               	.L33:
 610               	.LVL34:
 384:setup.c       **** 	}
 385:setup.c       **** 	else {
 386:setup.c       **** 		if (command == EEPROM_READ) {
 387:setup.c       **** 			address |= (1<<7) | (1<<6);
 388:setup.c       **** 		}
 389:setup.c       **** 		else {
 390:setup.c       **** 			address |= (1<<7);
 391:setup.c       **** 		}
 392:setup.c       **** 		x = 7;
 393:setup.c       **** 	}
 394:setup.c       **** 	
 395:setup.c       **** 	// Loop through address, 8 or 16 bits depending on EEPROM (includes the 2 bits for request type)
 396:setup.c       **** 	while (x >= 0) {
 397:setup.c       **** 		if (address & (1<<x)) {
 611               		.loc 1 397 0
 612 0160 E1E0      		ldi r30,lo8(1)
 613 0162 F0E0      		ldi r31,0
 614 0164 00C0      		rjmp .L32
 615               	.LVL35:
 616               	.L31:
 381:setup.c       **** 		}
 617               		.loc 1 381 0
 618 0166 9068      		ori r25,128
 619               	.LVL36:
 620 0168 00C0      		rjmp .L40
 621               	.L30:
 386:setup.c       **** 			address |= (1<<7) | (1<<6);
 622               		.loc 1 386 0
 623 016a 4111      		cpse r20,__zero_reg__
 624 016c 00C0      		rjmp .L34
 387:setup.c       **** 		}
 625               		.loc 1 387 0
 626 016e 806C      		ori r24,192
 627               	.LVL37:
 628 0170 00C0      		rjmp .L39
 629               	.L34:
 390:setup.c       **** 		}
 630               		.loc 1 390 0
 631 0172 8068      		ori r24,128
 632               	.LVL38:
 633               	.L39:
 392:setup.c       **** 	}
 634               		.loc 1 392 0
 635 0174 27E0      		ldi r18,lo8(7)
 636 0176 00C0      		rjmp .L33
 637               	.LVL39:
 638               	.L35:
 398:setup.c       **** 			ad0Pin_high;
 399:setup.c       **** 		}
 400:setup.c       **** 		else {
 401:setup.c       **** 			ad0Pin_low;
 639               		.loc 1 401 0
 640 0178 C098      		cbi 0x18,0
 641               	.L36:
 402:setup.c       **** 		}
 403:setup.c       **** 		
 404:setup.c       **** 		wrPin_low; // CLK
 642               		.loc 1 404 0
 643 017a 9698      		cbi 0x12,6
 405:setup.c       **** 		asm ("nop");
 644               		.loc 1 405 0
 645               	/* #APP */
 646               	 ;  405 "setup.c" 1
 647 017c 0000      		nop
 648               	 ;  0 "" 2
 406:setup.c       **** 		asm ("nop");
 649               		.loc 1 406 0
 650               	 ;  406 "setup.c" 1
 651 017e 0000      		nop
 652               	 ;  0 "" 2
 407:setup.c       **** 		wrPin_high; 
 653               		.loc 1 407 0
 654               	/* #NOAPP */
 655 0180 969A      		sbi 0x12,6
 408:setup.c       **** 		asm ("nop");
 656               		.loc 1 408 0
 657               	/* #APP */
 658               	 ;  408 "setup.c" 1
 659 0182 0000      		nop
 660               	 ;  0 "" 2
 409:setup.c       **** 		asm ("nop");
 661               		.loc 1 409 0
 662               	 ;  409 "setup.c" 1
 663 0184 0000      		nop
 664               	 ;  0 "" 2
 665               	/* #NOAPP */
 666 0186 2150      		subi r18,lo8(-(-1))
 667               	.LVL40:
 396:setup.c       **** 		if (address & (1<<x)) {
 668               		.loc 1 396 0
 669 0188 27FD      		sbrc r18,7
 670 018a 00C0      		rjmp .L41
 671               	.L32:
 397:setup.c       **** 			ad0Pin_high;
 672               		.loc 1 397 0
 673 018c BF01      		movw r22,r30
 674 018e 022E      		mov r0,r18
 675 0190 00C0      		rjmp 2f
 676               		1:
 677 0192 660F      		lsl r22
 678 0194 771F      		rol r23
 679               		2:
 680 0196 0A94      		dec r0
 681 0198 02F4      		brpl 1b
 682 019a 6823      		and r22,r24
 683 019c 7923      		and r23,r25
 684 019e 672B      		or r22,r23
 685 01a0 01F0      		breq .L35
 398:setup.c       **** 		}
 686               		.loc 1 398 0
 687 01a2 C09A      		sbi 0x18,0
 688 01a4 00C0      		rjmp .L36
 689               	.L41:
 410:setup.c       **** 		
 411:setup.c       **** 		x--;
 412:setup.c       **** 	}
 413:setup.c       **** 	
 414:setup.c       **** 	// Only send stop bit (0) and WR/CS high if reading, as writing is done in 1 continuous chunk
 415:setup.c       **** 	if (command == EEPROM_READ) {  
 690               		.loc 1 415 0
 691 01a6 4111      		cpse r20,__zero_reg__
 692 01a8 00C0      		rjmp .L29
 416:setup.c       **** 		ad0Pin_low;
 693               		.loc 1 416 0
 694 01aa C098      		cbi 0x18,0
 417:setup.c       **** 		asm ("nop");
 695               		.loc 1 417 0
 696               	/* #APP */
 697               	 ;  417 "setup.c" 1
 698 01ac 0000      		nop
 699               	 ;  0 "" 2
 418:setup.c       **** 		wrPin_low;
 700               		.loc 1 418 0
 701               	/* #NOAPP */
 702 01ae 9698      		cbi 0x12,6
 419:setup.c       **** 		asm ("nop");
 703               		.loc 1 419 0
 704               	/* #APP */
 705               	 ;  419 "setup.c" 1
 706 01b0 0000      		nop
 707               	 ;  0 "" 2
 420:setup.c       **** 		asm ("nop");
 708               		.loc 1 420 0
 709               	 ;  420 "setup.c" 1
 710 01b2 0000      		nop
 711               	 ;  0 "" 2
 421:setup.c       **** 		
 422:setup.c       **** 		wrPin_high;
 712               		.loc 1 422 0
 713               	/* #NOAPP */
 714 01b4 969A      		sbi 0x12,6
 423:setup.c       **** 		cs_mreqPin_high;
 715               		.loc 1 423 0
 716 01b6 949A      		sbi 0x12,4
 717               	.L29:
 718 01b8 0895      		ret
 719               		.cfi_endproc
 720               	.LFE27:
 722               	.global	gba_eeprom_read
 724               	gba_eeprom_read:
 725               	.LFB28:
 424:setup.c       **** 	}
 425:setup.c       **** }
 426:setup.c       **** 
 427:setup.c       **** // Read 8 bytes from the EEPROM address, data is valid on rising edge
 428:setup.c       **** void gba_eeprom_read(uint16_t address, uint8_t eepromSize) {
 726               		.loc 1 428 0
 727               		.cfi_startproc
 728               	.LVL41:
 729               	/* prologue: function */
 730               	/* frame size = 0 */
 731               	/* stack size = 0 */
 732               	.L__stack_usage = 0
 429:setup.c       **** 	gba_eeprom_set_address(address, eepromSize, EEPROM_READ);
 733               		.loc 1 429 0
 734 01ba 40E0      		ldi r20,0
 735 01bc 00D0      		rcall gba_eeprom_set_address
 736               	.LVL42:
 430:setup.c       **** 	
 431:setup.c       **** 	// Set AD0 pin as input
 432:setup.c       **** 	GBA_PORT_EEPROM_DATA7_0 &= ~(1<<AD0);
 737               		.loc 1 432 0
 738 01be C098      		cbi 0x18,0
 433:setup.c       **** 	GBA_DDR_EEPROM_DATA7_0 &= ~(1<<AD0);
 739               		.loc 1 433 0
 740 01c0 B898      		cbi 0x17,0
 434:setup.c       **** 	
 435:setup.c       **** 	cs_mreqPin_low;
 741               		.loc 1 435 0
 742 01c2 9498      		cbi 0x12,4
 743               	.LVL43:
 744 01c4 84E0      		ldi r24,lo8(4)
 745               	.LVL44:
 746               	.L43:
 747               	.LBB53:
 436:setup.c       **** 	
 437:setup.c       **** 	// Ignore first 4 bits
 438:setup.c       **** 	for (int8_t x = 0; x < 4; x++) {
 439:setup.c       **** 		rdPin_low; // CLK
 748               		.loc 1 439 0 discriminator 3
 749 01c6 9598      		cbi 0x12,5
 440:setup.c       **** 		asm ("nop");
 750               		.loc 1 440 0 discriminator 3
 751               	/* #APP */
 752               	 ;  440 "setup.c" 1
 753 01c8 0000      		nop
 754               	 ;  0 "" 2
 441:setup.c       **** 		asm ("nop");
 755               		.loc 1 441 0 discriminator 3
 756               	 ;  441 "setup.c" 1
 757 01ca 0000      		nop
 758               	 ;  0 "" 2
 442:setup.c       **** 		rdPin_high; 
 759               		.loc 1 442 0 discriminator 3
 760               	/* #NOAPP */
 761 01cc 959A      		sbi 0x12,5
 443:setup.c       **** 		asm ("nop");
 762               		.loc 1 443 0 discriminator 3
 763               	/* #APP */
 764               	 ;  443 "setup.c" 1
 765 01ce 0000      		nop
 766               	 ;  0 "" 2
 444:setup.c       **** 		asm ("nop");
 767               		.loc 1 444 0 discriminator 3
 768               	 ;  444 "setup.c" 1
 769 01d0 0000      		nop
 770               	 ;  0 "" 2
 771               	.LVL45:
 772               	/* #NOAPP */
 773 01d2 8150      		subi r24,lo8(-(-1))
 774               	.LVL46:
 438:setup.c       **** 		rdPin_low; // CLK
 775               		.loc 1 438 0 discriminator 3
 776 01d4 01F4      		brne .L43
 777 01d6 E0E0      		ldi r30,lo8(eepromBuffer)
 778 01d8 F0E0      		ldi r31,hi8(eepromBuffer)
 779               	.LBE53:
 780               	.LBB54:
 781               	.LBB55:
 782               	.LBB56:
 445:setup.c       **** 	}
 446:setup.c       **** 	
 447:setup.c       **** 	// Read out 64 bits
 448:setup.c       **** 	for (uint8_t c = 0; c < 8; c++) {
 449:setup.c       **** 		uint8_t data = 0;
 450:setup.c       **** 		for (int8_t x = 7; x >= 0; x--) {
 451:setup.c       **** 			rdPin_low; // CLK
 452:setup.c       **** 			asm ("nop");
 453:setup.c       **** 			asm ("nop");
 454:setup.c       **** 			rdPin_high;
 455:setup.c       **** 			
 456:setup.c       **** 			if (GBA_PIN_EEPROM_DATA7_0 & (1<<AD0)) {
 457:setup.c       **** 				data |= (1<<x);
 783               		.loc 1 457 0
 784 01da 41E0      		ldi r20,lo8(1)
 785 01dc 50E0      		ldi r21,0
 786               	.LVL47:
 787               	.L44:
 788               	.LBE56:
 789               	.LBE55:
 790               	.LBE54:
 435:setup.c       **** 	
 791               		.loc 1 435 0
 792 01de 87E0      		ldi r24,lo8(7)
 793 01e0 90E0      		ldi r25,0
 794 01e2 20E0      		ldi r18,0
 795               	.LVL48:
 796               	.L46:
 797               	.LBB59:
 798               	.LBB58:
 799               	.LBB57:
 451:setup.c       **** 			asm ("nop");
 800               		.loc 1 451 0
 801 01e4 9598      		cbi 0x12,5
 452:setup.c       **** 			asm ("nop");
 802               		.loc 1 452 0
 803               	/* #APP */
 804               	 ;  452 "setup.c" 1
 805 01e6 0000      		nop
 806               	 ;  0 "" 2
 453:setup.c       **** 			rdPin_high;
 807               		.loc 1 453 0
 808               	 ;  453 "setup.c" 1
 809 01e8 0000      		nop
 810               	 ;  0 "" 2
 454:setup.c       **** 			
 811               		.loc 1 454 0
 812               	/* #NOAPP */
 813 01ea 959A      		sbi 0x12,5
 456:setup.c       **** 				data |= (1<<x);
 814               		.loc 1 456 0
 815 01ec B09B      		sbis 0x16,0
 816 01ee 00C0      		rjmp .L45
 817               		.loc 1 457 0
 818 01f0 BA01      		movw r22,r20
 819 01f2 082E      		mov r0,r24
 820 01f4 00C0      		rjmp 2f
 821               		1:
 822 01f6 660F      		lsl r22
 823               		2:
 824 01f8 0A94      		dec r0
 825 01fa 02F4      		brpl 1b
 826 01fc 262B      		or r18,r22
 827               	.LVL49:
 828               	.L45:
 829               	.LVL50:
 830 01fe 0197      		sbiw r24,1
 831 0200 00F4      		brcc .L46
 832               	.LBE57:
 458:setup.c       **** 			}
 459:setup.c       **** 		}
 460:setup.c       **** 		eepromBuffer[c] = data;
 833               		.loc 1 460 0 discriminator 2
 834 0202 2193      		st Z+,r18
 835               	.LVL51:
 836               	.LBE58:
 448:setup.c       **** 		uint8_t data = 0;
 837               		.loc 1 448 0 discriminator 2
 838 0204 80E0      		ldi r24,hi8(eepromBuffer+8)
 839 0206 E030      		cpi r30,lo8(eepromBuffer+8)
 840 0208 F807      		cpc r31,r24
 841               	.LVL52:
 842 020a 01F4      		brne .L44
 843               	.LBE59:
 461:setup.c       **** 	}
 462:setup.c       **** 	
 463:setup.c       **** 	cs_mreqPin_high;
 844               		.loc 1 463 0
 845 020c 949A      		sbi 0x12,4
 464:setup.c       **** 	
 465:setup.c       **** 	// Set AD0 pin as output
 466:setup.c       **** 	GBA_PORT_EEPROM_DATA7_0 |= (1<<AD0);
 846               		.loc 1 466 0
 847 020e C09A      		sbi 0x18,0
 467:setup.c       **** 	GBA_DDR_EEPROM_DATA7_0 |= (1<<AD0);
 848               		.loc 1 467 0
 849 0210 B89A      		sbi 0x17,0
 850 0212 0895      		ret
 851               		.cfi_endproc
 852               	.LFE28:
 854               	.global	gba_eeprom_write
 856               	gba_eeprom_write:
 857               	.LFB29:
 468:setup.c       **** }
 469:setup.c       **** 
 470:setup.c       **** // Write 8 bytes to the EEPROM address
 471:setup.c       **** void gba_eeprom_write(uint16_t address, uint8_t eepromSize) {
 858               		.loc 1 471 0
 859               		.cfi_startproc
 860               	.LVL53:
 861               	/* prologue: function */
 862               	/* frame size = 0 */
 863               	/* stack size = 0 */
 864               	.L__stack_usage = 0
 472:setup.c       **** 	gba_eeprom_set_address(address, eepromSize, EEPROM_WRITE);
 865               		.loc 1 472 0
 866 0214 41E0      		ldi r20,lo8(1)
 867 0216 00D0      		rcall gba_eeprom_set_address
 868               	.LVL54:
 869 0218 E0E0      		ldi r30,lo8(eepromBuffer)
 870 021a F0E0      		ldi r31,hi8(eepromBuffer)
 871 021c 48E0      		ldi r20,lo8(8)
 872               	.LVL55:
 873               	.L54:
 471:setup.c       **** 	gba_eeprom_set_address(address, eepromSize, EEPROM_WRITE);
 874               		.loc 1 471 0
 875 021e 27E0      		ldi r18,lo8(7)
 876 0220 30E0      		ldi r19,0
 877               	.LVL56:
 878               	.L57:
 879               	.LBB60:
 880               	.LBB61:
 473:setup.c       **** 	
 474:setup.c       **** 	// Write 64 bits
 475:setup.c       **** 	for (uint8_t c = 0; c < 8; c++) {
 476:setup.c       **** 		for (int8_t x = 7; x >= 0; x--) {
 477:setup.c       **** 			if (eepromBuffer[c] & (1<<x)) {
 881               		.loc 1 477 0
 882 0222 8081      		ld r24,Z
 883 0224 90E0      		ldi r25,0
 884 0226 022E      		mov r0,r18
 885 0228 00C0      		rjmp 2f
 886               		1:
 887 022a 9595      		asr r25
 888 022c 8795      		ror r24
 889               		2:
 890 022e 0A94      		dec r0
 891 0230 02F4      		brpl 1b
 892 0232 80FF      		sbrs r24,0
 893 0234 00C0      		rjmp .L55
 478:setup.c       **** 				ad0Pin_high;
 894               		.loc 1 478 0
 895 0236 C09A      		sbi 0x18,0
 896 0238 00C0      		rjmp .L56
 897               	.L55:
 479:setup.c       **** 			}
 480:setup.c       **** 			else {
 481:setup.c       **** 				ad0Pin_low;
 898               		.loc 1 481 0
 899 023a C098      		cbi 0x18,0
 900               	.L56:
 482:setup.c       **** 			}
 483:setup.c       **** 			
 484:setup.c       **** 			wrPin_low; // CLK
 901               		.loc 1 484 0 discriminator 2
 902 023c 9698      		cbi 0x12,6
 485:setup.c       **** 			asm ("nop");
 903               		.loc 1 485 0 discriminator 2
 904               	/* #APP */
 905               	 ;  485 "setup.c" 1
 906 023e 0000      		nop
 907               	 ;  0 "" 2
 486:setup.c       **** 			asm ("nop");
 908               		.loc 1 486 0 discriminator 2
 909               	 ;  486 "setup.c" 1
 910 0240 0000      		nop
 911               	 ;  0 "" 2
 487:setup.c       **** 			wrPin_high; 
 912               		.loc 1 487 0 discriminator 2
 913               	/* #NOAPP */
 914 0242 969A      		sbi 0x12,6
 488:setup.c       **** 			asm ("nop");
 915               		.loc 1 488 0 discriminator 2
 916               	/* #APP */
 917               	 ;  488 "setup.c" 1
 918 0244 0000      		nop
 919               	 ;  0 "" 2
 489:setup.c       **** 			asm ("nop");
 920               		.loc 1 489 0 discriminator 2
 921               	 ;  489 "setup.c" 1
 922 0246 0000      		nop
 923               	 ;  0 "" 2
 924               	.LVL57:
 925               	/* #NOAPP */
 926               	.LVL58:
 927 0248 2150      		subi r18,1
 928 024a 3109      		sbc r19,__zero_reg__
 929 024c 00F4      		brcc .L57
 930 024e 4150      		subi r20,lo8(-(-1))
 931 0250 3196      		adiw r30,1
 932               	.LVL59:
 933               	.LBE61:
 475:setup.c       **** 		for (int8_t x = 7; x >= 0; x--) {
 934               		.loc 1 475 0 discriminator 2
 935 0252 4111      		cpse r20,__zero_reg__
 936 0254 00C0      		rjmp .L54
 937               	.LBE60:
 490:setup.c       **** 		}
 491:setup.c       **** 	}
 492:setup.c       **** 	
 493:setup.c       **** 	// Last bit low
 494:setup.c       **** 	ad0Pin_low;
 938               		.loc 1 494 0
 939 0256 C098      		cbi 0x18,0
 495:setup.c       **** 	wrPin_low; // CLK
 940               		.loc 1 495 0
 941 0258 9698      		cbi 0x12,6
 496:setup.c       **** 	asm ("nop");
 942               		.loc 1 496 0
 943               	/* #APP */
 944               	 ;  496 "setup.c" 1
 945 025a 0000      		nop
 946               	 ;  0 "" 2
 497:setup.c       **** 	asm ("nop");
 947               		.loc 1 497 0
 948               	 ;  497 "setup.c" 1
 949 025c 0000      		nop
 950               	 ;  0 "" 2
 498:setup.c       **** 	wrPin_high; 
 951               		.loc 1 498 0
 952               	/* #NOAPP */
 953 025e 969A      		sbi 0x12,6
 499:setup.c       **** 	asm ("nop");
 954               		.loc 1 499 0
 955               	/* #APP */
 956               	 ;  499 "setup.c" 1
 957 0260 0000      		nop
 958               	 ;  0 "" 2
 500:setup.c       **** 	asm ("nop");
 959               		.loc 1 500 0
 960               	 ;  500 "setup.c" 1
 961 0262 0000      		nop
 962               	 ;  0 "" 2
 501:setup.c       **** 	
 502:setup.c       **** 	cs_mreqPin_high;
 963               		.loc 1 502 0
 964               	/* #NOAPP */
 965 0264 949A      		sbi 0x12,4
 966 0266 0895      		ret
 967               		.cfi_endproc
 968               	.LFE29:
 970               	.global	flash_write_bus_cycle
 972               	flash_write_bus_cycle:
 973               	.LFB30:
 503:setup.c       **** }
 504:setup.c       **** 
 505:setup.c       **** 
 506:setup.c       **** 
 507:setup.c       **** // ---------- FLASH ----------
 508:setup.c       **** 
 509:setup.c       **** // Set the address and data for the write byte cycle to the flash
 510:setup.c       **** void flash_write_bus_cycle(uint16_t address, uint8_t data) {
 974               		.loc 1 510 0
 975               		.cfi_startproc
 976               	.LVL60:
 977 0268 CF93      		push r28
 978               	.LCFI10:
 979               		.cfi_def_cfa_offset 3
 980               		.cfi_offset 28, -2
 981               	/* prologue: function */
 982               	/* frame size = 0 */
 983               	/* stack size = 1 */
 984               	.L__stack_usage = 1
 985 026a C62F      		mov r28,r22
 511:setup.c       **** 	GBA_DDR_RAM_DATA7_0 = 0xFF; // Set data pins as outputs
 986               		.loc 1 511 0
 987 026c 2FEF      		ldi r18,lo8(-1)
 988 026e 24BB      		out 0x14,r18
 512:setup.c       **** 	set_16bit_address(address);
 989               		.loc 1 512 0
 990 0270 00D0      		rcall set_16bit_address
 991               	.LVL61:
 513:setup.c       **** 	GBA_PORT_RAM_DATA7_0 = data;
 992               		.loc 1 513 0
 993 0272 C5BB      		out 0x15,r28
 514:setup.c       **** 	
 515:setup.c       **** 	wrPin_low;
 994               		.loc 1 515 0
 995 0274 9698      		cbi 0x12,6
 516:setup.c       **** 	cs2Pin_low;
 996               		.loc 1 516 0
 997 0276 3A98      		cbi 0x7,2
 517:setup.c       **** 	asm volatile("nop");
 998               		.loc 1 517 0
 999               	/* #APP */
 1000               	 ;  517 "setup.c" 1
 1001 0278 0000      		nop
 1002               	 ;  0 "" 2
 518:setup.c       **** 	wrPin_high;
 1003               		.loc 1 518 0
 1004               	/* #NOAPP */
 1005 027a 969A      		sbi 0x12,6
 519:setup.c       **** 	cs2Pin_high;
 1006               		.loc 1 519 0
 1007 027c 3A9A      		sbi 0x7,2
 1008               	/* epilogue start */
 520:setup.c       **** }
 1009               		.loc 1 520 0
 1010 027e CF91      		pop r28
 1011               	.LVL62:
 1012 0280 0895      		ret
 1013               		.cfi_endproc
 1014               	.LFE30:
 1016               	.global	flash_read_chip_id
 1018               	flash_read_chip_id:
 1019               	.LFB31:
 521:setup.c       **** 
 522:setup.c       **** // Read the flash manufacturer and device ID (Software ID)
 523:setup.c       **** void flash_read_chip_id(void) {
 1020               		.loc 1 523 0
 1021               		.cfi_startproc
 1022 0282 CF93      		push r28
 1023               	.LCFI11:
 1024               		.cfi_def_cfa_offset 3
 1025               		.cfi_offset 28, -2
 1026 0284 DF93      		push r29
 1027               	.LCFI12:
 1028               		.cfi_def_cfa_offset 4
 1029               		.cfi_offset 29, -3
 1030               	/* prologue: function */
 1031               	/* frame size = 0 */
 1032               	/* stack size = 2 */
 1033               	.L__stack_usage = 2
 524:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xAA);
 1034               		.loc 1 524 0
 1035 0286 6AEA      		ldi r22,lo8(-86)
 1036 0288 85E5      		ldi r24,lo8(85)
 1037 028a 95E5      		ldi r25,lo8(85)
 1038 028c 00D0      		rcall flash_write_bus_cycle
 1039               	.LVL63:
 525:setup.c       **** 	flash_write_bus_cycle(0x2AAA, 0x55);
 1040               		.loc 1 525 0
 1041 028e 65E5      		ldi r22,lo8(85)
 1042 0290 8AEA      		ldi r24,lo8(-86)
 1043 0292 9AE2      		ldi r25,lo8(42)
 1044 0294 00D0      		rcall flash_write_bus_cycle
 1045               	.LVL64:
 526:setup.c       **** 	flash_write_bus_cycle(0x5555, 0x90); // Software ID entry
 1046               		.loc 1 526 0
 1047 0296 60E9      		ldi r22,lo8(-112)
 1048 0298 85E5      		ldi r24,lo8(85)
 1049 029a 95E5      		ldi r25,lo8(85)
 1050 029c 00D0      		rcall flash_write_bus_cycle
 1051               	.LVL65:
 1052               	.LBB62:
 1053               	.LBB63:
 1054               		.file 2 "c:\\winavr-20100110\\avr\\include\\util\\delay.h"
   1:c:\winavr-20100110\avr\include\util\delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:c:\winavr-20100110\avr\include\util\delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:c:\winavr-20100110\avr\include\util\delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:c:\winavr-20100110\avr\include\util\delay.h ****    All rights reserved.
   5:c:\winavr-20100110\avr\include\util\delay.h **** 
   6:c:\winavr-20100110\avr\include\util\delay.h ****    Redistribution and use in source and binary forms, with or without
   7:c:\winavr-20100110\avr\include\util\delay.h ****    modification, are permitted provided that the following conditions are met:
   8:c:\winavr-20100110\avr\include\util\delay.h **** 
   9:c:\winavr-20100110\avr\include\util\delay.h ****    * Redistributions of source code must retain the above copyright
  10:c:\winavr-20100110\avr\include\util\delay.h ****      notice, this list of conditions and the following disclaimer.
  11:c:\winavr-20100110\avr\include\util\delay.h **** 
  12:c:\winavr-20100110\avr\include\util\delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:c:\winavr-20100110\avr\include\util\delay.h ****      notice, this list of conditions and the following disclaimer in
  14:c:\winavr-20100110\avr\include\util\delay.h ****      the documentation and/or other materials provided with the
  15:c:\winavr-20100110\avr\include\util\delay.h ****      distribution.
  16:c:\winavr-20100110\avr\include\util\delay.h **** 
  17:c:\winavr-20100110\avr\include\util\delay.h ****    * Neither the name of the copyright holders nor the names of
  18:c:\winavr-20100110\avr\include\util\delay.h ****      contributors may be used to endorse or promote products derived
  19:c:\winavr-20100110\avr\include\util\delay.h ****      from this software without specific prior written permission.
  20:c:\winavr-20100110\avr\include\util\delay.h **** 
  21:c:\winavr-20100110\avr\include\util\delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:c:\winavr-20100110\avr\include\util\delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:c:\winavr-20100110\avr\include\util\delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:c:\winavr-20100110\avr\include\util\delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:c:\winavr-20100110\avr\include\util\delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:c:\winavr-20100110\avr\include\util\delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:c:\winavr-20100110\avr\include\util\delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:c:\winavr-20100110\avr\include\util\delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:c:\winavr-20100110\avr\include\util\delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:c:\winavr-20100110\avr\include\util\delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:c:\winavr-20100110\avr\include\util\delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:c:\winavr-20100110\avr\include\util\delay.h **** 
  33:c:\winavr-20100110\avr\include\util\delay.h **** /* $Id$ */
  34:c:\winavr-20100110\avr\include\util\delay.h **** 
  35:c:\winavr-20100110\avr\include\util\delay.h **** #ifndef _UTIL_DELAY_H_
  36:c:\winavr-20100110\avr\include\util\delay.h **** #define _UTIL_DELAY_H_ 1
  37:c:\winavr-20100110\avr\include\util\delay.h **** 
  38:c:\winavr-20100110\avr\include\util\delay.h **** #ifndef __DOXYGEN__
  39:c:\winavr-20100110\avr\include\util\delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:c:\winavr-20100110\avr\include\util\delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:c:\winavr-20100110\avr\include\util\delay.h **** #  endif
  42:c:\winavr-20100110\avr\include\util\delay.h **** #endif  /* __DOXYGEN__ */
  43:c:\winavr-20100110\avr\include\util\delay.h **** 
  44:c:\winavr-20100110\avr\include\util\delay.h **** #include <inttypes.h>
  45:c:\winavr-20100110\avr\include\util\delay.h **** #include <util/delay_basic.h>
  46:c:\winavr-20100110\avr\include\util\delay.h **** #include <math.h>
  47:c:\winavr-20100110\avr\include\util\delay.h **** 
  48:c:\winavr-20100110\avr\include\util\delay.h **** /** \file */
  49:c:\winavr-20100110\avr\include\util\delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:c:\winavr-20100110\avr\include\util\delay.h ****     \code
  51:c:\winavr-20100110\avr\include\util\delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:c:\winavr-20100110\avr\include\util\delay.h ****     //#define F_CPU 14.7456E6
  53:c:\winavr-20100110\avr\include\util\delay.h ****     #include <util/delay.h>
  54:c:\winavr-20100110\avr\include\util\delay.h ****     \endcode
  55:c:\winavr-20100110\avr\include\util\delay.h **** 
  56:c:\winavr-20100110\avr\include\util\delay.h ****     \note As an alternative method, it is possible to pass the
  57:c:\winavr-20100110\avr\include\util\delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:c:\winavr-20100110\avr\include\util\delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:c:\winavr-20100110\avr\include\util\delay.h ****     used.
  60:c:\winavr-20100110\avr\include\util\delay.h **** 
  61:c:\winavr-20100110\avr\include\util\delay.h ****     The functions in this header file are wrappers around the basic
  62:c:\winavr-20100110\avr\include\util\delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:c:\winavr-20100110\avr\include\util\delay.h ****     convenience functions where actual time values can be specified
  64:c:\winavr-20100110\avr\include\util\delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:c:\winavr-20100110\avr\include\util\delay.h ****     that compile-time constant expressions will be eliminated by
  66:c:\winavr-20100110\avr\include\util\delay.h ****     compiler optimization so floating-point expressions can be used
  67:c:\winavr-20100110\avr\include\util\delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:c:\winavr-20100110\avr\include\util\delay.h ****     frequency passed by the macro F_CPU.
  69:c:\winavr-20100110\avr\include\util\delay.h **** 
  70:c:\winavr-20100110\avr\include\util\delay.h ****     \note In order for these functions to work as intended, compiler
  71:c:\winavr-20100110\avr\include\util\delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:c:\winavr-20100110\avr\include\util\delay.h ****     <em>must</em> be an expression that is a known constant at
  73:c:\winavr-20100110\avr\include\util\delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:c:\winavr-20100110\avr\include\util\delay.h ****     delay will be much longer (and basically unpredictable), and
  75:c:\winavr-20100110\avr\include\util\delay.h ****     applications that otherwise do not use floating-point calculations
  76:c:\winavr-20100110\avr\include\util\delay.h ****     will experience severe code bloat by the floating-point library
  77:c:\winavr-20100110\avr\include\util\delay.h ****     routines linked into the application.
  78:c:\winavr-20100110\avr\include\util\delay.h **** 
  79:c:\winavr-20100110\avr\include\util\delay.h ****     The functions available allow the specification of microsecond, and
  80:c:\winavr-20100110\avr\include\util\delay.h ****     millisecond delays directly, using the application-supplied macro
  81:c:\winavr-20100110\avr\include\util\delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:c:\winavr-20100110\avr\include\util\delay.h **** 
  83:c:\winavr-20100110\avr\include\util\delay.h **** */
  84:c:\winavr-20100110\avr\include\util\delay.h **** 
  85:c:\winavr-20100110\avr\include\util\delay.h **** #if !defined(__DOXYGEN__)
  86:c:\winavr-20100110\avr\include\util\delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:c:\winavr-20100110\avr\include\util\delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:c:\winavr-20100110\avr\include\util\delay.h **** #endif
  89:c:\winavr-20100110\avr\include\util\delay.h **** 
  90:c:\winavr-20100110\avr\include\util\delay.h **** #ifndef F_CPU
  91:c:\winavr-20100110\avr\include\util\delay.h **** /* prevent compiler error by supplying a default */
  92:c:\winavr-20100110\avr\include\util\delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:c:\winavr-20100110\avr\include\util\delay.h **** /** \ingroup util_delay
  94:c:\winavr-20100110\avr\include\util\delay.h ****     \def F_CPU
  95:c:\winavr-20100110\avr\include\util\delay.h ****     \brief CPU frequency in Hz
  96:c:\winavr-20100110\avr\include\util\delay.h **** 
  97:c:\winavr-20100110\avr\include\util\delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:c:\winavr-20100110\avr\include\util\delay.h ****     the delay macros.  This macro is normally supplied by the
  99:c:\winavr-20100110\avr\include\util\delay.h ****     environment (e.g. from within a project header, or the project's
 100:c:\winavr-20100110\avr\include\util\delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:c:\winavr-20100110\avr\include\util\delay.h ****     fallback if no such user-provided definition could be found.
 102:c:\winavr-20100110\avr\include\util\delay.h **** 
 103:c:\winavr-20100110\avr\include\util\delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:c:\winavr-20100110\avr\include\util\delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:c:\winavr-20100110\avr\include\util\delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:c:\winavr-20100110\avr\include\util\delay.h ****     integer value.
 107:c:\winavr-20100110\avr\include\util\delay.h ****  */
 108:c:\winavr-20100110\avr\include\util\delay.h **** # define F_CPU 1000000UL
 109:c:\winavr-20100110\avr\include\util\delay.h **** #endif
 110:c:\winavr-20100110\avr\include\util\delay.h **** 
 111:c:\winavr-20100110\avr\include\util\delay.h **** #ifndef __OPTIMIZE__
 112:c:\winavr-20100110\avr\include\util\delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:c:\winavr-20100110\avr\include\util\delay.h **** #endif
 114:c:\winavr-20100110\avr\include\util\delay.h **** 
 115:c:\winavr-20100110\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:c:\winavr-20100110\avr\include\util\delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:c:\winavr-20100110\avr\include\util\delay.h ****   __STDC_HOSTED__
 118:c:\winavr-20100110\avr\include\util\delay.h **** #  include <math.h>
 119:c:\winavr-20100110\avr\include\util\delay.h **** #endif
 120:c:\winavr-20100110\avr\include\util\delay.h **** 
 121:c:\winavr-20100110\avr\include\util\delay.h **** /**
 122:c:\winavr-20100110\avr\include\util\delay.h ****    \ingroup util_delay
 123:c:\winavr-20100110\avr\include\util\delay.h **** 
 124:c:\winavr-20100110\avr\include\util\delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:c:\winavr-20100110\avr\include\util\delay.h **** 
 126:c:\winavr-20100110\avr\include\util\delay.h ****    The macro F_CPU is supposed to be defined to a
 127:c:\winavr-20100110\avr\include\util\delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:c:\winavr-20100110\avr\include\util\delay.h **** 
 129:c:\winavr-20100110\avr\include\util\delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:c:\winavr-20100110\avr\include\util\delay.h **** 
 131:c:\winavr-20100110\avr\include\util\delay.h ****    When the user request delay which exceed the maximum possible one,
 132:c:\winavr-20100110\avr\include\util\delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:c:\winavr-20100110\avr\include\util\delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:c:\winavr-20100110\avr\include\util\delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:c:\winavr-20100110\avr\include\util\delay.h ****    user will not be informed about decreased resolution.
 136:c:\winavr-20100110\avr\include\util\delay.h **** 
 137:c:\winavr-20100110\avr\include\util\delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:c:\winavr-20100110\avr\include\util\delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:c:\winavr-20100110\avr\include\util\delay.h ****    values greater than the maximal possible delay, overflows results in
 140:c:\winavr-20100110\avr\include\util\delay.h ****    no delay i.e., 0ms.
 141:c:\winavr-20100110\avr\include\util\delay.h **** 
 142:c:\winavr-20100110\avr\include\util\delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:c:\winavr-20100110\avr\include\util\delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:c:\winavr-20100110\avr\include\util\delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:c:\winavr-20100110\avr\include\util\delay.h ****    microseconds of delay.
 146:c:\winavr-20100110\avr\include\util\delay.h **** 
 147:c:\winavr-20100110\avr\include\util\delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:c:\winavr-20100110\avr\include\util\delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:c:\winavr-20100110\avr\include\util\delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:c:\winavr-20100110\avr\include\util\delay.h ****    respectively.
 151:c:\winavr-20100110\avr\include\util\delay.h **** 
 152:c:\winavr-20100110\avr\include\util\delay.h ****    \note
 153:c:\winavr-20100110\avr\include\util\delay.h **** 
 154:c:\winavr-20100110\avr\include\util\delay.h ****    The implementation of _delay_ms() based on
 155:c:\winavr-20100110\avr\include\util\delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:c:\winavr-20100110\avr\include\util\delay.h ****    implementations.  In order to get functionality backward compatible
 157:c:\winavr-20100110\avr\include\util\delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:c:\winavr-20100110\avr\include\util\delay.h ****    must be defined before including this header file. Also, the
 159:c:\winavr-20100110\avr\include\util\delay.h ****    backward compatible algorithm will be chosen if the code is
 160:c:\winavr-20100110\avr\include\util\delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:c:\winavr-20100110\avr\include\util\delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:c:\winavr-20100110\avr\include\util\delay.h ****    not available to the compiler then.
 163:c:\winavr-20100110\avr\include\util\delay.h **** 
 164:c:\winavr-20100110\avr\include\util\delay.h ****  */
 165:c:\winavr-20100110\avr\include\util\delay.h **** void
 166:c:\winavr-20100110\avr\include\util\delay.h **** _delay_ms(double __ms)
 167:c:\winavr-20100110\avr\include\util\delay.h **** {
 168:c:\winavr-20100110\avr\include\util\delay.h **** 	double __tmp ;
 169:c:\winavr-20100110\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:c:\winavr-20100110\avr\include\util\delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:c:\winavr-20100110\avr\include\util\delay.h ****   __STDC_HOSTED__
 172:c:\winavr-20100110\avr\include\util\delay.h **** 	uint32_t __ticks_dc;
 173:c:\winavr-20100110\avr\include\util\delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 174:c:\winavr-20100110\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 175:c:\winavr-20100110\avr\include\util\delay.h **** 
 176:c:\winavr-20100110\avr\include\util\delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:c:\winavr-20100110\avr\include\util\delay.h **** 
 179:c:\winavr-20100110\avr\include\util\delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:c:\winavr-20100110\avr\include\util\delay.h **** 
 182:c:\winavr-20100110\avr\include\util\delay.h **** 	#else
 183:c:\winavr-20100110\avr\include\util\delay.h **** 		//round up by default
 184:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 185:c:\winavr-20100110\avr\include\util\delay.h **** 	#endif
 186:c:\winavr-20100110\avr\include\util\delay.h **** 
 187:c:\winavr-20100110\avr\include\util\delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 1055               		.loc 2 187 0
 1056 029e 8FE3      		ldi r24,lo8(-25537)
 1057 02a0 9CE9      		ldi r25,hi8(-25537)
 1058 02a2 0197      	1:	sbiw r24,1
 1059 02a4 01F4      		brne 1b
 1060 02a6 00C0      		rjmp .
 1061 02a8 0000      		nop
 1062               	.LVL66:
 1063               	.LBE63:
 1064               	.LBE62:
 527:setup.c       **** 	_delay_ms(20); // Wait a little (for Atmel chip)
 528:setup.c       **** 	
 529:setup.c       **** 	// Set data as inputs
 530:setup.c       **** 	GBA_PORT_RAM_DATA7_0 = 0;
 1065               		.loc 1 530 0
 1066 02aa 15BA      		out 0x15,__zero_reg__
 531:setup.c       **** 	GBA_DDR_RAM_DATA7_0 = 0;
 1067               		.loc 1 531 0
 1068 02ac 14BA      		out 0x14,__zero_reg__
 532:setup.c       **** 	
 533:setup.c       **** 	// Read and transmit the 2 bytes
 534:setup.c       **** 	flashChipIdBuffer[0] = gba_read_ram_8bit_data(0x0000);
 1069               		.loc 1 534 0
 1070 02ae 80E0      		ldi r24,0
 1071 02b0 90E0      		ldi r25,0
 1072 02b2 00D0      		rcall gba_read_ram_8bit_data
 1073               	.LVL67:
 1074 02b4 C0E0      		ldi r28,lo8(flashChipIdBuffer)
 1075 02b6 D0E0      		ldi r29,hi8(flashChipIdBuffer)
 1076 02b8 8883      		st Y,r24
 535:setup.c       **** 	flashChipIdBuffer[1] = gba_read_ram_8bit_data(0x0001);
 1077               		.loc 1 535 0
 1078 02ba 81E0      		ldi r24,lo8(1)
 1079 02bc 90E0      		ldi r25,0
 1080 02be 00D0      		rcall gba_read_ram_8bit_data
 1081               	.LVL68:
 1082 02c0 8983      		std Y+1,r24
 536:setup.c       **** 	
 537:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xAA);
 1083               		.loc 1 537 0
 1084 02c2 6AEA      		ldi r22,lo8(-86)
 1085 02c4 85E5      		ldi r24,lo8(85)
 1086 02c6 95E5      		ldi r25,lo8(85)
 1087 02c8 00D0      		rcall flash_write_bus_cycle
 1088               	.LVL69:
 538:setup.c       **** 	flash_write_bus_cycle(0x2AAA, 0x55);
 1089               		.loc 1 538 0
 1090 02ca 65E5      		ldi r22,lo8(85)
 1091 02cc 8AEA      		ldi r24,lo8(-86)
 1092 02ce 9AE2      		ldi r25,lo8(42)
 1093 02d0 00D0      		rcall flash_write_bus_cycle
 1094               	.LVL70:
 539:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xF0); // Software ID exit
 1095               		.loc 1 539 0
 1096 02d2 60EF      		ldi r22,lo8(-16)
 1097 02d4 85E5      		ldi r24,lo8(85)
 1098 02d6 95E5      		ldi r25,lo8(85)
 1099 02d8 00D0      		rcall flash_write_bus_cycle
 1100               	.LVL71:
 1101               	.LBB64:
 1102               	.LBB65:
 1103               		.loc 2 187 0
 1104 02da 8FE3      		ldi r24,lo8(-25537)
 1105 02dc 9CE9      		ldi r25,hi8(-25537)
 1106 02de 0197      	1:	sbiw r24,1
 1107 02e0 01F4      		brne 1b
 1108 02e2 00C0      		rjmp .
 1109 02e4 0000      		nop
 1110               	.LVL72:
 1111               	/* epilogue start */
 1112               	.LBE65:
 1113               	.LBE64:
 540:setup.c       **** 	_delay_ms(20); // Wait a little (for Atmel chip)
 541:setup.c       **** }
 1114               		.loc 1 541 0
 1115 02e6 DF91      		pop r29
 1116 02e8 CF91      		pop r28
 1117 02ea 0895      		ret
 1118               		.cfi_endproc
 1119               	.LFE31:
 1121               	.global	flash_switch_bank
 1123               	flash_switch_bank:
 1124               	.LFB32:
 542:setup.c       **** 
 543:setup.c       **** // Switch banks on the Flash
 544:setup.c       **** void flash_switch_bank(uint8_t bank) {
 1125               		.loc 1 544 0
 1126               		.cfi_startproc
 1127               	.LVL73:
 1128 02ec CF93      		push r28
 1129               	.LCFI13:
 1130               		.cfi_def_cfa_offset 3
 1131               		.cfi_offset 28, -2
 1132               	/* prologue: function */
 1133               	/* frame size = 0 */
 1134               	/* stack size = 1 */
 1135               	.L__stack_usage = 1
 1136 02ee C82F      		mov r28,r24
 545:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xAA);
 1137               		.loc 1 545 0
 1138 02f0 6AEA      		ldi r22,lo8(-86)
 1139 02f2 85E5      		ldi r24,lo8(85)
 1140 02f4 95E5      		ldi r25,lo8(85)
 1141               	.LVL74:
 1142 02f6 00D0      		rcall flash_write_bus_cycle
 1143               	.LVL75:
 546:setup.c       **** 	flash_write_bus_cycle(0x2AAA, 0x55);
 1144               		.loc 1 546 0
 1145 02f8 65E5      		ldi r22,lo8(85)
 1146 02fa 8AEA      		ldi r24,lo8(-86)
 1147 02fc 9AE2      		ldi r25,lo8(42)
 1148 02fe 00D0      		rcall flash_write_bus_cycle
 1149               	.LVL76:
 547:setup.c       **** 	
 548:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xB0);
 1150               		.loc 1 548 0
 1151 0300 60EB      		ldi r22,lo8(-80)
 1152 0302 85E5      		ldi r24,lo8(85)
 1153 0304 95E5      		ldi r25,lo8(85)
 1154 0306 00D0      		rcall flash_write_bus_cycle
 1155               	.LVL77:
 549:setup.c       **** 	flash_write_bus_cycle(0x0000, bank);
 1156               		.loc 1 549 0
 1157 0308 6C2F      		mov r22,r28
 1158 030a 80E0      		ldi r24,0
 1159 030c 90E0      		ldi r25,0
 1160               	/* epilogue start */
 550:setup.c       **** }
 1161               		.loc 1 550 0
 1162 030e CF91      		pop r28
 1163               	.LVL78:
 549:setup.c       **** 	flash_write_bus_cycle(0x0000, bank);
 1164               		.loc 1 549 0
 1165 0310 00C0      		rjmp flash_write_bus_cycle
 1166               	.LVL79:
 1167               		.cfi_endproc
 1168               	.LFE32:
 1170               	.global	flash_erase_4k_sector
 1172               	flash_erase_4k_sector:
 1173               	.LFB33:
 551:setup.c       **** 
 552:setup.c       **** // Erase 4K sector on Flash, expects first sector to start at 0, left shifts by 12 (A15-A12 to sele
 553:setup.c       **** // Takes 25ms after last command to erase sector
 554:setup.c       **** void flash_erase_4k_sector(uint8_t sector) {
 1174               		.loc 1 554 0
 1175               		.cfi_startproc
 1176               	.LVL80:
 1177 0312 CF93      		push r28
 1178               	.LCFI14:
 1179               		.cfi_def_cfa_offset 3
 1180               		.cfi_offset 28, -2
 1181               	/* prologue: function */
 1182               	/* frame size = 0 */
 1183               	/* stack size = 1 */
 1184               	.L__stack_usage = 1
 1185 0314 C82F      		mov r28,r24
 555:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xAA);
 1186               		.loc 1 555 0
 1187 0316 6AEA      		ldi r22,lo8(-86)
 1188 0318 85E5      		ldi r24,lo8(85)
 1189 031a 95E5      		ldi r25,lo8(85)
 1190               	.LVL81:
 1191 031c 00D0      		rcall flash_write_bus_cycle
 1192               	.LVL82:
 556:setup.c       **** 	flash_write_bus_cycle(0x2AAA, 0x55);
 1193               		.loc 1 556 0
 1194 031e 65E5      		ldi r22,lo8(85)
 1195 0320 8AEA      		ldi r24,lo8(-86)
 1196 0322 9AE2      		ldi r25,lo8(42)
 1197 0324 00D0      		rcall flash_write_bus_cycle
 1198               	.LVL83:
 557:setup.c       **** 	flash_write_bus_cycle(0x5555, 0x80);
 1199               		.loc 1 557 0
 1200 0326 60E8      		ldi r22,lo8(-128)
 1201 0328 85E5      		ldi r24,lo8(85)
 1202 032a 95E5      		ldi r25,lo8(85)
 1203 032c 00D0      		rcall flash_write_bus_cycle
 1204               	.LVL84:
 558:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xAA);
 1205               		.loc 1 558 0
 1206 032e 6AEA      		ldi r22,lo8(-86)
 1207 0330 85E5      		ldi r24,lo8(85)
 1208 0332 95E5      		ldi r25,lo8(85)
 1209 0334 00D0      		rcall flash_write_bus_cycle
 1210               	.LVL85:
 559:setup.c       **** 	flash_write_bus_cycle(0x2AAA, 0x55);
 1211               		.loc 1 559 0
 1212 0336 65E5      		ldi r22,lo8(85)
 1213 0338 8AEA      		ldi r24,lo8(-86)
 1214 033a 9AE2      		ldi r25,lo8(42)
 1215 033c 00D0      		rcall flash_write_bus_cycle
 1216               	.LVL86:
 560:setup.c       **** 	
 561:setup.c       **** 	flash_write_bus_cycle((uint16_t) sector << 12, 0x30);
 1217               		.loc 1 561 0
 1218 033e 60E3      		ldi r22,lo8(48)
 1219 0340 80E0      		ldi r24,0
 1220 0342 9C2F      		mov r25,r28
 1221 0344 9295      		swap r25
 1222 0346 907F      		andi r25,lo8(-16)
 1223 0348 00D0      		rcall flash_write_bus_cycle
 1224               	.LVL87:
 1225               	.LBB66:
 1226               	.LBB67:
 1227               		.loc 2 187 0
 1228 034a 8FE4      		ldi r24,lo8(-15537)
 1229 034c 93EC      		ldi r25,hi8(-15537)
 1230 034e 0197      	1:	sbiw r24,1
 1231 0350 01F4      		brne 1b
 1232 0352 00C0      		rjmp .
 1233 0354 0000      		nop
 1234               	.LVL88:
 1235               	/* epilogue start */
 1236               	.LBE67:
 1237               	.LBE66:
 562:setup.c       **** 	_delay_ms(25); // Wait 25ms for sector erase
 563:setup.c       **** }
 1238               		.loc 1 563 0
 1239 0356 CF91      		pop r28
 1240               	.LVL89:
 1241 0358 0895      		ret
 1242               		.cfi_endproc
 1243               	.LFE33:
 1245               	.global	flash_write_byte
 1247               	flash_write_byte:
 1248               	.LFB34:
 564:setup.c       **** 
 565:setup.c       **** // Write a single byte to the Flash address
 566:setup.c       **** // Takes 20us to program Flash
 567:setup.c       **** void flash_write_byte(uint16_t address, uint8_t data) {
 1249               		.loc 1 567 0
 1250               		.cfi_startproc
 1251               	.LVL90:
 1252 035a 1F93      		push r17
 1253               	.LCFI15:
 1254               		.cfi_def_cfa_offset 3
 1255               		.cfi_offset 17, -2
 1256 035c CF93      		push r28
 1257               	.LCFI16:
 1258               		.cfi_def_cfa_offset 4
 1259               		.cfi_offset 28, -3
 1260 035e DF93      		push r29
 1261               	.LCFI17:
 1262               		.cfi_def_cfa_offset 5
 1263               		.cfi_offset 29, -4
 1264               	/* prologue: function */
 1265               	/* frame size = 0 */
 1266               	/* stack size = 3 */
 1267               	.L__stack_usage = 3
 1268 0360 EC01      		movw r28,r24
 1269 0362 162F      		mov r17,r22
 568:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xAA);
 1270               		.loc 1 568 0
 1271 0364 6AEA      		ldi r22,lo8(-86)
 1272               	.LVL91:
 1273 0366 85E5      		ldi r24,lo8(85)
 1274 0368 95E5      		ldi r25,lo8(85)
 1275               	.LVL92:
 1276 036a 00D0      		rcall flash_write_bus_cycle
 1277               	.LVL93:
 569:setup.c       **** 	flash_write_bus_cycle(0x2AAA, 0x55);
 1278               		.loc 1 569 0
 1279 036c 65E5      		ldi r22,lo8(85)
 1280 036e 8AEA      		ldi r24,lo8(-86)
 1281 0370 9AE2      		ldi r25,lo8(42)
 1282 0372 00D0      		rcall flash_write_bus_cycle
 1283               	.LVL94:
 570:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xA0);
 1284               		.loc 1 570 0
 1285 0374 60EA      		ldi r22,lo8(-96)
 1286 0376 85E5      		ldi r24,lo8(85)
 1287 0378 95E5      		ldi r25,lo8(85)
 1288 037a 00D0      		rcall flash_write_bus_cycle
 1289               	.LVL95:
 571:setup.c       **** 	
 572:setup.c       **** 	flash_write_bus_cycle(address, data);
 1290               		.loc 1 572 0
 1291 037c 612F      		mov r22,r17
 1292 037e CE01      		movw r24,r28
 1293 0380 00D0      		rcall flash_write_bus_cycle
 1294               	.LVL96:
 1295               	.LBB68:
 1296               	.LBB69:
 188:c:\winavr-20100110\avr\include\util\delay.h **** 
 189:c:\winavr-20100110\avr\include\util\delay.h **** #else
 190:c:\winavr-20100110\avr\include\util\delay.h **** 	uint16_t __ticks;
 191:c:\winavr-20100110\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 4e3) * __ms;
 192:c:\winavr-20100110\avr\include\util\delay.h **** 	if (__tmp < 1.0)
 193:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks = 1;
 194:c:\winavr-20100110\avr\include\util\delay.h **** 	else if (__tmp > 65535)
 195:c:\winavr-20100110\avr\include\util\delay.h **** 	{
 196:c:\winavr-20100110\avr\include\util\delay.h **** 		//	__ticks = requested delay in 1/10 ms
 197:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 198:c:\winavr-20100110\avr\include\util\delay.h **** 		while(__ticks)
 199:c:\winavr-20100110\avr\include\util\delay.h **** 		{
 200:c:\winavr-20100110\avr\include\util\delay.h **** 			// wait 1/10 ms
 201:c:\winavr-20100110\avr\include\util\delay.h **** 			_delay_loop_2(((F_CPU) / 4e3) / 10);
 202:c:\winavr-20100110\avr\include\util\delay.h **** 			__ticks --;
 203:c:\winavr-20100110\avr\include\util\delay.h **** 		}
 204:c:\winavr-20100110\avr\include\util\delay.h **** 		return;
 205:c:\winavr-20100110\avr\include\util\delay.h **** 	}
 206:c:\winavr-20100110\avr\include\util\delay.h **** 	else
 207:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks = (uint16_t)__tmp;
 208:c:\winavr-20100110\avr\include\util\delay.h **** 	_delay_loop_2(__ticks);
 209:c:\winavr-20100110\avr\include\util\delay.h **** #endif
 210:c:\winavr-20100110\avr\include\util\delay.h **** }
 211:c:\winavr-20100110\avr\include\util\delay.h **** 
 212:c:\winavr-20100110\avr\include\util\delay.h **** /**
 213:c:\winavr-20100110\avr\include\util\delay.h ****    \ingroup util_delay
 214:c:\winavr-20100110\avr\include\util\delay.h **** 
 215:c:\winavr-20100110\avr\include\util\delay.h ****    Perform a delay of \c __us microseconds, using _delay_loop_1().
 216:c:\winavr-20100110\avr\include\util\delay.h **** 
 217:c:\winavr-20100110\avr\include\util\delay.h ****    The macro F_CPU is supposed to be defined to a
 218:c:\winavr-20100110\avr\include\util\delay.h ****    constant defining the CPU clock frequency (in Hertz).
 219:c:\winavr-20100110\avr\include\util\delay.h **** 
 220:c:\winavr-20100110\avr\include\util\delay.h ****    The maximal possible delay is 768 us / F_CPU in MHz.
 221:c:\winavr-20100110\avr\include\util\delay.h **** 
 222:c:\winavr-20100110\avr\include\util\delay.h ****    If the user requests a delay greater than the maximal possible one,
 223:c:\winavr-20100110\avr\include\util\delay.h ****    _delay_us() will automatically call _delay_ms() instead.  The user
 224:c:\winavr-20100110\avr\include\util\delay.h ****    will not be informed about this case.
 225:c:\winavr-20100110\avr\include\util\delay.h **** 
 226:c:\winavr-20100110\avr\include\util\delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 227:c:\winavr-20100110\avr\include\util\delay.h ****    support, maximal possible delay is 4294967.295 us/ F_CPU in MHz. For
 228:c:\winavr-20100110\avr\include\util\delay.h ****    values greater than the maximal possible delay, overflow results in
 229:c:\winavr-20100110\avr\include\util\delay.h ****    no delay i.e., 0us.
 230:c:\winavr-20100110\avr\include\util\delay.h **** 
 231:c:\winavr-20100110\avr\include\util\delay.h ****    Conversion of \c __us into clock cycles may not always result in
 232:c:\winavr-20100110\avr\include\util\delay.h ****    integer.  By default, the clock cycles rounded up to next
 233:c:\winavr-20100110\avr\include\util\delay.h ****    integer. This ensures that the user gets at least \c __us
 234:c:\winavr-20100110\avr\include\util\delay.h ****    microseconds of delay.
 235:c:\winavr-20100110\avr\include\util\delay.h **** 
 236:c:\winavr-20100110\avr\include\util\delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 237:c:\winavr-20100110\avr\include\util\delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 238:c:\winavr-20100110\avr\include\util\delay.h ****    algorithm can be made to round down, or round to closest integer,
 239:c:\winavr-20100110\avr\include\util\delay.h ****    respectively.
 240:c:\winavr-20100110\avr\include\util\delay.h **** 
 241:c:\winavr-20100110\avr\include\util\delay.h ****    \note
 242:c:\winavr-20100110\avr\include\util\delay.h **** 
 243:c:\winavr-20100110\avr\include\util\delay.h ****    The implementation of _delay_ms() based on
 244:c:\winavr-20100110\avr\include\util\delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 245:c:\winavr-20100110\avr\include\util\delay.h ****    implementations.  In order to get functionality backward compatible
 246:c:\winavr-20100110\avr\include\util\delay.h ****    with previous versions, the macro \c __DELAY_BACKWARD_COMPATIBLE__
 247:c:\winavr-20100110\avr\include\util\delay.h ****    must be defined before including this header file. Also, the
 248:c:\winavr-20100110\avr\include\util\delay.h ****    backward compatible algorithm will be chosen if the code is
 249:c:\winavr-20100110\avr\include\util\delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 250:c:\winavr-20100110\avr\include\util\delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 251:c:\winavr-20100110\avr\include\util\delay.h ****    not available to the compiler then.
 252:c:\winavr-20100110\avr\include\util\delay.h **** 
 253:c:\winavr-20100110\avr\include\util\delay.h ****  */
 254:c:\winavr-20100110\avr\include\util\delay.h **** void
 255:c:\winavr-20100110\avr\include\util\delay.h **** _delay_us(double __us)
 256:c:\winavr-20100110\avr\include\util\delay.h **** {
 257:c:\winavr-20100110\avr\include\util\delay.h **** 	double __tmp ;
 258:c:\winavr-20100110\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 259:c:\winavr-20100110\avr\include\util\delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 260:c:\winavr-20100110\avr\include\util\delay.h ****   __STDC_HOSTED__
 261:c:\winavr-20100110\avr\include\util\delay.h **** 	uint32_t __ticks_dc;
 262:c:\winavr-20100110\avr\include\util\delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 263:c:\winavr-20100110\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 264:c:\winavr-20100110\avr\include\util\delay.h **** 
 265:c:\winavr-20100110\avr\include\util\delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 266:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 267:c:\winavr-20100110\avr\include\util\delay.h **** 
 268:c:\winavr-20100110\avr\include\util\delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 269:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 270:c:\winavr-20100110\avr\include\util\delay.h **** 
 271:c:\winavr-20100110\avr\include\util\delay.h **** 	#else
 272:c:\winavr-20100110\avr\include\util\delay.h **** 		//round up by default
 273:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 274:c:\winavr-20100110\avr\include\util\delay.h **** 	#endif
 275:c:\winavr-20100110\avr\include\util\delay.h **** 
 276:c:\winavr-20100110\avr\include\util\delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 1297               		.loc 2 276 0
 1298 0382 85E3      		ldi r24,lo8(53)
 1299 0384 8A95      	1:	dec r24
 1300 0386 01F4      		brne 1b
 1301 0388 0000      		nop
 1302               	.LVL97:
 1303               	/* epilogue start */
 1304               	.LBE69:
 1305               	.LBE68:
 573:setup.c       **** 	_delay_us(20); // Wait byte program time
 574:setup.c       **** }
 1306               		.loc 1 574 0
 1307 038a DF91      		pop r29
 1308 038c CF91      		pop r28
 1309               	.LVL98:
 1310 038e 1F91      		pop r17
 1311               	.LVL99:
 1312 0390 0895      		ret
 1313               		.cfi_endproc
 1314               	.LFE34:
 1316               	.global	flash_write_sector
 1318               	flash_write_sector:
 1319               	.LFB35:
 575:setup.c       **** 
 576:setup.c       **** // Write a sector (128 bytes) to the Atmel flash
 577:setup.c       **** // Takes 20ms for write cycle
 578:setup.c       **** void flash_write_sector(uint16_t sector) {
 1320               		.loc 1 578 0
 1321               		.cfi_startproc
 1322               	.LVL100:
 1323 0392 EF92      		push r14
 1324               	.LCFI18:
 1325               		.cfi_def_cfa_offset 3
 1326               		.cfi_offset 14, -2
 1327 0394 FF92      		push r15
 1328               	.LCFI19:
 1329               		.cfi_def_cfa_offset 4
 1330               		.cfi_offset 15, -3
 1331 0396 0F93      		push r16
 1332               	.LCFI20:
 1333               		.cfi_def_cfa_offset 5
 1334               		.cfi_offset 16, -4
 1335 0398 1F93      		push r17
 1336               	.LCFI21:
 1337               		.cfi_def_cfa_offset 6
 1338               		.cfi_offset 17, -5
 1339 039a CF93      		push r28
 1340               	.LCFI22:
 1341               		.cfi_def_cfa_offset 7
 1342               		.cfi_offset 28, -6
 1343 039c DF93      		push r29
 1344               	.LCFI23:
 1345               		.cfi_def_cfa_offset 8
 1346               		.cfi_offset 29, -7
 1347               	/* prologue: function */
 1348               	/* frame size = 0 */
 1349               	/* stack size = 6 */
 1350               	.L__stack_usage = 6
 1351 039e 8C01      		movw r16,r24
 579:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xAA);
 1352               		.loc 1 579 0
 1353 03a0 6AEA      		ldi r22,lo8(-86)
 1354 03a2 85E5      		ldi r24,lo8(85)
 1355 03a4 95E5      		ldi r25,lo8(85)
 1356               	.LVL101:
 1357 03a6 00D0      		rcall flash_write_bus_cycle
 1358               	.LVL102:
 580:setup.c       **** 	flash_write_bus_cycle(0x2AAA, 0x55);
 1359               		.loc 1 580 0
 1360 03a8 65E5      		ldi r22,lo8(85)
 1361 03aa 8AEA      		ldi r24,lo8(-86)
 1362 03ac 9AE2      		ldi r25,lo8(42)
 1363 03ae 00D0      		rcall flash_write_bus_cycle
 1364               	.LVL103:
 581:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xA0);
 1365               		.loc 1 581 0
 1366 03b0 60EA      		ldi r22,lo8(-96)
 1367 03b2 85E5      		ldi r24,lo8(85)
 1368 03b4 95E5      		ldi r25,lo8(85)
 1369 03b6 00D0      		rcall flash_write_bus_cycle
 1370               	.LVL104:
 1371               	.LBB70:
 582:setup.c       **** 	
 583:setup.c       **** 	// Write the bytes (A0-A6 byte address, A7-A15 sector address)
 584:setup.c       **** 	for (uint8_t x = 0; x < 128; x++) {
 585:setup.c       **** 		flash_write_bus_cycle((uint16_t) (sector << 7) | (uint16_t) x, receivedBuffer[x]);
 1372               		.loc 1 585 0
 1373 03b8 1695      		lsr r17
 1374 03ba 102F      		mov r17,r16
 1375 03bc 0027      		clr r16
 1376 03be 1795      		ror r17
 1377 03c0 0795      		ror r16
 1378               	.LVL105:
 1379 03c2 90E0      		ldi r25,lo8(receivedBuffer)
 1380 03c4 E92E      		mov r14,r25
 1381 03c6 90E0      		ldi r25,hi8(receivedBuffer)
 1382 03c8 F92E      		mov r15,r25
 1383 03ca C0E0      		ldi r28,0
 1384 03cc D0E0      		ldi r29,0
 1385               	.LVL106:
 1386               	.L66:
 1387               		.loc 1 585 0 is_stmt 0 discriminator 3
 1388 03ce F701      		movw r30,r14
 1389 03d0 6191      		ld r22,Z+
 1390 03d2 7F01      		movw r14,r30
 1391 03d4 CE01      		movw r24,r28
 1392 03d6 802B      		or r24,r16
 1393 03d8 912B      		or r25,r17
 1394 03da 00D0      		rcall flash_write_bus_cycle
 1395               	.LVL107:
 1396 03dc 2196      		adiw r28,1
 1397               	.LVL108:
 584:setup.c       **** 		flash_write_bus_cycle((uint16_t) (sector << 7) | (uint16_t) x, receivedBuffer[x]);
 1398               		.loc 1 584 0 is_stmt 1 discriminator 3
 1399 03de C038      		cpi r28,-128
 1400 03e0 D105      		cpc r29,__zero_reg__
 1401 03e2 01F4      		brne .L66
 1402               	.LVL109:
 1403               	.LBE70:
 1404               	.LBB71:
 1405               	.LBB72:
 187:c:\winavr-20100110\avr\include\util\delay.h **** 
 1406               		.loc 2 187 0
 1407 03e4 8FE3      		ldi r24,lo8(-25537)
 1408 03e6 9CE9      		ldi r25,hi8(-25537)
 1409 03e8 0197      	1:	sbiw r24,1
 1410 03ea 01F4      		brne 1b
 1411 03ec 00C0      		rjmp .
 1412 03ee 0000      		nop
 1413               	.LVL110:
 1414               	/* epilogue start */
 1415               	.LBE72:
 1416               	.LBE71:
 586:setup.c       **** 	}
 587:setup.c       **** 	_delay_ms(20); // Wait sector program time
 588:setup.c       **** }
 1417               		.loc 1 588 0
 1418 03f0 DF91      		pop r29
 1419 03f2 CF91      		pop r28
 1420               	.LVL111:
 1421 03f4 1F91      		pop r17
 1422 03f6 0F91      		pop r16
 1423 03f8 FF90      		pop r15
 1424 03fa EF90      		pop r14
 1425 03fc 0895      		ret
 1426               		.cfi_endproc
 1427               	.LFE35:
 1429               	.global	audio_flash_write_bus_cycle
 1431               	audio_flash_write_bus_cycle:
 1432               	.LFB36:
 589:setup.c       **** 
 590:setup.c       **** 
 591:setup.c       **** 
 592:setup.c       **** // ---------- GB FLASH CARTS ----------
 593:setup.c       **** 
 594:setup.c       **** // 32K Audio WE - Set the address and data for the write byte cycle to the flash (pulsing audio pin
 595:setup.c       **** void audio_flash_write_bus_cycle(uint16_t address, uint8_t data) {
 1433               		.loc 1 595 0
 1434               		.cfi_startproc
 1435               	.LVL112:
 1436 03fe CF93      		push r28
 1437               	.LCFI24:
 1438               		.cfi_def_cfa_offset 3
 1439               		.cfi_offset 28, -2
 1440               	/* prologue: function */
 1441               	/* frame size = 0 */
 1442               	/* stack size = 1 */
 1443               	.L__stack_usage = 1
 1444 0400 C62F      		mov r28,r22
 596:setup.c       **** 	GBA_DDR_RAM_DATA7_0 = 0xFF; // Set data pins as outputs
 1445               		.loc 1 596 0
 1446 0402 2FEF      		ldi r18,lo8(-1)
 1447 0404 24BB      		out 0x14,r18
 597:setup.c       **** 	set_16bit_address(address);
 1448               		.loc 1 597 0
 1449 0406 00D0      		rcall set_16bit_address
 1450               	.LVL113:
 598:setup.c       **** 	GBA_PORT_RAM_DATA7_0 = data;
 1451               		.loc 1 598 0
 1452 0408 C5BB      		out 0x15,r28
 599:setup.c       **** 	
 600:setup.c       **** 	audioPin_low; // WE low
 1453               		.loc 1 600 0
 1454 040a 3998      		cbi 0x7,1
 601:setup.c       **** 	asm volatile("nop");
 1455               		.loc 1 601 0
 1456               	/* #APP */
 1457               	 ;  601 "setup.c" 1
 1458 040c 0000      		nop
 1459               	 ;  0 "" 2
 602:setup.c       **** 	asm volatile("nop");
 1460               		.loc 1 602 0
 1461               	 ;  602 "setup.c" 1
 1462 040e 0000      		nop
 1463               	 ;  0 "" 2
 603:setup.c       **** 	asm volatile("nop");
 1464               		.loc 1 603 0
 1465               	 ;  603 "setup.c" 1
 1466 0410 0000      		nop
 1467               	 ;  0 "" 2
 604:setup.c       **** 	audioPin_high; // WE high
 1468               		.loc 1 604 0
 1469               	/* #NOAPP */
 1470 0412 399A      		sbi 0x7,1
 1471               	/* epilogue start */
 605:setup.c       **** }
 1472               		.loc 1 605 0
 1473 0414 CF91      		pop r28
 1474               	.LVL114:
 1475 0416 0895      		ret
 1476               		.cfi_endproc
 1477               	.LFE36:
 1479               	.global	audio_flash_write_byte
 1481               	audio_flash_write_byte:
 1482               	.LFB37:
 606:setup.c       **** 
 607:setup.c       **** // 32K Audio WE - Write a single byte to the Flash address. Takes 20us to program Flash.
 608:setup.c       **** void audio_flash_write_byte(uint16_t address, uint8_t data) {
 1483               		.loc 1 608 0
 1484               		.cfi_startproc
 1485               	.LVL115:
 1486 0418 1F93      		push r17
 1487               	.LCFI25:
 1488               		.cfi_def_cfa_offset 3
 1489               		.cfi_offset 17, -2
 1490 041a CF93      		push r28
 1491               	.LCFI26:
 1492               		.cfi_def_cfa_offset 4
 1493               		.cfi_offset 28, -3
 1494 041c DF93      		push r29
 1495               	.LCFI27:
 1496               		.cfi_def_cfa_offset 5
 1497               		.cfi_offset 29, -4
 1498               	/* prologue: function */
 1499               	/* frame size = 0 */
 1500               	/* stack size = 3 */
 1501               	.L__stack_usage = 3
 1502 041e EC01      		movw r28,r24
 1503 0420 162F      		mov r17,r22
 609:setup.c       **** 	audio_flash_write_bus_cycle(0x555, 0xAA);
 1504               		.loc 1 609 0
 1505 0422 6AEA      		ldi r22,lo8(-86)
 1506               	.LVL116:
 1507 0424 85E5      		ldi r24,lo8(85)
 1508 0426 95E0      		ldi r25,lo8(5)
 1509               	.LVL117:
 1510 0428 00D0      		rcall audio_flash_write_bus_cycle
 1511               	.LVL118:
 610:setup.c       **** 	audio_flash_write_bus_cycle(0x2AA, 0x55);
 1512               		.loc 1 610 0
 1513 042a 65E5      		ldi r22,lo8(85)
 1514 042c 8AEA      		ldi r24,lo8(-86)
 1515 042e 92E0      		ldi r25,lo8(2)
 1516 0430 00D0      		rcall audio_flash_write_bus_cycle
 1517               	.LVL119:
 611:setup.c       **** 	audio_flash_write_bus_cycle(0x555, 0xA0);
 1518               		.loc 1 611 0
 1519 0432 60EA      		ldi r22,lo8(-96)
 1520 0434 85E5      		ldi r24,lo8(85)
 1521 0436 95E0      		ldi r25,lo8(5)
 1522 0438 00D0      		rcall audio_flash_write_bus_cycle
 1523               	.LVL120:
 612:setup.c       **** 	audio_flash_write_bus_cycle(address, data);
 1524               		.loc 1 612 0
 1525 043a 612F      		mov r22,r17
 1526 043c CE01      		movw r24,r28
 1527 043e 00D0      		rcall audio_flash_write_bus_cycle
 1528               	.LVL121:
 1529               	.LBB73:
 1530               	.LBB74:
 1531               		.loc 2 276 0
 1532 0440 85E3      		ldi r24,lo8(53)
 1533 0442 8A95      	1:	dec r24
 1534 0444 01F4      		brne 1b
 1535 0446 0000      		nop
 1536               	.LVL122:
 1537               	/* epilogue start */
 1538               	.LBE74:
 1539               	.LBE73:
 613:setup.c       **** 	_delay_us(20); // Wait byte program time
 614:setup.c       **** }
 1540               		.loc 1 614 0
 1541 0448 DF91      		pop r29
 1542 044a CF91      		pop r28
 1543               	.LVL123:
 1544 044c 1F91      		pop r17
 1545               	.LVL124:
 1546 044e 0895      		ret
 1547               		.cfi_endproc
 1548               	.LFE37:
 1550               	.global	bv5_flash_write_bus_cycle
 1552               	bv5_flash_write_bus_cycle:
 1553               	.LFB38:
 615:setup.c       **** 
 616:setup.c       **** // BV5 - Set the address and data for the write byte cycle to the flash (pulsing WR pin)
 617:setup.c       **** void bv5_flash_write_bus_cycle(uint16_t address, uint8_t data) {
 1554               		.loc 1 617 0
 1555               		.cfi_startproc
 1556               	.LVL125:
 1557 0450 CF93      		push r28
 1558               	.LCFI28:
 1559               		.cfi_def_cfa_offset 3
 1560               		.cfi_offset 28, -2
 1561               	/* prologue: function */
 1562               	/* frame size = 0 */
 1563               	/* stack size = 1 */
 1564               	.L__stack_usage = 1
 1565 0452 C62F      		mov r28,r22
 618:setup.c       **** 	GBA_DDR_RAM_DATA7_0 = 0xFF; // Set data pins as outputs
 1566               		.loc 1 618 0
 1567 0454 2FEF      		ldi r18,lo8(-1)
 1568 0456 24BB      		out 0x14,r18
 619:setup.c       **** 	set_16bit_address(address);
 1569               		.loc 1 619 0
 1570 0458 00D0      		rcall set_16bit_address
 1571               	.LVL126:
 620:setup.c       **** 	GBA_PORT_RAM_DATA7_0 = data;
 1572               		.loc 1 620 0
 1573 045a C5BB      		out 0x15,r28
 621:setup.c       **** 	
 622:setup.c       **** 	wrPin_low;
 1574               		.loc 1 622 0
 1575 045c 9698      		cbi 0x12,6
 623:setup.c       **** 	asm volatile("nop");
 1576               		.loc 1 623 0
 1577               	/* #APP */
 1578               	 ;  623 "setup.c" 1
 1579 045e 0000      		nop
 1580               	 ;  0 "" 2
 624:setup.c       **** 	asm volatile("nop");
 1581               		.loc 1 624 0
 1582               	 ;  624 "setup.c" 1
 1583 0460 0000      		nop
 1584               	 ;  0 "" 2
 625:setup.c       **** 	asm volatile("nop");
 1585               		.loc 1 625 0
 1586               	 ;  625 "setup.c" 1
 1587 0462 0000      		nop
 1588               	 ;  0 "" 2
 626:setup.c       **** 	wrPin_high;
 1589               		.loc 1 626 0
 1590               	/* #NOAPP */
 1591 0464 969A      		sbi 0x12,6
 1592               	/* epilogue start */
 627:setup.c       **** }
 1593               		.loc 1 627 0
 1594 0466 CF91      		pop r28
 1595               	.LVL127:
 1596 0468 0895      		ret
 1597               		.cfi_endproc
 1598               	.LFE38:
 1600               	.global	bv5_flash_write_byte
 1602               	bv5_flash_write_byte:
 1603               	.LFB39:
 628:setup.c       **** 
 629:setup.c       **** // BV5 - Write a single byte to the Flash address. Time to wait depends on Flash.
 630:setup.c       **** // Data byte's bit 0 & 1 are swapped for chip commands as D0 & D1 lines are swapped
 631:setup.c       **** void bv5_flash_write_byte(uint16_t address, uint8_t data) {
 1604               		.loc 1 631 0
 1605               		.cfi_startproc
 1606               	.LVL128:
 1607 046a 1F93      		push r17
 1608               	.LCFI29:
 1609               		.cfi_def_cfa_offset 3
 1610               		.cfi_offset 17, -2
 1611 046c CF93      		push r28
 1612               	.LCFI30:
 1613               		.cfi_def_cfa_offset 4
 1614               		.cfi_offset 28, -3
 1615 046e DF93      		push r29
 1616               	.LCFI31:
 1617               		.cfi_def_cfa_offset 5
 1618               		.cfi_offset 29, -4
 1619               	/* prologue: function */
 1620               	/* frame size = 0 */
 1621               	/* stack size = 3 */
 1622               	.L__stack_usage = 3
 1623 0470 EC01      		movw r28,r24
 1624 0472 162F      		mov r17,r22
 632:setup.c       **** 	bv5_flash_write_bus_cycle(0xAAA, 0xA9);
 1625               		.loc 1 632 0
 1626 0474 69EA      		ldi r22,lo8(-87)
 1627               	.LVL129:
 1628 0476 8AEA      		ldi r24,lo8(-86)
 1629 0478 9AE0      		ldi r25,lo8(10)
 1630               	.LVL130:
 1631 047a 00D0      		rcall bv5_flash_write_bus_cycle
 1632               	.LVL131:
 633:setup.c       **** 	bv5_flash_write_bus_cycle(0x555, 0x56);
 1633               		.loc 1 633 0
 1634 047c 66E5      		ldi r22,lo8(86)
 1635 047e 85E5      		ldi r24,lo8(85)
 1636 0480 95E0      		ldi r25,lo8(5)
 1637 0482 00D0      		rcall bv5_flash_write_bus_cycle
 1638               	.LVL132:
 634:setup.c       **** 	bv5_flash_write_bus_cycle(0xAAA, 0xA0);
 1639               		.loc 1 634 0
 1640 0484 60EA      		ldi r22,lo8(-96)
 1641 0486 8AEA      		ldi r24,lo8(-86)
 1642 0488 9AE0      		ldi r25,lo8(10)
 1643 048a 00D0      		rcall bv5_flash_write_bus_cycle
 1644               	.LVL133:
 635:setup.c       **** 	bv5_flash_write_bus_cycle(address, data);
 1645               		.loc 1 635 0
 1646 048c 612F      		mov r22,r17
 1647 048e CE01      		movw r24,r28
 1648 0490 00D0      		rcall bv5_flash_write_bus_cycle
 1649               	.LVL134:
 1650               	.LBB75:
 1651               	.LBB76:
 1652               		.loc 2 276 0
 1653 0492 85E3      		ldi r24,lo8(53)
 1654 0494 8A95      	1:	dec r24
 1655 0496 01F4      		brne 1b
 1656 0498 0000      		nop
 1657               	.LVL135:
 1658               	/* epilogue start */
 1659               	.LBE76:
 1660               	.LBE75:
 636:setup.c       **** 	_delay_us(20); // Wait byte program time
 637:setup.c       **** }
 1661               		.loc 1 637 0
 1662 049a DF91      		pop r29
 1663 049c CF91      		pop r28
 1664               	.LVL136:
 1665 049e 1F91      		pop r17
 1666               	.LVL137:
 1667 04a0 0895      		ret
 1668               		.cfi_endproc
 1669               	.LFE39:
 1671               	.global	gba_flash_write_bus_cycle
 1673               	gba_flash_write_bus_cycle:
 1674               	.LFB40:
 638:setup.c       **** 
 639:setup.c       **** 
 640:setup.c       **** // ---------- GBA FLASH CARTS ----------
 641:setup.c       **** 
 642:setup.c       **** // Set the 24 bit address and 16 bit data for the write byte cycle to the flash (pulse WR pin)
 643:setup.c       **** void gba_flash_write_bus_cycle(uint32_t address, uint16_t data) {
 1675               		.loc 1 643 0
 1676               		.cfi_startproc
 1677               	.LVL138:
 1678 04a2 CF93      		push r28
 1679               	.LCFI32:
 1680               		.cfi_def_cfa_offset 3
 1681               		.cfi_offset 28, -2
 1682 04a4 DF93      		push r29
 1683               	.LCFI33:
 1684               		.cfi_def_cfa_offset 4
 1685               		.cfi_offset 29, -3
 1686               	/* prologue: function */
 1687               	/* frame size = 0 */
 1688               	/* stack size = 2 */
 1689               	.L__stack_usage = 2
 1690 04a6 EA01      		movw r28,r20
 644:setup.c       **** 	gba_set_24bit_address(address);
 1691               		.loc 1 644 0
 1692 04a8 00D0      		rcall gba_set_24bit_address
 1693               	.LVL139:
 645:setup.c       **** 	
 646:setup.c       **** 	cs_mreqPin_low;
 1694               		.loc 1 646 0
 1695 04aa 9498      		cbi 0x12,4
 647:setup.c       **** 	
 648:setup.c       **** 	GBA_DDR_ROM_ADDR15_8 = 0xFF; // Set data pins as outputs
 1696               		.loc 1 648 0
 1697 04ac 8FEF      		ldi r24,lo8(-1)
 1698 04ae 8ABB      		out 0x1a,r24
 649:setup.c       **** 	GBA_DDR_ROM_ADDR7_0 = 0xFF;
 1699               		.loc 1 649 0
 1700 04b0 87BB      		out 0x17,r24
 650:setup.c       **** 	GBA_PORT_ROM_DATA15_8 = data >> 8; // Set data
 1701               		.loc 1 650 0
 1702 04b2 DBBB      		out 0x1b,r29
 651:setup.c       **** 	GBA_PORT_ROM_DATA7_0 = data & 0xFF;
 1703               		.loc 1 651 0
 1704 04b4 C8BB      		out 0x18,r28
 652:setup.c       **** 	
 653:setup.c       **** 	wrPin_low;
 1705               		.loc 1 653 0
 1706 04b6 9698      		cbi 0x12,6
 654:setup.c       **** 	asm volatile("nop");
 1707               		.loc 1 654 0
 1708               	/* #APP */
 1709               	 ;  654 "setup.c" 1
 1710 04b8 0000      		nop
 1711               	 ;  0 "" 2
 655:setup.c       **** 	asm volatile("nop");
 1712               		.loc 1 655 0
 1713               	 ;  655 "setup.c" 1
 1714 04ba 0000      		nop
 1715               	 ;  0 "" 2
 656:setup.c       **** 	asm volatile("nop");
 1716               		.loc 1 656 0
 1717               	 ;  656 "setup.c" 1
 1718 04bc 0000      		nop
 1719               	 ;  0 "" 2
 657:setup.c       **** 	wrPin_high;
 1720               		.loc 1 657 0
 1721               	/* #NOAPP */
 1722 04be 969A      		sbi 0x12,6
 658:setup.c       **** 	cs_mreqPin_high;
 1723               		.loc 1 658 0
 1724 04c0 949A      		sbi 0x12,4
 1725               	/* epilogue start */
 659:setup.c       **** }
 1726               		.loc 1 659 0
 1727 04c2 DF91      		pop r29
 1728 04c4 CF91      		pop r28
 1729               	.LVL140:
 1730 04c6 0895      		ret
 1731               		.cfi_endproc
 1732               	.LFE40:
 1734               	.global	gba_flash_write_byte_swapped
 1736               	gba_flash_write_byte_swapped:
 1737               	.LFB41:
 660:setup.c       **** 
 661:setup.c       **** // Write a 2 bytes to the Flash address. Time to wait depends on Flash.
 662:setup.c       **** // Address is divided by 2 as we are in GBA mode. 
 663:setup.c       **** // Data byte's bit 0 & 1 are swapped for chip commands as D0 & D1 lines are swapped
 664:setup.c       **** void gba_flash_write_byte_swapped(uint32_t address, uint16_t data) {
 1738               		.loc 1 664 0
 1739               		.cfi_startproc
 1740               	.LVL141:
 1741 04c8 CF92      		push r12
 1742               	.LCFI34:
 1743               		.cfi_def_cfa_offset 3
 1744               		.cfi_offset 12, -2
 1745 04ca DF92      		push r13
 1746               	.LCFI35:
 1747               		.cfi_def_cfa_offset 4
 1748               		.cfi_offset 13, -3
 1749 04cc EF92      		push r14
 1750               	.LCFI36:
 1751               		.cfi_def_cfa_offset 5
 1752               		.cfi_offset 14, -4
 1753 04ce FF92      		push r15
 1754               	.LCFI37:
 1755               		.cfi_def_cfa_offset 6
 1756               		.cfi_offset 15, -5
 1757 04d0 CF93      		push r28
 1758               	.LCFI38:
 1759               		.cfi_def_cfa_offset 7
 1760               		.cfi_offset 28, -6
 1761 04d2 DF93      		push r29
 1762               	.LCFI39:
 1763               		.cfi_def_cfa_offset 8
 1764               		.cfi_offset 29, -7
 1765               	/* prologue: function */
 1766               	/* frame size = 0 */
 1767               	/* stack size = 6 */
 1768               	.L__stack_usage = 6
 1769 04d4 6B01      		movw r12,r22
 1770 04d6 7C01      		movw r14,r24
 1771 04d8 EA01      		movw r28,r20
 665:setup.c       **** 	gba_flash_write_bus_cycle(0xAAA / 2, 0xA9);
 1772               		.loc 1 665 0
 1773 04da 49EA      		ldi r20,lo8(-87)
 1774 04dc 50E0      		ldi r21,0
 1775               	.LVL142:
 1776 04de 65E5      		ldi r22,lo8(85)
 1777 04e0 75E0      		ldi r23,lo8(5)
 1778 04e2 80E0      		ldi r24,0
 1779 04e4 90E0      		ldi r25,0
 1780               	.LVL143:
 1781 04e6 00D0      		rcall gba_flash_write_bus_cycle
 1782               	.LVL144:
 666:setup.c       **** 	gba_flash_write_bus_cycle(0x555 / 2, 0x56);
 1783               		.loc 1 666 0
 1784 04e8 46E5      		ldi r20,lo8(86)
 1785 04ea 50E0      		ldi r21,0
 1786 04ec 6AEA      		ldi r22,lo8(-86)
 1787 04ee 72E0      		ldi r23,lo8(2)
 1788 04f0 80E0      		ldi r24,0
 1789 04f2 90E0      		ldi r25,0
 1790 04f4 00D0      		rcall gba_flash_write_bus_cycle
 1791               	.LVL145:
 667:setup.c       **** 	gba_flash_write_bus_cycle(0xAAA / 2, 0xA0);
 1792               		.loc 1 667 0
 1793 04f6 40EA      		ldi r20,lo8(-96)
 1794 04f8 50E0      		ldi r21,0
 1795 04fa 65E5      		ldi r22,lo8(85)
 1796 04fc 75E0      		ldi r23,lo8(5)
 1797 04fe 80E0      		ldi r24,0
 1798 0500 90E0      		ldi r25,0
 1799 0502 00D0      		rcall gba_flash_write_bus_cycle
 1800               	.LVL146:
 668:setup.c       **** 	gba_flash_write_bus_cycle(address, data);
 1801               		.loc 1 668 0
 1802 0504 AE01      		movw r20,r28
 1803 0506 C701      		movw r24,r14
 1804 0508 B601      		movw r22,r12
 1805 050a 00D0      		rcall gba_flash_write_bus_cycle
 1806               	.LVL147:
 1807               	.LBB77:
 1808               	.LBB78:
 1809               		.loc 2 276 0
 1810 050c 85E8      		ldi r24,lo8(-123)
 1811 050e 8A95      	1:	dec r24
 1812 0510 01F4      		brne 1b
 1813 0512 0000      		nop
 1814               	.LVL148:
 1815               	/* epilogue start */
 1816               	.LBE78:
 1817               	.LBE77:
 669:setup.c       **** 	_delay_us(50); // Wait byte program time
 670:setup.c       **** }
 1818               		.loc 1 670 0
 1819 0514 DF91      		pop r29
 1820 0516 CF91      		pop r28
 1821               	.LVL149:
 1822 0518 FF90      		pop r15
 1823 051a EF90      		pop r14
 1824 051c DF90      		pop r13
 1825 051e CF90      		pop r12
 1826               	.LVL150:
 1827 0520 0895      		ret
 1828               		.cfi_endproc
 1829               	.LFE41:
 1831               	.global	setup
 1833               	setup:
 1834               	.LFB42:
 671:setup.c       **** 
 672:setup.c       **** 
 673:setup.c       **** // Setup
 674:setup.c       **** void setup(void) {
 1835               		.loc 1 674 0
 1836               		.cfi_startproc
 1837               	/* prologue: function */
 1838               	/* frame size = 0 */
 1839               	/* stack size = 0 */
 1840               	.L__stack_usage = 0
 675:setup.c       **** 	// Turn off watchdog
 676:setup.c       **** 	MCUCSR &= ~(1<<WDRF);
 1841               		.loc 1 676 0
 1842 0522 84B7      		in r24,0x34
 1843 0524 877F      		andi r24,lo8(-9)
 1844 0526 84BF      		out 0x34,r24
 677:setup.c       **** 	WDTCR = (1<<WDCE) | (1<<WDE);
 1845               		.loc 1 677 0
 1846 0528 88E1      		ldi r24,lo8(24)
 1847 052a 81BD      		out 0x21,r24
 678:setup.c       **** 	WDTCR = 0;
 1848               		.loc 1 678 0
 1849 052c 11BC      		out 0x21,__zero_reg__
 679:setup.c       **** 	
 680:setup.c       **** 	// Reset common lines
 681:setup.c       **** 	rd_wr_csmreq_cs2_reset();
 1850               		.loc 1 681 0
 1851 052e 00D0      		rcall rd_wr_csmreq_cs2_reset
 1852               	.LVL151:
 682:setup.c       **** 	
 683:setup.c       **** 	// Set outputs
 684:setup.c       **** 	DDRD |= (1<<ACTIVITY_LED) | (1<<WR_PIN) | (1<<RD_PIN) | (1<<CS_MREQ_PIN) | (1<<LED_5V);
 1853               		.loc 1 684 0
 1854 0530 81B3      		in r24,0x11
 1855 0532 886F      		ori r24,lo8(-8)
 1856 0534 81BB      		out 0x11,r24
 685:setup.c       **** 	DDRE |= (1<<CS2_PIN) | (1<<LED_3V);
 1857               		.loc 1 685 0
 1858 0536 86B1      		in r24,0x6
 1859 0538 8560      		ori r24,lo8(5)
 1860 053a 86B9      		out 0x6,r24
 686:setup.c       **** 	
 687:setup.c       **** 	// Set all pins as inputs
 688:setup.c       **** 	PORT_DATA7_0 = 0;
 1861               		.loc 1 688 0
 1862 053c 15BA      		out 0x15,__zero_reg__
 689:setup.c       **** 	DDR_DATA7_0 = 0;
 1863               		.loc 1 689 0
 1864 053e 14BA      		out 0x14,__zero_reg__
 690:setup.c       **** 	PORT_ADDR7_0 = 0;
 1865               		.loc 1 690 0
 1866 0540 18BA      		out 0x18,__zero_reg__
 691:setup.c       **** 	DDR_ADDR7_0 = 0;
 1867               		.loc 1 691 0
 1868 0542 17BA      		out 0x17,__zero_reg__
 692:setup.c       **** 	PORT_ADDR15_8 = 0;
 1869               		.loc 1 692 0
 1870 0544 1BBA      		out 0x1b,__zero_reg__
 693:setup.c       **** 	DDR_ADDR15_8 = 0;
 1871               		.loc 1 693 0
 1872 0546 1ABA      		out 0x1a,__zero_reg__
 694:setup.c       **** 	
 695:setup.c       **** 	// Light up 3.3V or 5V
 696:setup.c       **** 	if (PIND & (1<<SWITCH_DETECT)) {
 1873               		.loc 1 696 0
 1874 0548 829B      		sbis 0x10,2
 1875 054a 00C0      		rjmp .L75
 697:setup.c       **** 		PORTD |= (1<<LED_5V);
 1876               		.loc 1 697 0
 1877 054c 979A      		sbi 0x12,7
 698:setup.c       **** 		PORTE &= ~(1<<LED_3V);
 1878               		.loc 1 698 0
 1879 054e 3898      		cbi 0x7,0
 1880 0550 00C0      		rjmp .L76
 1881               	.L75:
 699:setup.c       **** 	}
 700:setup.c       **** 	else {
 701:setup.c       **** 		PORTE |= (1<<LED_3V);
 1882               		.loc 1 701 0
 1883 0552 389A      		sbi 0x7,0
 702:setup.c       **** 		PORTD &= ~(1<<LED_5V);
 1884               		.loc 1 702 0
 1885 0554 9798      		cbi 0x12,7
 1886               	.L76:
 703:setup.c       **** 	}
 704:setup.c       **** 	
 705:setup.c       **** 	// Light LED
 706:setup.c       **** 	PORTD |= (1<<ACTIVITY_LED);
 1887               		.loc 1 706 0
 1888 0556 939A      		sbi 0x12,3
 1889               	.LVL152:
 1890               	.LBB79:
 1891               	.LBB80:
 187:c:\winavr-20100110\avr\include\util\delay.h **** 
 1892               		.loc 2 187 0
 1893 0558 2FEF      		ldi r18,lo8(799999)
 1894 055a 84E3      		ldi r24,hi8(799999)
 1895 055c 9CE0      		ldi r25,hlo8(799999)
 1896 055e 2150      	1:	subi r18,1
 1897 0560 8040      		sbci r24,0
 1898 0562 9040      		sbci r25,0
 1899 0564 01F4      		brne 1b
 1900 0566 00C0      		rjmp .
 1901 0568 0000      		nop
 1902               	.LVL153:
 1903               	.LBE80:
 1904               	.LBE79:
 707:setup.c       **** 	_delay_ms(500);
 708:setup.c       **** 	PORTD &= ~(1<<ACTIVITY_LED);
 1905               		.loc 1 708 0
 1906 056a 9398      		cbi 0x12,3
 709:setup.c       **** 	
 710:setup.c       **** 	// Setup USART
 711:setup.c       **** 	UBRRL = 0; // 1Mbps Baud rate
 1907               		.loc 1 711 0
 1908 056c 19B8      		out 0x9,__zero_reg__
 712:setup.c       **** 	sbi(UCSRA, U2X); // Double rate
 1909               		.loc 1 712 0
 1910 056e 599A      		sbi 0xb,1
 713:setup.c       **** 	sbi(UCSRB, TXEN); // Transmitter enable
 1911               		.loc 1 713 0
 1912 0570 539A      		sbi 0xa,3
 714:setup.c       **** 	sbi(UCSRB, RXEN); // Receiver enable
 1913               		.loc 1 714 0
 1914 0572 549A      		sbi 0xa,4
 715:setup.c       **** 	
 716:setup.c       **** 	// Turn on interrupts
 717:setup.c       **** 	sei();
 1915               		.loc 1 717 0
 1916               	/* #APP */
 1917               	 ;  717 "setup.c" 1
 1918 0574 7894      		sei
 1919               	 ;  0 "" 2
 1920               	/* #NOAPP */
 1921 0576 0895      		ret
 1922               		.cfi_endproc
 1923               	.LFE42:
 1925               		.section	.text.startup,"ax",@progbits
 1926               	.global	main
 1928               	main:
 1929               	.LFB43:
 1930               		.file 3 "main.c"
   1:main.c        **** /*
   2:main.c        ****  GBxCart RW
   3:main.c        ****  PCB version: 1.1
   4:main.c        ****  Firmware version: R5
   5:main.c        ****  Author: Alex from insideGadgets (www.insidegadgets.com)
   6:main.c        ****  Created: 7/11/2016
   7:main.c        ****  Last Modified: 5/12/2017
   8:main.c        ****  
   9:main.c        ****  GBxCart RW allows you to dump your Gameboy/Gameboy Colour/Gameboy Advance games ROM, save the RAM 
  10:main.c        ****  
  11:main.c        ****  The ATmega8515L talks to the cartridge and interfaces with the CH340G serial to USB converter with
  12:main.c        ****  
  13:main.c        ****  
  14:main.c        ****  Set fuse bits: External 8MHz crystal, divide clock by 8 is off, boot loader is on (512 bytes), BOD
  15:main.c        ****  avrdude -p atmega8515 -c usbasp -U lfuse:w:0xaf:m -U hfuse:w:0xda:m
  16:main.c        ****  
  17:main.c        ****  Program the TinySafeBoot boot loader (modified ASM code, watchdog reset will act as a hardware res
  18:main.c        ****  avrdude -p atmega8515 -c usbasp -U flash:w:GBxCart_RW_v1.1_R3\tsb\tsb_m8515_d0d1_resetwdt.hex
  19:main.c        ****  
  20:main.c        ****  Program GBxCart RW through TinySafeBoot
  21:main.c        ****  tsb com16:57600 fw GBxCart_RW_v1.1_R3\main.hex
  22:main.c        ****  
  23:main.c        ****  Set TinySafeBoot delay time to 25 (T 25), gives ~0.5s in bootloader
  24:main.c        ****  tsb com16:9600 T 25
  25:main.c        ****  
  26:main.c        ****  
  27:main.c        ****  Programming shortcuts (if added in Programmers Notepad):
  28:main.c        ****  Alt + W - Program fuse
  29:main.c        ****  Alt + B - Burn bootloader
  30:main.c        ****  
  31:main.c        ****  Plug in USB then
  32:main.c        ****  Alt + T - Program
  33:main.c        ****  Alt + N - Program delay settings
  34:main.c        ****  
  35:main.c        ****  
  36:main.c        ****  */
  37:main.c        **** 
  38:main.c        **** // ATmega8515L Pin Map
  39:main.c        **** //
  40:main.c        **** // VCC (5)			GND (6)			XTAL (7 ,8)		Activity LED PD3 (9)				Switch sense PD2 (8)
  41:main.c        **** // SCK PB7 (3)		MOSI PB5 (1)	MISO PB6 (2)	RST (4)		RXD PD0 (5)			TXD PD1 (7)
  42:main.c        **** // 
  43:main.c        **** // Gameboy / Gameboy Colour
  44:main.c        **** // A0-A7 PB0-7 (40-44, 1-3) 		A8-A15 PA0-7 (37-30)			D0-D7 PC0-7 (18-25)		Audio PE1 (27)
  45:main.c        **** // 
  46:main.c        **** // Gameboy Advance
  47:main.c        **** // AD0-AD7 PB0-7 (40-44, 1-3) 	AD8-AD15 PA0-7 (37-30)		A16-23 / D0-D7 PC0-7 (19-26)
  48:main.c        **** // *WR PD6 (13)						*RD PD5 (14)					*MREQ/CS PD4 (15)			CS2/RST PE2 (16)
  49:main.c        **** 
  50:main.c        **** #define F_CPU 8000000 // 8 MHz
  51:main.c        **** #define PCB_VERSION 2
  52:main.c        **** #define FIRMWARE_VERSION 5
  53:main.c        **** 
  54:main.c        **** #include <avr/io.h>
  55:main.c        **** #include <avr/wdt.h>
  56:main.c        **** #include <avr/eeprom.h>
  57:main.c        **** #include <avr/interrupt.h>
  58:main.c        **** #include <avr/sleep.h>
  59:main.c        **** #include <util/delay.h>
  60:main.c        **** #include <stdlib.h>
  61:main.c        **** #include <string.h>
  62:main.c        **** #include "setup.c" // See defines, variables, constants, functions here
  63:main.c        **** 
  64:main.c        **** 
  65:main.c        **** int main(void) {
 1931               		.loc 3 65 0
 1932               		.cfi_startproc
 1933               	/* prologue: function */
 1934               	/* frame size = 0 */
 1935               	/* stack size = 0 */
 1936               	.L__stack_usage = 0
  66:main.c        **** 	setup();
 1937               		.loc 3 66 0
 1938 0000 00D0      		rcall setup
 1939               	.LVL154:
  67:main.c        **** 	
  68:main.c        **** 	uint32_t address = 0;
  69:main.c        **** 	uint8_t eepromSize = EEPROM_4KBIT;
  70:main.c        **** 	uint8_t cartMode = GB_MODE;
  71:main.c        **** 	uint8_t resetCommonLines = 1;
 1940               		.loc 3 71 0
 1941 0002 8824      		clr r8
 1942 0004 8394      		inc r8
  69:main.c        **** 	uint8_t cartMode = GB_MODE;
 1943               		.loc 3 69 0
 1944 0006 9924      		clr r9
 1945 0008 9394      		inc r9
  68:main.c        **** 	uint8_t eepromSize = EEPROM_4KBIT;
 1946               		.loc 3 68 0
 1947 000a C12C      		mov r12,__zero_reg__
 1948 000c D12C      		mov r13,__zero_reg__
 1949 000e 7601      		movw r14,r12
 1950 0010 30E0      		ldi r19,lo8(receivedBuffer+64)
 1951 0012 632E      		mov r6,r19
 1952 0014 30E0      		ldi r19,hi8(receivedBuffer+64)
 1953 0016 732E      		mov r7,r19
 1954 0018 00E0      		ldi r16,lo8(eepromBuffer+8)
 1955 001a 10E0      		ldi r17,hi8(eepromBuffer+8)
 1956               	.LVL155:
 1957               	.L78:
  72:main.c        **** 	
  73:main.c        **** 	while(1) {
  74:main.c        **** 		if (resetCommonLines == 1) {
 1958               		.loc 3 74 0
 1959 001c 21E0      		ldi r18,lo8(1)
 1960 001e 8212      		cpse r8,r18
 1961 0020 00C0      		rjmp .L79
 1962               	.LVL156:
 1963               	.L179:
  75:main.c        **** 			rd_wr_csmreq_cs2_reset();
 1964               		.loc 3 75 0
 1965 0022 00D0      		rcall rd_wr_csmreq_cs2_reset
 1966               	.LVL157:
 1967               	.L79:
  76:main.c        **** 		}
  77:main.c        **** 		receivedChar = USART_Receive(); // Wait for 1 byte of data
 1968               		.loc 3 77 0
 1969 0024 00D0      		rcall USART_Receive
 1970               	.LVL158:
 1971 0026 8093 0000 		sts receivedChar,r24
  78:main.c        **** 		
  79:main.c        **** 		// Read the pin to find out which mode we are in, if it reads high, we are powered by 5V
  80:main.c        **** 		if (PIND & (1<<SWITCH_DETECT)) {
 1972               		.loc 3 80 0
 1973 002a 829B      		sbis 0x10,2
 1974 002c 00C0      		rjmp .L80
 1975               	.LVL159:
  81:main.c        **** 			cartMode = GB_MODE;
  82:main.c        **** 			PORTD |= (1<<LED_5V);
 1976               		.loc 3 82 0
 1977 002e 979A      		sbi 0x12,7
  83:main.c        **** 			PORTE &= ~(1<<LED_3V);
 1978               		.loc 3 83 0
 1979 0030 3898      		cbi 0x7,0
  81:main.c        **** 			cartMode = GB_MODE;
 1980               		.loc 3 81 0
 1981 0032 81E0      		ldi r24,lo8(1)
 1982 0034 00C0      		rjmp .L81
 1983               	.LVL160:
 1984               	.L80:
  84:main.c        **** 		}
  85:main.c        **** 		else {
  86:main.c        **** 			cartMode = GBA_MODE;
  87:main.c        **** 			PORTE |= (1<<LED_3V);
 1985               		.loc 3 87 0
 1986 0036 389A      		sbi 0x7,0
  88:main.c        **** 			PORTD &= ~(1<<LED_5V);
 1987               		.loc 3 88 0
 1988 0038 9798      		cbi 0x12,7
  86:main.c        **** 			PORTE |= (1<<LED_3V);
 1989               		.loc 3 86 0
 1990 003a 82E0      		ldi r24,lo8(2)
 1991               	.LVL161:
 1992               	.L81:
  89:main.c        **** 		}
  90:main.c        **** 		
  91:main.c        **** 		// Return the cart mode in use
  92:main.c        **** 		if (receivedChar == CART_MODE) {
 1993               		.loc 3 92 0
 1994 003c 9091 0000 		lds r25,receivedChar
 1995 0040 9334      		cpi r25,lo8(67)
 1996 0042 01F4      		brne .+2
 1997 0044 00C0      		rjmp .L180
  93:main.c        **** 			USART_Transmit(cartMode);
  94:main.c        **** 		}
  95:main.c        **** 		
  96:main.c        **** 		// Change to GB mode or GBA mode if requested
  97:main.c        **** 		else if (receivedChar == GB_CART_MODE) {
 1998               		.loc 3 97 0
 1999 0046 9734      		cpi r25,lo8(71)
 2000 0048 01F4      		brne .L84
  98:main.c        **** 			gb_mode();
 2001               		.loc 3 98 0
 2002 004a 00D0      		rcall gb_mode
 2003               	.LVL162:
 2004 004c 00C0      		rjmp .L78
 2005               	.LVL163:
 2006               	.L84:
  99:main.c        **** 		}
 100:main.c        **** 		else if (receivedChar == GBA_CART_MODE) {
 2007               		.loc 3 100 0
 2008 004e 9736      		cpi r25,lo8(103)
 2009 0050 01F4      		brne .+2
 2010 0052 00C0      		rjmp .L182
 101:main.c        **** 			gba_mode();
 102:main.c        **** 		}
 103:main.c        **** 		
 104:main.c        **** 		// Set address
 105:main.c        **** 		else if (receivedChar == SET_START_ADDRESS) {
 2011               		.loc 3 105 0
 2012 0054 9134      		cpi r25,lo8(65)
 2013 0056 01F4      		brne .L86
 106:main.c        **** 			usart_read_chars(); // Read start address
 2014               		.loc 3 106 0
 2015 0058 00D0      		rcall usart_read_chars
 2016               	.LVL164:
 107:main.c        **** 			address = strtol(receivedBuffer, NULL, 16); // Convert address string in hex to dec
 2017               		.loc 3 107 0
 2018 005a 40E1      		ldi r20,lo8(16)
 2019 005c 50E0      		ldi r21,0
 2020 005e 60E0      		ldi r22,0
 2021 0060 70E0      		ldi r23,0
 2022 0062 80E0      		ldi r24,lo8(receivedBuffer)
 2023 0064 90E0      		ldi r25,hi8(receivedBuffer)
 2024 0066 00D0      		rcall strtol
 2025               	.LVL165:
 2026 0068 6B01      		movw r12,r22
 2027 006a 7C01      		movw r14,r24
 2028               	.LVL166:
 2029 006c 00C0      		rjmp .L78
 2030               	.LVL167:
 2031               	.L86:
 108:main.c        **** 		}
 109:main.c        **** 		
 110:main.c        **** 		
 111:main.c        **** 		// ****** Gameboy / Gameboy Colour ******
 112:main.c        **** 		
 113:main.c        **** 		// Read 64 bytes of ROM/RAM from address (and increment) until anything but 1 is received
 114:main.c        **** 		else if (receivedChar == READ_ROM_RAM) {
 2032               		.loc 3 114 0
 2033 006e 9235      		cpi r25,lo8(82)
 2034 0070 01F4      		brne .L87
 115:main.c        **** 			gb_mode();
 2035               		.loc 3 115 0
 2036 0072 00D0      		rcall gb_mode
 2037               	.LVL168:
 116:main.c        **** 			receivedChar = '1';
 2038               		.loc 3 116 0
 2039 0074 81E3      		ldi r24,lo8(49)
 2040               	.LVL169:
 2041               	.L185:
 117:main.c        **** 			while (receivedChar == '1') {
 118:main.c        **** 				PORTD |= (1<<ACTIVITY_LED);
 119:main.c        **** 				for (uint8_t x = 0; x < 64; x++) {
 120:main.c        **** 					USART_Transmit(read_8bit_data(address));
 121:main.c        **** 					address++;
 122:main.c        **** 				}
 123:main.c        **** 				
 124:main.c        **** 				PORTD &= ~(1<<ACTIVITY_LED);
 125:main.c        **** 				receivedChar = USART_Receive();
 2042               		.loc 3 125 0
 2043 0076 8093 0000 		sts receivedChar,r24
 2044               	.LVL170:
 117:main.c        **** 			while (receivedChar == '1') {
 2045               		.loc 3 117 0
 2046 007a 8091 0000 		lds r24,receivedChar
 2047 007e 8133      		cpi r24,lo8(49)
 2048 0080 01F4      		brne .L78
 118:main.c        **** 				for (uint8_t x = 0; x < 64; x++) {
 2049               		.loc 3 118 0
 2050 0082 939A      		sbi 0x12,3
 2051               	.LVL171:
 2052 0084 C0E0      		ldi r28,0
 2053 0086 D0E0      		ldi r29,0
 2054               	.LVL172:
 2055               	.L89:
 2056               	.LBB81:
 120:main.c        **** 					address++;
 2057               		.loc 3 120 0 discriminator 3
 2058 0088 CE01      		movw r24,r28
 2059 008a 8C0D      		add r24,r12
 2060 008c 9D1D      		adc r25,r13
 2061 008e 00D0      		rcall read_8bit_data
 2062               	.LVL173:
 2063 0090 00D0      		rcall USART_Transmit
 2064               	.LVL174:
 2065 0092 2196      		adiw r28,1
 2066               	.LVL175:
 119:main.c        **** 					USART_Transmit(read_8bit_data(address));
 2067               		.loc 3 119 0 discriminator 3
 2068 0094 C034      		cpi r28,64
 2069 0096 D105      		cpc r29,__zero_reg__
 2070 0098 01F4      		brne .L89
 2071 009a 80E4      		ldi r24,64
 2072 009c C80E      		add r12,r24
 2073 009e D11C      		adc r13,__zero_reg__
 2074 00a0 E11C      		adc r14,__zero_reg__
 2075 00a2 F11C      		adc r15,__zero_reg__
 2076               	.LBE81:
 124:main.c        **** 				receivedChar = USART_Receive();
 2077               		.loc 3 124 0
 2078 00a4 9398      		cbi 0x12,3
 2079               		.loc 3 125 0
 2080 00a6 00D0      		rcall USART_Receive
 2081               	.LVL176:
 2082 00a8 00C0      		rjmp .L185
 2083               	.LVL177:
 2084               	.L87:
 126:main.c        **** 			}
 127:main.c        **** 		}
 128:main.c        **** 		
 129:main.c        **** 		// Write 64 bytes to RAM on address (and increment)
 130:main.c        **** 		else if (receivedChar == WRITE_RAM) {
 2085               		.loc 3 130 0
 2086 00aa 9735      		cpi r25,lo8(87)
 2087 00ac 01F4      		brne .L91
 131:main.c        **** 			gb_mode();
 2088               		.loc 3 131 0
 2089 00ae 00D0      		rcall gb_mode
 2090               	.LVL178:
 132:main.c        **** 			
 133:main.c        **** 			// Read 64 bytes first as CH340G sends them all at once
 134:main.c        **** 			usart_read_bytes(64);
 2091               		.loc 3 134 0
 2092 00b0 80E4      		ldi r24,lo8(64)
 2093 00b2 00D0      		rcall usart_read_bytes
 2094               	.LVL179:
 135:main.c        **** 			
 136:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 2095               		.loc 3 136 0
 2096 00b4 939A      		sbi 0x12,3
 2097               	.LVL180:
 2098 00b6 C0E0      		ldi r28,lo8(receivedBuffer)
 2099 00b8 D0E0      		ldi r29,hi8(receivedBuffer)
 2100 00ba A12C      		mov r10,__zero_reg__
 2101 00bc B12C      		mov r11,__zero_reg__
 2102               	.LVL181:
 2103               	.L92:
 2104               	.LBB82:
 137:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 138:main.c        **** 				write_8bit_data(address, receivedBuffer[x], MEMORY_WRITE);
 2105               		.loc 3 138 0 discriminator 3
 2106 00be 6991      		ld r22,Y+
 2107 00c0 C501      		movw r24,r10
 2108 00c2 8C0D      		add r24,r12
 2109 00c4 9D1D      		adc r25,r13
 2110 00c6 41E0      		ldi r20,lo8(1)
 2111 00c8 00D0      		rcall write_8bit_data
 2112               	.LVL182:
 2113 00ca 9FEF      		ldi r25,-1
 2114 00cc A91A      		sub r10,r25
 2115 00ce B90A      		sbc r11,r25
 2116               	.LVL183:
 137:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 2117               		.loc 3 137 0 discriminator 3
 2118 00d0 E0E4      		ldi r30,64
 2119 00d2 AE16      		cp r10,r30
 2120 00d4 B104      		cpc r11,__zero_reg__
 2121 00d6 01F4      		brne .L92
 2122 00d8 F0E4      		ldi r31,64
 2123 00da CF0E      		add r12,r31
 2124 00dc D11C      		adc r13,__zero_reg__
 2125 00de E11C      		adc r14,__zero_reg__
 2126 00e0 F11C      		adc r15,__zero_reg__
 2127 00e2 00C0      		rjmp .L202
 2128               	.LVL184:
 2129               	.L91:
 2130               	.LBE82:
 139:main.c        **** 				address++;
 140:main.c        **** 			}
 141:main.c        **** 			
 142:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 143:main.c        **** 			USART_Transmit('1'); // Send back acknowledgement
 144:main.c        **** 		}
 145:main.c        **** 		
 146:main.c        **** 		// Set bank address and write a byte
 147:main.c        **** 		else if (receivedChar == SET_BANK) {
 2131               		.loc 3 147 0
 2132 00e4 9234      		cpi r25,lo8(66)
 2133 00e6 01F4      		brne .L93
 2134               	.LBB83:
 148:main.c        **** 			gb_mode();
 2135               		.loc 3 148 0
 2136 00e8 00D0      		rcall gb_mode
 2137               	.LVL185:
 149:main.c        **** 			
 150:main.c        **** 			usart_read_chars(); // Read start address
 2138               		.loc 3 150 0
 2139 00ea 00D0      		rcall usart_read_chars
 2140               	.LVL186:
 151:main.c        **** 			uint16_t bankaddress = strtol(receivedBuffer, NULL, 16); // Convert address string in hex to dec
 2141               		.loc 3 151 0
 2142 00ec 40E1      		ldi r20,lo8(16)
 2143 00ee 50E0      		ldi r21,0
 2144 00f0 60E0      		ldi r22,0
 2145 00f2 70E0      		ldi r23,0
 2146 00f4 80E0      		ldi r24,lo8(receivedBuffer)
 2147 00f6 90E0      		ldi r25,hi8(receivedBuffer)
 2148 00f8 00D0      		rcall strtol
 2149               	.LVL187:
 2150 00fa 1B01      		movw r2,r22
 2151 00fc 2C01      		movw r4,r24
 2152               	.LVL188:
 152:main.c        **** 			
 153:main.c        **** 			receivedChar = USART_Receive(); // Wait for bank number
 2153               		.loc 3 153 0
 2154 00fe 00D0      		rcall USART_Receive
 2155               	.LVL189:
 2156 0100 8093 0000 		sts receivedChar,r24
 154:main.c        **** 			if (receivedChar == 'B') {
 2157               		.loc 3 154 0
 2158 0104 8234      		cpi r24,lo8(66)
 2159 0106 01F0      		breq .+2
 2160 0108 00C0      		rjmp .L78
 2161               	.LBB84:
 155:main.c        **** 				usart_read_chars(); // Read data
 2162               		.loc 3 155 0
 2163 010a 00D0      		rcall usart_read_chars
 2164               	.LVL190:
 156:main.c        **** 				uint8_t data = atoi(receivedBuffer); // Convert data string to dec
 2165               		.loc 3 156 0
 2166 010c 80E0      		ldi r24,lo8(receivedBuffer)
 2167 010e 90E0      		ldi r25,hi8(receivedBuffer)
 2168 0110 00D0      		rcall atoi
 2169               	.LVL191:
 157:main.c        **** 				
 158:main.c        **** 				write_8bit_data(bankaddress, data, BANK_WRITE);
 2170               		.loc 3 158 0
 2171 0112 40E0      		ldi r20,0
 2172 0114 682F      		mov r22,r24
 2173 0116 C101      		movw r24,r2
 2174               	.LVL192:
 2175 0118 00D0      		rcall write_8bit_data
 2176               	.LVL193:
 2177 011a 00C0      		rjmp .L78
 2178               	.LVL194:
 2179               	.L93:
 2180               	.LBE84:
 2181               	.LBE83:
 159:main.c        **** 			}
 160:main.c        **** 		}
 161:main.c        **** 		
 162:main.c        **** 		
 163:main.c        **** 		// ****** Gameboy Advance ******
 164:main.c        **** 		
 165:main.c        **** 		// ---------- ROM ----------
 166:main.c        **** 		// Read one 16bit byte from ROM using address (and increment) until anything but 1 is received
 167:main.c        **** 		else if (receivedChar == GBA_READ_ROM) {
 2182               		.loc 3 167 0
 2183 011c 9237      		cpi r25,lo8(114)
 2184 011e 01F4      		brne .L94
 168:main.c        **** 			gba_mode(); 
 2185               		.loc 3 168 0
 2186 0120 00D0      		rcall gba_mode
 2187               	.LVL195:
 169:main.c        **** 			
 170:main.c        **** 			receivedChar = '1';
 2188               		.loc 3 170 0
 2189 0122 81E3      		ldi r24,lo8(49)
 2190               	.LVL196:
 2191               	.L186:
 171:main.c        **** 			while (receivedChar == '1') {
 172:main.c        **** 				PORTD |= (1<<ACTIVITY_LED);
 173:main.c        **** 				for (uint8_t x = 0; x < 32; x++) {
 174:main.c        **** 					uint16_t dataRead = gba_read_16bit_data(address);
 175:main.c        **** 					
 176:main.c        **** 					// Low byte & High byte
 177:main.c        **** 					USART_Transmit(dataRead & 0xFF);
 178:main.c        **** 					USART_Transmit(dataRead >> 8);
 179:main.c        **** 					
 180:main.c        **** 					address++;
 181:main.c        **** 				}
 182:main.c        **** 				
 183:main.c        **** 				PORTD &= ~(1<<ACTIVITY_LED);
 184:main.c        **** 				receivedChar = USART_Receive();
 2192               		.loc 3 184 0
 2193 0124 8093 0000 		sts receivedChar,r24
 2194               	.LVL197:
 171:main.c        **** 			while (receivedChar == '1') {
 2195               		.loc 3 171 0
 2196 0128 8091 0000 		lds r24,receivedChar
 2197 012c 8133      		cpi r24,lo8(49)
 2198 012e 01F0      		breq .+2
 2199 0130 00C0      		rjmp .L78
 172:main.c        **** 				for (uint8_t x = 0; x < 32; x++) {
 2200               		.loc 3 172 0
 2201 0132 939A      		sbi 0x12,3
 2202               	.LVL198:
 2203 0134 1601      		movw r2,r12
 2204 0136 2701      		movw r4,r14
 2205 0138 C0E2      		ldi r28,lo8(32)
 2206               	.LVL199:
 2207               	.L96:
 2208               	.LBB85:
 2209               	.LBB86:
 174:main.c        **** 					
 2210               		.loc 3 174 0 discriminator 3
 2211 013a C201      		movw r24,r4
 2212 013c B101      		movw r22,r2
 2213 013e 00D0      		rcall gba_read_16bit_data
 2214               	.LVL200:
 2215 0140 D92F      		mov r29,r25
 2216               	.LVL201:
 177:main.c        **** 					USART_Transmit(dataRead >> 8);
 2217               		.loc 3 177 0 discriminator 3
 2218 0142 00D0      		rcall USART_Transmit
 2219               	.LVL202:
 178:main.c        **** 					
 2220               		.loc 3 178 0 discriminator 3
 2221 0144 8D2F      		mov r24,r29
 2222 0146 00D0      		rcall USART_Transmit
 2223               	.LVL203:
 180:main.c        **** 				}
 2224               		.loc 3 180 0 discriminator 3
 2225 0148 2FEF      		ldi r18,-1
 2226 014a 221A      		sub r2,r18
 2227 014c 320A      		sbc r3,r18
 2228 014e 420A      		sbc r4,r18
 2229 0150 520A      		sbc r5,r18
 2230               	.LVL204:
 2231 0152 C150      		subi r28,lo8(-(-1))
 2232               	.LBE86:
 173:main.c        **** 					uint16_t dataRead = gba_read_16bit_data(address);
 2233               		.loc 3 173 0 discriminator 3
 2234 0154 01F4      		brne .L96
 2235 0156 80E2      		ldi r24,32
 2236 0158 C80E      		add r12,r24
 2237 015a D11C      		adc r13,__zero_reg__
 2238 015c E11C      		adc r14,__zero_reg__
 2239 015e F11C      		adc r15,__zero_reg__
 2240               	.LVL205:
 2241               	.LBE85:
 183:main.c        **** 				receivedChar = USART_Receive();
 2242               		.loc 3 183 0
 2243 0160 9398      		cbi 0x12,3
 2244               		.loc 3 184 0
 2245 0162 00D0      		rcall USART_Receive
 2246               	.LVL206:
 2247 0164 00C0      		rjmp .L186
 2248               	.LVL207:
 2249               	.L94:
 185:main.c        **** 			}
 186:main.c        **** 		}
 187:main.c        **** 		
 188:main.c        **** 		
 189:main.c        **** 		// ---------- SRAM ----------
 190:main.c        **** 		// Read RAM from address (and increment) until anything but 1 is received
 191:main.c        **** 		else if (receivedChar == GBA_READ_SRAM) {
 2250               		.loc 3 191 0
 2251 0166 9D36      		cpi r25,lo8(109)
 2252 0168 01F4      		brne .L98
 192:main.c        **** 			gb_mode(); // Set GB mode as it uses 16 bit address with 8 bit data
 2253               		.loc 3 192 0
 2254 016a 00D0      		rcall gb_mode
 2255               	.LVL208:
 193:main.c        **** 			
 194:main.c        **** 			receivedChar = '1';
 2256               		.loc 3 194 0
 2257 016c 81E3      		ldi r24,lo8(49)
 2258               	.LVL209:
 2259               	.L187:
 195:main.c        **** 			while (receivedChar == '1') {
 196:main.c        **** 				PORTD |= (1<<ACTIVITY_LED);
 197:main.c        **** 				for (uint8_t x = 0; x < 64; x++) {
 198:main.c        **** 					USART_Transmit(gba_read_ram_8bit_data(address));
 199:main.c        **** 					address++;
 200:main.c        **** 				}
 201:main.c        **** 				
 202:main.c        **** 				PORTD &= ~(1<<ACTIVITY_LED);
 203:main.c        **** 				receivedChar = USART_Receive();
 2260               		.loc 3 203 0
 2261 016e 8093 0000 		sts receivedChar,r24
 2262               	.LVL210:
 195:main.c        **** 			while (receivedChar == '1') {
 2263               		.loc 3 195 0
 2264 0172 8091 0000 		lds r24,receivedChar
 2265 0176 8133      		cpi r24,lo8(49)
 2266 0178 01F4      		brne .L182
 196:main.c        **** 				for (uint8_t x = 0; x < 64; x++) {
 2267               		.loc 3 196 0
 2268 017a 939A      		sbi 0x12,3
 2269               	.LVL211:
 2270 017c C0E0      		ldi r28,0
 2271 017e D0E0      		ldi r29,0
 2272               	.LVL212:
 2273               	.L100:
 2274               	.LBB87:
 198:main.c        **** 					address++;
 2275               		.loc 3 198 0 discriminator 3
 2276 0180 CE01      		movw r24,r28
 2277 0182 8C0D      		add r24,r12
 2278 0184 9D1D      		adc r25,r13
 2279 0186 00D0      		rcall gba_read_ram_8bit_data
 2280               	.LVL213:
 2281 0188 00D0      		rcall USART_Transmit
 2282               	.LVL214:
 2283 018a 2196      		adiw r28,1
 2284               	.LVL215:
 197:main.c        **** 					USART_Transmit(gba_read_ram_8bit_data(address));
 2285               		.loc 3 197 0 discriminator 3
 2286 018c C034      		cpi r28,64
 2287 018e D105      		cpc r29,__zero_reg__
 2288 0190 01F4      		brne .L100
 2289 0192 90E4      		ldi r25,64
 2290 0194 C90E      		add r12,r25
 2291 0196 D11C      		adc r13,__zero_reg__
 2292 0198 E11C      		adc r14,__zero_reg__
 2293 019a F11C      		adc r15,__zero_reg__
 2294               	.LBE87:
 202:main.c        **** 				receivedChar = USART_Receive();
 2295               		.loc 3 202 0
 2296 019c 9398      		cbi 0x12,3
 2297               		.loc 3 203 0
 2298 019e 00D0      		rcall USART_Receive
 2299               	.LVL216:
 2300 01a0 00C0      		rjmp .L187
 2301               	.LVL217:
 2302               	.L98:
 204:main.c        **** 			}
 205:main.c        **** 			
 206:main.c        **** 			gba_mode(); // Set back
 207:main.c        **** 		}
 208:main.c        **** 		
 209:main.c        **** 		// Write to RAM on address (and increment) with 64 bytes of data
 210:main.c        **** 		else if (receivedChar == GBA_WRITE_SRAM) {
 2303               		.loc 3 210 0
 2304 01a2 9737      		cpi r25,lo8(119)
 2305 01a4 01F4      		brne .L102
 211:main.c        **** 			gb_mode();
 2306               		.loc 3 211 0
 2307 01a6 00D0      		rcall gb_mode
 2308               	.LVL218:
 212:main.c        **** 			
 213:main.c        **** 			usart_read_bytes(64);
 2309               		.loc 3 213 0
 2310 01a8 80E4      		ldi r24,lo8(64)
 2311 01aa 00D0      		rcall usart_read_bytes
 2312               	.LVL219:
 214:main.c        **** 			
 215:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 2313               		.loc 3 215 0
 2314 01ac 939A      		sbi 0x12,3
 2315               	.LVL220:
 2316 01ae C0E0      		ldi r28,lo8(receivedBuffer)
 2317 01b0 D0E0      		ldi r29,hi8(receivedBuffer)
 2318 01b2 A12C      		mov r10,__zero_reg__
 2319 01b4 B12C      		mov r11,__zero_reg__
 2320               	.LVL221:
 2321               	.L103:
 2322               	.LBB88:
 216:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 217:main.c        **** 				gba_write_ram_8bit_data(address, receivedBuffer[x]);
 2323               		.loc 3 217 0 discriminator 3
 2324 01b6 6991      		ld r22,Y+
 2325 01b8 C501      		movw r24,r10
 2326 01ba 8C0D      		add r24,r12
 2327 01bc 9D1D      		adc r25,r13
 2328 01be 00D0      		rcall gba_write_ram_8bit_data
 2329               	.LVL222:
 2330 01c0 EFEF      		ldi r30,-1
 2331 01c2 AE1A      		sub r10,r30
 2332 01c4 BE0A      		sbc r11,r30
 2333               	.LVL223:
 216:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 2334               		.loc 3 216 0 discriminator 3
 2335 01c6 F0E4      		ldi r31,64
 2336 01c8 AF16      		cp r10,r31
 2337 01ca B104      		cpc r11,__zero_reg__
 2338 01cc 01F4      		brne .L103
 2339 01ce 20E4      		ldi r18,64
 2340 01d0 C20E      		add r12,r18
 2341 01d2 D11C      		adc r13,__zero_reg__
 2342 01d4 E11C      		adc r14,__zero_reg__
 2343 01d6 F11C      		adc r15,__zero_reg__
 2344               	.LVL224:
 2345               	.L184:
 2346               	.LBE88:
 218:main.c        **** 				address++;
 219:main.c        **** 			}
 220:main.c        **** 			USART_Transmit('1'); // Send back acknowledgement
 2347               		.loc 3 220 0
 2348 01d8 81E3      		ldi r24,lo8(49)
 2349 01da 00D0      		rcall USART_Transmit
 2350               	.LVL225:
 221:main.c        **** 			
 222:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 2351               		.loc 3 222 0
 2352 01dc 9398      		cbi 0x12,3
 2353               	.L182:
 223:main.c        **** 			gba_mode(); // Set back
 2354               		.loc 3 223 0
 2355 01de 00D0      		rcall gba_mode
 2356               	.LVL226:
 2357 01e0 00C0      		rjmp .L78
 2358               	.LVL227:
 2359               	.L102:
 224:main.c        **** 		}
 225:main.c        **** 		
 226:main.c        **** 		// Write 1 byte to SRAM address
 227:main.c        **** 		else if (receivedChar == GBA_WRITE_ONE_BYTE_SRAM) {
 2360               		.loc 3 227 0
 2361 01e2 9F36      		cpi r25,lo8(111)
 2362 01e4 01F4      		brne .L104
 2363               	.LBB89:
 228:main.c        **** 			gb_mode();
 2364               		.loc 3 228 0
 2365 01e6 00D0      		rcall gb_mode
 2366               	.LVL228:
 229:main.c        **** 			
 230:main.c        **** 			uint8_t data = USART_Receive();
 2367               		.loc 3 230 0
 2368 01e8 00D0      		rcall USART_Receive
 2369               	.LVL229:
 231:main.c        **** 			gba_write_ram_8bit_data(address, data);
 2370               		.loc 3 231 0
 2371 01ea 682F      		mov r22,r24
 2372 01ec C601      		movw r24,r12
 2373               	.LVL230:
 2374 01ee 00D0      		rcall gba_write_ram_8bit_data
 2375               	.LVL231:
 2376 01f0 00C0      		rjmp .L189
 2377               	.LVL232:
 2378               	.L104:
 2379               	.LBE89:
 232:main.c        **** 			USART_Transmit('1'); // Send back acknowledgement
 233:main.c        **** 			
 234:main.c        **** 			gba_mode(); // Set back
 235:main.c        **** 		}
 236:main.c        **** 		
 237:main.c        **** 		
 238:main.c        **** 		// ---------- FLASH ----------
 239:main.c        **** 		// Read the Flash Manufacturer and Device ID
 240:main.c        **** 		else if (receivedChar == GBA_FLASH_READ_ID) {
 2380               		.loc 3 240 0
 2381 01f2 9936      		cpi r25,lo8(105)
 2382 01f4 01F4      		brne .L105
 241:main.c        **** 			gb_mode();
 2383               		.loc 3 241 0
 2384 01f6 00D0      		rcall gb_mode
 2385               	.LVL233:
 242:main.c        **** 			
 243:main.c        **** 			flash_read_chip_id();
 2386               		.loc 3 243 0
 2387 01f8 00D0      		rcall flash_read_chip_id
 2388               	.LVL234:
 244:main.c        **** 			USART_Transmit(flashChipIdBuffer[0]);
 2389               		.loc 3 244 0
 2390 01fa 8091 0000 		lds r24,flashChipIdBuffer
 2391 01fe 00D0      		rcall USART_Transmit
 2392               	.LVL235:
 245:main.c        **** 			USART_Transmit(flashChipIdBuffer[1]);
 2393               		.loc 3 245 0
 2394 0200 8091 0000 		lds r24,flashChipIdBuffer+1
 2395               	.L188:
 2396 0204 00D0      		rcall USART_Transmit
 2397               	.LVL236:
 2398 0206 00C0      		rjmp .L182
 2399               	.LVL237:
 2400               	.L105:
 246:main.c        **** 			
 247:main.c        **** 			gba_mode(); // Set back
 248:main.c        **** 		}
 249:main.c        **** 		
 250:main.c        **** 		// Change bank
 251:main.c        **** 		else if (receivedChar == GBA_FLASH_SET_BANK) {
 2401               		.loc 3 251 0
 2402 0208 9B36      		cpi r25,lo8(107)
 2403 020a 01F4      		brne .L106
 2404               	.LBB90:
 252:main.c        **** 			usart_read_chars(); // Read data
 2405               		.loc 3 252 0
 2406 020c 00D0      		rcall usart_read_chars
 2407               	.LVL238:
 253:main.c        **** 			uint8_t bank = atoi(receivedBuffer); // Convert data string to dec
 2408               		.loc 3 253 0
 2409 020e 80E0      		ldi r24,lo8(receivedBuffer)
 2410 0210 90E0      		ldi r25,hi8(receivedBuffer)
 2411 0212 00D0      		rcall atoi
 2412               	.LVL239:
 2413 0214 C82F      		mov r28,r24
 2414               	.LVL240:
 254:main.c        **** 			
 255:main.c        **** 			gb_mode();
 2415               		.loc 3 255 0
 2416 0216 00D0      		rcall gb_mode
 2417               	.LVL241:
 256:main.c        **** 			flash_switch_bank(bank);
 2418               		.loc 3 256 0
 2419 0218 8C2F      		mov r24,r28
 2420 021a 00D0      		rcall flash_switch_bank
 2421               	.LVL242:
 2422 021c 00C0      		rjmp .L182
 2423               	.LVL243:
 2424               	.L106:
 2425               	.LBE90:
 257:main.c        **** 			
 258:main.c        **** 			gba_mode(); // Set back
 259:main.c        **** 		}
 260:main.c        **** 		
 261:main.c        **** 		// Erase 4K sector on Flash (sector 0 to 15 for 512Kbit)
 262:main.c        **** 		else if (receivedChar == GBA_FLASH_4K_SECTOR_ERASE) {
 2426               		.loc 3 262 0
 2427 021e 9337      		cpi r25,lo8(115)
 2428 0220 01F4      		brne .L107
 2429               	.LBB91:
 263:main.c        **** 			gb_mode();
 2430               		.loc 3 263 0
 2431 0222 00D0      		rcall gb_mode
 2432               	.LVL244:
 264:main.c        **** 			
 265:main.c        **** 			usart_read_chars(); // Read sector
 2433               		.loc 3 265 0
 2434 0224 00D0      		rcall usart_read_chars
 2435               	.LVL245:
 266:main.c        **** 			uint8_t sectorAddress = strtol(receivedBuffer, NULL, 16); // Convert address string in hex to de
 2436               		.loc 3 266 0
 2437 0226 40E1      		ldi r20,lo8(16)
 2438 0228 50E0      		ldi r21,0
 2439 022a 60E0      		ldi r22,0
 2440 022c 70E0      		ldi r23,0
 2441 022e 80E0      		ldi r24,lo8(receivedBuffer)
 2442 0230 90E0      		ldi r25,hi8(receivedBuffer)
 2443 0232 00D0      		rcall strtol
 2444               	.LVL246:
 2445 0234 862F      		mov r24,r22
 2446               	.LVL247:
 267:main.c        **** 			
 268:main.c        **** 			flash_erase_4k_sector(sectorAddress);
 2447               		.loc 3 268 0
 2448 0236 00D0      		rcall flash_erase_4k_sector
 2449               	.LVL248:
 2450               	.L189:
 269:main.c        **** 			USART_Transmit('1'); // Send back acknowledgement
 2451               		.loc 3 269 0
 2452 0238 81E3      		ldi r24,lo8(49)
 2453 023a 00C0      		rjmp .L188
 2454               	.LVL249:
 2455               	.L107:
 2456               	.LBE91:
 270:main.c        **** 			
 271:main.c        **** 			gba_mode(); // Set back
 272:main.c        **** 		}
 273:main.c        **** 		
 274:main.c        **** 		// Write 64 bytes to Flash address one byte write at a time (and increment)
 275:main.c        **** 		else if (receivedChar == GBA_FLASH_WRITE_BYTE) {
 2457               		.loc 3 275 0
 2458 023c 9236      		cpi r25,lo8(98)
 2459 023e 01F4      		brne .L108
 276:main.c        **** 			gb_mode();
 2460               		.loc 3 276 0
 2461 0240 00D0      		rcall gb_mode
 2462               	.LVL250:
 277:main.c        **** 			
 278:main.c        **** 			usart_read_bytes(64);
 2463               		.loc 3 278 0
 2464 0242 80E4      		ldi r24,lo8(64)
 2465 0244 00D0      		rcall usart_read_bytes
 2466               	.LVL251:
 279:main.c        **** 			
 280:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 2467               		.loc 3 280 0
 2468 0246 939A      		sbi 0x12,3
 2469               	.LVL252:
 2470 0248 20E0      		ldi r18,lo8(receivedBuffer)
 2471 024a A22E      		mov r10,r18
 2472 024c 20E0      		ldi r18,hi8(receivedBuffer)
 2473 024e B22E      		mov r11,r18
 2474 0250 C0E0      		ldi r28,0
 2475 0252 D0E0      		ldi r29,0
 2476               	.LVL253:
 2477               	.L109:
 2478               	.LBB92:
 281:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 282:main.c        **** 				flash_write_byte(address, receivedBuffer[x]);
 2479               		.loc 3 282 0 discriminator 3
 2480 0254 F501      		movw r30,r10
 2481 0256 6191      		ld r22,Z+
 2482 0258 5F01      		movw r10,r30
 2483 025a CE01      		movw r24,r28
 2484 025c 8C0D      		add r24,r12
 2485 025e 9D1D      		adc r25,r13
 2486 0260 00D0      		rcall flash_write_byte
 2487               	.LVL254:
 2488 0262 2196      		adiw r28,1
 2489               	.LVL255:
 281:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 2490               		.loc 3 281 0 discriminator 3
 2491 0264 C034      		cpi r28,64
 2492 0266 D105      		cpc r29,__zero_reg__
 2493 0268 01F4      		brne .L109
 2494 026a F0E4      		ldi r31,64
 2495 026c CF0E      		add r12,r31
 2496 026e D11C      		adc r13,__zero_reg__
 2497 0270 E11C      		adc r14,__zero_reg__
 2498 0272 F11C      		adc r15,__zero_reg__
 2499 0274 00C0      		rjmp .L184
 2500               	.LVL256:
 2501               	.L108:
 2502               	.LBE92:
 283:main.c        **** 				address++;
 284:main.c        **** 			}
 285:main.c        **** 			USART_Transmit('1'); // Send back acknowledgement
 286:main.c        **** 			
 287:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 288:main.c        **** 			gba_mode(); // Set back
 289:main.c        **** 		}
 290:main.c        **** 		
 291:main.c        **** 		// Write 128 bytes to flash sector for Atmel flash (and increment)
 292:main.c        **** 		else if (receivedChar == GBA_FLASH_WRITE_ATMEL) {
 2503               		.loc 3 292 0
 2504 0276 9136      		cpi r25,lo8(97)
 2505 0278 01F4      		brne .L110
 293:main.c        **** 			gb_mode();
 2506               		.loc 3 293 0
 2507 027a 00D0      		rcall gb_mode
 2508               	.LVL257:
 294:main.c        **** 			
 295:main.c        **** 			usart_read_bytes(128);
 2509               		.loc 3 295 0
 2510 027c 80E8      		ldi r24,lo8(-128)
 2511 027e 00D0      		rcall usart_read_bytes
 2512               	.LVL258:
 296:main.c        **** 			
 297:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 2513               		.loc 3 297 0
 2514 0280 939A      		sbi 0x12,3
 298:main.c        **** 			flash_write_sector(address); // Address used as sector number
 2515               		.loc 3 298 0
 2516 0282 C601      		movw r24,r12
 2517 0284 00D0      		rcall flash_write_sector
 2518               	.LVL259:
 299:main.c        **** 			address++;
 2519               		.loc 3 299 0
 2520 0286 2FEF      		ldi r18,-1
 2521 0288 C21A      		sub r12,r18
 2522 028a D20A      		sbc r13,r18
 2523 028c E20A      		sbc r14,r18
 2524 028e F20A      		sbc r15,r18
 2525               	.LVL260:
 2526 0290 00C0      		rjmp .L184
 2527               	.LVL261:
 2528               	.L110:
 300:main.c        **** 			USART_Transmit('1'); // Send back acknowledgement
 301:main.c        **** 			
 302:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 303:main.c        **** 			gba_mode(); // Set back
 304:main.c        **** 		}
 305:main.c        **** 		
 306:main.c        **** 		
 307:main.c        **** 		// ---------- EEPROM ----------
 308:main.c        **** 		// Set EEPROM size
 309:main.c        **** 		else if (receivedChar == GBA_SET_EEPROM_SIZE) {
 2529               		.loc 3 309 0
 2530 0292 9335      		cpi r25,lo8(83)
 2531 0294 01F4      		brne .L111
 310:main.c        **** 			usart_read_chars(); // Read size
 2532               		.loc 3 310 0
 2533 0296 00D0      		rcall usart_read_chars
 2534               	.LVL262:
 311:main.c        **** 			eepromSize = strtol(receivedBuffer, NULL, 16); // Convert size to dec
 2535               		.loc 3 311 0
 2536 0298 40E1      		ldi r20,lo8(16)
 2537 029a 50E0      		ldi r21,0
 2538 029c 60E0      		ldi r22,0
 2539 029e 70E0      		ldi r23,0
 2540 02a0 80E0      		ldi r24,lo8(receivedBuffer)
 2541 02a2 90E0      		ldi r25,hi8(receivedBuffer)
 2542 02a4 00D0      		rcall strtol
 2543               	.LVL263:
 2544 02a6 962E      		mov r9,r22
 2545               	.LVL264:
 2546 02a8 00C0      		rjmp .L78
 2547               	.LVL265:
 2548               	.L111:
 312:main.c        **** 		}
 313:main.c        **** 		
 314:main.c        **** 		// Read the EEPROM on address (and increment) until anything but 1 is received
 315:main.c        **** 		else if (receivedChar == GBA_READ_EEPROM) {
 2549               		.loc 3 315 0
 2550 02aa 9536      		cpi r25,lo8(101)
 2551 02ac 01F4      		brne .L112
 316:main.c        **** 			gba_eeprom_mode();
 2552               		.loc 3 316 0
 2553 02ae 00D0      		rcall gba_eeprom_mode
 2554               	.LVL266:
 317:main.c        **** 			
 318:main.c        **** 			receivedChar = '1';
 2555               		.loc 3 318 0
 2556 02b0 81E3      		ldi r24,lo8(49)
 2557               	.L190:
 319:main.c        **** 			while (receivedChar == '1') {
 320:main.c        **** 				PORTD |= (1<<ACTIVITY_LED);
 321:main.c        **** 				gba_eeprom_read(address, eepromSize);
 322:main.c        **** 				
 323:main.c        **** 				// Send back the 8 bytes of data
 324:main.c        **** 				for (uint8_t c = 0; c < 8; c++) {
 325:main.c        **** 					USART_Transmit(eepromBuffer[c]);
 326:main.c        **** 				}
 327:main.c        **** 				address++; // Increment to next 8 bytes
 328:main.c        **** 				
 329:main.c        **** 				PORTD &= ~(1<<ACTIVITY_LED);
 330:main.c        **** 				receivedChar = USART_Receive();
 2558               		.loc 3 330 0
 2559 02b2 8093 0000 		sts receivedChar,r24
 319:main.c        **** 			while (receivedChar == '1') {
 2560               		.loc 3 319 0
 2561 02b6 8091 0000 		lds r24,receivedChar
 2562 02ba 8133      		cpi r24,lo8(49)
 2563 02bc 01F0      		breq .+2
 2564 02be 00C0      		rjmp .L182
 320:main.c        **** 				gba_eeprom_read(address, eepromSize);
 2565               		.loc 3 320 0
 2566 02c0 939A      		sbi 0x12,3
 321:main.c        **** 				
 2567               		.loc 3 321 0
 2568 02c2 692D      		mov r22,r9
 2569 02c4 C601      		movw r24,r12
 2570 02c6 00D0      		rcall gba_eeprom_read
 2571               	.LVL267:
 2572 02c8 C0E0      		ldi r28,lo8(eepromBuffer)
 2573 02ca D0E0      		ldi r29,hi8(eepromBuffer)
 2574               	.LVL268:
 2575               	.L114:
 2576               	.LBB93:
 325:main.c        **** 				}
 2577               		.loc 3 325 0 discriminator 3
 2578 02cc 8991      		ld r24,Y+
 2579               	.LVL269:
 2580 02ce 00D0      		rcall USART_Transmit
 2581               	.LVL270:
 324:main.c        **** 					USART_Transmit(eepromBuffer[c]);
 2582               		.loc 3 324 0 discriminator 3
 2583 02d0 0C17      		cp r16,r28
 2584 02d2 1D07      		cpc r17,r29
 2585 02d4 01F4      		brne .L114
 2586               	.LBE93:
 327:main.c        **** 				
 2587               		.loc 3 327 0
 2588 02d6 8FEF      		ldi r24,-1
 2589 02d8 C81A      		sub r12,r24
 2590 02da D80A      		sbc r13,r24
 2591 02dc E80A      		sbc r14,r24
 2592 02de F80A      		sbc r15,r24
 2593               	.LVL271:
 329:main.c        **** 				receivedChar = USART_Receive();
 2594               		.loc 3 329 0
 2595 02e0 9398      		cbi 0x12,3
 2596               		.loc 3 330 0
 2597 02e2 00D0      		rcall USART_Receive
 2598               	.LVL272:
 2599 02e4 00C0      		rjmp .L190
 2600               	.LVL273:
 2601               	.L112:
 331:main.c        **** 			}
 332:main.c        **** 			
 333:main.c        **** 			gba_mode(); // Set back
 334:main.c        **** 		}
 335:main.c        **** 		
 336:main.c        **** 		// Write 8 bytes to the EEPROM address (and increment)
 337:main.c        **** 		else if (receivedChar == GBA_WRITE_EEPROM) {
 2602               		.loc 3 337 0
 2603 02e6 9037      		cpi r25,lo8(112)
 2604 02e8 01F4      		brne .L116
 338:main.c        **** 			gba_eeprom_mode();
 2605               		.loc 3 338 0
 2606 02ea 00D0      		rcall gba_eeprom_mode
 2607               	.LVL274:
 2608 02ec C0E0      		ldi r28,lo8(eepromBuffer)
 2609 02ee D0E0      		ldi r29,hi8(eepromBuffer)
 2610               	.LVL275:
 2611               	.L117:
 2612               	.LBB94:
 339:main.c        **** 			
 340:main.c        **** 			// Read 8 bytes from USART and place in buffer
 341:main.c        **** 			for (uint8_t x = 0; x < 8; x++) {
 342:main.c        **** 				eepromBuffer[x] = USART_Receive();
 2613               		.loc 3 342 0 discriminator 3
 2614 02f0 00D0      		rcall USART_Receive
 2615               	.LVL276:
 2616 02f2 8993      		st Y+,r24
 2617               	.LVL277:
 341:main.c        **** 				eepromBuffer[x] = USART_Receive();
 2618               		.loc 3 341 0 discriminator 3
 2619 02f4 0C17      		cp r16,r28
 2620 02f6 1D07      		cpc r17,r29
 2621 02f8 01F4      		brne .L117
 2622               	.LBE94:
 343:main.c        **** 			}
 344:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 2623               		.loc 3 344 0
 2624 02fa 939A      		sbi 0x12,3
 345:main.c        **** 			
 346:main.c        **** 			gba_eeprom_write(address, eepromSize);
 2625               		.loc 3 346 0
 2626 02fc 692D      		mov r22,r9
 2627 02fe C601      		movw r24,r12
 2628 0300 00D0      		rcall gba_eeprom_write
 2629               	.LVL278:
 347:main.c        **** 			address++;
 2630               		.loc 3 347 0
 2631 0302 9FEF      		ldi r25,-1
 2632 0304 C91A      		sub r12,r25
 2633 0306 D90A      		sbc r13,r25
 2634 0308 E90A      		sbc r14,r25
 2635 030a F90A      		sbc r15,r25
 2636               	.LVL279:
 2637               	.LBB95:
 2638               	.LBB96:
 187:c:\winavr-20100110\avr\include\util\delay.h **** 
 2639               		.loc 2 187 0
 2640 030c EFE7      		ldi r30,lo8(15999)
 2641 030e FEE3      		ldi r31,hi8(15999)
 2642 0310 3197      	1:	sbiw r30,1
 2643 0312 01F4      		brne 1b
 2644 0314 00C0      		rjmp .
 2645 0316 0000      		nop
 2646               	.LVL280:
 2647 0318 00C0      		rjmp .L184
 2648               	.LVL281:
 2649               	.L116:
 2650               	.LBE96:
 2651               	.LBE95:
 348:main.c        **** 			
 349:main.c        **** 			_delay_ms(8); // Wait for EEPROM to write data (8ms)
 350:main.c        **** 			USART_Transmit('1'); // Send back acknowledgement
 351:main.c        **** 			
 352:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 353:main.c        **** 			gba_mode(); // Set back
 354:main.c        **** 		}
 355:main.c        **** 		
 356:main.c        **** 		
 357:main.c        **** 		// ---------- GB FLASH CARTS ----------
 358:main.c        **** 		// Write address, one byte and pulse a pin
 359:main.c        **** 		else if (receivedChar == GB_FLASH_WRITE_BYTE) {
 2652               		.loc 3 359 0
 2653 031a 9634      		cpi r25,lo8(70)
 2654 031c 01F4      		brne .L118
 2655               	.LBB97:
 360:main.c        **** 			usart_read_chars(); // Read address
 2656               		.loc 3 360 0
 2657 031e 00D0      		rcall usart_read_chars
 2658               	.LVL282:
 361:main.c        **** 			uint16_t flashAddress = strtol(receivedBuffer, NULL, 16); // Convert address string in hex to de
 2659               		.loc 3 361 0
 2660 0320 40E1      		ldi r20,lo8(16)
 2661 0322 50E0      		ldi r21,0
 2662 0324 60E0      		ldi r22,0
 2663 0326 70E0      		ldi r23,0
 2664 0328 80E0      		ldi r24,lo8(receivedBuffer)
 2665 032a 90E0      		ldi r25,hi8(receivedBuffer)
 2666 032c 00D0      		rcall strtol
 2667               	.LVL283:
 2668 032e 1B01      		movw r2,r22
 2669 0330 2C01      		movw r4,r24
 2670               	.LVL284:
 362:main.c        **** 			
 363:main.c        **** 			receivedChar = USART_Receive(); // Wait for byte
 2671               		.loc 3 363 0
 2672 0332 00D0      		rcall USART_Receive
 2673               	.LVL285:
 2674 0334 8093 0000 		sts receivedChar,r24
 364:main.c        **** 			if (receivedChar == GB_AUDIO_FLASH_WRITE || receivedChar == GB_BV5_FLASH_WRITE) {
 2675               		.loc 3 364 0
 2676 0338 8535      		cpi r24,lo8(85)
 2677 033a 01F0      		breq .L119
 2678               		.loc 3 364 0 is_stmt 0 discriminator 1
 2679 033c 8533      		cpi r24,lo8(53)
 2680 033e 01F0      		breq .+2
 2681 0340 00C0      		rjmp .L78
 2682               	.L119:
 2683               	.LBB98:
 365:main.c        **** 				usart_read_chars(); // Read data
 2684               		.loc 3 365 0 is_stmt 1
 2685 0342 00D0      		rcall usart_read_chars
 2686               	.LVL286:
 366:main.c        **** 				uint8_t flashByte = strtol(receivedBuffer, NULL, 16); // Convert data byte in hex to dec
 2687               		.loc 3 366 0
 2688 0344 40E1      		ldi r20,lo8(16)
 2689 0346 50E0      		ldi r21,0
 2690 0348 60E0      		ldi r22,0
 2691 034a 70E0      		ldi r23,0
 2692 034c 80E0      		ldi r24,lo8(receivedBuffer)
 2693 034e 90E0      		ldi r25,hi8(receivedBuffer)
 2694 0350 00D0      		rcall strtol
 2695               	.LVL287:
 367:main.c        **** 				
 368:main.c        **** 				PORTD |= (1<<ACTIVITY_LED);
 2696               		.loc 3 368 0
 2697 0352 939A      		sbi 0x12,3
 369:main.c        **** 				if (receivedChar == GB_AUDIO_FLASH_WRITE) { // Pulse audio pin
 2698               		.loc 3 369 0
 2699 0354 8091 0000 		lds r24,receivedChar
 2700 0358 8535      		cpi r24,lo8(85)
 2701 035a 01F4      		brne .L120
 370:main.c        **** 					audio_flash_write_bus_cycle(flashAddress, flashByte);
 2702               		.loc 3 370 0
 2703 035c C101      		movw r24,r2
 2704 035e 00D0      		rcall audio_flash_write_bus_cycle
 2705               	.LVL288:
 2706 0360 00C0      		rjmp .L202
 2707               	.LVL289:
 2708               	.L120:
 371:main.c        **** 				}
 372:main.c        **** 				else if (receivedChar == GB_BV5_FLASH_WRITE) { // Pulse WR pin
 2709               		.loc 3 372 0
 2710 0362 8533      		cpi r24,lo8(53)
 2711 0364 01F0      		breq .+2
 2712 0366 00C0      		rjmp .L202
 373:main.c        **** 					bv5_flash_write_bus_cycle(flashAddress, flashByte);
 2713               		.loc 3 373 0
 2714 0368 C101      		movw r24,r2
 2715 036a 00D0      		rcall bv5_flash_write_bus_cycle
 2716               	.LVL290:
 2717 036c 00C0      		rjmp .L202
 2718               	.LVL291:
 2719               	.L118:
 2720               	.LBE98:
 2721               	.LBE97:
 374:main.c        **** 				}
 375:main.c        **** 				PORTD &= ~(1<<ACTIVITY_LED);
 376:main.c        **** 				
 377:main.c        **** 				USART_Transmit('1'); // Send back acknowledgement
 378:main.c        **** 			}
 379:main.c        **** 		}
 380:main.c        **** 		
 381:main.c        **** 		// Write 64 bytes to Flash address one byte write at a time (and increment), pulse a pin
 382:main.c        **** 		else if (receivedChar == GB_FLASH_WRITE_64BYTE) {
 2722               		.loc 3 382 0
 2723 036e 9435      		cpi r25,lo8(84)
 2724 0370 01F4      		brne .L122
 383:main.c        **** 			receivedChar = USART_Receive(); // Wait for byte
 2725               		.loc 3 383 0
 2726 0372 00D0      		rcall USART_Receive
 2727               	.LVL292:
 2728 0374 8093 0000 		sts receivedChar,r24
 384:main.c        **** 			usart_read_bytes(64);
 2729               		.loc 3 384 0
 2730 0378 80E4      		ldi r24,lo8(64)
 2731 037a 00D0      		rcall usart_read_bytes
 2732               	.LVL293:
 385:main.c        **** 			
 386:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 2733               		.loc 3 386 0
 2734 037c 939A      		sbi 0x12,3
 2735               	.LVL294:
 2736 037e C0E0      		ldi r28,lo8(receivedBuffer)
 2737 0380 D0E0      		ldi r29,hi8(receivedBuffer)
 2738 0382 90E4      		ldi r25,lo8(64)
 2739 0384 592E      		mov r5,r25
 2740               	.LBB99:
 387:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 388:main.c        **** 				if (receivedChar == GB_AUDIO_FLASH_WRITE) { // Pulse audio pin
 389:main.c        **** 					audio_flash_write_byte(address, receivedBuffer[x]);
 390:main.c        **** 				}
 391:main.c        **** 				else if (receivedChar == GB_BV5_FLASH_WRITE) { // Pulse WR pin
 392:main.c        **** 					bv5_flash_write_byte(address, receivedBuffer[x]);
 2741               		.loc 3 392 0
 2742 0386 C601      		movw r24,r12
 2743 0388 8050      		subi r24,lo8(receivedBuffer)
 2744 038a 9040      		sbci r25,hi8(receivedBuffer)
 2745 038c 5C01      		movw r10,r24
 2746               	.LVL295:
 2747               	.L125:
 388:main.c        **** 					audio_flash_write_byte(address, receivedBuffer[x]);
 2748               		.loc 3 388 0
 2749 038e 8091 0000 		lds r24,receivedChar
 2750 0392 8535      		cpi r24,lo8(85)
 2751 0394 01F4      		brne .L123
 389:main.c        **** 				}
 2752               		.loc 3 389 0
 2753 0396 6881      		ld r22,Y
 2754 0398 C501      		movw r24,r10
 2755 039a 8C0F      		add r24,r28
 2756 039c 9D1F      		adc r25,r29
 2757 039e 00D0      		rcall audio_flash_write_byte
 2758               	.LVL296:
 2759 03a0 00C0      		rjmp .L124
 2760               	.L123:
 391:main.c        **** 					bv5_flash_write_byte(address, receivedBuffer[x]);
 2761               		.loc 3 391 0
 2762 03a2 8533      		cpi r24,lo8(53)
 2763 03a4 01F4      		brne .L124
 2764               		.loc 3 392 0
 2765 03a6 6881      		ld r22,Y
 2766 03a8 C501      		movw r24,r10
 2767 03aa 8C0F      		add r24,r28
 2768 03ac 9D1F      		adc r25,r29
 2769 03ae 00D0      		rcall bv5_flash_write_byte
 2770               	.LVL297:
 2771               	.L124:
 2772 03b0 5A94      		dec r5
 2773 03b2 2196      		adiw r28,1
 2774               	.LVL298:
 387:main.c        **** 				if (receivedChar == GB_AUDIO_FLASH_WRITE) { // Pulse audio pin
 2775               		.loc 3 387 0 discriminator 2
 2776 03b4 5110      		cpse r5,__zero_reg__
 2777 03b6 00C0      		rjmp .L125
 2778 03b8 90E4      		ldi r25,64
 2779 03ba C90E      		add r12,r25
 2780 03bc D11C      		adc r13,__zero_reg__
 2781 03be E11C      		adc r14,__zero_reg__
 2782 03c0 F11C      		adc r15,__zero_reg__
 2783 03c2 00C0      		rjmp .L191
 2784               	.LVL299:
 2785               	.L122:
 2786               	.LBE99:
 393:main.c        **** 				}
 394:main.c        **** 				
 395:main.c        **** 				address++;
 396:main.c        **** 			}
 397:main.c        **** 			USART_Transmit('1'); // Send back acknowledgement
 398:main.c        **** 			
 399:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 400:main.c        **** 		}
 401:main.c        **** 		
 402:main.c        **** 		
 403:main.c        **** 		// ---------- GBA FLASH CARTS ----------
 404:main.c        **** 		// Write 24 bit address, 16 bit data and pulse a pin
 405:main.c        **** 		else if (receivedChar == GBA_FLASH_CART_WRITE_BYTE) {
 2787               		.loc 3 405 0
 2788 03c4 9E36      		cpi r25,lo8(110)
 2789 03c6 01F4      		brne .L126
 2790               	.LBB100:
 406:main.c        **** 			usart_read_chars(); // Read address
 2791               		.loc 3 406 0
 2792 03c8 00D0      		rcall usart_read_chars
 2793               	.LVL300:
 407:main.c        **** 			uint32_t flashAddress = strtol(receivedBuffer, NULL, 16); // Convert address string in hex to de
 2794               		.loc 3 407 0
 2795 03ca 40E1      		ldi r20,lo8(16)
 2796 03cc 50E0      		ldi r21,0
 2797 03ce 60E0      		ldi r22,0
 2798 03d0 70E0      		ldi r23,0
 2799 03d2 80E0      		ldi r24,lo8(receivedBuffer)
 2800 03d4 90E0      		ldi r25,hi8(receivedBuffer)
 2801 03d6 00D0      		rcall strtol
 2802               	.LVL301:
 2803 03d8 1B01      		movw r2,r22
 2804 03da 2C01      		movw r4,r24
 2805               	.LVL302:
 408:main.c        **** 			
 409:main.c        **** 			receivedChar = USART_Receive(); // Wait for byte
 2806               		.loc 3 409 0
 2807 03dc 00D0      		rcall USART_Receive
 2808               	.LVL303:
 2809 03de 8093 0000 		sts receivedChar,r24
 410:main.c        **** 			if (receivedChar == GBA_FLASH_CART_WRITE_BYTE) {
 2810               		.loc 3 410 0
 2811 03e2 8E36      		cpi r24,lo8(110)
 2812 03e4 01F0      		breq .+2
 2813 03e6 00C0      		rjmp .L78
 2814               	.LBB101:
 411:main.c        **** 				usart_read_chars(); // Read data
 2815               		.loc 3 411 0
 2816 03e8 00D0      		rcall usart_read_chars
 2817               	.LVL304:
 412:main.c        **** 				uint16_t flashByte = strtol(receivedBuffer, NULL, 16); // Convert data byte in hex to dec
 2818               		.loc 3 412 0
 2819 03ea 40E1      		ldi r20,lo8(16)
 2820 03ec 50E0      		ldi r21,0
 2821 03ee 60E0      		ldi r22,0
 2822 03f0 70E0      		ldi r23,0
 2823 03f2 80E0      		ldi r24,lo8(receivedBuffer)
 2824 03f4 90E0      		ldi r25,hi8(receivedBuffer)
 2825 03f6 00D0      		rcall strtol
 2826               	.LVL305:
 413:main.c        **** 				
 414:main.c        **** 				PORTD |= (1<<ACTIVITY_LED);
 2827               		.loc 3 414 0
 2828 03f8 939A      		sbi 0x12,3
 415:main.c        **** 				gba_flash_write_bus_cycle(flashAddress, flashByte);
 2829               		.loc 3 415 0
 2830 03fa AB01      		movw r20,r22
 2831 03fc C201      		movw r24,r4
 2832 03fe B101      		movw r22,r2
 2833               	.LVL306:
 2834 0400 00D0      		rcall gba_flash_write_bus_cycle
 2835               	.LVL307:
 2836               	.L202:
 416:main.c        **** 				PORTD &= ~(1<<ACTIVITY_LED);
 2837               		.loc 3 416 0
 2838 0402 9398      		cbi 0x12,3
 417:main.c        **** 				
 418:main.c        **** 				USART_Transmit('1'); // Send back acknowledgement
 2839               		.loc 3 418 0
 2840 0404 81E3      		ldi r24,lo8(49)
 2841 0406 00C0      		rjmp .L180
 2842               	.LVL308:
 2843               	.L126:
 2844               	.LBE101:
 2845               	.LBE100:
 419:main.c        **** 			}
 420:main.c        **** 		}
 421:main.c        **** 		
 422:main.c        **** 		// Write 64 bytes to Flash address, combine 2 bytes and write at a time (and increment address by
 423:main.c        **** 		else if (receivedChar == GBA_FLASH_WRITE_64BYTE) {
 2846               		.loc 3 423 0
 2847 0408 9137      		cpi r25,lo8(113)
 2848 040a 01F4      		brne .L127
 424:main.c        **** 			usart_read_bytes(64);
 2849               		.loc 3 424 0
 2850 040c 80E4      		ldi r24,lo8(64)
 2851               	.LVL309:
 2852 040e 00D0      		rcall usart_read_bytes
 2853               	.LVL310:
 425:main.c        **** 			
 426:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 2854               		.loc 3 426 0
 2855 0410 939A      		sbi 0x12,3
 2856               	.LVL311:
 2857 0412 C0E0      		ldi r28,lo8(receivedBuffer)
 2858 0414 D0E0      		ldi r29,hi8(receivedBuffer)
 2859 0416 1601      		movw r2,r12
 2860 0418 2701      		movw r4,r14
 2861               	.LVL312:
 2862               	.L128:
 2863               	.LBB102:
 2864               	.LBB103:
 427:main.c        **** 			for (uint8_t x = 0; x < 64; x += 2) {
 428:main.c        **** 				uint16_t combinedBytes = (uint16_t) receivedBuffer[x+1] << 8 | (uint16_t) receivedBuffer[x];
 429:main.c        **** 				gba_flash_write_byte_swapped(address, combinedBytes);
 2865               		.loc 3 429 0 discriminator 3
 2866 041a 4981      		ldd r20,Y+1
 2867 041c 50E0      		ldi r21,0
 2868 041e 542F      		mov r21,r20
 2869 0420 4427      		clr r20
 2870 0422 8881      		ld r24,Y
 2871 0424 482B      		or r20,r24
 2872 0426 C201      		movw r24,r4
 2873 0428 B101      		movw r22,r2
 2874 042a 00D0      		rcall gba_flash_write_byte_swapped
 2875               	.LVL313:
 430:main.c        **** 				address++;
 2876               		.loc 3 430 0 discriminator 3
 2877 042c EFEF      		ldi r30,-1
 2878 042e 2E1A      		sub r2,r30
 2879 0430 3E0A      		sbc r3,r30
 2880 0432 4E0A      		sbc r4,r30
 2881 0434 5E0A      		sbc r5,r30
 2882               	.LVL314:
 2883 0436 2296      		adiw r28,2
 2884               	.LVL315:
 2885               	.LBE103:
 427:main.c        **** 			for (uint8_t x = 0; x < 64; x += 2) {
 2886               		.loc 3 427 0 discriminator 3
 2887 0438 6C16      		cp r6,r28
 2888 043a 7D06      		cpc r7,r29
 2889 043c 01F4      		brne .L128
 2890 043e F0E2      		ldi r31,32
 2891 0440 CF0E      		add r12,r31
 2892 0442 D11C      		adc r13,__zero_reg__
 2893 0444 E11C      		adc r14,__zero_reg__
 2894 0446 F11C      		adc r15,__zero_reg__
 2895               	.LVL316:
 2896               	.L191:
 2897               	.LBE102:
 431:main.c        **** 			}
 432:main.c        **** 			USART_Transmit('1'); // Send back acknowledgement
 2898               		.loc 3 432 0
 2899 0448 81E3      		ldi r24,lo8(49)
 2900 044a 00C0      		rjmp .L183
 2901               	.LVL317:
 2902               	.L127:
 433:main.c        **** 			
 434:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 435:main.c        **** 		}
 436:main.c        **** 		
 437:main.c        **** 		
 438:main.c        **** 		// ---------- General commands ----------
 439:main.c        **** 		// Set any pin as input/output
 440:main.c        **** 		// Reads the DDR/PORT (e.g. DDRB/PORTB is 'B') and the hex value that represents pins to set to a
 441:main.c        **** 		else if (receivedChar == SET_INPUT || receivedChar == SET_OUTPUT) {
 2903               		.loc 3 441 0
 2904 044c 9934      		cpi r25,lo8(73)
 2905 044e 01F0      		breq .L129
 2906               		.loc 3 441 0 is_stmt 0 discriminator 1
 2907 0450 9F34      		cpi r25,lo8(79)
 2908 0452 01F0      		breq .+2
 2909 0454 00C0      		rjmp .L130
 2910               	.L129:
 2911               	.LBB104:
 442:main.c        **** 			char portChar = USART_Receive();
 2912               		.loc 3 442 0 is_stmt 1
 2913 0456 00D0      		rcall USART_Receive
 2914               	.LVL318:
 2915 0458 C82F      		mov r28,r24
 2916               	.LVL319:
 443:main.c        **** 			usart_read_chars();
 2917               		.loc 3 443 0
 2918 045a 00D0      		rcall usart_read_chars
 2919               	.LVL320:
 444:main.c        **** 			uint8_t setValue = strtol(receivedBuffer, NULL, 16);
 2920               		.loc 3 444 0
 2921 045c 40E1      		ldi r20,lo8(16)
 2922 045e 50E0      		ldi r21,0
 2923 0460 60E0      		ldi r22,0
 2924 0462 70E0      		ldi r23,0
 2925 0464 80E0      		ldi r24,lo8(receivedBuffer)
 2926 0466 90E0      		ldi r25,hi8(receivedBuffer)
 2927 0468 00D0      		rcall strtol
 2928               	.LVL321:
 445:main.c        **** 			
 446:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 2929               		.loc 3 446 0
 2930 046a 939A      		sbi 0x12,3
 447:main.c        **** 			if (receivedChar == SET_INPUT) {
 2931               		.loc 3 447 0
 2932 046c 8091 0000 		lds r24,receivedChar
 2933 0470 8934      		cpi r24,lo8(73)
 2934 0472 01F4      		brne .L131
 448:main.c        **** 				if (portChar == 'A') {
 2935               		.loc 3 448 0
 2936 0474 C134      		cpi r28,lo8(65)
 2937 0476 01F4      		brne .L132
 449:main.c        **** 					DDRA &= ~(setValue);
 2938               		.loc 3 449 0
 2939 0478 8AB3      		in r24,0x1a
 2940 047a 6095      		com r22
 2941               	.LVL322:
 2942 047c 6823      		and r22,r24
 2943               	.LVL323:
 2944 047e 00C0      		rjmp .L193
 2945               	.LVL324:
 2946               	.L132:
 450:main.c        **** 				}
 451:main.c        **** 				else if (portChar == 'B') {
 2947               		.loc 3 451 0
 2948 0480 C234      		cpi r28,lo8(66)
 2949 0482 01F4      		brne .L134
 452:main.c        **** 					DDRB &= ~(setValue);
 2950               		.loc 3 452 0
 2951 0484 87B3      		in r24,0x17
 2952 0486 6095      		com r22
 2953               	.LVL325:
 2954 0488 6823      		and r22,r24
 2955               	.LVL326:
 2956 048a 00C0      		rjmp .L194
 2957               	.LVL327:
 2958               	.L134:
 453:main.c        **** 				}
 454:main.c        **** 				else if (portChar == 'C') {
 2959               		.loc 3 454 0
 2960 048c C334      		cpi r28,lo8(67)
 2961 048e 01F4      		brne .L135
 455:main.c        **** 					DDRC &= ~(setValue);
 2962               		.loc 3 455 0
 2963 0490 84B3      		in r24,0x14
 2964 0492 6095      		com r22
 2965               	.LVL328:
 2966 0494 6823      		and r22,r24
 2967               	.LVL329:
 2968 0496 00C0      		rjmp .L199
 2969               	.LVL330:
 2970               	.L135:
 456:main.c        **** 				}
 457:main.c        **** 				else if (portChar == 'D') {
 2971               		.loc 3 457 0
 2972 0498 C434      		cpi r28,lo8(68)
 2973 049a 01F4      		brne .L136
 458:main.c        **** 					DDRD &= ~(setValue);
 2974               		.loc 3 458 0
 2975 049c 81B3      		in r24,0x11
 2976 049e 6095      		com r22
 2977               	.LVL331:
 2978 04a0 6823      		and r22,r24
 2979               	.LVL332:
 2980 04a2 00C0      		rjmp .L200
 2981               	.LVL333:
 2982               	.L136:
 459:main.c        **** 				}
 460:main.c        **** 				else if (portChar == 'E') {
 2983               		.loc 3 460 0
 2984 04a4 C534      		cpi r28,lo8(69)
 2985 04a6 01F0      		breq .+2
 2986 04a8 00C0      		rjmp .L155
 461:main.c        **** 					DDRE &= ~(setValue);
 2987               		.loc 3 461 0
 2988 04aa 86B1      		in r24,0x6
 2989 04ac 6095      		com r22
 2990               	.LVL334:
 2991 04ae 6823      		and r22,r24
 2992               	.LVL335:
 2993 04b0 00C0      		rjmp .L201
 2994               	.LVL336:
 2995               	.L131:
 462:main.c        **** 				}
 463:main.c        **** 			}
 464:main.c        **** 			else if (receivedChar == SET_OUTPUT) {
 2996               		.loc 3 464 0
 2997 04b2 8F34      		cpi r24,lo8(79)
 2998 04b4 01F0      		breq .+2
 2999 04b6 00C0      		rjmp .L155
 465:main.c        **** 				if (portChar == 'A') {
 3000               		.loc 3 465 0
 3001 04b8 C134      		cpi r28,lo8(65)
 3002 04ba 01F4      		brne .L137
 466:main.c        **** 					DDRA |= (setValue);
 3003               		.loc 3 466 0
 3004 04bc 8AB3      		in r24,0x1a
 3005 04be 682B      		or r22,r24
 3006               	.LVL337:
 3007               	.L193:
 3008 04c0 6ABB      		out 0x1a,r22
 3009 04c2 00C0      		rjmp .L155
 3010               	.LVL338:
 3011               	.L137:
 467:main.c        **** 				}
 468:main.c        **** 				else if (portChar == 'B') {
 3012               		.loc 3 468 0
 3013 04c4 C234      		cpi r28,lo8(66)
 3014 04c6 01F4      		brne .L138
 469:main.c        **** 					DDRB |= (setValue);
 3015               		.loc 3 469 0
 3016 04c8 87B3      		in r24,0x17
 3017 04ca 682B      		or r22,r24
 3018               	.LVL339:
 3019               	.L194:
 3020 04cc 67BB      		out 0x17,r22
 3021 04ce 00C0      		rjmp .L155
 3022               	.LVL340:
 3023               	.L138:
 470:main.c        **** 				}
 471:main.c        **** 				else if (portChar == 'C') {
 3024               		.loc 3 471 0
 3025 04d0 C334      		cpi r28,lo8(67)
 3026 04d2 01F4      		brne .L139
 472:main.c        **** 					DDRC |= (setValue);
 3027               		.loc 3 472 0
 3028 04d4 84B3      		in r24,0x14
 3029 04d6 682B      		or r22,r24
 3030               	.LVL341:
 3031               	.L199:
 3032 04d8 64BB      		out 0x14,r22
 3033 04da 00C0      		rjmp .L155
 3034               	.LVL342:
 3035               	.L139:
 473:main.c        **** 				}
 474:main.c        **** 				else if (portChar == 'D') {
 3036               		.loc 3 474 0
 3037 04dc C434      		cpi r28,lo8(68)
 3038 04de 01F4      		brne .L140
 475:main.c        **** 					DDRD |= (setValue);
 3039               		.loc 3 475 0
 3040 04e0 81B3      		in r24,0x11
 3041 04e2 682B      		or r22,r24
 3042               	.LVL343:
 3043               	.L200:
 3044 04e4 61BB      		out 0x11,r22
 3045 04e6 00C0      		rjmp .L155
 3046               	.LVL344:
 3047               	.L140:
 476:main.c        **** 				}
 477:main.c        **** 				else if (portChar == 'E') {
 3048               		.loc 3 477 0
 3049 04e8 C534      		cpi r28,lo8(69)
 3050 04ea 01F0      		breq .+2
 3051 04ec 00C0      		rjmp .L155
 478:main.c        **** 					DDRE |= (setValue);
 3052               		.loc 3 478 0
 3053 04ee 86B1      		in r24,0x6
 3054 04f0 682B      		or r22,r24
 3055               	.LVL345:
 3056               	.L201:
 3057 04f2 66B9      		out 0x6,r22
 3058 04f4 00C0      		rjmp .L155
 3059               	.LVL346:
 3060               	.L130:
 3061               	.LBE104:
 479:main.c        **** 				}
 480:main.c        **** 			}
 481:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 482:main.c        **** 		}
 483:main.c        **** 		
 484:main.c        **** 		// Set pin output as low
 485:main.c        **** 		else if (receivedChar == SET_OUTPUT_LOW) {
 3062               		.loc 3 485 0
 3063 04f6 9C34      		cpi r25,lo8(76)
 3064 04f8 01F4      		brne .L141
 3065               	.LBB105:
 486:main.c        **** 			char portChar = USART_Receive();			
 3066               		.loc 3 486 0
 3067 04fa 00D0      		rcall USART_Receive
 3068               	.LVL347:
 3069 04fc C82F      		mov r28,r24
 3070               	.LVL348:
 487:main.c        **** 			usart_read_chars();
 3071               		.loc 3 487 0
 3072 04fe 00D0      		rcall usart_read_chars
 3073               	.LVL349:
 488:main.c        **** 			uint8_t setValue = strtol(receivedBuffer, NULL, 16);
 3074               		.loc 3 488 0
 3075 0500 40E1      		ldi r20,lo8(16)
 3076 0502 50E0      		ldi r21,0
 3077 0504 60E0      		ldi r22,0
 3078 0506 70E0      		ldi r23,0
 3079 0508 80E0      		ldi r24,lo8(receivedBuffer)
 3080 050a 90E0      		ldi r25,hi8(receivedBuffer)
 3081 050c 00D0      		rcall strtol
 3082               	.LVL350:
 489:main.c        **** 			
 490:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 3083               		.loc 3 490 0
 3084 050e 939A      		sbi 0x12,3
 491:main.c        **** 			if (portChar == 'A') {
 3085               		.loc 3 491 0
 3086 0510 C134      		cpi r28,lo8(65)
 3087 0512 01F4      		brne .L142
 492:main.c        **** 				PORTA &= ~(setValue);
 3088               		.loc 3 492 0
 3089 0514 8BB3      		in r24,0x1b
 3090 0516 6095      		com r22
 3091               	.LVL351:
 3092 0518 6823      		and r22,r24
 3093               	.LVL352:
 3094 051a 00C0      		rjmp .L198
 3095               	.LVL353:
 3096               	.L142:
 493:main.c        **** 			}
 494:main.c        **** 			else if (portChar == 'B') {
 3097               		.loc 3 494 0
 3098 051c C234      		cpi r28,lo8(66)
 3099 051e 01F4      		brne .L144
 495:main.c        **** 				PORTB &= ~(setValue);
 3100               		.loc 3 495 0
 3101 0520 88B3      		in r24,0x18
 3102 0522 6095      		com r22
 3103               	.LVL354:
 3104 0524 6823      		and r22,r24
 3105               	.LVL355:
 3106 0526 00C0      		rjmp .L197
 3107               	.LVL356:
 3108               	.L144:
 496:main.c        **** 			}
 497:main.c        **** 			else if (portChar == 'C') {
 3109               		.loc 3 497 0
 3110 0528 C334      		cpi r28,lo8(67)
 3111 052a 01F4      		brne .L145
 498:main.c        **** 				PORTC &= ~(setValue);
 3112               		.loc 3 498 0
 3113 052c 85B3      		in r24,0x15
 3114 052e 6095      		com r22
 3115               	.LVL357:
 3116 0530 6823      		and r22,r24
 3117               	.LVL358:
 3118 0532 00C0      		rjmp .L196
 3119               	.LVL359:
 3120               	.L145:
 499:main.c        **** 			}
 500:main.c        **** 			else if (portChar == 'D') {
 3121               		.loc 3 500 0
 3122 0534 C434      		cpi r28,lo8(68)
 3123 0536 01F4      		brne .L146
 501:main.c        **** 				PORTD &= ~(setValue);
 3124               		.loc 3 501 0
 3125 0538 82B3      		in r24,0x12
 3126 053a 6095      		com r22
 3127               	.LVL360:
 3128 053c 6823      		and r22,r24
 3129               	.LVL361:
 3130 053e 00C0      		rjmp .L195
 3131               	.LVL362:
 3132               	.L146:
 502:main.c        **** 			}
 503:main.c        **** 			else if (portChar == 'E') {
 3133               		.loc 3 503 0
 3134 0540 C534      		cpi r28,lo8(69)
 3135 0542 01F0      		breq .+2
 3136 0544 00C0      		rjmp .L155
 504:main.c        **** 				PORTE &= ~(setValue);
 3137               		.loc 3 504 0
 3138 0546 87B1      		in r24,0x7
 3139 0548 6095      		com r22
 3140               	.LVL363:
 3141 054a 6823      		and r22,r24
 3142               	.LVL364:
 3143 054c 00C0      		rjmp .L192
 3144               	.LVL365:
 3145               	.L141:
 3146               	.LBE105:
 505:main.c        **** 			}
 506:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 507:main.c        **** 		}
 508:main.c        **** 		
 509:main.c        **** 		// Set pin output as high
 510:main.c        **** 		else if (receivedChar == SET_OUTPUT_HIGH) {
 3147               		.loc 3 510 0
 3148 054e 9834      		cpi r25,lo8(72)
 3149 0550 01F4      		brne .L147
 3150               	.LBB106:
 511:main.c        **** 			char portChar = USART_Receive();			
 3151               		.loc 3 511 0
 3152 0552 00D0      		rcall USART_Receive
 3153               	.LVL366:
 3154 0554 C82F      		mov r28,r24
 3155               	.LVL367:
 512:main.c        **** 			usart_read_chars();
 3156               		.loc 3 512 0
 3157 0556 00D0      		rcall usart_read_chars
 3158               	.LVL368:
 513:main.c        **** 			uint8_t setValue = strtol(receivedBuffer, NULL, 16);
 3159               		.loc 3 513 0
 3160 0558 40E1      		ldi r20,lo8(16)
 3161 055a 50E0      		ldi r21,0
 3162 055c 60E0      		ldi r22,0
 3163 055e 70E0      		ldi r23,0
 3164 0560 80E0      		ldi r24,lo8(receivedBuffer)
 3165 0562 90E0      		ldi r25,hi8(receivedBuffer)
 3166 0564 00D0      		rcall strtol
 3167               	.LVL369:
 514:main.c        **** 			
 515:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 3168               		.loc 3 515 0
 3169 0566 939A      		sbi 0x12,3
 516:main.c        **** 			if (portChar == 'A') {
 3170               		.loc 3 516 0
 3171 0568 C134      		cpi r28,lo8(65)
 3172 056a 01F4      		brne .L148
 517:main.c        **** 				PORTA |= (setValue);
 3173               		.loc 3 517 0
 3174 056c 8BB3      		in r24,0x1b
 3175 056e 682B      		or r22,r24
 3176               	.LVL370:
 3177               	.L198:
 3178 0570 6BBB      		out 0x1b,r22
 3179 0572 00C0      		rjmp .L155
 3180               	.LVL371:
 3181               	.L148:
 518:main.c        **** 			}
 519:main.c        **** 			else if (portChar == 'B') {
 3182               		.loc 3 519 0
 3183 0574 C234      		cpi r28,lo8(66)
 3184 0576 01F4      		brne .L150
 520:main.c        **** 				PORTB |= (setValue);
 3185               		.loc 3 520 0
 3186 0578 88B3      		in r24,0x18
 3187 057a 682B      		or r22,r24
 3188               	.LVL372:
 3189               	.L197:
 3190 057c 68BB      		out 0x18,r22
 3191 057e 00C0      		rjmp .L155
 3192               	.LVL373:
 3193               	.L150:
 521:main.c        **** 			}
 522:main.c        **** 			else if (portChar == 'C') {
 3194               		.loc 3 522 0
 3195 0580 C334      		cpi r28,lo8(67)
 3196 0582 01F4      		brne .L151
 523:main.c        **** 				PORTC |= (setValue);
 3197               		.loc 3 523 0
 3198 0584 85B3      		in r24,0x15
 3199 0586 682B      		or r22,r24
 3200               	.LVL374:
 3201               	.L196:
 3202 0588 65BB      		out 0x15,r22
 3203 058a 00C0      		rjmp .L155
 3204               	.LVL375:
 3205               	.L151:
 524:main.c        **** 			}
 525:main.c        **** 			else if (portChar == 'D') {
 3206               		.loc 3 525 0
 3207 058c C434      		cpi r28,lo8(68)
 3208 058e 01F4      		brne .L152
 526:main.c        **** 				PORTD |= (setValue);
 3209               		.loc 3 526 0
 3210 0590 82B3      		in r24,0x12
 3211 0592 682B      		or r22,r24
 3212               	.LVL376:
 3213               	.L195:
 3214 0594 62BB      		out 0x12,r22
 3215 0596 00C0      		rjmp .L155
 3216               	.LVL377:
 3217               	.L152:
 527:main.c        **** 			}
 528:main.c        **** 			else if (portChar == 'E') {
 3218               		.loc 3 528 0
 3219 0598 C534      		cpi r28,lo8(69)
 3220 059a 01F4      		brne .L155
 529:main.c        **** 				PORTE |= (setValue);
 3221               		.loc 3 529 0
 3222 059c 87B1      		in r24,0x7
 3223 059e 682B      		or r22,r24
 3224               	.LVL378:
 3225               	.L192:
 3226 05a0 67B9      		out 0x7,r22
 3227 05a2 00C0      		rjmp .L155
 3228               	.LVL379:
 3229               	.L147:
 3230               	.LBE106:
 530:main.c        **** 			}
 531:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 532:main.c        **** 		}
 533:main.c        **** 		
 534:main.c        **** 		// Read all pins of a PORT and return the value
 535:main.c        **** 		else if (receivedChar == READ_INPUT) {
 3231               		.loc 3 535 0
 3232 05a4 9434      		cpi r25,lo8(68)
 3233 05a6 01F4      		brne .L153
 3234               	.LBB107:
 536:main.c        **** 			char portChar = USART_Receive();			
 3235               		.loc 3 536 0
 3236 05a8 00D0      		rcall USART_Receive
 3237               	.LVL380:
 537:main.c        **** 			
 538:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 3238               		.loc 3 538 0
 3239 05aa 939A      		sbi 0x12,3
 539:main.c        **** 			if (portChar == 'A') {
 3240               		.loc 3 539 0
 3241 05ac 8134      		cpi r24,lo8(65)
 3242 05ae 01F4      		brne .L154
 540:main.c        **** 				USART_Transmit(PINA);
 3243               		.loc 3 540 0
 3244 05b0 89B3      		in r24,0x19
 3245               	.LVL381:
 3246 05b2 00C0      		rjmp .L183
 3247               	.LVL382:
 3248               	.L154:
 541:main.c        **** 			}
 542:main.c        **** 			else if (portChar == 'B') {
 3249               		.loc 3 542 0
 3250 05b4 8234      		cpi r24,lo8(66)
 3251 05b6 01F4      		brne .L156
 543:main.c        **** 				USART_Transmit(PINB);
 3252               		.loc 3 543 0
 3253 05b8 86B3      		in r24,0x16
 3254               	.LVL383:
 3255 05ba 00C0      		rjmp .L183
 3256               	.LVL384:
 3257               	.L156:
 544:main.c        **** 			}
 545:main.c        **** 			else if (portChar == 'C') {
 3258               		.loc 3 545 0
 3259 05bc 8334      		cpi r24,lo8(67)
 3260 05be 01F4      		brne .L157
 546:main.c        **** 				USART_Transmit(PINC);
 3261               		.loc 3 546 0
 3262 05c0 83B3      		in r24,0x13
 3263               	.LVL385:
 3264 05c2 00C0      		rjmp .L183
 3265               	.LVL386:
 3266               	.L157:
 547:main.c        **** 			}
 548:main.c        **** 			else if (portChar == 'D') {
 3267               		.loc 3 548 0
 3268 05c4 8434      		cpi r24,lo8(68)
 3269 05c6 01F4      		brne .L158
 549:main.c        **** 				USART_Transmit(PIND);
 3270               		.loc 3 549 0
 3271 05c8 80B3      		in r24,0x10
 3272               	.LVL387:
 3273 05ca 00C0      		rjmp .L183
 3274               	.LVL388:
 3275               	.L158:
 550:main.c        **** 			}
 551:main.c        **** 			else if (portChar == 'E') {
 3276               		.loc 3 551 0
 3277 05cc 8534      		cpi r24,lo8(69)
 3278 05ce 01F4      		brne .L155
 552:main.c        **** 				USART_Transmit(PINE);
 3279               		.loc 3 552 0
 3280 05d0 85B1      		in r24,0x5
 3281               	.LVL389:
 3282               	.L183:
 3283 05d2 00D0      		rcall USART_Transmit
 3284               	.LVL390:
 3285               	.L155:
 553:main.c        **** 			}
 554:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 3286               		.loc 3 554 0
 3287 05d4 9398      		cbi 0x12,3
 3288               	.LBE107:
 3289 05d6 00C0      		rjmp .L78
 3290               	.LVL391:
 3291               	.L153:
 555:main.c        **** 		}
 556:main.c        **** 		
 557:main.c        **** 		// Set the reset common lines variable on or off, useful if you are controlling all the pins dire
 558:main.c        **** 		else if (receivedChar == RESET_COMMON_LINES) {
 3292               		.loc 3 558 0
 3293 05d8 9D34      		cpi r25,lo8(77)
 3294 05da 01F4      		brne .L159
 3295               	.LBB108:
 559:main.c        **** 			char commonChar = USART_Receive();
 3296               		.loc 3 559 0
 3297 05dc 00D0      		rcall USART_Receive
 3298               	.LVL392:
 560:main.c        **** 			if (commonChar == '1') {
 3299               		.loc 3 560 0
 3300 05de 8133      		cpi r24,lo8(49)
 3301 05e0 01F4      		brne .L203
 561:main.c        **** 				resetCommonLines = 1;
 3302               		.loc 3 561 0
 3303 05e2 8824      		clr r8
 3304 05e4 8394      		inc r8
 3305 05e6 00C0      		rjmp .L179
 3306               	.L203:
 562:main.c        **** 			}
 563:main.c        **** 			else if (commonChar == '0') {
 3307               		.loc 3 563 0
 3308 05e8 8033      		cpi r24,lo8(48)
 3309 05ea 01F0      		breq .+2
 3310 05ec 00C0      		rjmp .L78
 564:main.c        **** 				resetCommonLines = 0;
 3311               		.loc 3 564 0
 3312 05ee 812C      		mov r8,__zero_reg__
 3313 05f0 00C0      		rjmp .L79
 3314               	.LVL393:
 3315               	.L159:
 3316               	.LBE108:
 565:main.c        **** 			}
 566:main.c        **** 		}
 567:main.c        **** 		
 568:main.c        **** 		// Send back the PCB version number
 569:main.c        **** 		else if (receivedChar == READ_PCB_VERSION) {
 3317               		.loc 3 569 0
 3318 05f2 9836      		cpi r25,lo8(104)
 3319 05f4 01F4      		brne .L160
 570:main.c        **** 			USART_Transmit(PCB_VERSION);
 3320               		.loc 3 570 0
 3321 05f6 82E0      		ldi r24,lo8(2)
 3322               	.LVL394:
 3323 05f8 00C0      		rjmp .L180
 3324               	.LVL395:
 3325               	.L160:
 571:main.c        **** 		}
 572:main.c        **** 		
 573:main.c        **** 		// Send back the firmware version number
 574:main.c        **** 		else if (receivedChar == READ_FIRMWARE_VERSION) {
 3326               		.loc 3 574 0
 3327 05fa 9635      		cpi r25,lo8(86)
 3328 05fc 01F4      		brne .L161
 575:main.c        **** 			USART_Transmit(FIRMWARE_VERSION);
 3329               		.loc 3 575 0
 3330 05fe 85E0      		ldi r24,lo8(5)
 3331               	.LVL396:
 3332               	.L180:
 3333 0600 00D0      		rcall USART_Transmit
 3334               	.LVL397:
 3335 0602 00C0      		rjmp .L78
 3336               	.LVL398:
 3337               	.L161:
 576:main.c        **** 		}
 577:main.c        **** 		
 578:main.c        **** 		// Reset the AVR if it matches the number
 579:main.c        **** 		else if (receivedChar == RESET_AVR) {
 3338               		.loc 3 579 0
 3339 0604 9A32      		cpi r25,lo8(42)
 3340 0606 01F0      		breq .+2
 3341 0608 00C0      		rjmp .L78
 3342               	.LBB109:
 580:main.c        **** 			usart_read_chars();
 3343               		.loc 3 580 0
 3344 060a 00D0      		rcall usart_read_chars
 3345               	.LVL399:
 581:main.c        **** 			uint32_t resetValue = strtol(receivedBuffer, NULL, 16);
 3346               		.loc 3 581 0
 3347 060c 40E1      		ldi r20,lo8(16)
 3348 060e 50E0      		ldi r21,0
 3349 0610 60E0      		ldi r22,0
 3350 0612 70E0      		ldi r23,0
 3351 0614 80E0      		ldi r24,lo8(receivedBuffer)
 3352 0616 90E0      		ldi r25,hi8(receivedBuffer)
 3353 0618 00D0      		rcall strtol
 3354               	.LVL400:
 582:main.c        **** 			if (resetValue == RESET_VALUE) {
 3355               		.loc 3 582 0
 3356 061a 613E      		cpi r22,-31
 3357 061c 754E      		sbci r23,-27
 3358 061e 8740      		sbci r24,7
 3359 0620 9105      		cpc r25,__zero_reg__
 3360 0622 01F0      		breq .+2
 3361 0624 00C0      		rjmp .L78
 583:main.c        **** 				// Clear watchdog flag
 584:main.c        **** 				MCUCSR &= ~(1<<WDRF);
 3362               		.loc 3 584 0
 3363 0626 84B7      		in r24,0x34
 3364 0628 877F      		andi r24,lo8(-9)
 3365 062a 84BF      		out 0x34,r24
 585:main.c        **** 				
 586:main.c        **** 				// Start timed sequence
 587:main.c        **** 				WDTCR = (1<<WDCE) | (1<<WDE);
 3366               		.loc 3 587 0
 3367 062c 88E1      		ldi r24,lo8(24)
 3368 062e 81BD      		out 0x21,r24
 588:main.c        **** 				
 589:main.c        **** 				// Reset in 250 ms
 590:main.c        **** 				WDTCR = (1<<WDP2) | (1<<WDE);
 3369               		.loc 3 590 0
 3370 0630 9CE0      		ldi r25,lo8(12)
 3371 0632 91BD      		out 0x21,r25
 3372               	.LVL401:
 3373               	.LBB110:
 3374               	.LBB111:
 3375               		.file 4 "c:\\winavr-20100110\\avr\\include\\util\\delay_basic.h"
   1:c:\winavr-20100110\avr\include\util\delay_basic.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:c:\winavr-20100110\avr\include\util\delay_basic.h ****    Copyright (c) 2007 Joerg Wunsch
   3:c:\winavr-20100110\avr\include\util\delay_basic.h ****    All rights reserved.
   4:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
   5:c:\winavr-20100110\avr\include\util\delay_basic.h ****    Redistribution and use in source and binary forms, with or without
   6:c:\winavr-20100110\avr\include\util\delay_basic.h ****    modification, are permitted provided that the following conditions are met:
   7:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
   8:c:\winavr-20100110\avr\include\util\delay_basic.h ****    * Redistributions of source code must retain the above copyright
   9:c:\winavr-20100110\avr\include\util\delay_basic.h ****      notice, this list of conditions and the following disclaimer.
  10:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  11:c:\winavr-20100110\avr\include\util\delay_basic.h ****    * Redistributions in binary form must reproduce the above copyright
  12:c:\winavr-20100110\avr\include\util\delay_basic.h ****      notice, this list of conditions and the following disclaimer in
  13:c:\winavr-20100110\avr\include\util\delay_basic.h ****      the documentation and/or other materials provided with the
  14:c:\winavr-20100110\avr\include\util\delay_basic.h ****      distribution.
  15:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  16:c:\winavr-20100110\avr\include\util\delay_basic.h ****    * Neither the name of the copyright holders nor the names of
  17:c:\winavr-20100110\avr\include\util\delay_basic.h ****      contributors may be used to endorse or promote products derived
  18:c:\winavr-20100110\avr\include\util\delay_basic.h ****      from this software without specific prior written permission.
  19:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  20:c:\winavr-20100110\avr\include\util\delay_basic.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  21:c:\winavr-20100110\avr\include\util\delay_basic.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  22:c:\winavr-20100110\avr\include\util\delay_basic.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  23:c:\winavr-20100110\avr\include\util\delay_basic.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  24:c:\winavr-20100110\avr\include\util\delay_basic.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  25:c:\winavr-20100110\avr\include\util\delay_basic.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  26:c:\winavr-20100110\avr\include\util\delay_basic.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  27:c:\winavr-20100110\avr\include\util\delay_basic.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  28:c:\winavr-20100110\avr\include\util\delay_basic.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  29:c:\winavr-20100110\avr\include\util\delay_basic.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  30:c:\winavr-20100110\avr\include\util\delay_basic.h ****   POSSIBILITY OF SUCH DAMAGE. */
  31:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  32:c:\winavr-20100110\avr\include\util\delay_basic.h **** /* $Id$ */
  33:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  34:c:\winavr-20100110\avr\include\util\delay_basic.h **** #ifndef _UTIL_DELAY_BASIC_H_
  35:c:\winavr-20100110\avr\include\util\delay_basic.h **** #define _UTIL_DELAY_BASIC_H_ 1
  36:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  37:c:\winavr-20100110\avr\include\util\delay_basic.h **** #include <inttypes.h>
  38:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  39:c:\winavr-20100110\avr\include\util\delay_basic.h **** #if !defined(__DOXYGEN__)
  40:c:\winavr-20100110\avr\include\util\delay_basic.h **** static __inline__ void _delay_loop_1(uint8_t __count) __attribute__((__always_inline__));
  41:c:\winavr-20100110\avr\include\util\delay_basic.h **** static __inline__ void _delay_loop_2(uint16_t __count) __attribute__((__always_inline__));
  42:c:\winavr-20100110\avr\include\util\delay_basic.h **** #endif
  43:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  44:c:\winavr-20100110\avr\include\util\delay_basic.h **** /** \file */
  45:c:\winavr-20100110\avr\include\util\delay_basic.h **** /** \defgroup util_delay_basic <util/delay_basic.h>: Basic busy-wait delay loops
  46:c:\winavr-20100110\avr\include\util\delay_basic.h ****     \code
  47:c:\winavr-20100110\avr\include\util\delay_basic.h ****     #include <util/delay_basic.h>
  48:c:\winavr-20100110\avr\include\util\delay_basic.h ****     \endcode
  49:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  50:c:\winavr-20100110\avr\include\util\delay_basic.h ****     The functions in this header file implement simple delay loops
  51:c:\winavr-20100110\avr\include\util\delay_basic.h ****     that perform a busy-waiting.  They are typically used to
  52:c:\winavr-20100110\avr\include\util\delay_basic.h ****     facilitate short delays in the program execution.  They are
  53:c:\winavr-20100110\avr\include\util\delay_basic.h ****     implemented as count-down loops with a well-known CPU cycle
  54:c:\winavr-20100110\avr\include\util\delay_basic.h ****     count per loop iteration.  As such, no other processing can
  55:c:\winavr-20100110\avr\include\util\delay_basic.h ****     occur simultaneously.  It should be kept in mind that the
  56:c:\winavr-20100110\avr\include\util\delay_basic.h ****     functions described here do not disable interrupts.
  57:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  58:c:\winavr-20100110\avr\include\util\delay_basic.h ****     In general, for long delays, the use of hardware timers is
  59:c:\winavr-20100110\avr\include\util\delay_basic.h ****     much preferrable, as they free the CPU, and allow for
  60:c:\winavr-20100110\avr\include\util\delay_basic.h ****     concurrent processing of other events while the timer is
  61:c:\winavr-20100110\avr\include\util\delay_basic.h ****     running.  However, in particular for very short delays, the
  62:c:\winavr-20100110\avr\include\util\delay_basic.h ****     overhead of setting up a hardware timer is too much compared
  63:c:\winavr-20100110\avr\include\util\delay_basic.h ****     to the overall delay time.
  64:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  65:c:\winavr-20100110\avr\include\util\delay_basic.h ****     Two inline functions are provided for the actual delay algorithms.
  66:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  67:c:\winavr-20100110\avr\include\util\delay_basic.h **** */
  68:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  69:c:\winavr-20100110\avr\include\util\delay_basic.h **** /** \ingroup util_delay_basic
  70:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  71:c:\winavr-20100110\avr\include\util\delay_basic.h ****     Delay loop using an 8-bit counter \c __count, so up to 256
  72:c:\winavr-20100110\avr\include\util\delay_basic.h ****     iterations are possible.  (The value 256 would have to be passed
  73:c:\winavr-20100110\avr\include\util\delay_basic.h ****     as 0.)  The loop executes three CPU cycles per iteration, not
  74:c:\winavr-20100110\avr\include\util\delay_basic.h ****     including the overhead the compiler needs to setup the counter
  75:c:\winavr-20100110\avr\include\util\delay_basic.h ****     register.
  76:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  77:c:\winavr-20100110\avr\include\util\delay_basic.h ****     Thus, at a CPU speed of 1 MHz, delays of up to 768 microseconds
  78:c:\winavr-20100110\avr\include\util\delay_basic.h ****     can be achieved.
  79:c:\winavr-20100110\avr\include\util\delay_basic.h **** */
  80:c:\winavr-20100110\avr\include\util\delay_basic.h **** void
  81:c:\winavr-20100110\avr\include\util\delay_basic.h **** _delay_loop_1(uint8_t __count)
  82:c:\winavr-20100110\avr\include\util\delay_basic.h **** {
  83:c:\winavr-20100110\avr\include\util\delay_basic.h **** 	__asm__ volatile (
  84:c:\winavr-20100110\avr\include\util\delay_basic.h **** 		"1: dec %0" "\n\t"
  85:c:\winavr-20100110\avr\include\util\delay_basic.h **** 		"brne 1b"
  86:c:\winavr-20100110\avr\include\util\delay_basic.h **** 		: "=r" (__count)
  87:c:\winavr-20100110\avr\include\util\delay_basic.h **** 		: "0" (__count)
  88:c:\winavr-20100110\avr\include\util\delay_basic.h **** 	);
  89:c:\winavr-20100110\avr\include\util\delay_basic.h **** }
  90:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  91:c:\winavr-20100110\avr\include\util\delay_basic.h **** /** \ingroup util_delay_basic
  92:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  93:c:\winavr-20100110\avr\include\util\delay_basic.h ****     Delay loop using a 16-bit counter \c __count, so up to 65536
  94:c:\winavr-20100110\avr\include\util\delay_basic.h ****     iterations are possible.  (The value 65536 would have to be
  95:c:\winavr-20100110\avr\include\util\delay_basic.h ****     passed as 0.)  The loop executes four CPU cycles per iteration,
  96:c:\winavr-20100110\avr\include\util\delay_basic.h ****     not including the overhead the compiler requires to setup the
  97:c:\winavr-20100110\avr\include\util\delay_basic.h ****     counter register pair.
  98:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  99:c:\winavr-20100110\avr\include\util\delay_basic.h ****     Thus, at a CPU speed of 1 MHz, delays of up to about 262.1
 100:c:\winavr-20100110\avr\include\util\delay_basic.h ****     milliseconds can be achieved.
 101:c:\winavr-20100110\avr\include\util\delay_basic.h ****  */
 102:c:\winavr-20100110\avr\include\util\delay_basic.h **** void
 103:c:\winavr-20100110\avr\include\util\delay_basic.h **** _delay_loop_2(uint16_t __count)
 104:c:\winavr-20100110\avr\include\util\delay_basic.h **** {
 105:c:\winavr-20100110\avr\include\util\delay_basic.h **** 	__asm__ volatile (
 3376               		.loc 4 105 0
 3377 0634 8FEF      		ldi r24,lo8(-1)
 3378 0636 9FEF      		ldi r25,lo8(-1)
 3379               	/* #APP */
 3380               	 ;  105 "c:\winavr-20100110\avr\include\util\delay_basic.h" 1
 3381 0638 0197      		1: sbiw r24,1
 3382 063a 01F4      		brne 1b
 3383               	 ;  0 "" 2
 3384               	.LVL402:
 3385               	/* #NOAPP */
 3386 063c 00C0      		rjmp .L78
 3387               	.LBE111:
 3388               	.LBE110:
 3389               	.LBE109:
 3390               		.cfi_endproc
 3391               	.LFE43:
 3393               		.comm	flashChipIdBuffer,2,1
 3394               		.comm	eepromBuffer,8,1
 3395               		.comm	receivedChar,1,1
 3396               		.comm	receivedBuffer,129,1
 3397               		.text
 3398               	.Letext0:
 3399               		.file 5 "c:\\winavr-20100110\\avr\\include\\stdint.h"
 3400               		.file 6 "c:\\winavr-20100110\\avr\\include\\stdlib.h"
DEFINED SYMBOLS
                            *ABS*:00000000 main.c
C:\Users\Alex\AppData\Local\Temp\ccbw96ZB.s:2      *ABS*:0000003e __SP_H__
C:\Users\Alex\AppData\Local\Temp\ccbw96ZB.s:3      *ABS*:0000003d __SP_L__
C:\Users\Alex\AppData\Local\Temp\ccbw96ZB.s:4      *ABS*:0000003f __SREG__
C:\Users\Alex\AppData\Local\Temp\ccbw96ZB.s:5      *ABS*:00000000 __tmp_reg__
C:\Users\Alex\AppData\Local\Temp\ccbw96ZB.s:6      *ABS*:00000001 __zero_reg__
C:\Users\Alex\AppData\Local\Temp\ccbw96ZB.s:12     .text:00000000 USART_Receive
C:\Users\Alex\AppData\Local\Temp\ccbw96ZB.s:34     .text:00000008 USART_Transmit
C:\Users\Alex\AppData\Local\Temp\ccbw96ZB.s:55     .text:00000010 usart_read_bytes
                            *COM*:00000081 receivedBuffer
C:\Users\Alex\AppData\Local\Temp\ccbw96ZB.s:118    .text:0000003a usart_read_chars
C:\Users\Alex\AppData\Local\Temp\ccbw96ZB.s:162    .text:00000056 rd_wr_csmreq_cs2_reset
C:\Users\Alex\AppData\Local\Temp\ccbw96ZB.s:184    .text:00000060 gb_mode
C:\Users\Alex\AppData\Local\Temp\ccbw96ZB.s:211    .text:00000070 set_16bit_address
C:\Users\Alex\AppData\Local\Temp\ccbw96ZB.s:230    .text:00000076 read_8bit_data
C:\Users\Alex\AppData\Local\Temp\ccbw96ZB.s:270    .text:00000088 write_8bit_data
C:\Users\Alex\AppData\Local\Temp\ccbw96ZB.s:335    .text:000000b4 gba_mode
C:\Users\Alex\AppData\Local\Temp\ccbw96ZB.s:362    .text:000000c4 gba_set_24bit_address
C:\Users\Alex\AppData\Local\Temp\ccbw96ZB.s:415    .text:000000f0 gba_read_16bit_data
C:\Users\Alex\AppData\Local\Temp\ccbw96ZB.s:463    .text:0000010e gba_read_ram_8bit_data
C:\Users\Alex\AppData\Local\Temp\ccbw96ZB.s:503    .text:00000120 gba_write_ram_8bit_data
C:\Users\Alex\AppData\Local\Temp\ccbw96ZB.s:557    .text:00000140 gba_eeprom_mode
C:\Users\Alex\AppData\Local\Temp\ccbw96ZB.s:585    .text:00000152 gba_eeprom_set_address
C:\Users\Alex\AppData\Local\Temp\ccbw96ZB.s:724    .text:000001ba gba_eeprom_read
                            *COM*:00000008 eepromBuffer
C:\Users\Alex\AppData\Local\Temp\ccbw96ZB.s:856    .text:00000214 gba_eeprom_write
C:\Users\Alex\AppData\Local\Temp\ccbw96ZB.s:972    .text:00000268 flash_write_bus_cycle
C:\Users\Alex\AppData\Local\Temp\ccbw96ZB.s:1018   .text:00000282 flash_read_chip_id
                            *COM*:00000002 flashChipIdBuffer
C:\Users\Alex\AppData\Local\Temp\ccbw96ZB.s:1123   .text:000002ec flash_switch_bank
C:\Users\Alex\AppData\Local\Temp\ccbw96ZB.s:1172   .text:00000312 flash_erase_4k_sector
C:\Users\Alex\AppData\Local\Temp\ccbw96ZB.s:1247   .text:0000035a flash_write_byte
C:\Users\Alex\AppData\Local\Temp\ccbw96ZB.s:1318   .text:00000392 flash_write_sector
C:\Users\Alex\AppData\Local\Temp\ccbw96ZB.s:1431   .text:000003fe audio_flash_write_bus_cycle
C:\Users\Alex\AppData\Local\Temp\ccbw96ZB.s:1481   .text:00000418 audio_flash_write_byte
C:\Users\Alex\AppData\Local\Temp\ccbw96ZB.s:1552   .text:00000450 bv5_flash_write_bus_cycle
C:\Users\Alex\AppData\Local\Temp\ccbw96ZB.s:1602   .text:0000046a bv5_flash_write_byte
C:\Users\Alex\AppData\Local\Temp\ccbw96ZB.s:1673   .text:000004a2 gba_flash_write_bus_cycle
C:\Users\Alex\AppData\Local\Temp\ccbw96ZB.s:1736   .text:000004c8 gba_flash_write_byte_swapped
C:\Users\Alex\AppData\Local\Temp\ccbw96ZB.s:1833   .text:00000522 setup
C:\Users\Alex\AppData\Local\Temp\ccbw96ZB.s:1928   .text.startup:00000000 main
                            *COM*:00000001 receivedChar

UNDEFINED SYMBOLS
strtol
atoi
__do_clear_bss
