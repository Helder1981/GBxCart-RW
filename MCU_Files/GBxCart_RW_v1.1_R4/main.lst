   1               		.file	"main.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               	.global	USART_Receive
  12               	USART_Receive:
  13               	.LFB12:
  14               		.file 1 "setup.c"
   1:setup.c       **** /*
   2:setup.c       ****  GBxCart RW
   3:setup.c       ****  PCB version: 1.1
   4:setup.c       ****  Firmware version: R4
   5:setup.c       ****  Author: Alex from insideGadgets (www.insidegadgets.com)
   6:setup.c       ****  Created: 7/11/2016
   7:setup.c       ****  Last Modified: 15/10/2017
   8:setup.c       ****  
   9:setup.c       ****  */
  10:setup.c       ****  
  11:setup.c       **** #ifndef cbi
  12:setup.c       **** #define cbi(sfr, bit) (_SFR_BYTE(sfr) &= ~_BV(bit))
  13:setup.c       **** #endif
  14:setup.c       **** #ifndef sbi
  15:setup.c       **** #define sbi(sfr, bit) (_SFR_BYTE(sfr) |= _BV(bit))
  16:setup.c       **** #endif
  17:setup.c       **** 
  18:setup.c       **** #ifndef NULL
  19:setup.c       **** #define NULL ((void *)0)
  20:setup.c       **** #endif
  21:setup.c       **** 
  22:setup.c       **** #define LOW 0
  23:setup.c       **** #define HIGH 1
  24:setup.c       **** #define false 0
  25:setup.c       **** #define true 1
  26:setup.c       **** 
  27:setup.c       **** #define SWITCH_DETECT PD2
  28:setup.c       **** #define ACTIVITY_LED PD3
  29:setup.c       **** #define LED_5V PD7
  30:setup.c       **** #define LED_3V PE0
  31:setup.c       **** 
  32:setup.c       **** #define WR_PIN PD6
  33:setup.c       **** #define RD_PIN PD5
  34:setup.c       **** #define CS_MREQ_PIN PD4
  35:setup.c       **** #define CS2_PIN PE2
  36:setup.c       **** #define AUDIO_PIN PE1
  37:setup.c       **** 
  38:setup.c       **** #define wrPin_high	PORTD |= (1<<WR_PIN);
  39:setup.c       **** #define wrPin_low		PORTD &= ~(1<<WR_PIN);
  40:setup.c       **** #define rdPin_high	PORTD |= (1<<RD_PIN);
  41:setup.c       **** #define rdPin_low		PORTD &= ~(1<<RD_PIN);
  42:setup.c       **** #define cs_mreqPin_high		PORTD |= (1<<CS_MREQ_PIN);
  43:setup.c       **** #define cs_mreqPin_low		PORTD &= ~(1<<CS_MREQ_PIN);
  44:setup.c       **** #define cs2Pin_high		PORTE |= (1<<CS2_PIN);
  45:setup.c       **** #define cs2Pin_low		PORTE &= ~(1<<CS2_PIN);
  46:setup.c       **** #define audioPin_high		PORTE |= (1<<AUDIO_PIN);
  47:setup.c       **** #define audioPin_low		PORTE &= ~(1<<AUDIO_PIN);
  48:setup.c       **** 
  49:setup.c       **** #define GB_MODE 1
  50:setup.c       **** #define GBA_MODE 2
  51:setup.c       **** 
  52:setup.c       **** // GB/GBC
  53:setup.c       **** #define PORT_ADDR7_0 PORTB
  54:setup.c       **** #define PORT_ADDR15_8 PORTA
  55:setup.c       **** #define PORT_DATA7_0 PORTC
  56:setup.c       **** 
  57:setup.c       **** #define DDR_ADDR7_0 DDRB
  58:setup.c       **** #define DDR_ADDR15_8 DDRA
  59:setup.c       **** #define DDR_DATA7_0 DDRC
  60:setup.c       **** 
  61:setup.c       **** #define PIN_ADDR7_0 PINB
  62:setup.c       **** #define PIN_ADDR15_8 PINA
  63:setup.c       **** #define PIN_DATA7_0 PINC
  64:setup.c       **** 
  65:setup.c       **** #define BANK_WRITE 0
  66:setup.c       **** #define MEMORY_WRITE 1
  67:setup.c       **** 
  68:setup.c       **** // GBA
  69:setup.c       **** #define EEPROM_WRITE 1
  70:setup.c       **** #define EEPROM_READ 0
  71:setup.c       **** 
  72:setup.c       **** #define EEPROM_NONE 0
  73:setup.c       **** #define EEPROM_4KBIT 1
  74:setup.c       **** #define EEPROM_64KBIT 2
  75:setup.c       **** 
  76:setup.c       **** #define AD0 PB0
  77:setup.c       **** #define ad0Pin_high		PORTB |= (1<<AD0);
  78:setup.c       **** #define ad0Pin_low		PORTB &= ~(1<<AD0);
  79:setup.c       **** 
  80:setup.c       **** #define A23 PC7
  81:setup.c       **** #define a23Pin_high		PORTC |= (1<<A23);
  82:setup.c       **** #define a23Pin_low		PORTC &= ~(1<<A23);
  83:setup.c       **** 
  84:setup.c       **** #define GBA_DDR_ROM_ADDR7_0 DDRB
  85:setup.c       **** #define GBA_DDR_ROM_ADDR15_8 DDRA
  86:setup.c       **** #define GBA_DDR_ROM_ADDR23_16 DDRC
  87:setup.c       **** #define GBA_DDR_ROM_DATA7_0 DDRB
  88:setup.c       **** #define GBA_DDR_ROM_DATA15_8 DDRA
  89:setup.c       **** #define GBA_DDR_RAM_DATA7_0 DDRC
  90:setup.c       **** #define GBA_DDR_EEPROM_DATA7_0 DDRB
  91:setup.c       **** 
  92:setup.c       **** #define GBA_PORT_ROM_ADDR7_0 PORTB
  93:setup.c       **** #define GBA_PORT_ROM_ADDR15_8 PORTA
  94:setup.c       **** #define GBA_PORT_ROM_ADDR23_16 PORTC
  95:setup.c       **** #define GBA_PORT_ROM_DATA7_0 PORTB
  96:setup.c       **** #define GBA_PORT_ROM_DATA15_8 PORTA
  97:setup.c       **** #define GBA_PORT_RAM_DATA7_0 PORTC
  98:setup.c       **** #define GBA_PORT_EEPROM_DATA7_0 PORTB
  99:setup.c       **** 
 100:setup.c       **** #define GBA_PIN_ROM_DATA7_0 PINB
 101:setup.c       **** #define GBA_PIN_ROM_DATA15_8 PINA
 102:setup.c       **** #define GBA_PIN_RAM_DATA7_0 PINC
 103:setup.c       **** #define GBA_PIN_EEPROM_DATA7_0 PINB
 104:setup.c       **** 
 105:setup.c       **** // GB/GBC commands
 106:setup.c       **** #define SET_START_ADDRESS 'A'
 107:setup.c       **** #define READ_ROM_RAM 'R'
 108:setup.c       **** #define WRITE_RAM 'W'
 109:setup.c       **** #define SET_BANK 'B'
 110:setup.c       **** #define GB_CART_MODE 'G'
 111:setup.c       **** 
 112:setup.c       **** // GBA commands
 113:setup.c       **** #define GBA_READ_ROM 'r'
 114:setup.c       **** #define GBA_READ_SRAM 'm'
 115:setup.c       **** #define GBA_WRITE_SRAM 'w'
 116:setup.c       **** #define GBA_WRITE_ONE_BYTE_SRAM 'o'
 117:setup.c       **** #define GBA_CART_MODE 'g'
 118:setup.c       **** 
 119:setup.c       **** #define GBA_FLASH_READ_ID 'i'
 120:setup.c       **** #define GBA_FLASH_SET_BANK 'k'
 121:setup.c       **** #define GBA_FLASH_4K_SECTOR_ERASE 's'
 122:setup.c       **** #define GBA_FLASH_WRITE_BYTE 'b'
 123:setup.c       **** #define GBA_FLASH_WRITE_ATMEL 'a'
 124:setup.c       **** 
 125:setup.c       **** #define GBA_SET_EEPROM_SIZE 'S'
 126:setup.c       **** #define GBA_READ_EEPROM 'e'
 127:setup.c       **** #define GBA_WRITE_EEPROM 'p'
 128:setup.c       **** 
 129:setup.c       **** // Flash ROM commands
 130:setup.c       **** #define GB_FLASH_WRITE_BYTE 'F'
 131:setup.c       **** #define GB_FLASH_WRITE_64BYTE 'T'
 132:setup.c       **** 
 133:setup.c       **** #define GB_AUDIO_FLASH_WRITE 'U'
 134:setup.c       **** #define GB_BV5_FLASH_WRITE '5'
 135:setup.c       **** 
 136:setup.c       **** // General commands
 137:setup.c       **** #define CART_MODE 'C'
 138:setup.c       **** #define SET_INPUT 'I'
 139:setup.c       **** #define SET_OUTPUT 'O'
 140:setup.c       **** #define SET_OUTPUT_LOW 'L'
 141:setup.c       **** #define SET_OUTPUT_HIGH 'H'
 142:setup.c       **** #define READ_INPUT 'D'
 143:setup.c       **** #define RESET_COMMON_LINES 'M'
 144:setup.c       **** #define READ_FIRMWARE_VERSION 'V'
 145:setup.c       **** #define READ_PCB_VERSION 'h'
 146:setup.c       **** 
 147:setup.c       **** #define RESET_AVR '*'
 148:setup.c       **** #define RESET_VALUE 0x7E5E1
 149:setup.c       **** 
 150:setup.c       **** 
 151:setup.c       **** char receivedBuffer[129];
 152:setup.c       **** char receivedChar;
 153:setup.c       **** uint8_t eepromBuffer[8];
 154:setup.c       **** uint8_t flashChipIdBuffer[2];
 155:setup.c       **** 
 156:setup.c       **** // Receive USART data
 157:setup.c       **** uint8_t USART_Receive(void) {
  15               		.loc 1 157 0
  16               		.cfi_startproc
  17               	/* prologue: function */
  18               	/* frame size = 0 */
  19               	/* stack size = 0 */
  20               	.L__stack_usage = 0
  21               	.L2:
 158:setup.c       **** 	while ( !(UCSRA & (1<<RXC)) ); // Wait for data to be received
  22               		.loc 1 158 0 discriminator 1
  23 0000 5F9B      		sbis 0xb,7
  24 0002 00C0      		rjmp .L2
 159:setup.c       **** 	return UDR; // Get and return received data from buffer
  25               		.loc 1 159 0
  26 0004 8CB1      		in r24,0xc
 160:setup.c       **** }
  27               		.loc 1 160 0
  28 0006 0895      		ret
  29               		.cfi_endproc
  30               	.LFE12:
  32               	.global	USART_Transmit
  34               	USART_Transmit:
  35               	.LFB13:
 161:setup.c       **** 
 162:setup.c       **** // Transmit USART data
 163:setup.c       **** void USART_Transmit(unsigned char data) {
  36               		.loc 1 163 0
  37               		.cfi_startproc
  38               	/* prologue: function */
  39               	/* frame size = 0 */
  40               	/* stack size = 0 */
  41               	.L__stack_usage = 0
  42               	.LVL0:
  43               	.L6:
 164:setup.c       **** 	while ( !( UCSRA & (1<<UDRE)) ); // Wait for empty transmit buffer
  44               		.loc 1 164 0 discriminator 1
  45 0008 5D9B      		sbis 0xb,5
  46 000a 00C0      		rjmp .L6
 165:setup.c       **** 	UDR = data;
  47               		.loc 1 165 0
  48 000c 8CB9      		out 0xc,r24
  49 000e 0895      		ret
  50               		.cfi_endproc
  51               	.LFE13:
  53               	.global	usart_read_bytes
  55               	usart_read_bytes:
  56               	.LFB14:
 166:setup.c       **** }
 167:setup.c       **** 
 168:setup.c       **** // Read 1-128 bytes from the USART 
 169:setup.c       **** void usart_read_bytes(uint8_t count) {
  57               		.loc 1 169 0
  58               		.cfi_startproc
  59               	.LVL1:
  60 0010 EF92      		push r14
  61               	.LCFI0:
  62               		.cfi_def_cfa_offset 3
  63               		.cfi_offset 14, -2
  64 0012 FF92      		push r15
  65               	.LCFI1:
  66               		.cfi_def_cfa_offset 4
  67               		.cfi_offset 15, -3
  68 0014 1F93      		push r17
  69               	.LCFI2:
  70               		.cfi_def_cfa_offset 5
  71               		.cfi_offset 17, -4
  72 0016 CF93      		push r28
  73               	.LCFI3:
  74               		.cfi_def_cfa_offset 6
  75               		.cfi_offset 28, -5
  76 0018 DF93      		push r29
  77               	.LCFI4:
  78               		.cfi_def_cfa_offset 7
  79               		.cfi_offset 29, -6
  80               	/* prologue: function */
  81               	/* frame size = 0 */
  82               	/* stack size = 5 */
  83               	.L__stack_usage = 5
  84 001a 182F      		mov r17,r24
  85               	.LVL2:
  86 001c 80E0      		ldi r24,lo8(receivedBuffer)
  87 001e E82E      		mov r14,r24
  88 0020 80E0      		ldi r24,hi8(receivedBuffer)
  89 0022 F82E      		mov r15,r24
  90               	.LVL3:
  91               	.LBB46:
 170:setup.c       **** 	for (uint8_t x = 0; x < count; x++) {
  92               		.loc 1 170 0
  93 0024 E701      		movw r28,r14
  94               	.LVL4:
  95               	.L10:
  96 0026 8C2F      		mov r24,r28
  97 0028 8E19      		sub r24,r14
  98               		.loc 1 170 0 is_stmt 0 discriminator 1
  99 002a 8117      		cp r24,r17
 100 002c 00F4      		brsh .L12
 171:setup.c       **** 		receivedBuffer[x] = USART_Receive();
 101               		.loc 1 171 0 is_stmt 1 discriminator 3
 102 002e 00D0      		rcall USART_Receive
 103               	.LVL5:
 104 0030 8993      		st Y+,r24
 105               	.LVL6:
 106 0032 00C0      		rjmp .L10
 107               	.L12:
 108               	/* epilogue start */
 109               	.LBE46:
 172:setup.c       **** 	}
 173:setup.c       **** }
 110               		.loc 1 173 0
 111 0034 DF91      		pop r29
 112 0036 CF91      		pop r28
 113               	.LVL7:
 114 0038 1F91      		pop r17
 115               	.LVL8:
 116 003a FF90      		pop r15
 117 003c EF90      		pop r14
 118 003e 0895      		ret
 119               		.cfi_endproc
 120               	.LFE14:
 122               	.global	usart_read_chars
 124               	usart_read_chars:
 125               	.LFB15:
 174:setup.c       **** 
 175:setup.c       **** // Read the USART until a 0 (string terminator byte) is received
 176:setup.c       **** void usart_read_chars(void) {
 126               		.loc 1 176 0
 127               		.cfi_startproc
 128 0040 CF93      		push r28
 129               	.LCFI5:
 130               		.cfi_def_cfa_offset 3
 131               		.cfi_offset 28, -2
 132               	/* prologue: function */
 133               	/* frame size = 0 */
 134               	/* stack size = 1 */
 135               	.L__stack_usage = 1
 136               	.LVL9:
 177:setup.c       **** 	uint8_t x = 0;
 137               		.loc 1 177 0
 138 0042 C0E0      		ldi r28,0
 139               	.LVL10:
 140               	.L15:
 178:setup.c       **** 	while (1) {
 179:setup.c       **** 		receivedBuffer[x] = USART_Receive();
 141               		.loc 1 179 0
 142 0044 00D0      		rcall USART_Receive
 143               	.LVL11:
 144 0046 EC2F      		mov r30,r28
 145 0048 F0E0      		ldi r31,0
 146 004a E050      		subi r30,lo8(-(receivedBuffer))
 147 004c F040      		sbci r31,hi8(-(receivedBuffer))
 148 004e 8083      		st Z,r24
 180:setup.c       **** 		if (receivedBuffer[x] == 0) {
 149               		.loc 1 180 0
 150 0050 8823      		tst r24
 151 0052 01F0      		breq .L13
 181:setup.c       **** 			break;
 182:setup.c       **** 		}
 183:setup.c       **** 		x++;
 152               		.loc 1 183 0
 153 0054 CF5F      		subi r28,lo8(-(1))
 154               	.LVL12:
 184:setup.c       **** 	}
 155               		.loc 1 184 0
 156 0056 00C0      		rjmp .L15
 157               	.L13:
 158               	/* epilogue start */
 185:setup.c       **** }
 159               		.loc 1 185 0
 160 0058 CF91      		pop r28
 161               	.LVL13:
 162 005a 0895      		ret
 163               		.cfi_endproc
 164               	.LFE15:
 166               	.global	rd_wr_csmreq_cs2_reset
 168               	rd_wr_csmreq_cs2_reset:
 169               	.LFB16:
 186:setup.c       **** 
 187:setup.c       **** // Turn RD, WR, CS/MREQ and CS2 to high so they are deselected (reset state)
 188:setup.c       **** void rd_wr_csmreq_cs2_reset(void) {
 170               		.loc 1 188 0
 171               		.cfi_startproc
 172               	/* prologue: function */
 173               	/* frame size = 0 */
 174               	/* stack size = 0 */
 175               	.L__stack_usage = 0
 189:setup.c       **** 	cs2Pin_high; // CS2 off
 176               		.loc 1 189 0
 177 005c 3A9A      		sbi 0x7,2
 190:setup.c       **** 	cs_mreqPin_high; // CS/MREQ off
 178               		.loc 1 190 0
 179 005e 949A      		sbi 0x12,4
 191:setup.c       **** 	rdPin_high; // RD off
 180               		.loc 1 191 0
 181 0060 959A      		sbi 0x12,5
 192:setup.c       **** 	wrPin_high; // WR off
 182               		.loc 1 192 0
 183 0062 969A      		sbi 0x12,6
 184 0064 0895      		ret
 185               		.cfi_endproc
 186               	.LFE16:
 188               	.global	gb_mode
 190               	gb_mode:
 191               	.LFB17:
 193:setup.c       **** }
 194:setup.c       **** 
 195:setup.c       **** 
 196:setup.c       **** 
 197:setup.c       **** // ****** Gameboy / Gameboy Colour functions ******
 198:setup.c       **** 
 199:setup.c       **** // Set Gameboy mode
 200:setup.c       **** void gb_mode(void) {
 192               		.loc 1 200 0
 193               		.cfi_startproc
 194               	/* prologue: function */
 195               	/* frame size = 0 */
 196               	/* stack size = 0 */
 197               	.L__stack_usage = 0
 201:setup.c       **** 	// Set inputs
 202:setup.c       **** 	PORT_DATA7_0 = 0;
 198               		.loc 1 202 0
 199 0066 15BA      		out 0x15,__zero_reg__
 203:setup.c       **** 	DDR_DATA7_0 = 0;
 200               		.loc 1 203 0
 201 0068 14BA      		out 0x14,__zero_reg__
 204:setup.c       **** 	
 205:setup.c       **** 	// Set outputs
 206:setup.c       **** 	PORT_ADDR7_0 = 0;
 202               		.loc 1 206 0
 203 006a 18BA      		out 0x18,__zero_reg__
 207:setup.c       **** 	PORT_ADDR15_8 = 0;
 204               		.loc 1 207 0
 205 006c 1BBA      		out 0x1b,__zero_reg__
 208:setup.c       **** 	DDR_ADDR7_0 = 0xFF;
 206               		.loc 1 208 0
 207 006e 8FEF      		ldi r24,lo8(-1)
 208 0070 87BB      		out 0x17,r24
 209:setup.c       **** 	DDR_ADDR15_8 = 0xFF;
 209               		.loc 1 209 0
 210 0072 8ABB      		out 0x1a,r24
 211 0074 0895      		ret
 212               		.cfi_endproc
 213               	.LFE17:
 215               	.global	set_16bit_address
 217               	set_16bit_address:
 218               	.LFB18:
 210:setup.c       **** }
 211:setup.c       **** 
 212:setup.c       **** // Set the 16 bit address on A15-0
 213:setup.c       **** void set_16bit_address(uint16_t address) {
 219               		.loc 1 213 0
 220               		.cfi_startproc
 221               	.LVL14:
 222               	/* prologue: function */
 223               	/* frame size = 0 */
 224               	/* stack size = 0 */
 225               	.L__stack_usage = 0
 214:setup.c       **** 	PORT_ADDR15_8 = (address >> 8);
 226               		.loc 1 214 0
 227 0076 9BBB      		out 0x1b,r25
 215:setup.c       **** 	PORT_ADDR7_0 = (address & 0xFF);
 228               		.loc 1 215 0
 229 0078 88BB      		out 0x18,r24
 230 007a 0895      		ret
 231               		.cfi_endproc
 232               	.LFE18:
 234               	.global	read_8bit_data
 236               	read_8bit_data:
 237               	.LFB19:
 216:setup.c       **** }
 217:setup.c       **** 
 218:setup.c       **** // Set the address and read a byte from the 8 bit data line
 219:setup.c       **** uint8_t read_8bit_data(uint16_t address) {
 238               		.loc 1 219 0
 239               		.cfi_startproc
 240               	.LVL15:
 241               	/* prologue: function */
 242               	/* frame size = 0 */
 243               	/* stack size = 0 */
 244               	.L__stack_usage = 0
 220:setup.c       **** 	set_16bit_address(address);
 245               		.loc 1 220 0
 246 007c 00D0      		rcall set_16bit_address
 247               	.LVL16:
 221:setup.c       **** 	
 222:setup.c       **** 	cs_mreqPin_low;
 248               		.loc 1 222 0
 249 007e 9498      		cbi 0x12,4
 223:setup.c       **** 	rdPin_low;
 250               		.loc 1 223 0
 251 0080 9598      		cbi 0x12,5
 224:setup.c       **** 	
 225:setup.c       **** 	asm volatile("nop"); // Delay a little (minimum needed is 1 nops, 2 nops for GB camera)
 252               		.loc 1 225 0
 253               	/* #APP */
 254               	 ;  225 "setup.c" 1
 255 0082 0000      		nop
 256               	 ;  0 "" 2
 226:setup.c       **** 	asm volatile("nop");
 257               		.loc 1 226 0
 258               	 ;  226 "setup.c" 1
 259 0084 0000      		nop
 260               	 ;  0 "" 2
 227:setup.c       **** 	uint8_t data = PIN_DATA7_0; // Read data
 261               		.loc 1 227 0
 262               	/* #NOAPP */
 263 0086 83B3      		in r24,0x13
 264               	.LVL17:
 228:setup.c       **** 	
 229:setup.c       **** 	rdPin_high;
 265               		.loc 1 229 0
 266 0088 959A      		sbi 0x12,5
 230:setup.c       **** 	cs_mreqPin_high;
 267               		.loc 1 230 0
 268 008a 949A      		sbi 0x12,4
 231:setup.c       **** 	
 232:setup.c       **** 	return data;
 233:setup.c       **** }
 269               		.loc 1 233 0
 270 008c 0895      		ret
 271               		.cfi_endproc
 272               	.LFE19:
 274               	.global	write_8bit_data
 276               	write_8bit_data:
 277               	.LFB20:
 234:setup.c       **** 
 235:setup.c       **** // Set the address and write a byte to the 8 bit data line and pulse cs/mREQ if writing to RAM
 236:setup.c       **** void write_8bit_data(uint16_t address, uint8_t data, uint8_t type) {
 278               		.loc 1 236 0
 279               		.cfi_startproc
 280               	.LVL18:
 281 008e CF93      		push r28
 282               	.LCFI6:
 283               		.cfi_def_cfa_offset 3
 284               		.cfi_offset 28, -2
 285 0090 DF93      		push r29
 286               	.LCFI7:
 287               		.cfi_def_cfa_offset 4
 288               		.cfi_offset 29, -3
 289 0092 00D0      		rcall .
 290               	.LCFI8:
 291               		.cfi_def_cfa_offset 6
 292 0094 CDB7      		in r28,__SP_L__
 293 0096 DEB7      		in r29,__SP_H__
 294               	.LCFI9:
 295               		.cfi_def_cfa_register 28
 296               	/* prologue: function */
 297               	/* frame size = 2 */
 298               	/* stack size = 4 */
 299               	.L__stack_usage = 4
 237:setup.c       **** 	set_16bit_address(address);
 300               		.loc 1 237 0
 301 0098 4A83      		std Y+2,r20
 302 009a 6983      		std Y+1,r22
 303 009c 00D0      		rcall set_16bit_address
 304               	.LVL19:
 238:setup.c       **** 	
 239:setup.c       **** 	DDR_DATA7_0 = 0xFF; // Set data pins as outputs
 305               		.loc 1 239 0
 306 009e 8FEF      		ldi r24,lo8(-1)
 307 00a0 84BB      		out 0x14,r24
 240:setup.c       **** 	PORT_DATA7_0 = data; // Set data
 308               		.loc 1 240 0
 309 00a2 6981      		ldd r22,Y+1
 310 00a4 65BB      		out 0x15,r22
 241:setup.c       **** 	
 242:setup.c       **** 	// Pulse WR and mREQ if the type matches
 243:setup.c       **** 	wrPin_low;
 311               		.loc 1 243 0
 312 00a6 9698      		cbi 0x12,6
 244:setup.c       **** 	if (type == MEMORY_WRITE) {
 313               		.loc 1 244 0
 314 00a8 4A81      		ldd r20,Y+2
 315 00aa 4130      		cpi r20,lo8(1)
 316 00ac 01F4      		brne .L21
 245:setup.c       **** 		cs_mreqPin_low;
 317               		.loc 1 245 0
 318 00ae 9498      		cbi 0x12,4
 319               	.L21:
 246:setup.c       **** 	}
 247:setup.c       **** 	
 248:setup.c       **** 	asm volatile("nop");
 320               		.loc 1 248 0
 321               	/* #APP */
 322               	 ;  248 "setup.c" 1
 323 00b0 0000      		nop
 324               	 ;  0 "" 2
 249:setup.c       **** 	
 250:setup.c       **** 	if (type == MEMORY_WRITE) {
 325               		.loc 1 250 0
 326               	/* #NOAPP */
 327 00b2 4130      		cpi r20,lo8(1)
 328 00b4 01F4      		brne .L22
 251:setup.c       **** 		cs_mreqPin_high;
 329               		.loc 1 251 0
 330 00b6 949A      		sbi 0x12,4
 331               	.L22:
 252:setup.c       **** 	}
 253:setup.c       **** 	wrPin_high;
 332               		.loc 1 253 0
 333 00b8 969A      		sbi 0x12,6
 254:setup.c       **** 	
 255:setup.c       **** 	// Clear data outputs and set data pins as inputs
 256:setup.c       **** 	PORT_DATA7_0 = 0;
 334               		.loc 1 256 0
 335 00ba 15BA      		out 0x15,__zero_reg__
 257:setup.c       **** 	DDR_DATA7_0 = 0;
 336               		.loc 1 257 0
 337 00bc 14BA      		out 0x14,__zero_reg__
 338               	/* epilogue start */
 258:setup.c       **** }
 339               		.loc 1 258 0
 340 00be 0F90      		pop __tmp_reg__
 341 00c0 0F90      		pop __tmp_reg__
 342 00c2 DF91      		pop r29
 343 00c4 CF91      		pop r28
 344 00c6 0895      		ret
 345               		.cfi_endproc
 346               	.LFE20:
 348               	.global	gba_mode
 350               	gba_mode:
 351               	.LFB21:
 259:setup.c       **** 
 260:setup.c       **** 
 261:setup.c       **** 
 262:setup.c       **** // ****** Gameboy Advance functions ****** 
 263:setup.c       **** 
 264:setup.c       **** // Set GBA mode
 265:setup.c       **** void gba_mode(void) {
 352               		.loc 1 265 0
 353               		.cfi_startproc
 354               	/* prologue: function */
 355               	/* frame size = 0 */
 356               	/* stack size = 0 */
 357               	.L__stack_usage = 0
 266:setup.c       **** 	// Set outputs for reading ROM addresses as default
 267:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = 0;
 358               		.loc 1 267 0
 359 00c8 18BA      		out 0x18,__zero_reg__
 268:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = 0;
 360               		.loc 1 268 0
 361 00ca 1BBA      		out 0x1b,__zero_reg__
 269:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = 0;
 362               		.loc 1 269 0
 363 00cc 15BA      		out 0x15,__zero_reg__
 270:setup.c       **** 	GBA_DDR_ROM_ADDR7_0 = 0xFF;
 364               		.loc 1 270 0
 365 00ce 8FEF      		ldi r24,lo8(-1)
 366 00d0 87BB      		out 0x17,r24
 271:setup.c       **** 	GBA_DDR_ROM_ADDR15_8 = 0xFF;
 367               		.loc 1 271 0
 368 00d2 8ABB      		out 0x1a,r24
 272:setup.c       **** 	GBA_DDR_ROM_ADDR23_16 = 0xFF;
 369               		.loc 1 272 0
 370 00d4 84BB      		out 0x14,r24
 371 00d6 0895      		ret
 372               		.cfi_endproc
 373               	.LFE21:
 375               	.global	gba_set_24bit_address
 377               	gba_set_24bit_address:
 378               	.LFB22:
 273:setup.c       **** }
 274:setup.c       **** 
 275:setup.c       **** // Set the 24 bit address on A23-0
 276:setup.c       **** void gba_set_24bit_address(uint32_t address) {	
 379               		.loc 1 276 0
 380               		.cfi_startproc
 381               	.LVL20:
 382 00d8 0F93      		push r16
 383               	.LCFI10:
 384               		.cfi_def_cfa_offset 3
 385               		.cfi_offset 16, -2
 386 00da 1F93      		push r17
 387               	.LCFI11:
 388               		.cfi_def_cfa_offset 4
 389               		.cfi_offset 17, -3
 390               	/* prologue: function */
 391               	/* frame size = 0 */
 392               	/* stack size = 2 */
 393               	.L__stack_usage = 2
 277:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = 0; // Set 0-23 address lines low and set as outputs
 394               		.loc 1 277 0
 395 00dc 15BA      		out 0x15,__zero_reg__
 278:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = 0;
 396               		.loc 1 278 0
 397 00de 1BBA      		out 0x1b,__zero_reg__
 279:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = 0;
 398               		.loc 1 279 0
 399 00e0 18BA      		out 0x18,__zero_reg__
 280:setup.c       **** 	GBA_DDR_ROM_ADDR23_16 = 0xFF;
 400               		.loc 1 280 0
 401 00e2 2FEF      		ldi r18,lo8(-1)
 402 00e4 24BB      		out 0x14,r18
 281:setup.c       **** 	GBA_DDR_ROM_ADDR15_8 = 0xFF;
 403               		.loc 1 281 0
 404 00e6 2ABB      		out 0x1a,r18
 282:setup.c       **** 	GBA_DDR_ROM_ADDR7_0 = 0xFF;
 405               		.loc 1 282 0
 406 00e8 27BB      		out 0x17,r18
 283:setup.c       **** 	
 284:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = (address >> 16);
 407               		.loc 1 284 0
 408 00ea 8C01      		movw r16,r24
 409 00ec 2227      		clr r18
 410 00ee 3327      		clr r19
 411 00f0 05BB      		out 0x15,r16
 285:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = (address >> 8);
 412               		.loc 1 285 0
 413 00f2 072F      		mov r16,r23
 414 00f4 182F      		mov r17,r24
 415 00f6 292F      		mov r18,r25
 416 00f8 3327      		clr r19
 417 00fa 0BBB      		out 0x1b,r16
 286:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = (address & 0xFF);
 418               		.loc 1 286 0
 419 00fc 68BB      		out 0x18,r22
 420               	/* epilogue start */
 287:setup.c       **** }
 421               		.loc 1 287 0
 422 00fe 1F91      		pop r17
 423 0100 0F91      		pop r16
 424 0102 0895      		ret
 425               		.cfi_endproc
 426               	.LFE22:
 428               	.global	gba_read_16bit_data
 430               	gba_read_16bit_data:
 431               	.LFB23:
 288:setup.c       **** 
 289:setup.c       **** 
 290:setup.c       **** 
 291:setup.c       **** // ---------- ROM/SRAM ----------
 292:setup.c       **** 
 293:setup.c       **** // Read a byte from the 16 bit data line non-sequentially
 294:setup.c       **** uint16_t gba_read_16bit_data(uint32_t address) {
 432               		.loc 1 294 0
 433               		.cfi_startproc
 434               	.LVL21:
 435               	/* prologue: function */
 436               	/* frame size = 0 */
 437               	/* stack size = 0 */
 438               	.L__stack_usage = 0
 295:setup.c       **** 	gba_set_24bit_address(address);
 439               		.loc 1 295 0
 440 0104 00D0      		rcall gba_set_24bit_address
 441               	.LVL22:
 296:setup.c       **** 	
 297:setup.c       **** 	cs_mreqPin_low;
 442               		.loc 1 297 0
 443 0106 9498      		cbi 0x12,4
 298:setup.c       **** 	
 299:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = 0; // Set address lines low and set as inputs
 444               		.loc 1 299 0
 445 0108 1BBA      		out 0x1b,__zero_reg__
 300:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = 0;
 446               		.loc 1 300 0
 447 010a 18BA      		out 0x18,__zero_reg__
 301:setup.c       **** 	GBA_DDR_ROM_ADDR15_8 = 0;
 448               		.loc 1 301 0
 449 010c 1ABA      		out 0x1a,__zero_reg__
 302:setup.c       **** 	GBA_DDR_ROM_ADDR7_0 = 0;
 450               		.loc 1 302 0
 451 010e 17BA      		out 0x17,__zero_reg__
 303:setup.c       **** 	
 304:setup.c       **** 	rdPin_low;
 452               		.loc 1 304 0
 453 0110 9598      		cbi 0x12,5
 305:setup.c       **** 	asm volatile("nop");
 454               		.loc 1 305 0
 455               	/* #APP */
 456               	 ;  305 "setup.c" 1
 457 0112 0000      		nop
 458               	 ;  0 "" 2
 306:setup.c       **** 	
 307:setup.c       **** 	uint16_t data = (GBA_PIN_ROM_DATA15_8 << 8) | GBA_PIN_ROM_DATA7_0; // Read data
 459               		.loc 1 307 0
 460               	/* #NOAPP */
 461 0114 29B3      		in r18,0x19
 462 0116 86B3      		in r24,0x16
 463               	.LVL23:
 308:setup.c       **** 	
 309:setup.c       **** 	rdPin_high;
 464               		.loc 1 309 0
 465 0118 959A      		sbi 0x12,5
 310:setup.c       **** 	cs_mreqPin_high;
 466               		.loc 1 310 0
 467 011a 949A      		sbi 0x12,4
 307:setup.c       **** 	
 468               		.loc 1 307 0
 469 011c 90E0      		ldi r25,0
 311:setup.c       **** 	
 312:setup.c       **** 	return data;
 313:setup.c       **** }
 470               		.loc 1 313 0
 471 011e 922B      		or r25,r18
 472 0120 0895      		ret
 473               		.cfi_endproc
 474               	.LFE23:
 476               	.global	gba_read_ram_8bit_data
 478               	gba_read_ram_8bit_data:
 479               	.LFB24:
 314:setup.c       **** 
 315:setup.c       **** // Set the address and read a byte from the 8 bit data line
 316:setup.c       **** uint8_t gba_read_ram_8bit_data(uint16_t address) {
 480               		.loc 1 316 0
 481               		.cfi_startproc
 482               	.LVL24:
 483               	/* prologue: function */
 484               	/* frame size = 0 */
 485               	/* stack size = 0 */
 486               	.L__stack_usage = 0
 317:setup.c       **** 	set_16bit_address(address);
 487               		.loc 1 317 0
 488 0122 00D0      		rcall set_16bit_address
 489               	.LVL25:
 318:setup.c       **** 	
 319:setup.c       **** 	rdPin_low;
 490               		.loc 1 319 0
 491 0124 9598      		cbi 0x12,5
 320:setup.c       **** 	cs2Pin_low; // CS2 pin low for SRAM/Flash select
 492               		.loc 1 320 0
 493 0126 3A98      		cbi 0x7,2
 321:setup.c       **** 	
 322:setup.c       **** 	asm volatile("nop"); // Delay a little (minimum needed is 2)
 494               		.loc 1 322 0
 495               	/* #APP */
 496               	 ;  322 "setup.c" 1
 497 0128 0000      		nop
 498               	 ;  0 "" 2
 323:setup.c       **** 	asm volatile("nop");
 499               		.loc 1 323 0
 500               	 ;  323 "setup.c" 1
 501 012a 0000      		nop
 502               	 ;  0 "" 2
 324:setup.c       **** 	
 325:setup.c       **** 	uint8_t data = GBA_PIN_RAM_DATA7_0; // Read data
 503               		.loc 1 325 0
 504               	/* #NOAPP */
 505 012c 83B3      		in r24,0x13
 506               	.LVL26:
 326:setup.c       **** 	
 327:setup.c       **** 	cs2Pin_high;
 507               		.loc 1 327 0
 508 012e 3A9A      		sbi 0x7,2
 328:setup.c       **** 	rdPin_high;
 509               		.loc 1 328 0
 510 0130 959A      		sbi 0x12,5
 329:setup.c       **** 	
 330:setup.c       **** 	return data;
 331:setup.c       **** }
 511               		.loc 1 331 0
 512 0132 0895      		ret
 513               		.cfi_endproc
 514               	.LFE24:
 516               	.global	gba_write_ram_8bit_data
 518               	gba_write_ram_8bit_data:
 519               	.LFB25:
 332:setup.c       **** 
 333:setup.c       **** // Set the address and write a byte to the 8 bit data line 
 334:setup.c       **** void gba_write_ram_8bit_data(uint16_t address, uint8_t data) {
 520               		.loc 1 334 0
 521               		.cfi_startproc
 522               	.LVL27:
 523 0134 CF93      		push r28
 524               	.LCFI12:
 525               		.cfi_def_cfa_offset 3
 526               		.cfi_offset 28, -2
 527 0136 DF93      		push r29
 528               	.LCFI13:
 529               		.cfi_def_cfa_offset 4
 530               		.cfi_offset 29, -3
 531 0138 1F92      		push __zero_reg__
 532               	.LCFI14:
 533               		.cfi_def_cfa_offset 5
 534 013a CDB7      		in r28,__SP_L__
 535 013c DEB7      		in r29,__SP_H__
 536               	.LCFI15:
 537               		.cfi_def_cfa_register 28
 538               	/* prologue: function */
 539               	/* frame size = 1 */
 540               	/* stack size = 3 */
 541               	.L__stack_usage = 3
 335:setup.c       **** 	set_16bit_address(address);
 542               		.loc 1 335 0
 543 013e 6983      		std Y+1,r22
 544 0140 00D0      		rcall set_16bit_address
 545               	.LVL28:
 336:setup.c       **** 	
 337:setup.c       **** 	GBA_DDR_RAM_DATA7_0 = 0xFF; // Set data pins as outputs
 546               		.loc 1 337 0
 547 0142 8FEF      		ldi r24,lo8(-1)
 548 0144 84BB      		out 0x14,r24
 338:setup.c       **** 	GBA_PORT_RAM_DATA7_0 = data; // Set data
 549               		.loc 1 338 0
 550 0146 6981      		ldd r22,Y+1
 551 0148 65BB      		out 0x15,r22
 339:setup.c       **** 	
 340:setup.c       **** 	// Pulse WR
 341:setup.c       **** 	wrPin_low;
 552               		.loc 1 341 0
 553 014a 9698      		cbi 0x12,6
 342:setup.c       **** 	cs2Pin_low; // CS2 pin low for SRAM/Flash select
 554               		.loc 1 342 0
 555 014c 3A98      		cbi 0x7,2
 343:setup.c       **** 	
 344:setup.c       **** 	asm volatile("nop");
 556               		.loc 1 344 0
 557               	/* #APP */
 558               	 ;  344 "setup.c" 1
 559 014e 0000      		nop
 560               	 ;  0 "" 2
 345:setup.c       **** 	asm volatile("nop");
 561               		.loc 1 345 0
 562               	 ;  345 "setup.c" 1
 563 0150 0000      		nop
 564               	 ;  0 "" 2
 346:setup.c       **** 	
 347:setup.c       **** 	cs2Pin_high;
 565               		.loc 1 347 0
 566               	/* #NOAPP */
 567 0152 3A9A      		sbi 0x7,2
 348:setup.c       **** 	wrPin_high;
 568               		.loc 1 348 0
 569 0154 969A      		sbi 0x12,6
 349:setup.c       **** 	
 350:setup.c       **** 	// Clear data outputs and set data pins as inputs
 351:setup.c       **** 	GBA_PORT_RAM_DATA7_0 = 0;
 570               		.loc 1 351 0
 571 0156 15BA      		out 0x15,__zero_reg__
 352:setup.c       **** 	GBA_DDR_RAM_DATA7_0 = 0;
 572               		.loc 1 352 0
 573 0158 14BA      		out 0x14,__zero_reg__
 574               	/* epilogue start */
 353:setup.c       **** }
 575               		.loc 1 353 0
 576 015a 0F90      		pop __tmp_reg__
 577 015c DF91      		pop r29
 578 015e CF91      		pop r28
 579 0160 0895      		ret
 580               		.cfi_endproc
 581               	.LFE25:
 583               	.global	gba_eeprom_mode
 585               	gba_eeprom_mode:
 586               	.LFB26:
 354:setup.c       **** 
 355:setup.c       **** 
 356:setup.c       **** 
 357:setup.c       **** // ---------- EEPROM ----------
 358:setup.c       **** 
 359:setup.c       **** // Set address/data all high (includes AD0/A23)
 360:setup.c       **** void gba_eeprom_mode (void) {
 587               		.loc 1 360 0
 588               		.cfi_startproc
 589               	/* prologue: function */
 590               	/* frame size = 0 */
 591               	/* stack size = 0 */
 592               	.L__stack_usage = 0
 361:setup.c       **** 	GBA_DDR_ROM_ADDR7_0 = 0xFF;
 593               		.loc 1 361 0
 594 0162 8FEF      		ldi r24,lo8(-1)
 595 0164 87BB      		out 0x17,r24
 362:setup.c       **** 	GBA_DDR_ROM_ADDR15_8 = 0xFF;
 596               		.loc 1 362 0
 597 0166 8ABB      		out 0x1a,r24
 363:setup.c       **** 	GBA_DDR_ROM_ADDR23_16 = 0xFF;
 598               		.loc 1 363 0
 599 0168 84BB      		out 0x14,r24
 364:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = 0x80;
 600               		.loc 1 364 0
 601 016a 90E8      		ldi r25,lo8(-128)
 602 016c 98BB      		out 0x18,r25
 365:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = 0xFF;
 603               		.loc 1 365 0
 604 016e 8BBB      		out 0x1b,r24
 366:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = 0xFF;
 605               		.loc 1 366 0
 606 0170 85BB      		out 0x15,r24
 607 0172 0895      		ret
 608               		.cfi_endproc
 609               	.LFE26:
 611               	.global	gba_eeprom_set_address
 613               	gba_eeprom_set_address:
 614               	.LFB27:
 367:setup.c       **** }
 368:setup.c       **** 
 369:setup.c       **** // Send out EEPROM address serially (WR clock, AD0 data out)
 370:setup.c       **** void gba_eeprom_set_address(uint16_t address, uint8_t eepromSize, uint8_t command) {
 615               		.loc 1 370 0
 616               		.cfi_startproc
 617               	.LVL29:
 618               	/* prologue: function */
 619               	/* frame size = 0 */
 620               	/* stack size = 0 */
 621               	.L__stack_usage = 0
 371:setup.c       **** 	cs_mreqPin_low;
 622               		.loc 1 371 0
 623 0174 9498      		cbi 0x12,4
 624               	.LVL30:
 372:setup.c       **** 	
 373:setup.c       **** 	int8_t x = 0;
 374:setup.c       **** 	if (eepromSize == EEPROM_64KBIT) {
 625               		.loc 1 374 0
 626 0176 6230      		cpi r22,lo8(2)
 627 0178 01F4      		brne .L30
 375:setup.c       **** 		if (command == EEPROM_READ) {
 628               		.loc 1 375 0
 629 017a 4111      		cpse r20,__zero_reg__
 630 017c 00C0      		rjmp .L31
 376:setup.c       **** 			address |= (1<<15) | (1<<14); // Set upper 2 bits high for read request
 631               		.loc 1 376 0
 632 017e 906C      		ori r25,192
 633               	.LVL31:
 634               	.L40:
 377:setup.c       **** 		}
 378:setup.c       **** 		else {
 379:setup.c       **** 			address |= (1<<15); // Set upper 1 bit high for write request
 380:setup.c       **** 		}
 381:setup.c       **** 		x = 15;
 635               		.loc 1 381 0
 636 0180 2FE0      		ldi r18,lo8(15)
 637               	.L33:
 638               	.LVL32:
 382:setup.c       **** 	}
 383:setup.c       **** 	else {
 384:setup.c       **** 		if (command == EEPROM_READ) {
 385:setup.c       **** 			address |= (1<<7) | (1<<6);
 386:setup.c       **** 		}
 387:setup.c       **** 		else {
 388:setup.c       **** 			address |= (1<<7);
 389:setup.c       **** 		}
 390:setup.c       **** 		x = 7;
 391:setup.c       **** 	}
 392:setup.c       **** 	
 393:setup.c       **** 	// Loop through address, 8 or 16 bits depending on EEPROM (includes the 2 bits for request type)
 394:setup.c       **** 	while (x >= 0) {
 395:setup.c       **** 		if (address & (1<<x)) {
 639               		.loc 1 395 0
 640 0182 E1E0      		ldi r30,lo8(1)
 641 0184 F0E0      		ldi r31,0
 642 0186 00C0      		rjmp .L32
 643               	.LVL33:
 644               	.L31:
 379:setup.c       **** 		}
 645               		.loc 1 379 0
 646 0188 9068      		ori r25,128
 647               	.LVL34:
 648 018a 00C0      		rjmp .L40
 649               	.L30:
 384:setup.c       **** 			address |= (1<<7) | (1<<6);
 650               		.loc 1 384 0
 651 018c 4111      		cpse r20,__zero_reg__
 652 018e 00C0      		rjmp .L34
 385:setup.c       **** 		}
 653               		.loc 1 385 0
 654 0190 806C      		ori r24,192
 655               	.LVL35:
 656 0192 00C0      		rjmp .L39
 657               	.L34:
 388:setup.c       **** 		}
 658               		.loc 1 388 0
 659 0194 8068      		ori r24,128
 660               	.LVL36:
 661               	.L39:
 390:setup.c       **** 	}
 662               		.loc 1 390 0
 663 0196 27E0      		ldi r18,lo8(7)
 664 0198 00C0      		rjmp .L33
 665               	.LVL37:
 666               	.L35:
 396:setup.c       **** 			ad0Pin_high;
 397:setup.c       **** 		}
 398:setup.c       **** 		else {
 399:setup.c       **** 			ad0Pin_low;
 667               		.loc 1 399 0
 668 019a C098      		cbi 0x18,0
 669               	.L36:
 400:setup.c       **** 		}
 401:setup.c       **** 		
 402:setup.c       **** 		wrPin_low; // CLK
 670               		.loc 1 402 0
 671 019c 9698      		cbi 0x12,6
 403:setup.c       **** 		asm ("nop");
 672               		.loc 1 403 0
 673               	/* #APP */
 674               	 ;  403 "setup.c" 1
 675 019e 0000      		nop
 676               	 ;  0 "" 2
 404:setup.c       **** 		asm ("nop");
 677               		.loc 1 404 0
 678               	 ;  404 "setup.c" 1
 679 01a0 0000      		nop
 680               	 ;  0 "" 2
 405:setup.c       **** 		wrPin_high; 
 681               		.loc 1 405 0
 682               	/* #NOAPP */
 683 01a2 969A      		sbi 0x12,6
 406:setup.c       **** 		asm ("nop");
 684               		.loc 1 406 0
 685               	/* #APP */
 686               	 ;  406 "setup.c" 1
 687 01a4 0000      		nop
 688               	 ;  0 "" 2
 407:setup.c       **** 		asm ("nop");
 689               		.loc 1 407 0
 690               	 ;  407 "setup.c" 1
 691 01a6 0000      		nop
 692               	 ;  0 "" 2
 693               	/* #NOAPP */
 694 01a8 2150      		subi r18,lo8(-(-1))
 695               	.LVL38:
 394:setup.c       **** 		if (address & (1<<x)) {
 696               		.loc 1 394 0
 697 01aa 27FD      		sbrc r18,7
 698 01ac 00C0      		rjmp .L41
 699               	.L32:
 395:setup.c       **** 			ad0Pin_high;
 700               		.loc 1 395 0
 701 01ae BF01      		movw r22,r30
 702 01b0 022E      		mov r0,r18
 703 01b2 00C0      		rjmp 2f
 704               		1:
 705 01b4 660F      		lsl r22
 706 01b6 771F      		rol r23
 707               		2:
 708 01b8 0A94      		dec r0
 709 01ba 02F4      		brpl 1b
 710 01bc 6823      		and r22,r24
 711 01be 7923      		and r23,r25
 712 01c0 672B      		or r22,r23
 713 01c2 01F0      		breq .L35
 396:setup.c       **** 		}
 714               		.loc 1 396 0
 715 01c4 C09A      		sbi 0x18,0
 716 01c6 00C0      		rjmp .L36
 717               	.L41:
 408:setup.c       **** 		
 409:setup.c       **** 		x--;
 410:setup.c       **** 	}
 411:setup.c       **** 	
 412:setup.c       **** 	// Only send stop bit (0) and WR/CS high if reading, as writing is done in 1 continuous chunk
 413:setup.c       **** 	if (command == EEPROM_READ) {  
 718               		.loc 1 413 0
 719 01c8 4111      		cpse r20,__zero_reg__
 720 01ca 00C0      		rjmp .L29
 414:setup.c       **** 		ad0Pin_low;
 721               		.loc 1 414 0
 722 01cc C098      		cbi 0x18,0
 415:setup.c       **** 		asm ("nop");
 723               		.loc 1 415 0
 724               	/* #APP */
 725               	 ;  415 "setup.c" 1
 726 01ce 0000      		nop
 727               	 ;  0 "" 2
 416:setup.c       **** 		wrPin_low;
 728               		.loc 1 416 0
 729               	/* #NOAPP */
 730 01d0 9698      		cbi 0x12,6
 417:setup.c       **** 		asm ("nop");
 731               		.loc 1 417 0
 732               	/* #APP */
 733               	 ;  417 "setup.c" 1
 734 01d2 0000      		nop
 735               	 ;  0 "" 2
 418:setup.c       **** 		asm ("nop");
 736               		.loc 1 418 0
 737               	 ;  418 "setup.c" 1
 738 01d4 0000      		nop
 739               	 ;  0 "" 2
 419:setup.c       **** 		
 420:setup.c       **** 		wrPin_high;
 740               		.loc 1 420 0
 741               	/* #NOAPP */
 742 01d6 969A      		sbi 0x12,6
 421:setup.c       **** 		cs_mreqPin_high;
 743               		.loc 1 421 0
 744 01d8 949A      		sbi 0x12,4
 745               	.L29:
 746 01da 0895      		ret
 747               		.cfi_endproc
 748               	.LFE27:
 750               	.global	gba_eeprom_read
 752               	gba_eeprom_read:
 753               	.LFB28:
 422:setup.c       **** 	}
 423:setup.c       **** }
 424:setup.c       **** 
 425:setup.c       **** // Read 8 bytes from the EEPROM address, data is valid on rising edge
 426:setup.c       **** void gba_eeprom_read(uint16_t address, uint8_t eepromSize) {
 754               		.loc 1 426 0
 755               		.cfi_startproc
 756               	.LVL39:
 757               	/* prologue: function */
 758               	/* frame size = 0 */
 759               	/* stack size = 0 */
 760               	.L__stack_usage = 0
 427:setup.c       **** 	gba_eeprom_set_address(address, eepromSize, EEPROM_READ);
 761               		.loc 1 427 0
 762 01dc 40E0      		ldi r20,0
 763 01de 00D0      		rcall gba_eeprom_set_address
 764               	.LVL40:
 428:setup.c       **** 	
 429:setup.c       **** 	// Set AD0 pin as input
 430:setup.c       **** 	GBA_PORT_EEPROM_DATA7_0 &= ~(1<<AD0);
 765               		.loc 1 430 0
 766 01e0 C098      		cbi 0x18,0
 431:setup.c       **** 	GBA_DDR_EEPROM_DATA7_0 &= ~(1<<AD0);
 767               		.loc 1 431 0
 768 01e2 B898      		cbi 0x17,0
 432:setup.c       **** 	
 433:setup.c       **** 	cs_mreqPin_low;
 769               		.loc 1 433 0
 770 01e4 9498      		cbi 0x12,4
 771               	.LVL41:
 772 01e6 84E0      		ldi r24,lo8(4)
 773               	.LVL42:
 774               	.L43:
 775               	.LBB47:
 434:setup.c       **** 	
 435:setup.c       **** 	// Ignore first 4 bits
 436:setup.c       **** 	for (int8_t x = 0; x < 4; x++) {
 437:setup.c       **** 		rdPin_low; // CLK
 776               		.loc 1 437 0 discriminator 3
 777 01e8 9598      		cbi 0x12,5
 438:setup.c       **** 		asm ("nop");
 778               		.loc 1 438 0 discriminator 3
 779               	/* #APP */
 780               	 ;  438 "setup.c" 1
 781 01ea 0000      		nop
 782               	 ;  0 "" 2
 439:setup.c       **** 		asm ("nop");
 783               		.loc 1 439 0 discriminator 3
 784               	 ;  439 "setup.c" 1
 785 01ec 0000      		nop
 786               	 ;  0 "" 2
 440:setup.c       **** 		rdPin_high; 
 787               		.loc 1 440 0 discriminator 3
 788               	/* #NOAPP */
 789 01ee 959A      		sbi 0x12,5
 441:setup.c       **** 		asm ("nop");
 790               		.loc 1 441 0 discriminator 3
 791               	/* #APP */
 792               	 ;  441 "setup.c" 1
 793 01f0 0000      		nop
 794               	 ;  0 "" 2
 442:setup.c       **** 		asm ("nop");
 795               		.loc 1 442 0 discriminator 3
 796               	 ;  442 "setup.c" 1
 797 01f2 0000      		nop
 798               	 ;  0 "" 2
 799               	.LVL43:
 800               	/* #NOAPP */
 801 01f4 8150      		subi r24,lo8(-(-1))
 802               	.LVL44:
 436:setup.c       **** 		rdPin_low; // CLK
 803               		.loc 1 436 0 discriminator 3
 804 01f6 01F4      		brne .L43
 436:setup.c       **** 		rdPin_low; // CLK
 805               		.loc 1 436 0 is_stmt 0
 806 01f8 E0E0      		ldi r30,lo8(eepromBuffer)
 807 01fa F0E0      		ldi r31,hi8(eepromBuffer)
 808               	.LBE47:
 809               	.LBB48:
 810               	.LBB49:
 811               	.LBB50:
 443:setup.c       **** 	}
 444:setup.c       **** 	
 445:setup.c       **** 	// Read out 64 bits
 446:setup.c       **** 	for (uint8_t c = 0; c < 8; c++) {
 447:setup.c       **** 		uint8_t data = 0;
 448:setup.c       **** 		for (int8_t x = 7; x >= 0; x--) {
 449:setup.c       **** 			rdPin_low; // CLK
 450:setup.c       **** 			asm ("nop");
 451:setup.c       **** 			asm ("nop");
 452:setup.c       **** 			rdPin_high;
 453:setup.c       **** 			
 454:setup.c       **** 			if (GBA_PIN_EEPROM_DATA7_0 & (1<<AD0)) {
 455:setup.c       **** 				data |= (1<<x);
 812               		.loc 1 455 0 is_stmt 1
 813 01fc 41E0      		ldi r20,lo8(1)
 814 01fe 50E0      		ldi r21,0
 815 0200 38E0      		ldi r19,lo8(8)
 816 0202 3E0F      		add r19,r30
 817               	.LVL45:
 818               	.L44:
 819               	.LBE50:
 820               	.LBE49:
 821               	.LBE48:
 433:setup.c       **** 	
 822               		.loc 1 433 0
 823 0204 87E0      		ldi r24,lo8(7)
 824 0206 90E0      		ldi r25,0
 825 0208 20E0      		ldi r18,0
 826               	.LVL46:
 827               	.L46:
 828               	.LBB53:
 829               	.LBB52:
 830               	.LBB51:
 449:setup.c       **** 			asm ("nop");
 831               		.loc 1 449 0
 832 020a 9598      		cbi 0x12,5
 450:setup.c       **** 			asm ("nop");
 833               		.loc 1 450 0
 834               	/* #APP */
 835               	 ;  450 "setup.c" 1
 836 020c 0000      		nop
 837               	 ;  0 "" 2
 451:setup.c       **** 			rdPin_high;
 838               		.loc 1 451 0
 839               	 ;  451 "setup.c" 1
 840 020e 0000      		nop
 841               	 ;  0 "" 2
 452:setup.c       **** 			
 842               		.loc 1 452 0
 843               	/* #NOAPP */
 844 0210 959A      		sbi 0x12,5
 454:setup.c       **** 				data |= (1<<x);
 845               		.loc 1 454 0
 846 0212 B09B      		sbis 0x16,0
 847 0214 00C0      		rjmp .L45
 848               		.loc 1 455 0
 849 0216 BA01      		movw r22,r20
 850 0218 082E      		mov r0,r24
 851 021a 00C0      		rjmp 2f
 852               		1:
 853 021c 660F      		lsl r22
 854               		2:
 855 021e 0A94      		dec r0
 856 0220 02F4      		brpl 1b
 857 0222 262B      		or r18,r22
 858               	.LVL47:
 859               	.L45:
 860               	.LVL48:
 861 0224 0197      		sbiw r24,1
 862 0226 00F4      		brcc .L46
 863               	.LBE51:
 456:setup.c       **** 			}
 457:setup.c       **** 		}
 458:setup.c       **** 		eepromBuffer[c] = data;
 864               		.loc 1 458 0
 865 0228 2193      		st Z+,r18
 866               	.LVL49:
 867               	.LBE52:
 446:setup.c       **** 		uint8_t data = 0;
 868               		.loc 1 446 0
 869 022a 3E13      		cpse r19,r30
 870 022c 00C0      		rjmp .L44
 871               	.LBE53:
 459:setup.c       **** 	}
 460:setup.c       **** 	
 461:setup.c       **** 	cs_mreqPin_high;
 872               		.loc 1 461 0
 873 022e 949A      		sbi 0x12,4
 462:setup.c       **** 	
 463:setup.c       **** 	// Set AD0 pin as output
 464:setup.c       **** 	GBA_PORT_EEPROM_DATA7_0 |= (1<<AD0);
 874               		.loc 1 464 0
 875 0230 C09A      		sbi 0x18,0
 465:setup.c       **** 	GBA_DDR_EEPROM_DATA7_0 |= (1<<AD0);
 876               		.loc 1 465 0
 877 0232 B89A      		sbi 0x17,0
 878 0234 0895      		ret
 879               		.cfi_endproc
 880               	.LFE28:
 882               	.global	gba_eeprom_write
 884               	gba_eeprom_write:
 885               	.LFB29:
 466:setup.c       **** }
 467:setup.c       **** 
 468:setup.c       **** // Write 8 bytes to the EEPROM address
 469:setup.c       **** void gba_eeprom_write(uint16_t address, uint8_t eepromSize) {
 886               		.loc 1 469 0
 887               		.cfi_startproc
 888               	.LVL50:
 889               	/* prologue: function */
 890               	/* frame size = 0 */
 891               	/* stack size = 0 */
 892               	.L__stack_usage = 0
 470:setup.c       **** 	gba_eeprom_set_address(address, eepromSize, EEPROM_WRITE);
 893               		.loc 1 470 0
 894 0236 41E0      		ldi r20,lo8(1)
 895 0238 00D0      		rcall gba_eeprom_set_address
 896               	.LVL51:
 897 023a E0E0      		ldi r30,lo8(eepromBuffer)
 898 023c F0E0      		ldi r31,hi8(eepromBuffer)
 899 023e 48E0      		ldi r20,lo8(8)
 900 0240 4E0F      		add r20,r30
 901               	.LVL52:
 902               	.L54:
 469:setup.c       **** 	gba_eeprom_set_address(address, eepromSize, EEPROM_WRITE);
 903               		.loc 1 469 0
 904 0242 27E0      		ldi r18,lo8(7)
 905 0244 30E0      		ldi r19,0
 906               	.LVL53:
 907               	.L57:
 908               	.LBB54:
 909               	.LBB55:
 471:setup.c       **** 	
 472:setup.c       **** 	// Write 64 bits
 473:setup.c       **** 	for (uint8_t c = 0; c < 8; c++) {
 474:setup.c       **** 		for (int8_t x = 7; x >= 0; x--) {
 475:setup.c       **** 			if (eepromBuffer[c] & (1<<x)) {
 910               		.loc 1 475 0
 911 0246 8081      		ld r24,Z
 912 0248 90E0      		ldi r25,0
 913 024a 022E      		mov r0,r18
 914 024c 00C0      		rjmp 2f
 915               		1:
 916 024e 9595      		asr r25
 917 0250 8795      		ror r24
 918               		2:
 919 0252 0A94      		dec r0
 920 0254 02F4      		brpl 1b
 921 0256 80FF      		sbrs r24,0
 922 0258 00C0      		rjmp .L55
 476:setup.c       **** 				ad0Pin_high;
 923               		.loc 1 476 0
 924 025a C09A      		sbi 0x18,0
 925 025c 00C0      		rjmp .L56
 926               	.L55:
 477:setup.c       **** 			}
 478:setup.c       **** 			else {
 479:setup.c       **** 				ad0Pin_low;
 927               		.loc 1 479 0
 928 025e C098      		cbi 0x18,0
 929               	.L56:
 480:setup.c       **** 			}
 481:setup.c       **** 			
 482:setup.c       **** 			wrPin_low; // CLK
 930               		.loc 1 482 0 discriminator 2
 931 0260 9698      		cbi 0x12,6
 483:setup.c       **** 			asm ("nop");
 932               		.loc 1 483 0 discriminator 2
 933               	/* #APP */
 934               	 ;  483 "setup.c" 1
 935 0262 0000      		nop
 936               	 ;  0 "" 2
 484:setup.c       **** 			asm ("nop");
 937               		.loc 1 484 0 discriminator 2
 938               	 ;  484 "setup.c" 1
 939 0264 0000      		nop
 940               	 ;  0 "" 2
 485:setup.c       **** 			wrPin_high; 
 941               		.loc 1 485 0 discriminator 2
 942               	/* #NOAPP */
 943 0266 969A      		sbi 0x12,6
 486:setup.c       **** 			asm ("nop");
 944               		.loc 1 486 0 discriminator 2
 945               	/* #APP */
 946               	 ;  486 "setup.c" 1
 947 0268 0000      		nop
 948               	 ;  0 "" 2
 487:setup.c       **** 			asm ("nop");
 949               		.loc 1 487 0 discriminator 2
 950               	 ;  487 "setup.c" 1
 951 026a 0000      		nop
 952               	 ;  0 "" 2
 953               	.LVL54:
 954               	/* #NOAPP */
 955               	.LVL55:
 956 026c 2150      		subi r18,1
 957 026e 3109      		sbc r19,__zero_reg__
 958 0270 00F4      		brcc .L57
 959 0272 3196      		adiw r30,1
 960               	.LVL56:
 961               	.LBE55:
 473:setup.c       **** 		for (int8_t x = 7; x >= 0; x--) {
 962               		.loc 1 473 0 discriminator 2
 963 0274 4E13      		cpse r20,r30
 964 0276 00C0      		rjmp .L54
 965               	.LBE54:
 488:setup.c       **** 		}
 489:setup.c       **** 	}
 490:setup.c       **** 	
 491:setup.c       **** 	// Last bit low
 492:setup.c       **** 	ad0Pin_low;
 966               		.loc 1 492 0
 967 0278 C098      		cbi 0x18,0
 493:setup.c       **** 	wrPin_low; // CLK
 968               		.loc 1 493 0
 969 027a 9698      		cbi 0x12,6
 494:setup.c       **** 	asm ("nop");
 970               		.loc 1 494 0
 971               	/* #APP */
 972               	 ;  494 "setup.c" 1
 973 027c 0000      		nop
 974               	 ;  0 "" 2
 495:setup.c       **** 	asm ("nop");
 975               		.loc 1 495 0
 976               	 ;  495 "setup.c" 1
 977 027e 0000      		nop
 978               	 ;  0 "" 2
 496:setup.c       **** 	wrPin_high; 
 979               		.loc 1 496 0
 980               	/* #NOAPP */
 981 0280 969A      		sbi 0x12,6
 497:setup.c       **** 	asm ("nop");
 982               		.loc 1 497 0
 983               	/* #APP */
 984               	 ;  497 "setup.c" 1
 985 0282 0000      		nop
 986               	 ;  0 "" 2
 498:setup.c       **** 	asm ("nop");
 987               		.loc 1 498 0
 988               	 ;  498 "setup.c" 1
 989 0284 0000      		nop
 990               	 ;  0 "" 2
 499:setup.c       **** 	
 500:setup.c       **** 	cs_mreqPin_high;
 991               		.loc 1 500 0
 992               	/* #NOAPP */
 993 0286 949A      		sbi 0x12,4
 994 0288 0895      		ret
 995               		.cfi_endproc
 996               	.LFE29:
 998               	.global	flash_write_bus_cycle
 1000               	flash_write_bus_cycle:
 1001               	.LFB30:
 501:setup.c       **** }
 502:setup.c       **** 
 503:setup.c       **** 
 504:setup.c       **** 
 505:setup.c       **** // ---------- FLASH ----------
 506:setup.c       **** 
 507:setup.c       **** // Set the address and data for the write byte cycle to the flash
 508:setup.c       **** void flash_write_bus_cycle(uint16_t address, uint8_t data) {
 1002               		.loc 1 508 0
 1003               		.cfi_startproc
 1004               	.LVL57:
 1005 028a CF93      		push r28
 1006               	.LCFI16:
 1007               		.cfi_def_cfa_offset 3
 1008               		.cfi_offset 28, -2
 1009 028c DF93      		push r29
 1010               	.LCFI17:
 1011               		.cfi_def_cfa_offset 4
 1012               		.cfi_offset 29, -3
 1013 028e 1F92      		push __zero_reg__
 1014               	.LCFI18:
 1015               		.cfi_def_cfa_offset 5
 1016 0290 CDB7      		in r28,__SP_L__
 1017 0292 DEB7      		in r29,__SP_H__
 1018               	.LCFI19:
 1019               		.cfi_def_cfa_register 28
 1020               	/* prologue: function */
 1021               	/* frame size = 1 */
 1022               	/* stack size = 3 */
 1023               	.L__stack_usage = 3
 509:setup.c       **** 	GBA_DDR_RAM_DATA7_0 = 0xFF; // Set data pins as outputs
 1024               		.loc 1 509 0
 1025 0294 2FEF      		ldi r18,lo8(-1)
 1026 0296 24BB      		out 0x14,r18
 510:setup.c       **** 	set_16bit_address(address);
 1027               		.loc 1 510 0
 1028 0298 6983      		std Y+1,r22
 1029 029a 00D0      		rcall set_16bit_address
 1030               	.LVL58:
 511:setup.c       **** 	GBA_PORT_RAM_DATA7_0 = data;
 1031               		.loc 1 511 0
 1032 029c 6981      		ldd r22,Y+1
 1033 029e 65BB      		out 0x15,r22
 512:setup.c       **** 	
 513:setup.c       **** 	wrPin_low;
 1034               		.loc 1 513 0
 1035 02a0 9698      		cbi 0x12,6
 514:setup.c       **** 	cs2Pin_low;
 1036               		.loc 1 514 0
 1037 02a2 3A98      		cbi 0x7,2
 515:setup.c       **** 	asm volatile("nop");
 1038               		.loc 1 515 0
 1039               	/* #APP */
 1040               	 ;  515 "setup.c" 1
 1041 02a4 0000      		nop
 1042               	 ;  0 "" 2
 516:setup.c       **** 	wrPin_high;
 1043               		.loc 1 516 0
 1044               	/* #NOAPP */
 1045 02a6 969A      		sbi 0x12,6
 517:setup.c       **** 	cs2Pin_high;
 1046               		.loc 1 517 0
 1047 02a8 3A9A      		sbi 0x7,2
 1048               	/* epilogue start */
 518:setup.c       **** }
 1049               		.loc 1 518 0
 1050 02aa 0F90      		pop __tmp_reg__
 1051 02ac DF91      		pop r29
 1052 02ae CF91      		pop r28
 1053 02b0 0895      		ret
 1054               		.cfi_endproc
 1055               	.LFE30:
 1057               	.global	flash_read_chip_id
 1059               	flash_read_chip_id:
 1060               	.LFB31:
 519:setup.c       **** 
 520:setup.c       **** // Read the flash manufacturer and device ID (Software ID)
 521:setup.c       **** void flash_read_chip_id(void) {
 1061               		.loc 1 521 0
 1062               		.cfi_startproc
 1063 02b2 CF93      		push r28
 1064               	.LCFI20:
 1065               		.cfi_def_cfa_offset 3
 1066               		.cfi_offset 28, -2
 1067 02b4 DF93      		push r29
 1068               	.LCFI21:
 1069               		.cfi_def_cfa_offset 4
 1070               		.cfi_offset 29, -3
 1071               	/* prologue: function */
 1072               	/* frame size = 0 */
 1073               	/* stack size = 2 */
 1074               	.L__stack_usage = 2
 522:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xAA);
 1075               		.loc 1 522 0
 1076 02b6 6AEA      		ldi r22,lo8(-86)
 1077 02b8 85E5      		ldi r24,lo8(85)
 1078 02ba 95E5      		ldi r25,lo8(85)
 1079 02bc 00D0      		rcall flash_write_bus_cycle
 1080               	.LVL59:
 523:setup.c       **** 	flash_write_bus_cycle(0x2AAA, 0x55);
 1081               		.loc 1 523 0
 1082 02be 65E5      		ldi r22,lo8(85)
 1083 02c0 8AEA      		ldi r24,lo8(-86)
 1084 02c2 9AE2      		ldi r25,lo8(42)
 1085 02c4 00D0      		rcall flash_write_bus_cycle
 1086               	.LVL60:
 524:setup.c       **** 	flash_write_bus_cycle(0x5555, 0x90); // Software ID entry
 1087               		.loc 1 524 0
 1088 02c6 60E9      		ldi r22,lo8(-112)
 1089 02c8 85E5      		ldi r24,lo8(85)
 1090 02ca 95E5      		ldi r25,lo8(85)
 1091 02cc 00D0      		rcall flash_write_bus_cycle
 1092               	.LVL61:
 1093               	.LBB56:
 1094               	.LBB57:
 1095               		.file 2 "c:\\winavr-20100110\\avr\\include\\util\\delay.h"
   1:c:\winavr-20100110\avr\include\util\delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:c:\winavr-20100110\avr\include\util\delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:c:\winavr-20100110\avr\include\util\delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:c:\winavr-20100110\avr\include\util\delay.h ****    All rights reserved.
   5:c:\winavr-20100110\avr\include\util\delay.h **** 
   6:c:\winavr-20100110\avr\include\util\delay.h ****    Redistribution and use in source and binary forms, with or without
   7:c:\winavr-20100110\avr\include\util\delay.h ****    modification, are permitted provided that the following conditions are met:
   8:c:\winavr-20100110\avr\include\util\delay.h **** 
   9:c:\winavr-20100110\avr\include\util\delay.h ****    * Redistributions of source code must retain the above copyright
  10:c:\winavr-20100110\avr\include\util\delay.h ****      notice, this list of conditions and the following disclaimer.
  11:c:\winavr-20100110\avr\include\util\delay.h **** 
  12:c:\winavr-20100110\avr\include\util\delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:c:\winavr-20100110\avr\include\util\delay.h ****      notice, this list of conditions and the following disclaimer in
  14:c:\winavr-20100110\avr\include\util\delay.h ****      the documentation and/or other materials provided with the
  15:c:\winavr-20100110\avr\include\util\delay.h ****      distribution.
  16:c:\winavr-20100110\avr\include\util\delay.h **** 
  17:c:\winavr-20100110\avr\include\util\delay.h ****    * Neither the name of the copyright holders nor the names of
  18:c:\winavr-20100110\avr\include\util\delay.h ****      contributors may be used to endorse or promote products derived
  19:c:\winavr-20100110\avr\include\util\delay.h ****      from this software without specific prior written permission.
  20:c:\winavr-20100110\avr\include\util\delay.h **** 
  21:c:\winavr-20100110\avr\include\util\delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:c:\winavr-20100110\avr\include\util\delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:c:\winavr-20100110\avr\include\util\delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:c:\winavr-20100110\avr\include\util\delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:c:\winavr-20100110\avr\include\util\delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:c:\winavr-20100110\avr\include\util\delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:c:\winavr-20100110\avr\include\util\delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:c:\winavr-20100110\avr\include\util\delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:c:\winavr-20100110\avr\include\util\delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:c:\winavr-20100110\avr\include\util\delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:c:\winavr-20100110\avr\include\util\delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:c:\winavr-20100110\avr\include\util\delay.h **** 
  33:c:\winavr-20100110\avr\include\util\delay.h **** /* $Id$ */
  34:c:\winavr-20100110\avr\include\util\delay.h **** 
  35:c:\winavr-20100110\avr\include\util\delay.h **** #ifndef _UTIL_DELAY_H_
  36:c:\winavr-20100110\avr\include\util\delay.h **** #define _UTIL_DELAY_H_ 1
  37:c:\winavr-20100110\avr\include\util\delay.h **** 
  38:c:\winavr-20100110\avr\include\util\delay.h **** #ifndef __DOXYGEN__
  39:c:\winavr-20100110\avr\include\util\delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:c:\winavr-20100110\avr\include\util\delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:c:\winavr-20100110\avr\include\util\delay.h **** #  endif
  42:c:\winavr-20100110\avr\include\util\delay.h **** #endif  /* __DOXYGEN__ */
  43:c:\winavr-20100110\avr\include\util\delay.h **** 
  44:c:\winavr-20100110\avr\include\util\delay.h **** #include <inttypes.h>
  45:c:\winavr-20100110\avr\include\util\delay.h **** #include <util/delay_basic.h>
  46:c:\winavr-20100110\avr\include\util\delay.h **** #include <math.h>
  47:c:\winavr-20100110\avr\include\util\delay.h **** 
  48:c:\winavr-20100110\avr\include\util\delay.h **** /** \file */
  49:c:\winavr-20100110\avr\include\util\delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:c:\winavr-20100110\avr\include\util\delay.h ****     \code
  51:c:\winavr-20100110\avr\include\util\delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:c:\winavr-20100110\avr\include\util\delay.h ****     //#define F_CPU 14.7456E6
  53:c:\winavr-20100110\avr\include\util\delay.h ****     #include <util/delay.h>
  54:c:\winavr-20100110\avr\include\util\delay.h ****     \endcode
  55:c:\winavr-20100110\avr\include\util\delay.h **** 
  56:c:\winavr-20100110\avr\include\util\delay.h ****     \note As an alternative method, it is possible to pass the
  57:c:\winavr-20100110\avr\include\util\delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:c:\winavr-20100110\avr\include\util\delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:c:\winavr-20100110\avr\include\util\delay.h ****     used.
  60:c:\winavr-20100110\avr\include\util\delay.h **** 
  61:c:\winavr-20100110\avr\include\util\delay.h ****     The functions in this header file are wrappers around the basic
  62:c:\winavr-20100110\avr\include\util\delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:c:\winavr-20100110\avr\include\util\delay.h ****     convenience functions where actual time values can be specified
  64:c:\winavr-20100110\avr\include\util\delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:c:\winavr-20100110\avr\include\util\delay.h ****     that compile-time constant expressions will be eliminated by
  66:c:\winavr-20100110\avr\include\util\delay.h ****     compiler optimization so floating-point expressions can be used
  67:c:\winavr-20100110\avr\include\util\delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:c:\winavr-20100110\avr\include\util\delay.h ****     frequency passed by the macro F_CPU.
  69:c:\winavr-20100110\avr\include\util\delay.h **** 
  70:c:\winavr-20100110\avr\include\util\delay.h ****     \note In order for these functions to work as intended, compiler
  71:c:\winavr-20100110\avr\include\util\delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:c:\winavr-20100110\avr\include\util\delay.h ****     <em>must</em> be an expression that is a known constant at
  73:c:\winavr-20100110\avr\include\util\delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:c:\winavr-20100110\avr\include\util\delay.h ****     delay will be much longer (and basically unpredictable), and
  75:c:\winavr-20100110\avr\include\util\delay.h ****     applications that otherwise do not use floating-point calculations
  76:c:\winavr-20100110\avr\include\util\delay.h ****     will experience severe code bloat by the floating-point library
  77:c:\winavr-20100110\avr\include\util\delay.h ****     routines linked into the application.
  78:c:\winavr-20100110\avr\include\util\delay.h **** 
  79:c:\winavr-20100110\avr\include\util\delay.h ****     The functions available allow the specification of microsecond, and
  80:c:\winavr-20100110\avr\include\util\delay.h ****     millisecond delays directly, using the application-supplied macro
  81:c:\winavr-20100110\avr\include\util\delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:c:\winavr-20100110\avr\include\util\delay.h **** 
  83:c:\winavr-20100110\avr\include\util\delay.h **** */
  84:c:\winavr-20100110\avr\include\util\delay.h **** 
  85:c:\winavr-20100110\avr\include\util\delay.h **** #if !defined(__DOXYGEN__)
  86:c:\winavr-20100110\avr\include\util\delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:c:\winavr-20100110\avr\include\util\delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:c:\winavr-20100110\avr\include\util\delay.h **** #endif
  89:c:\winavr-20100110\avr\include\util\delay.h **** 
  90:c:\winavr-20100110\avr\include\util\delay.h **** #ifndef F_CPU
  91:c:\winavr-20100110\avr\include\util\delay.h **** /* prevent compiler error by supplying a default */
  92:c:\winavr-20100110\avr\include\util\delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:c:\winavr-20100110\avr\include\util\delay.h **** /** \ingroup util_delay
  94:c:\winavr-20100110\avr\include\util\delay.h ****     \def F_CPU
  95:c:\winavr-20100110\avr\include\util\delay.h ****     \brief CPU frequency in Hz
  96:c:\winavr-20100110\avr\include\util\delay.h **** 
  97:c:\winavr-20100110\avr\include\util\delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:c:\winavr-20100110\avr\include\util\delay.h ****     the delay macros.  This macro is normally supplied by the
  99:c:\winavr-20100110\avr\include\util\delay.h ****     environment (e.g. from within a project header, or the project's
 100:c:\winavr-20100110\avr\include\util\delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:c:\winavr-20100110\avr\include\util\delay.h ****     fallback if no such user-provided definition could be found.
 102:c:\winavr-20100110\avr\include\util\delay.h **** 
 103:c:\winavr-20100110\avr\include\util\delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:c:\winavr-20100110\avr\include\util\delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:c:\winavr-20100110\avr\include\util\delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:c:\winavr-20100110\avr\include\util\delay.h ****     integer value.
 107:c:\winavr-20100110\avr\include\util\delay.h ****  */
 108:c:\winavr-20100110\avr\include\util\delay.h **** # define F_CPU 1000000UL
 109:c:\winavr-20100110\avr\include\util\delay.h **** #endif
 110:c:\winavr-20100110\avr\include\util\delay.h **** 
 111:c:\winavr-20100110\avr\include\util\delay.h **** #ifndef __OPTIMIZE__
 112:c:\winavr-20100110\avr\include\util\delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:c:\winavr-20100110\avr\include\util\delay.h **** #endif
 114:c:\winavr-20100110\avr\include\util\delay.h **** 
 115:c:\winavr-20100110\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:c:\winavr-20100110\avr\include\util\delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:c:\winavr-20100110\avr\include\util\delay.h ****   __STDC_HOSTED__
 118:c:\winavr-20100110\avr\include\util\delay.h **** #  include <math.h>
 119:c:\winavr-20100110\avr\include\util\delay.h **** #endif
 120:c:\winavr-20100110\avr\include\util\delay.h **** 
 121:c:\winavr-20100110\avr\include\util\delay.h **** /**
 122:c:\winavr-20100110\avr\include\util\delay.h ****    \ingroup util_delay
 123:c:\winavr-20100110\avr\include\util\delay.h **** 
 124:c:\winavr-20100110\avr\include\util\delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:c:\winavr-20100110\avr\include\util\delay.h **** 
 126:c:\winavr-20100110\avr\include\util\delay.h ****    The macro F_CPU is supposed to be defined to a
 127:c:\winavr-20100110\avr\include\util\delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:c:\winavr-20100110\avr\include\util\delay.h **** 
 129:c:\winavr-20100110\avr\include\util\delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:c:\winavr-20100110\avr\include\util\delay.h **** 
 131:c:\winavr-20100110\avr\include\util\delay.h ****    When the user request delay which exceed the maximum possible one,
 132:c:\winavr-20100110\avr\include\util\delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:c:\winavr-20100110\avr\include\util\delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:c:\winavr-20100110\avr\include\util\delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:c:\winavr-20100110\avr\include\util\delay.h ****    user will not be informed about decreased resolution.
 136:c:\winavr-20100110\avr\include\util\delay.h **** 
 137:c:\winavr-20100110\avr\include\util\delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:c:\winavr-20100110\avr\include\util\delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:c:\winavr-20100110\avr\include\util\delay.h ****    values greater than the maximal possible delay, overflows results in
 140:c:\winavr-20100110\avr\include\util\delay.h ****    no delay i.e., 0ms.
 141:c:\winavr-20100110\avr\include\util\delay.h **** 
 142:c:\winavr-20100110\avr\include\util\delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:c:\winavr-20100110\avr\include\util\delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:c:\winavr-20100110\avr\include\util\delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:c:\winavr-20100110\avr\include\util\delay.h ****    microseconds of delay.
 146:c:\winavr-20100110\avr\include\util\delay.h **** 
 147:c:\winavr-20100110\avr\include\util\delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:c:\winavr-20100110\avr\include\util\delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:c:\winavr-20100110\avr\include\util\delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:c:\winavr-20100110\avr\include\util\delay.h ****    respectively.
 151:c:\winavr-20100110\avr\include\util\delay.h **** 
 152:c:\winavr-20100110\avr\include\util\delay.h ****    \note
 153:c:\winavr-20100110\avr\include\util\delay.h **** 
 154:c:\winavr-20100110\avr\include\util\delay.h ****    The implementation of _delay_ms() based on
 155:c:\winavr-20100110\avr\include\util\delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:c:\winavr-20100110\avr\include\util\delay.h ****    implementations.  In order to get functionality backward compatible
 157:c:\winavr-20100110\avr\include\util\delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:c:\winavr-20100110\avr\include\util\delay.h ****    must be defined before including this header file. Also, the
 159:c:\winavr-20100110\avr\include\util\delay.h ****    backward compatible algorithm will be chosen if the code is
 160:c:\winavr-20100110\avr\include\util\delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:c:\winavr-20100110\avr\include\util\delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:c:\winavr-20100110\avr\include\util\delay.h ****    not available to the compiler then.
 163:c:\winavr-20100110\avr\include\util\delay.h **** 
 164:c:\winavr-20100110\avr\include\util\delay.h ****  */
 165:c:\winavr-20100110\avr\include\util\delay.h **** void
 166:c:\winavr-20100110\avr\include\util\delay.h **** _delay_ms(double __ms)
 167:c:\winavr-20100110\avr\include\util\delay.h **** {
 168:c:\winavr-20100110\avr\include\util\delay.h **** 	double __tmp ;
 169:c:\winavr-20100110\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:c:\winavr-20100110\avr\include\util\delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:c:\winavr-20100110\avr\include\util\delay.h ****   __STDC_HOSTED__
 172:c:\winavr-20100110\avr\include\util\delay.h **** 	uint32_t __ticks_dc;
 173:c:\winavr-20100110\avr\include\util\delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 174:c:\winavr-20100110\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 175:c:\winavr-20100110\avr\include\util\delay.h **** 
 176:c:\winavr-20100110\avr\include\util\delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:c:\winavr-20100110\avr\include\util\delay.h **** 
 179:c:\winavr-20100110\avr\include\util\delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:c:\winavr-20100110\avr\include\util\delay.h **** 
 182:c:\winavr-20100110\avr\include\util\delay.h **** 	#else
 183:c:\winavr-20100110\avr\include\util\delay.h **** 		//round up by default
 184:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 185:c:\winavr-20100110\avr\include\util\delay.h **** 	#endif
 186:c:\winavr-20100110\avr\include\util\delay.h **** 
 187:c:\winavr-20100110\avr\include\util\delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 1096               		.loc 2 187 0
 1097 02ce 8FE3      		ldi r24,lo8(-25537)
 1098 02d0 9CE9      		ldi r25,hi8(-25537)
 1099 02d2 0197      	1:	sbiw r24,1
 1100 02d4 01F4      		brne 1b
 1101 02d6 00C0      		rjmp .
 1102 02d8 0000      		nop
 1103               	.LBE57:
 1104               	.LBE56:
 525:setup.c       **** 	_delay_ms(20); // Wait a little (for Atmel chip)
 526:setup.c       **** 	
 527:setup.c       **** 	// Set data as inputs
 528:setup.c       **** 	GBA_PORT_RAM_DATA7_0 = 0;
 1105               		.loc 1 528 0
 1106 02da 15BA      		out 0x15,__zero_reg__
 529:setup.c       **** 	GBA_DDR_RAM_DATA7_0 = 0;
 1107               		.loc 1 529 0
 1108 02dc 14BA      		out 0x14,__zero_reg__
 530:setup.c       **** 	
 531:setup.c       **** 	// Read and transmit the 2 bytes
 532:setup.c       **** 	flashChipIdBuffer[0] = gba_read_ram_8bit_data(0x0000);
 1109               		.loc 1 532 0
 1110 02de 80E0      		ldi r24,0
 1111 02e0 90E0      		ldi r25,0
 1112 02e2 00D0      		rcall gba_read_ram_8bit_data
 1113               	.LVL62:
 1114 02e4 C0E0      		ldi r28,lo8(flashChipIdBuffer)
 1115 02e6 D0E0      		ldi r29,hi8(flashChipIdBuffer)
 1116 02e8 8883      		st Y,r24
 533:setup.c       **** 	flashChipIdBuffer[1] = gba_read_ram_8bit_data(0x0001);
 1117               		.loc 1 533 0
 1118 02ea 81E0      		ldi r24,lo8(1)
 1119 02ec 90E0      		ldi r25,0
 1120 02ee 00D0      		rcall gba_read_ram_8bit_data
 1121               	.LVL63:
 1122 02f0 8983      		std Y+1,r24
 534:setup.c       **** 	
 535:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xAA);
 1123               		.loc 1 535 0
 1124 02f2 6AEA      		ldi r22,lo8(-86)
 1125 02f4 85E5      		ldi r24,lo8(85)
 1126 02f6 95E5      		ldi r25,lo8(85)
 1127 02f8 00D0      		rcall flash_write_bus_cycle
 1128               	.LVL64:
 536:setup.c       **** 	flash_write_bus_cycle(0x2AAA, 0x55);
 1129               		.loc 1 536 0
 1130 02fa 65E5      		ldi r22,lo8(85)
 1131 02fc 8AEA      		ldi r24,lo8(-86)
 1132 02fe 9AE2      		ldi r25,lo8(42)
 1133 0300 00D0      		rcall flash_write_bus_cycle
 1134               	.LVL65:
 537:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xF0); // Software ID exit
 1135               		.loc 1 537 0
 1136 0302 60EF      		ldi r22,lo8(-16)
 1137 0304 85E5      		ldi r24,lo8(85)
 1138 0306 95E5      		ldi r25,lo8(85)
 1139 0308 00D0      		rcall flash_write_bus_cycle
 1140               	.LVL66:
 1141               	.LBB58:
 1142               	.LBB59:
 1143               		.loc 2 187 0
 1144 030a 8FE3      		ldi r24,lo8(-25537)
 1145 030c 9CE9      		ldi r25,hi8(-25537)
 1146 030e 0197      	1:	sbiw r24,1
 1147 0310 01F4      		brne 1b
 1148 0312 00C0      		rjmp .
 1149 0314 0000      		nop
 1150               	/* epilogue start */
 1151               	.LBE59:
 1152               	.LBE58:
 538:setup.c       **** 	_delay_ms(20); // Wait a little (for Atmel chip)
 539:setup.c       **** }
 1153               		.loc 1 539 0
 1154 0316 DF91      		pop r29
 1155 0318 CF91      		pop r28
 1156 031a 0895      		ret
 1157               		.cfi_endproc
 1158               	.LFE31:
 1160               	.global	flash_switch_bank
 1162               	flash_switch_bank:
 1163               	.LFB32:
 540:setup.c       **** 
 541:setup.c       **** // Switch banks on the Flash
 542:setup.c       **** void flash_switch_bank(uint8_t bank) {
 1164               		.loc 1 542 0
 1165               		.cfi_startproc
 1166               	.LVL67:
 1167 031c CF93      		push r28
 1168               	.LCFI22:
 1169               		.cfi_def_cfa_offset 3
 1170               		.cfi_offset 28, -2
 1171               	/* prologue: function */
 1172               	/* frame size = 0 */
 1173               	/* stack size = 1 */
 1174               	.L__stack_usage = 1
 1175 031e C82F      		mov r28,r24
 543:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xAA);
 1176               		.loc 1 543 0
 1177 0320 6AEA      		ldi r22,lo8(-86)
 1178 0322 85E5      		ldi r24,lo8(85)
 1179 0324 95E5      		ldi r25,lo8(85)
 1180               	.LVL68:
 1181 0326 00D0      		rcall flash_write_bus_cycle
 1182               	.LVL69:
 544:setup.c       **** 	flash_write_bus_cycle(0x2AAA, 0x55);
 1183               		.loc 1 544 0
 1184 0328 65E5      		ldi r22,lo8(85)
 1185 032a 8AEA      		ldi r24,lo8(-86)
 1186 032c 9AE2      		ldi r25,lo8(42)
 1187 032e 00D0      		rcall flash_write_bus_cycle
 1188               	.LVL70:
 545:setup.c       **** 	
 546:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xB0);
 1189               		.loc 1 546 0
 1190 0330 60EB      		ldi r22,lo8(-80)
 1191 0332 85E5      		ldi r24,lo8(85)
 1192 0334 95E5      		ldi r25,lo8(85)
 1193 0336 00D0      		rcall flash_write_bus_cycle
 1194               	.LVL71:
 547:setup.c       **** 	flash_write_bus_cycle(0x0000, bank);
 1195               		.loc 1 547 0
 1196 0338 6C2F      		mov r22,r28
 1197 033a 80E0      		ldi r24,0
 1198 033c 90E0      		ldi r25,0
 1199               	/* epilogue start */
 548:setup.c       **** }
 1200               		.loc 1 548 0
 1201 033e CF91      		pop r28
 1202               	.LVL72:
 547:setup.c       **** 	flash_write_bus_cycle(0x0000, bank);
 1203               		.loc 1 547 0
 1204 0340 00C0      		rjmp flash_write_bus_cycle
 1205               	.LVL73:
 1206               		.cfi_endproc
 1207               	.LFE32:
 1209               	.global	flash_erase_4k_sector
 1211               	flash_erase_4k_sector:
 1212               	.LFB33:
 549:setup.c       **** 
 550:setup.c       **** // Erase 4K sector on Flash, expects first sector to start at 0, left shifts by 12 (A15-A12 to sele
 551:setup.c       **** // Takes 25ms after last command to erase sector
 552:setup.c       **** void flash_erase_4k_sector(uint8_t sector) {
 1213               		.loc 1 552 0
 1214               		.cfi_startproc
 1215               	.LVL74:
 1216 0342 CF93      		push r28
 1217               	.LCFI23:
 1218               		.cfi_def_cfa_offset 3
 1219               		.cfi_offset 28, -2
 1220               	/* prologue: function */
 1221               	/* frame size = 0 */
 1222               	/* stack size = 1 */
 1223               	.L__stack_usage = 1
 1224 0344 C82F      		mov r28,r24
 553:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xAA);
 1225               		.loc 1 553 0
 1226 0346 6AEA      		ldi r22,lo8(-86)
 1227 0348 85E5      		ldi r24,lo8(85)
 1228 034a 95E5      		ldi r25,lo8(85)
 1229               	.LVL75:
 1230 034c 00D0      		rcall flash_write_bus_cycle
 1231               	.LVL76:
 554:setup.c       **** 	flash_write_bus_cycle(0x2AAA, 0x55);
 1232               		.loc 1 554 0
 1233 034e 65E5      		ldi r22,lo8(85)
 1234 0350 8AEA      		ldi r24,lo8(-86)
 1235 0352 9AE2      		ldi r25,lo8(42)
 1236 0354 00D0      		rcall flash_write_bus_cycle
 1237               	.LVL77:
 555:setup.c       **** 	flash_write_bus_cycle(0x5555, 0x80);
 1238               		.loc 1 555 0
 1239 0356 60E8      		ldi r22,lo8(-128)
 1240 0358 85E5      		ldi r24,lo8(85)
 1241 035a 95E5      		ldi r25,lo8(85)
 1242 035c 00D0      		rcall flash_write_bus_cycle
 1243               	.LVL78:
 556:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xAA);
 1244               		.loc 1 556 0
 1245 035e 6AEA      		ldi r22,lo8(-86)
 1246 0360 85E5      		ldi r24,lo8(85)
 1247 0362 95E5      		ldi r25,lo8(85)
 1248 0364 00D0      		rcall flash_write_bus_cycle
 1249               	.LVL79:
 557:setup.c       **** 	flash_write_bus_cycle(0x2AAA, 0x55);
 1250               		.loc 1 557 0
 1251 0366 65E5      		ldi r22,lo8(85)
 1252 0368 8AEA      		ldi r24,lo8(-86)
 1253 036a 9AE2      		ldi r25,lo8(42)
 1254 036c 00D0      		rcall flash_write_bus_cycle
 1255               	.LVL80:
 558:setup.c       **** 	
 559:setup.c       **** 	flash_write_bus_cycle((uint16_t) sector << 12, 0x30);
 1256               		.loc 1 559 0
 1257 036e 60E3      		ldi r22,lo8(48)
 1258 0370 80E0      		ldi r24,0
 1259 0372 9C2F      		mov r25,r28
 1260 0374 9295      		swap r25
 1261 0376 907F      		andi r25,lo8(-16)
 1262 0378 00D0      		rcall flash_write_bus_cycle
 1263               	.LVL81:
 1264               	.LBB60:
 1265               	.LBB61:
 1266               		.loc 2 187 0
 1267 037a 8FE4      		ldi r24,lo8(-15537)
 1268 037c 93EC      		ldi r25,hi8(-15537)
 1269 037e 0197      	1:	sbiw r24,1
 1270 0380 01F4      		brne 1b
 1271 0382 00C0      		rjmp .
 1272 0384 0000      		nop
 1273               	/* epilogue start */
 1274               	.LBE61:
 1275               	.LBE60:
 560:setup.c       **** 	_delay_ms(25); // Wait 25ms for sector erase
 561:setup.c       **** }
 1276               		.loc 1 561 0
 1277 0386 CF91      		pop r28
 1278               	.LVL82:
 1279 0388 0895      		ret
 1280               		.cfi_endproc
 1281               	.LFE33:
 1283               	.global	flash_write_byte
 1285               	flash_write_byte:
 1286               	.LFB34:
 562:setup.c       **** 
 563:setup.c       **** // Write a single byte to the Flash address
 564:setup.c       **** // Takes 20us to program Flash
 565:setup.c       **** void flash_write_byte(uint16_t address, uint8_t data) {
 1287               		.loc 1 565 0
 1288               		.cfi_startproc
 1289               	.LVL83:
 1290 038a 1F93      		push r17
 1291               	.LCFI24:
 1292               		.cfi_def_cfa_offset 3
 1293               		.cfi_offset 17, -2
 1294 038c CF93      		push r28
 1295               	.LCFI25:
 1296               		.cfi_def_cfa_offset 4
 1297               		.cfi_offset 28, -3
 1298 038e DF93      		push r29
 1299               	.LCFI26:
 1300               		.cfi_def_cfa_offset 5
 1301               		.cfi_offset 29, -4
 1302               	/* prologue: function */
 1303               	/* frame size = 0 */
 1304               	/* stack size = 3 */
 1305               	.L__stack_usage = 3
 1306 0390 EC01      		movw r28,r24
 1307 0392 162F      		mov r17,r22
 566:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xAA);
 1308               		.loc 1 566 0
 1309 0394 6AEA      		ldi r22,lo8(-86)
 1310               	.LVL84:
 1311 0396 85E5      		ldi r24,lo8(85)
 1312 0398 95E5      		ldi r25,lo8(85)
 1313               	.LVL85:
 1314 039a 00D0      		rcall flash_write_bus_cycle
 1315               	.LVL86:
 567:setup.c       **** 	flash_write_bus_cycle(0x2AAA, 0x55);
 1316               		.loc 1 567 0
 1317 039c 65E5      		ldi r22,lo8(85)
 1318 039e 8AEA      		ldi r24,lo8(-86)
 1319 03a0 9AE2      		ldi r25,lo8(42)
 1320 03a2 00D0      		rcall flash_write_bus_cycle
 1321               	.LVL87:
 568:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xA0);
 1322               		.loc 1 568 0
 1323 03a4 60EA      		ldi r22,lo8(-96)
 1324 03a6 85E5      		ldi r24,lo8(85)
 1325 03a8 95E5      		ldi r25,lo8(85)
 1326 03aa 00D0      		rcall flash_write_bus_cycle
 1327               	.LVL88:
 569:setup.c       **** 	
 570:setup.c       **** 	flash_write_bus_cycle(address, data);
 1328               		.loc 1 570 0
 1329 03ac 612F      		mov r22,r17
 1330 03ae CE01      		movw r24,r28
 1331 03b0 00D0      		rcall flash_write_bus_cycle
 1332               	.LVL89:
 1333               	.LBB62:
 1334               	.LBB63:
 188:c:\winavr-20100110\avr\include\util\delay.h **** 
 189:c:\winavr-20100110\avr\include\util\delay.h **** #else
 190:c:\winavr-20100110\avr\include\util\delay.h **** 	uint16_t __ticks;
 191:c:\winavr-20100110\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 4e3) * __ms;
 192:c:\winavr-20100110\avr\include\util\delay.h **** 	if (__tmp < 1.0)
 193:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks = 1;
 194:c:\winavr-20100110\avr\include\util\delay.h **** 	else if (__tmp > 65535)
 195:c:\winavr-20100110\avr\include\util\delay.h **** 	{
 196:c:\winavr-20100110\avr\include\util\delay.h **** 		//	__ticks = requested delay in 1/10 ms
 197:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 198:c:\winavr-20100110\avr\include\util\delay.h **** 		while(__ticks)
 199:c:\winavr-20100110\avr\include\util\delay.h **** 		{
 200:c:\winavr-20100110\avr\include\util\delay.h **** 			// wait 1/10 ms
 201:c:\winavr-20100110\avr\include\util\delay.h **** 			_delay_loop_2(((F_CPU) / 4e3) / 10);
 202:c:\winavr-20100110\avr\include\util\delay.h **** 			__ticks --;
 203:c:\winavr-20100110\avr\include\util\delay.h **** 		}
 204:c:\winavr-20100110\avr\include\util\delay.h **** 		return;
 205:c:\winavr-20100110\avr\include\util\delay.h **** 	}
 206:c:\winavr-20100110\avr\include\util\delay.h **** 	else
 207:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks = (uint16_t)__tmp;
 208:c:\winavr-20100110\avr\include\util\delay.h **** 	_delay_loop_2(__ticks);
 209:c:\winavr-20100110\avr\include\util\delay.h **** #endif
 210:c:\winavr-20100110\avr\include\util\delay.h **** }
 211:c:\winavr-20100110\avr\include\util\delay.h **** 
 212:c:\winavr-20100110\avr\include\util\delay.h **** /**
 213:c:\winavr-20100110\avr\include\util\delay.h ****    \ingroup util_delay
 214:c:\winavr-20100110\avr\include\util\delay.h **** 
 215:c:\winavr-20100110\avr\include\util\delay.h ****    Perform a delay of \c __us microseconds, using _delay_loop_1().
 216:c:\winavr-20100110\avr\include\util\delay.h **** 
 217:c:\winavr-20100110\avr\include\util\delay.h ****    The macro F_CPU is supposed to be defined to a
 218:c:\winavr-20100110\avr\include\util\delay.h ****    constant defining the CPU clock frequency (in Hertz).
 219:c:\winavr-20100110\avr\include\util\delay.h **** 
 220:c:\winavr-20100110\avr\include\util\delay.h ****    The maximal possible delay is 768 us / F_CPU in MHz.
 221:c:\winavr-20100110\avr\include\util\delay.h **** 
 222:c:\winavr-20100110\avr\include\util\delay.h ****    If the user requests a delay greater than the maximal possible one,
 223:c:\winavr-20100110\avr\include\util\delay.h ****    _delay_us() will automatically call _delay_ms() instead.  The user
 224:c:\winavr-20100110\avr\include\util\delay.h ****    will not be informed about this case.
 225:c:\winavr-20100110\avr\include\util\delay.h **** 
 226:c:\winavr-20100110\avr\include\util\delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 227:c:\winavr-20100110\avr\include\util\delay.h ****    support, maximal possible delay is 4294967.295 us/ F_CPU in MHz. For
 228:c:\winavr-20100110\avr\include\util\delay.h ****    values greater than the maximal possible delay, overflow results in
 229:c:\winavr-20100110\avr\include\util\delay.h ****    no delay i.e., 0us.
 230:c:\winavr-20100110\avr\include\util\delay.h **** 
 231:c:\winavr-20100110\avr\include\util\delay.h ****    Conversion of \c __us into clock cycles may not always result in
 232:c:\winavr-20100110\avr\include\util\delay.h ****    integer.  By default, the clock cycles rounded up to next
 233:c:\winavr-20100110\avr\include\util\delay.h ****    integer. This ensures that the user gets at least \c __us
 234:c:\winavr-20100110\avr\include\util\delay.h ****    microseconds of delay.
 235:c:\winavr-20100110\avr\include\util\delay.h **** 
 236:c:\winavr-20100110\avr\include\util\delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 237:c:\winavr-20100110\avr\include\util\delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 238:c:\winavr-20100110\avr\include\util\delay.h ****    algorithm can be made to round down, or round to closest integer,
 239:c:\winavr-20100110\avr\include\util\delay.h ****    respectively.
 240:c:\winavr-20100110\avr\include\util\delay.h **** 
 241:c:\winavr-20100110\avr\include\util\delay.h ****    \note
 242:c:\winavr-20100110\avr\include\util\delay.h **** 
 243:c:\winavr-20100110\avr\include\util\delay.h ****    The implementation of _delay_ms() based on
 244:c:\winavr-20100110\avr\include\util\delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 245:c:\winavr-20100110\avr\include\util\delay.h ****    implementations.  In order to get functionality backward compatible
 246:c:\winavr-20100110\avr\include\util\delay.h ****    with previous versions, the macro \c __DELAY_BACKWARD_COMPATIBLE__
 247:c:\winavr-20100110\avr\include\util\delay.h ****    must be defined before including this header file. Also, the
 248:c:\winavr-20100110\avr\include\util\delay.h ****    backward compatible algorithm will be chosen if the code is
 249:c:\winavr-20100110\avr\include\util\delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 250:c:\winavr-20100110\avr\include\util\delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 251:c:\winavr-20100110\avr\include\util\delay.h ****    not available to the compiler then.
 252:c:\winavr-20100110\avr\include\util\delay.h **** 
 253:c:\winavr-20100110\avr\include\util\delay.h ****  */
 254:c:\winavr-20100110\avr\include\util\delay.h **** void
 255:c:\winavr-20100110\avr\include\util\delay.h **** _delay_us(double __us)
 256:c:\winavr-20100110\avr\include\util\delay.h **** {
 257:c:\winavr-20100110\avr\include\util\delay.h **** 	double __tmp ;
 258:c:\winavr-20100110\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 259:c:\winavr-20100110\avr\include\util\delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 260:c:\winavr-20100110\avr\include\util\delay.h ****   __STDC_HOSTED__
 261:c:\winavr-20100110\avr\include\util\delay.h **** 	uint32_t __ticks_dc;
 262:c:\winavr-20100110\avr\include\util\delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 263:c:\winavr-20100110\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 264:c:\winavr-20100110\avr\include\util\delay.h **** 
 265:c:\winavr-20100110\avr\include\util\delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 266:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 267:c:\winavr-20100110\avr\include\util\delay.h **** 
 268:c:\winavr-20100110\avr\include\util\delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 269:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 270:c:\winavr-20100110\avr\include\util\delay.h **** 
 271:c:\winavr-20100110\avr\include\util\delay.h **** 	#else
 272:c:\winavr-20100110\avr\include\util\delay.h **** 		//round up by default
 273:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 274:c:\winavr-20100110\avr\include\util\delay.h **** 	#endif
 275:c:\winavr-20100110\avr\include\util\delay.h **** 
 276:c:\winavr-20100110\avr\include\util\delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 1335               		.loc 2 276 0
 1336 03b2 85E3      		ldi r24,lo8(53)
 1337 03b4 8A95      	1:	dec r24
 1338 03b6 01F4      		brne 1b
 1339 03b8 0000      		nop
 1340               	/* epilogue start */
 1341               	.LBE63:
 1342               	.LBE62:
 571:setup.c       **** 	_delay_us(20); // Wait byte program time
 572:setup.c       **** }
 1343               		.loc 1 572 0
 1344 03ba DF91      		pop r29
 1345 03bc CF91      		pop r28
 1346               	.LVL90:
 1347 03be 1F91      		pop r17
 1348               	.LVL91:
 1349 03c0 0895      		ret
 1350               		.cfi_endproc
 1351               	.LFE34:
 1353               	.global	flash_write_sector
 1355               	flash_write_sector:
 1356               	.LFB35:
 573:setup.c       **** 
 574:setup.c       **** // Write a sector (128 bytes) to the Atmel flash
 575:setup.c       **** // Takes 20ms for write cycle
 576:setup.c       **** void flash_write_sector(uint16_t sector) {
 1357               		.loc 1 576 0
 1358               		.cfi_startproc
 1359               	.LVL92:
 1360 03c2 EF92      		push r14
 1361               	.LCFI27:
 1362               		.cfi_def_cfa_offset 3
 1363               		.cfi_offset 14, -2
 1364 03c4 FF92      		push r15
 1365               	.LCFI28:
 1366               		.cfi_def_cfa_offset 4
 1367               		.cfi_offset 15, -3
 1368 03c6 0F93      		push r16
 1369               	.LCFI29:
 1370               		.cfi_def_cfa_offset 5
 1371               		.cfi_offset 16, -4
 1372 03c8 1F93      		push r17
 1373               	.LCFI30:
 1374               		.cfi_def_cfa_offset 6
 1375               		.cfi_offset 17, -5
 1376 03ca CF93      		push r28
 1377               	.LCFI31:
 1378               		.cfi_def_cfa_offset 7
 1379               		.cfi_offset 28, -6
 1380 03cc DF93      		push r29
 1381               	.LCFI32:
 1382               		.cfi_def_cfa_offset 8
 1383               		.cfi_offset 29, -7
 1384               	/* prologue: function */
 1385               	/* frame size = 0 */
 1386               	/* stack size = 6 */
 1387               	.L__stack_usage = 6
 1388 03ce 8C01      		movw r16,r24
 577:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xAA);
 1389               		.loc 1 577 0
 1390 03d0 6AEA      		ldi r22,lo8(-86)
 1391 03d2 85E5      		ldi r24,lo8(85)
 1392 03d4 95E5      		ldi r25,lo8(85)
 1393               	.LVL93:
 1394 03d6 00D0      		rcall flash_write_bus_cycle
 1395               	.LVL94:
 578:setup.c       **** 	flash_write_bus_cycle(0x2AAA, 0x55);
 1396               		.loc 1 578 0
 1397 03d8 65E5      		ldi r22,lo8(85)
 1398 03da 8AEA      		ldi r24,lo8(-86)
 1399 03dc 9AE2      		ldi r25,lo8(42)
 1400 03de 00D0      		rcall flash_write_bus_cycle
 1401               	.LVL95:
 579:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xA0);
 1402               		.loc 1 579 0
 1403 03e0 60EA      		ldi r22,lo8(-96)
 1404 03e2 85E5      		ldi r24,lo8(85)
 1405 03e4 95E5      		ldi r25,lo8(85)
 1406 03e6 00D0      		rcall flash_write_bus_cycle
 1407               	.LVL96:
 1408               	.LBB64:
 580:setup.c       **** 	
 581:setup.c       **** 	// Write the bytes (A0-A6 byte address, A7-A15 sector address)
 582:setup.c       **** 	for (uint8_t x = 0; x < 128; x++) {
 583:setup.c       **** 		flash_write_bus_cycle((uint16_t) (sector << 7) | (uint16_t) x, receivedBuffer[x]);
 1409               		.loc 1 583 0
 1410 03e8 1695      		lsr r17
 1411 03ea 102F      		mov r17,r16
 1412 03ec 0027      		clr r16
 1413 03ee 1795      		ror r17
 1414 03f0 0795      		ror r16
 1415               	.LVL97:
 1416 03f2 90E0      		ldi r25,lo8(receivedBuffer)
 1417 03f4 E92E      		mov r14,r25
 1418 03f6 90E0      		ldi r25,hi8(receivedBuffer)
 1419 03f8 F92E      		mov r15,r25
 1420 03fa C0E0      		ldi r28,0
 1421 03fc D0E0      		ldi r29,0
 1422               	.LVL98:
 1423               	.L66:
 1424               		.loc 1 583 0 is_stmt 0 discriminator 3
 1425 03fe F701      		movw r30,r14
 1426 0400 6191      		ld r22,Z+
 1427 0402 7F01      		movw r14,r30
 1428 0404 CE01      		movw r24,r28
 1429 0406 802B      		or r24,r16
 1430 0408 912B      		or r25,r17
 1431 040a 00D0      		rcall flash_write_bus_cycle
 1432               	.LVL99:
 1433 040c 2196      		adiw r28,1
 1434               	.LVL100:
 582:setup.c       **** 		flash_write_bus_cycle((uint16_t) (sector << 7) | (uint16_t) x, receivedBuffer[x]);
 1435               		.loc 1 582 0 is_stmt 1 discriminator 3
 1436 040e C038      		cpi r28,-128
 1437 0410 D105      		cpc r29,__zero_reg__
 1438 0412 01F4      		brne .L66
 1439               	.LVL101:
 1440               	.LBE64:
 1441               	.LBB65:
 1442               	.LBB66:
 187:c:\winavr-20100110\avr\include\util\delay.h **** 
 1443               		.loc 2 187 0
 1444 0414 8FE3      		ldi r24,lo8(-25537)
 1445 0416 9CE9      		ldi r25,hi8(-25537)
 1446 0418 0197      	1:	sbiw r24,1
 1447 041a 01F4      		brne 1b
 1448 041c 00C0      		rjmp .
 1449 041e 0000      		nop
 1450               	/* epilogue start */
 1451               	.LBE66:
 1452               	.LBE65:
 584:setup.c       **** 	}
 585:setup.c       **** 	_delay_ms(20); // Wait sector program time
 586:setup.c       **** }
 1453               		.loc 1 586 0
 1454 0420 DF91      		pop r29
 1455 0422 CF91      		pop r28
 1456               	.LVL102:
 1457 0424 1F91      		pop r17
 1458 0426 0F91      		pop r16
 1459 0428 FF90      		pop r15
 1460 042a EF90      		pop r14
 1461 042c 0895      		ret
 1462               		.cfi_endproc
 1463               	.LFE35:
 1465               	.global	audio_flash_write_bus_cycle
 1467               	audio_flash_write_bus_cycle:
 1468               	.LFB36:
 587:setup.c       **** 
 588:setup.c       **** 
 589:setup.c       **** 
 590:setup.c       **** // ---------- FLASH CARTS ----------
 591:setup.c       **** 
 592:setup.c       **** // 32K Audio WE - Set the address and data for the write byte cycle to the flash (pulsing audio pin
 593:setup.c       **** void audio_flash_write_bus_cycle(uint16_t address, uint8_t data) {
 1469               		.loc 1 593 0
 1470               		.cfi_startproc
 1471               	.LVL103:
 1472 042e CF93      		push r28
 1473               	.LCFI33:
 1474               		.cfi_def_cfa_offset 3
 1475               		.cfi_offset 28, -2
 1476 0430 DF93      		push r29
 1477               	.LCFI34:
 1478               		.cfi_def_cfa_offset 4
 1479               		.cfi_offset 29, -3
 1480 0432 1F92      		push __zero_reg__
 1481               	.LCFI35:
 1482               		.cfi_def_cfa_offset 5
 1483 0434 CDB7      		in r28,__SP_L__
 1484 0436 DEB7      		in r29,__SP_H__
 1485               	.LCFI36:
 1486               		.cfi_def_cfa_register 28
 1487               	/* prologue: function */
 1488               	/* frame size = 1 */
 1489               	/* stack size = 3 */
 1490               	.L__stack_usage = 3
 594:setup.c       **** 	GBA_DDR_RAM_DATA7_0 = 0xFF; // Set data pins as outputs
 1491               		.loc 1 594 0
 1492 0438 2FEF      		ldi r18,lo8(-1)
 1493 043a 24BB      		out 0x14,r18
 595:setup.c       **** 	set_16bit_address(address);
 1494               		.loc 1 595 0
 1495 043c 6983      		std Y+1,r22
 1496 043e 00D0      		rcall set_16bit_address
 1497               	.LVL104:
 596:setup.c       **** 	GBA_PORT_RAM_DATA7_0 = data;
 1498               		.loc 1 596 0
 1499 0440 6981      		ldd r22,Y+1
 1500 0442 65BB      		out 0x15,r22
 597:setup.c       **** 	
 598:setup.c       **** 	audioPin_low; // WE low
 1501               		.loc 1 598 0
 1502 0444 3998      		cbi 0x7,1
 599:setup.c       **** 	asm volatile("nop");
 1503               		.loc 1 599 0
 1504               	/* #APP */
 1505               	 ;  599 "setup.c" 1
 1506 0446 0000      		nop
 1507               	 ;  0 "" 2
 600:setup.c       **** 	asm volatile("nop");
 1508               		.loc 1 600 0
 1509               	 ;  600 "setup.c" 1
 1510 0448 0000      		nop
 1511               	 ;  0 "" 2
 601:setup.c       **** 	asm volatile("nop");
 1512               		.loc 1 601 0
 1513               	 ;  601 "setup.c" 1
 1514 044a 0000      		nop
 1515               	 ;  0 "" 2
 602:setup.c       **** 	audioPin_high; // WE high
 1516               		.loc 1 602 0
 1517               	/* #NOAPP */
 1518 044c 399A      		sbi 0x7,1
 1519               	/* epilogue start */
 603:setup.c       **** }
 1520               		.loc 1 603 0
 1521 044e 0F90      		pop __tmp_reg__
 1522 0450 DF91      		pop r29
 1523 0452 CF91      		pop r28
 1524 0454 0895      		ret
 1525               		.cfi_endproc
 1526               	.LFE36:
 1528               	.global	audio_flash_write_byte
 1530               	audio_flash_write_byte:
 1531               	.LFB37:
 604:setup.c       **** 
 605:setup.c       **** // 32K Audio WE - Write a single byte to the Flash address. Takes 20us to program Flash.
 606:setup.c       **** void audio_flash_write_byte(uint16_t address, uint8_t data) {
 1532               		.loc 1 606 0
 1533               		.cfi_startproc
 1534               	.LVL105:
 1535 0456 1F93      		push r17
 1536               	.LCFI37:
 1537               		.cfi_def_cfa_offset 3
 1538               		.cfi_offset 17, -2
 1539 0458 CF93      		push r28
 1540               	.LCFI38:
 1541               		.cfi_def_cfa_offset 4
 1542               		.cfi_offset 28, -3
 1543 045a DF93      		push r29
 1544               	.LCFI39:
 1545               		.cfi_def_cfa_offset 5
 1546               		.cfi_offset 29, -4
 1547               	/* prologue: function */
 1548               	/* frame size = 0 */
 1549               	/* stack size = 3 */
 1550               	.L__stack_usage = 3
 1551 045c EC01      		movw r28,r24
 1552 045e 162F      		mov r17,r22
 607:setup.c       **** 	audio_flash_write_bus_cycle(0x555, 0xAA);
 1553               		.loc 1 607 0
 1554 0460 6AEA      		ldi r22,lo8(-86)
 1555               	.LVL106:
 1556 0462 85E5      		ldi r24,lo8(85)
 1557 0464 95E0      		ldi r25,lo8(5)
 1558               	.LVL107:
 1559 0466 00D0      		rcall audio_flash_write_bus_cycle
 1560               	.LVL108:
 608:setup.c       **** 	audio_flash_write_bus_cycle(0x2AA, 0x55);
 1561               		.loc 1 608 0
 1562 0468 65E5      		ldi r22,lo8(85)
 1563 046a 8AEA      		ldi r24,lo8(-86)
 1564 046c 92E0      		ldi r25,lo8(2)
 1565 046e 00D0      		rcall audio_flash_write_bus_cycle
 1566               	.LVL109:
 609:setup.c       **** 	audio_flash_write_bus_cycle(0x555, 0xA0);
 1567               		.loc 1 609 0
 1568 0470 60EA      		ldi r22,lo8(-96)
 1569 0472 85E5      		ldi r24,lo8(85)
 1570 0474 95E0      		ldi r25,lo8(5)
 1571 0476 00D0      		rcall audio_flash_write_bus_cycle
 1572               	.LVL110:
 610:setup.c       **** 	audio_flash_write_bus_cycle(address, data);
 1573               		.loc 1 610 0
 1574 0478 612F      		mov r22,r17
 1575 047a CE01      		movw r24,r28
 1576 047c 00D0      		rcall audio_flash_write_bus_cycle
 1577               	.LVL111:
 1578               	.LBB67:
 1579               	.LBB68:
 1580               		.loc 2 276 0
 1581 047e 85E3      		ldi r24,lo8(53)
 1582 0480 8A95      	1:	dec r24
 1583 0482 01F4      		brne 1b
 1584 0484 0000      		nop
 1585               	/* epilogue start */
 1586               	.LBE68:
 1587               	.LBE67:
 611:setup.c       **** 	_delay_us(20); // Wait byte program time
 612:setup.c       **** }
 1588               		.loc 1 612 0
 1589 0486 DF91      		pop r29
 1590 0488 CF91      		pop r28
 1591               	.LVL112:
 1592 048a 1F91      		pop r17
 1593               	.LVL113:
 1594 048c 0895      		ret
 1595               		.cfi_endproc
 1596               	.LFE37:
 1598               	.global	bv5_flash_write_bus_cycle
 1600               	bv5_flash_write_bus_cycle:
 1601               	.LFB38:
 613:setup.c       **** 
 614:setup.c       **** // BV5 - Set the address and data for the write byte cycle to the flash (pulsing WR pin)
 615:setup.c       **** void bv5_flash_write_bus_cycle(uint16_t address, uint8_t data) {
 1602               		.loc 1 615 0
 1603               		.cfi_startproc
 1604               	.LVL114:
 1605 048e CF93      		push r28
 1606               	.LCFI40:
 1607               		.cfi_def_cfa_offset 3
 1608               		.cfi_offset 28, -2
 1609 0490 DF93      		push r29
 1610               	.LCFI41:
 1611               		.cfi_def_cfa_offset 4
 1612               		.cfi_offset 29, -3
 1613 0492 1F92      		push __zero_reg__
 1614               	.LCFI42:
 1615               		.cfi_def_cfa_offset 5
 1616 0494 CDB7      		in r28,__SP_L__
 1617 0496 DEB7      		in r29,__SP_H__
 1618               	.LCFI43:
 1619               		.cfi_def_cfa_register 28
 1620               	/* prologue: function */
 1621               	/* frame size = 1 */
 1622               	/* stack size = 3 */
 1623               	.L__stack_usage = 3
 616:setup.c       **** 	GBA_DDR_RAM_DATA7_0 = 0xFF; // Set data pins as outputs
 1624               		.loc 1 616 0
 1625 0498 2FEF      		ldi r18,lo8(-1)
 1626 049a 24BB      		out 0x14,r18
 617:setup.c       **** 	set_16bit_address(address);
 1627               		.loc 1 617 0
 1628 049c 6983      		std Y+1,r22
 1629 049e 00D0      		rcall set_16bit_address
 1630               	.LVL115:
 618:setup.c       **** 	GBA_PORT_RAM_DATA7_0 = data;
 1631               		.loc 1 618 0
 1632 04a0 6981      		ldd r22,Y+1
 1633 04a2 65BB      		out 0x15,r22
 619:setup.c       **** 	
 620:setup.c       **** 	wrPin_low;
 1634               		.loc 1 620 0
 1635 04a4 9698      		cbi 0x12,6
 621:setup.c       **** 	asm volatile("nop");
 1636               		.loc 1 621 0
 1637               	/* #APP */
 1638               	 ;  621 "setup.c" 1
 1639 04a6 0000      		nop
 1640               	 ;  0 "" 2
 622:setup.c       **** 	asm volatile("nop");
 1641               		.loc 1 622 0
 1642               	 ;  622 "setup.c" 1
 1643 04a8 0000      		nop
 1644               	 ;  0 "" 2
 623:setup.c       **** 	asm volatile("nop");
 1645               		.loc 1 623 0
 1646               	 ;  623 "setup.c" 1
 1647 04aa 0000      		nop
 1648               	 ;  0 "" 2
 624:setup.c       **** 	wrPin_high;
 1649               		.loc 1 624 0
 1650               	/* #NOAPP */
 1651 04ac 969A      		sbi 0x12,6
 1652               	/* epilogue start */
 625:setup.c       **** }
 1653               		.loc 1 625 0
 1654 04ae 0F90      		pop __tmp_reg__
 1655 04b0 DF91      		pop r29
 1656 04b2 CF91      		pop r28
 1657 04b4 0895      		ret
 1658               		.cfi_endproc
 1659               	.LFE38:
 1661               	.global	bv5_flash_write_byte
 1663               	bv5_flash_write_byte:
 1664               	.LFB39:
 626:setup.c       **** 
 627:setup.c       **** // BV5 - Write a single byte to the Flash address. Time to wait depends on Flash.
 628:setup.c       **** // (data byte's bit 0 & 1 are swapped for chip commands as D0 & D1 lines are swapped)
 629:setup.c       **** void bv5_flash_write_byte(uint16_t address, uint8_t data) {
 1665               		.loc 1 629 0
 1666               		.cfi_startproc
 1667               	.LVL116:
 1668 04b6 1F93      		push r17
 1669               	.LCFI44:
 1670               		.cfi_def_cfa_offset 3
 1671               		.cfi_offset 17, -2
 1672 04b8 CF93      		push r28
 1673               	.LCFI45:
 1674               		.cfi_def_cfa_offset 4
 1675               		.cfi_offset 28, -3
 1676 04ba DF93      		push r29
 1677               	.LCFI46:
 1678               		.cfi_def_cfa_offset 5
 1679               		.cfi_offset 29, -4
 1680               	/* prologue: function */
 1681               	/* frame size = 0 */
 1682               	/* stack size = 3 */
 1683               	.L__stack_usage = 3
 1684 04bc EC01      		movw r28,r24
 1685 04be 162F      		mov r17,r22
 630:setup.c       **** 	bv5_flash_write_bus_cycle(0xAAA, 0xA9);
 1686               		.loc 1 630 0
 1687 04c0 69EA      		ldi r22,lo8(-87)
 1688               	.LVL117:
 1689 04c2 8AEA      		ldi r24,lo8(-86)
 1690 04c4 9AE0      		ldi r25,lo8(10)
 1691               	.LVL118:
 1692 04c6 00D0      		rcall bv5_flash_write_bus_cycle
 1693               	.LVL119:
 631:setup.c       **** 	bv5_flash_write_bus_cycle(0x555, 0x56);
 1694               		.loc 1 631 0
 1695 04c8 66E5      		ldi r22,lo8(86)
 1696 04ca 85E5      		ldi r24,lo8(85)
 1697 04cc 95E0      		ldi r25,lo8(5)
 1698 04ce 00D0      		rcall bv5_flash_write_bus_cycle
 1699               	.LVL120:
 632:setup.c       **** 	bv5_flash_write_bus_cycle(0xAAA, 0xA0);
 1700               		.loc 1 632 0
 1701 04d0 60EA      		ldi r22,lo8(-96)
 1702 04d2 8AEA      		ldi r24,lo8(-86)
 1703 04d4 9AE0      		ldi r25,lo8(10)
 1704 04d6 00D0      		rcall bv5_flash_write_bus_cycle
 1705               	.LVL121:
 633:setup.c       **** 	bv5_flash_write_bus_cycle(address, data);
 1706               		.loc 1 633 0
 1707 04d8 612F      		mov r22,r17
 1708 04da CE01      		movw r24,r28
 1709 04dc 00D0      		rcall bv5_flash_write_bus_cycle
 1710               	.LVL122:
 1711               	.LBB69:
 1712               	.LBB70:
 1713               		.loc 2 276 0
 1714 04de 85E3      		ldi r24,lo8(53)
 1715 04e0 8A95      	1:	dec r24
 1716 04e2 01F4      		brne 1b
 1717 04e4 0000      		nop
 1718               	/* epilogue start */
 1719               	.LBE70:
 1720               	.LBE69:
 634:setup.c       **** 	_delay_us(20); // Wait byte program time
 635:setup.c       **** }
 1721               		.loc 1 635 0
 1722 04e6 DF91      		pop r29
 1723 04e8 CF91      		pop r28
 1724               	.LVL123:
 1725 04ea 1F91      		pop r17
 1726               	.LVL124:
 1727 04ec 0895      		ret
 1728               		.cfi_endproc
 1729               	.LFE39:
 1731               	.global	setup
 1733               	setup:
 1734               	.LFB40:
 636:setup.c       **** 
 637:setup.c       **** 
 638:setup.c       **** // Setup
 639:setup.c       **** void setup(void) {
 1735               		.loc 1 639 0
 1736               		.cfi_startproc
 1737               	/* prologue: function */
 1738               	/* frame size = 0 */
 1739               	/* stack size = 0 */
 1740               	.L__stack_usage = 0
 640:setup.c       **** 	// Turn off watchdog
 641:setup.c       **** 	MCUCSR &= ~(1<<WDRF);
 1741               		.loc 1 641 0
 1742 04ee 84B7      		in r24,0x34
 1743 04f0 877F      		andi r24,lo8(-9)
 1744 04f2 84BF      		out 0x34,r24
 642:setup.c       **** 	WDTCR = (1<<WDCE) | (1<<WDE);
 1745               		.loc 1 642 0
 1746 04f4 88E1      		ldi r24,lo8(24)
 1747 04f6 81BD      		out 0x21,r24
 643:setup.c       **** 	WDTCR = 0;
 1748               		.loc 1 643 0
 1749 04f8 11BC      		out 0x21,__zero_reg__
 644:setup.c       **** 	
 645:setup.c       **** 	// Reset common lines
 646:setup.c       **** 	rd_wr_csmreq_cs2_reset();
 1750               		.loc 1 646 0
 1751 04fa 00D0      		rcall rd_wr_csmreq_cs2_reset
 1752               	.LVL125:
 647:setup.c       **** 	
 648:setup.c       **** 	// Set outputs
 649:setup.c       **** 	DDRD |= (1<<ACTIVITY_LED) | (1<<WR_PIN) | (1<<RD_PIN) | (1<<CS_MREQ_PIN) | (1<<LED_5V);
 1753               		.loc 1 649 0
 1754 04fc 81B3      		in r24,0x11
 1755 04fe 886F      		ori r24,lo8(-8)
 1756 0500 81BB      		out 0x11,r24
 650:setup.c       **** 	DDRE |= (1<<CS2_PIN) | (1<<LED_3V);
 1757               		.loc 1 650 0
 1758 0502 86B1      		in r24,0x6
 1759 0504 8560      		ori r24,lo8(5)
 1760 0506 86B9      		out 0x6,r24
 651:setup.c       **** 	
 652:setup.c       **** 	// Set all pins as inputs
 653:setup.c       **** 	PORT_DATA7_0 = 0;
 1761               		.loc 1 653 0
 1762 0508 15BA      		out 0x15,__zero_reg__
 654:setup.c       **** 	DDR_DATA7_0 = 0;
 1763               		.loc 1 654 0
 1764 050a 14BA      		out 0x14,__zero_reg__
 655:setup.c       **** 	PORT_ADDR7_0 = 0;
 1765               		.loc 1 655 0
 1766 050c 18BA      		out 0x18,__zero_reg__
 656:setup.c       **** 	DDR_ADDR7_0 = 0;
 1767               		.loc 1 656 0
 1768 050e 17BA      		out 0x17,__zero_reg__
 657:setup.c       **** 	PORT_ADDR15_8 = 0;
 1769               		.loc 1 657 0
 1770 0510 1BBA      		out 0x1b,__zero_reg__
 658:setup.c       **** 	DDR_ADDR15_8 = 0;
 1771               		.loc 1 658 0
 1772 0512 1ABA      		out 0x1a,__zero_reg__
 659:setup.c       **** 	
 660:setup.c       **** 	// Light up 3.3V or 5V
 661:setup.c       **** 	if (PIND & (1<<SWITCH_DETECT)) {
 1773               		.loc 1 661 0
 1774 0514 829B      		sbis 0x10,2
 1775 0516 00C0      		rjmp .L73
 662:setup.c       **** 		PORTD |= (1<<LED_5V);
 1776               		.loc 1 662 0
 1777 0518 979A      		sbi 0x12,7
 663:setup.c       **** 		PORTE &= ~(1<<LED_3V);
 1778               		.loc 1 663 0
 1779 051a 3898      		cbi 0x7,0
 1780 051c 00C0      		rjmp .L74
 1781               	.L73:
 664:setup.c       **** 	}
 665:setup.c       **** 	else {
 666:setup.c       **** 		PORTE |= (1<<LED_3V);
 1782               		.loc 1 666 0
 1783 051e 389A      		sbi 0x7,0
 667:setup.c       **** 		PORTD &= ~(1<<LED_5V);
 1784               		.loc 1 667 0
 1785 0520 9798      		cbi 0x12,7
 1786               	.L74:
 668:setup.c       **** 	}
 669:setup.c       **** 	
 670:setup.c       **** 	// Light LED
 671:setup.c       **** 	PORTD |= (1<<ACTIVITY_LED);
 1787               		.loc 1 671 0
 1788 0522 939A      		sbi 0x12,3
 1789               	.LVL126:
 1790               	.LBB71:
 1791               	.LBB72:
 187:c:\winavr-20100110\avr\include\util\delay.h **** 
 1792               		.loc 2 187 0
 1793 0524 2FEF      		ldi r18,lo8(799999)
 1794 0526 84E3      		ldi r24,hi8(799999)
 1795 0528 9CE0      		ldi r25,hlo8(799999)
 1796 052a 2150      	1:	subi r18,1
 1797 052c 8040      		sbci r24,0
 1798 052e 9040      		sbci r25,0
 1799 0530 01F4      		brne 1b
 1800 0532 00C0      		rjmp .
 1801 0534 0000      		nop
 1802               	.LBE72:
 1803               	.LBE71:
 672:setup.c       **** 	_delay_ms(500);
 673:setup.c       **** 	PORTD &= ~(1<<ACTIVITY_LED);
 1804               		.loc 1 673 0
 1805 0536 9398      		cbi 0x12,3
 674:setup.c       **** 	
 675:setup.c       **** 	// Setup USART
 676:setup.c       **** 	UBRRL = 0; // 1Mbps Baud rate
 1806               		.loc 1 676 0
 1807 0538 19B8      		out 0x9,__zero_reg__
 677:setup.c       **** 	sbi(UCSRA, U2X); // Double rate
 1808               		.loc 1 677 0
 1809 053a 599A      		sbi 0xb,1
 678:setup.c       **** 	sbi(UCSRB, TXEN); // Transmitter enable
 1810               		.loc 1 678 0
 1811 053c 539A      		sbi 0xa,3
 679:setup.c       **** 	sbi(UCSRB, RXEN); // Receiver enable
 1812               		.loc 1 679 0
 1813 053e 549A      		sbi 0xa,4
 680:setup.c       **** 	
 681:setup.c       **** 	// Turn on interrupts
 682:setup.c       **** 	sei();
 1814               		.loc 1 682 0
 1815               	/* #APP */
 1816               	 ;  682 "setup.c" 1
 1817 0540 7894      		sei
 1818               	 ;  0 "" 2
 1819               	/* #NOAPP */
 1820 0542 0895      		ret
 1821               		.cfi_endproc
 1822               	.LFE40:
 1824               		.section	.text.startup,"ax",@progbits
 1825               	.global	main
 1827               	main:
 1828               	.LFB41:
 1829               		.file 3 "main.c"
   1:main.c        **** /*
   2:main.c        ****  GBxCart RW
   3:main.c        ****  PCB version: 1.1
   4:main.c        ****  Firmware version: R4
   5:main.c        ****  Author: Alex from insideGadgets (www.insidegadgets.com)
   6:main.c        ****  Created: 7/11/2016
   7:main.c        ****  Last Modified: 15/10/2017
   8:main.c        ****  
   9:main.c        ****  GBxCart RW allows you to dump your Gameboy/Gameboy Colour/Gameboy Advance games ROM, save the RAM 
  10:main.c        ****  
  11:main.c        ****  The ATmega8515L talks to the cartridge and interfaces with the CH340G serial to USB converter with
  12:main.c        ****  
  13:main.c        ****  
  14:main.c        ****  Set fuse bits: External 8MHz crystal, divide clock by 8 is off, boot loader is on (512 bytes), BOD
  15:main.c        ****  avrdude -p atmega8515 -c usbasp -U lfuse:w:0xaf:m -U hfuse:w:0xda:m
  16:main.c        ****  
  17:main.c        ****  Program the TinySafeBoot boot loader (modified ASM code, watchdog reset will act as a hardware res
  18:main.c        ****  avrdude -p atmega8515 -c usbasp -U flash:w:GBxCart_RW_v1.1_R3\tsb\tsb_m8515_d0d1_resetwdt.hex
  19:main.c        ****  
  20:main.c        ****  Program GBxCart RW through TinySafeBoot
  21:main.c        ****  tsb com16:57600 fw GBxCart_RW_v1.1_R3\main.hex
  22:main.c        ****  
  23:main.c        ****  Set TinySafeBoot delay time to 25 (T 25), gives ~0.5s in bootloader
  24:main.c        ****  tsb com16:9600 T 25
  25:main.c        ****  
  26:main.c        ****  
  27:main.c        ****  Programming shortcuts (if added in Programmers Notepad):
  28:main.c        ****  Alt + W - Program fuse
  29:main.c        ****  Alt + B - Burn bootloader
  30:main.c        ****  
  31:main.c        ****  Plug in USB then
  32:main.c        ****  Alt + T - Program
  33:main.c        ****  Alt + N - Program delay settings
  34:main.c        ****  
  35:main.c        ****  
  36:main.c        ****  */
  37:main.c        **** 
  38:main.c        **** // ATmega8515L Pin Map
  39:main.c        **** //
  40:main.c        **** // VCC (5)			GND (6)			XTAL (7 ,8)		Activity LED PD3 (9)				Switch sense PD2 (8)
  41:main.c        **** // SCK PB7 (3)		MOSI PB5 (1)	MISO PB6 (2)	RST (4)		RXD PD0 (5)			TXD PD1 (7)
  42:main.c        **** // 
  43:main.c        **** // Gameboy / Gameboy Colour
  44:main.c        **** // A0-A7 PB0-7 (40-44, 1-3) 		A8-A15 PA0-7 (37-30)			D0-D7 PC0-7 (18-25)		Audio PE1 (27)
  45:main.c        **** // 
  46:main.c        **** // Gameboy Advance
  47:main.c        **** // AD0-AD7 PB0-7 (40-44, 1-3) 	AD8-AD15 PA0-7 (37-30)		A16-23 / D0-D7 PC0-7 (19-26)
  48:main.c        **** // *WR PD6 (13)						*RD PD5 (14)					*MREQ/CS PD4 (15)			CS2/RST PE2 (16)
  49:main.c        **** 
  50:main.c        **** #define F_CPU 8000000 // 8 MHz
  51:main.c        **** #define PCB_VERSION 2
  52:main.c        **** #define FIRMWARE_VERSION 4
  53:main.c        **** 
  54:main.c        **** #include <avr/io.h>
  55:main.c        **** #include <avr/wdt.h>
  56:main.c        **** #include <avr/eeprom.h>
  57:main.c        **** #include <avr/interrupt.h>
  58:main.c        **** #include <avr/sleep.h>
  59:main.c        **** #include <util/delay.h>
  60:main.c        **** #include <stdlib.h>
  61:main.c        **** #include <string.h>
  62:main.c        **** #include "setup.c" // See defines, variables, constants, functions here
  63:main.c        **** 
  64:main.c        **** 
  65:main.c        **** int main(void) {
 1830               		.loc 3 65 0
 1831               		.cfi_startproc
 1832 0000 CF93      		push r28
 1833               	.LCFI47:
 1834               		.cfi_def_cfa_offset 3
 1835               		.cfi_offset 28, -2
 1836 0002 DF93      		push r29
 1837               	.LCFI48:
 1838               		.cfi_def_cfa_offset 4
 1839               		.cfi_offset 29, -3
 1840 0004 00D0      		rcall .
 1841 0006 1F92      		push __zero_reg__
 1842               	.LCFI49:
 1843               		.cfi_def_cfa_offset 7
 1844 0008 CDB7      		in r28,__SP_L__
 1845 000a DEB7      		in r29,__SP_H__
 1846               	.LCFI50:
 1847               		.cfi_def_cfa_register 28
 1848               	/* prologue: function */
 1849               	/* frame size = 3 */
 1850               	/* stack size = 5 */
 1851               	.L__stack_usage = 5
  66:main.c        **** 	setup();
 1852               		.loc 3 66 0
 1853 000c 00D0      		rcall setup
 1854               	.LVL127:
  67:main.c        **** 	
  68:main.c        **** 	uint32_t address = 0;
  69:main.c        **** 	uint8_t eepromSize = EEPROM_4KBIT;
  70:main.c        **** 	uint8_t cartMode = GB_MODE;
  71:main.c        **** 	uint8_t resetCommonLines = 1;
 1855               		.loc 3 71 0
 1856 000e 21E0      		ldi r18,lo8(1)
 1857 0010 2983      		std Y+1,r18
  69:main.c        **** 	uint8_t cartMode = GB_MODE;
 1858               		.loc 3 69 0
 1859 0012 01E0      		ldi r16,lo8(1)
  68:main.c        **** 	uint8_t eepromSize = EEPROM_4KBIT;
 1860               		.loc 3 68 0
 1861 0014 C12C      		mov r12,__zero_reg__
 1862 0016 D12C      		mov r13,__zero_reg__
 1863 0018 7601      		movw r14,r12
 1864               	.LBB73:
 1865               	.LBB74:
 1866               	.LBB75:
 1867               		.file 4 "c:\\winavr-20100110\\avr\\include\\util\\delay_basic.h"
   1:c:\winavr-20100110\avr\include\util\delay_basic.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:c:\winavr-20100110\avr\include\util\delay_basic.h ****    Copyright (c) 2007 Joerg Wunsch
   3:c:\winavr-20100110\avr\include\util\delay_basic.h ****    All rights reserved.
   4:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
   5:c:\winavr-20100110\avr\include\util\delay_basic.h ****    Redistribution and use in source and binary forms, with or without
   6:c:\winavr-20100110\avr\include\util\delay_basic.h ****    modification, are permitted provided that the following conditions are met:
   7:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
   8:c:\winavr-20100110\avr\include\util\delay_basic.h ****    * Redistributions of source code must retain the above copyright
   9:c:\winavr-20100110\avr\include\util\delay_basic.h ****      notice, this list of conditions and the following disclaimer.
  10:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  11:c:\winavr-20100110\avr\include\util\delay_basic.h ****    * Redistributions in binary form must reproduce the above copyright
  12:c:\winavr-20100110\avr\include\util\delay_basic.h ****      notice, this list of conditions and the following disclaimer in
  13:c:\winavr-20100110\avr\include\util\delay_basic.h ****      the documentation and/or other materials provided with the
  14:c:\winavr-20100110\avr\include\util\delay_basic.h ****      distribution.
  15:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  16:c:\winavr-20100110\avr\include\util\delay_basic.h ****    * Neither the name of the copyright holders nor the names of
  17:c:\winavr-20100110\avr\include\util\delay_basic.h ****      contributors may be used to endorse or promote products derived
  18:c:\winavr-20100110\avr\include\util\delay_basic.h ****      from this software without specific prior written permission.
  19:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  20:c:\winavr-20100110\avr\include\util\delay_basic.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  21:c:\winavr-20100110\avr\include\util\delay_basic.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  22:c:\winavr-20100110\avr\include\util\delay_basic.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  23:c:\winavr-20100110\avr\include\util\delay_basic.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  24:c:\winavr-20100110\avr\include\util\delay_basic.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  25:c:\winavr-20100110\avr\include\util\delay_basic.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  26:c:\winavr-20100110\avr\include\util\delay_basic.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  27:c:\winavr-20100110\avr\include\util\delay_basic.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  28:c:\winavr-20100110\avr\include\util\delay_basic.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  29:c:\winavr-20100110\avr\include\util\delay_basic.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  30:c:\winavr-20100110\avr\include\util\delay_basic.h ****   POSSIBILITY OF SUCH DAMAGE. */
  31:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  32:c:\winavr-20100110\avr\include\util\delay_basic.h **** /* $Id$ */
  33:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  34:c:\winavr-20100110\avr\include\util\delay_basic.h **** #ifndef _UTIL_DELAY_BASIC_H_
  35:c:\winavr-20100110\avr\include\util\delay_basic.h **** #define _UTIL_DELAY_BASIC_H_ 1
  36:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  37:c:\winavr-20100110\avr\include\util\delay_basic.h **** #include <inttypes.h>
  38:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  39:c:\winavr-20100110\avr\include\util\delay_basic.h **** #if !defined(__DOXYGEN__)
  40:c:\winavr-20100110\avr\include\util\delay_basic.h **** static __inline__ void _delay_loop_1(uint8_t __count) __attribute__((__always_inline__));
  41:c:\winavr-20100110\avr\include\util\delay_basic.h **** static __inline__ void _delay_loop_2(uint16_t __count) __attribute__((__always_inline__));
  42:c:\winavr-20100110\avr\include\util\delay_basic.h **** #endif
  43:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  44:c:\winavr-20100110\avr\include\util\delay_basic.h **** /** \file */
  45:c:\winavr-20100110\avr\include\util\delay_basic.h **** /** \defgroup util_delay_basic <util/delay_basic.h>: Basic busy-wait delay loops
  46:c:\winavr-20100110\avr\include\util\delay_basic.h ****     \code
  47:c:\winavr-20100110\avr\include\util\delay_basic.h ****     #include <util/delay_basic.h>
  48:c:\winavr-20100110\avr\include\util\delay_basic.h ****     \endcode
  49:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  50:c:\winavr-20100110\avr\include\util\delay_basic.h ****     The functions in this header file implement simple delay loops
  51:c:\winavr-20100110\avr\include\util\delay_basic.h ****     that perform a busy-waiting.  They are typically used to
  52:c:\winavr-20100110\avr\include\util\delay_basic.h ****     facilitate short delays in the program execution.  They are
  53:c:\winavr-20100110\avr\include\util\delay_basic.h ****     implemented as count-down loops with a well-known CPU cycle
  54:c:\winavr-20100110\avr\include\util\delay_basic.h ****     count per loop iteration.  As such, no other processing can
  55:c:\winavr-20100110\avr\include\util\delay_basic.h ****     occur simultaneously.  It should be kept in mind that the
  56:c:\winavr-20100110\avr\include\util\delay_basic.h ****     functions described here do not disable interrupts.
  57:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  58:c:\winavr-20100110\avr\include\util\delay_basic.h ****     In general, for long delays, the use of hardware timers is
  59:c:\winavr-20100110\avr\include\util\delay_basic.h ****     much preferrable, as they free the CPU, and allow for
  60:c:\winavr-20100110\avr\include\util\delay_basic.h ****     concurrent processing of other events while the timer is
  61:c:\winavr-20100110\avr\include\util\delay_basic.h ****     running.  However, in particular for very short delays, the
  62:c:\winavr-20100110\avr\include\util\delay_basic.h ****     overhead of setting up a hardware timer is too much compared
  63:c:\winavr-20100110\avr\include\util\delay_basic.h ****     to the overall delay time.
  64:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  65:c:\winavr-20100110\avr\include\util\delay_basic.h ****     Two inline functions are provided for the actual delay algorithms.
  66:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  67:c:\winavr-20100110\avr\include\util\delay_basic.h **** */
  68:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  69:c:\winavr-20100110\avr\include\util\delay_basic.h **** /** \ingroup util_delay_basic
  70:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  71:c:\winavr-20100110\avr\include\util\delay_basic.h ****     Delay loop using an 8-bit counter \c __count, so up to 256
  72:c:\winavr-20100110\avr\include\util\delay_basic.h ****     iterations are possible.  (The value 256 would have to be passed
  73:c:\winavr-20100110\avr\include\util\delay_basic.h ****     as 0.)  The loop executes three CPU cycles per iteration, not
  74:c:\winavr-20100110\avr\include\util\delay_basic.h ****     including the overhead the compiler needs to setup the counter
  75:c:\winavr-20100110\avr\include\util\delay_basic.h ****     register.
  76:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  77:c:\winavr-20100110\avr\include\util\delay_basic.h ****     Thus, at a CPU speed of 1 MHz, delays of up to 768 microseconds
  78:c:\winavr-20100110\avr\include\util\delay_basic.h ****     can be achieved.
  79:c:\winavr-20100110\avr\include\util\delay_basic.h **** */
  80:c:\winavr-20100110\avr\include\util\delay_basic.h **** void
  81:c:\winavr-20100110\avr\include\util\delay_basic.h **** _delay_loop_1(uint8_t __count)
  82:c:\winavr-20100110\avr\include\util\delay_basic.h **** {
  83:c:\winavr-20100110\avr\include\util\delay_basic.h **** 	__asm__ volatile (
  84:c:\winavr-20100110\avr\include\util\delay_basic.h **** 		"1: dec %0" "\n\t"
  85:c:\winavr-20100110\avr\include\util\delay_basic.h **** 		"brne 1b"
  86:c:\winavr-20100110\avr\include\util\delay_basic.h **** 		: "=r" (__count)
  87:c:\winavr-20100110\avr\include\util\delay_basic.h **** 		: "0" (__count)
  88:c:\winavr-20100110\avr\include\util\delay_basic.h **** 	);
  89:c:\winavr-20100110\avr\include\util\delay_basic.h **** }
  90:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  91:c:\winavr-20100110\avr\include\util\delay_basic.h **** /** \ingroup util_delay_basic
  92:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  93:c:\winavr-20100110\avr\include\util\delay_basic.h ****     Delay loop using a 16-bit counter \c __count, so up to 65536
  94:c:\winavr-20100110\avr\include\util\delay_basic.h ****     iterations are possible.  (The value 65536 would have to be
  95:c:\winavr-20100110\avr\include\util\delay_basic.h ****     passed as 0.)  The loop executes four CPU cycles per iteration,
  96:c:\winavr-20100110\avr\include\util\delay_basic.h ****     not including the overhead the compiler requires to setup the
  97:c:\winavr-20100110\avr\include\util\delay_basic.h ****     counter register pair.
  98:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  99:c:\winavr-20100110\avr\include\util\delay_basic.h ****     Thus, at a CPU speed of 1 MHz, delays of up to about 262.1
 100:c:\winavr-20100110\avr\include\util\delay_basic.h ****     milliseconds can be achieved.
 101:c:\winavr-20100110\avr\include\util\delay_basic.h ****  */
 102:c:\winavr-20100110\avr\include\util\delay_basic.h **** void
 103:c:\winavr-20100110\avr\include\util\delay_basic.h **** _delay_loop_2(uint16_t __count)
 104:c:\winavr-20100110\avr\include\util\delay_basic.h **** {
 105:c:\winavr-20100110\avr\include\util\delay_basic.h **** 	__asm__ volatile (
 1868               		.loc 4 105 0
 1869 001a AA24      		clr r10
 1870 001c AA94      		dec r10
 1871 001e BA2C      		mov r11,r10
 1872 0020 80E0      		ldi r24,lo8(receivedBuffer)
 1873 0022 90E0      		ldi r25,hi8(receivedBuffer)
 1874 0024 20E4      		ldi r18,lo8(64)
 1875 0026 280F      		add r18,r24
 1876 0028 2A83      		std Y+2,r18
 1877 002a 80E0      		ldi r24,lo8(eepromBuffer)
 1878 002c 90E0      		ldi r25,hi8(eepromBuffer)
 1879 002e 18E0      		ldi r17,lo8(8)
 1880 0030 180F      		add r17,r24
 1881               	.LVL128:
 1882               	.L76:
 1883               	.LBE75:
 1884               	.LBE74:
 1885               	.LBE73:
  72:main.c        **** 	
  73:main.c        **** 	while(1) {
  74:main.c        **** 		if (resetCommonLines == 1) {
 1886               		.loc 3 74 0
 1887 0032 2981      		ldd r18,Y+1
 1888 0034 2130      		cpi r18,lo8(1)
 1889 0036 01F4      		brne .L77
 1890               	.LVL129:
 1891               	.L173:
  75:main.c        **** 			rd_wr_csmreq_cs2_reset();
 1892               		.loc 3 75 0
 1893 0038 00D0      		rcall rd_wr_csmreq_cs2_reset
 1894               	.LVL130:
 1895               	.L77:
  76:main.c        **** 		}
  77:main.c        **** 		receivedChar = USART_Receive(); // Wait for 1 byte of data
 1896               		.loc 3 77 0
 1897 003a 00D0      		rcall USART_Receive
 1898               	.LVL131:
 1899 003c 8093 0000 		sts receivedChar,r24
  78:main.c        **** 		
  79:main.c        **** 		// Read the pin to find out which mode we are in, if it reads high, we are powered by 5V
  80:main.c        **** 		if (PIND & (1<<SWITCH_DETECT)) {
 1900               		.loc 3 80 0
 1901 0040 829B      		sbis 0x10,2
 1902 0042 00C0      		rjmp .L78
 1903               	.LVL132:
  81:main.c        **** 			cartMode = GB_MODE;
  82:main.c        **** 			PORTD |= (1<<LED_5V);
 1904               		.loc 3 82 0
 1905 0044 979A      		sbi 0x12,7
  83:main.c        **** 			PORTE &= ~(1<<LED_3V);
 1906               		.loc 3 83 0
 1907 0046 3898      		cbi 0x7,0
  81:main.c        **** 			cartMode = GB_MODE;
 1908               		.loc 3 81 0
 1909 0048 81E0      		ldi r24,lo8(1)
 1910 004a 00C0      		rjmp .L79
 1911               	.LVL133:
 1912               	.L78:
  84:main.c        **** 		}
  85:main.c        **** 		else {
  86:main.c        **** 			cartMode = GBA_MODE;
  87:main.c        **** 			PORTE |= (1<<LED_3V);
 1913               		.loc 3 87 0
 1914 004c 389A      		sbi 0x7,0
  88:main.c        **** 			PORTD &= ~(1<<LED_5V);
 1915               		.loc 3 88 0
 1916 004e 9798      		cbi 0x12,7
  86:main.c        **** 			PORTE |= (1<<LED_3V);
 1917               		.loc 3 86 0
 1918 0050 82E0      		ldi r24,lo8(2)
 1919               	.LVL134:
 1920               	.L79:
  89:main.c        **** 		}
  90:main.c        **** 		
  91:main.c        **** 		// Return the cart mode in use
  92:main.c        **** 		if (receivedChar == CART_MODE) {
 1921               		.loc 3 92 0
 1922 0052 9091 0000 		lds r25,receivedChar
 1923 0056 9334      		cpi r25,lo8(67)
 1924 0058 01F4      		brne .+2
 1925 005a 00C0      		rjmp .L174
  93:main.c        **** 			USART_Transmit(cartMode);
  94:main.c        **** 		}
  95:main.c        **** 		
  96:main.c        **** 		// Change to GB mode or GBA mode if requested
  97:main.c        **** 		else if (receivedChar == GB_CART_MODE) {
 1926               		.loc 3 97 0
 1927 005c 9734      		cpi r25,lo8(71)
 1928 005e 01F4      		brne .L82
  98:main.c        **** 			gb_mode();
 1929               		.loc 3 98 0
 1930 0060 00D0      		rcall gb_mode
 1931               	.LVL135:
 1932 0062 00C0      		rjmp .L76
 1933               	.LVL136:
 1934               	.L82:
  99:main.c        **** 		}
 100:main.c        **** 		else if (receivedChar == GBA_CART_MODE) {
 1935               		.loc 3 100 0
 1936 0064 9736      		cpi r25,lo8(103)
 1937 0066 01F4      		brne .+2
 1938 0068 00C0      		rjmp .L176
 101:main.c        **** 			gba_mode();
 102:main.c        **** 		}
 103:main.c        **** 		
 104:main.c        **** 		// Set address
 105:main.c        **** 		else if (receivedChar == SET_START_ADDRESS) {
 1939               		.loc 3 105 0
 1940 006a 9134      		cpi r25,lo8(65)
 1941 006c 01F4      		brne .L84
 106:main.c        **** 			usart_read_chars(); // Read start address
 1942               		.loc 3 106 0
 1943 006e 00D0      		rcall usart_read_chars
 1944               	.LVL137:
 107:main.c        **** 			address = strtol(receivedBuffer, NULL, 16); // Convert address string in hex to dec
 1945               		.loc 3 107 0
 1946 0070 40E1      		ldi r20,lo8(16)
 1947 0072 50E0      		ldi r21,0
 1948 0074 60E0      		ldi r22,0
 1949 0076 70E0      		ldi r23,0
 1950 0078 80E0      		ldi r24,lo8(receivedBuffer)
 1951 007a 90E0      		ldi r25,hi8(receivedBuffer)
 1952 007c 00D0      		rcall strtol
 1953               	.LVL138:
 1954 007e 6B01      		movw r12,r22
 1955 0080 7C01      		movw r14,r24
 1956               	.LVL139:
 1957 0082 00C0      		rjmp .L76
 1958               	.LVL140:
 1959               	.L84:
 108:main.c        **** 		}
 109:main.c        **** 		
 110:main.c        **** 		
 111:main.c        **** 		// ****** Gameboy / Gameboy Colour ******
 112:main.c        **** 		
 113:main.c        **** 		// Read 64 bytes of ROM/RAM from address (and increment) until anything but 1 is received
 114:main.c        **** 		else if (receivedChar == READ_ROM_RAM) {
 1960               		.loc 3 114 0
 1961 0084 9235      		cpi r25,lo8(82)
 1962 0086 01F4      		brne .L85
 115:main.c        **** 			gb_mode();
 1963               		.loc 3 115 0
 1964 0088 00D0      		rcall gb_mode
 1965               	.LVL141:
 116:main.c        **** 			receivedChar = '1';
 1966               		.loc 3 116 0
 1967 008a 81E3      		ldi r24,lo8(49)
 1968               	.LVL142:
 1969               	.L180:
 117:main.c        **** 			while (receivedChar == '1') {
 118:main.c        **** 				PORTD |= (1<<ACTIVITY_LED);
 119:main.c        **** 				for (uint8_t x = 0; x < 64; x++) {
 120:main.c        **** 					USART_Transmit(read_8bit_data(address));
 121:main.c        **** 					address++;
 122:main.c        **** 				}
 123:main.c        **** 				
 124:main.c        **** 				PORTD &= ~(1<<ACTIVITY_LED);
 125:main.c        **** 				receivedChar = USART_Receive();
 1970               		.loc 3 125 0
 1971 008c 8093 0000 		sts receivedChar,r24
 1972               	.LVL143:
 117:main.c        **** 			while (receivedChar == '1') {
 1973               		.loc 3 117 0
 1974 0090 8091 0000 		lds r24,receivedChar
 1975 0094 8133      		cpi r24,lo8(49)
 1976 0096 01F4      		brne .L76
 118:main.c        **** 				for (uint8_t x = 0; x < 64; x++) {
 1977               		.loc 3 118 0
 1978 0098 939A      		sbi 0x12,3
 1979               	.LVL144:
 1980 009a 812C      		mov r8,__zero_reg__
 1981 009c 912C      		mov r9,__zero_reg__
 1982               	.LVL145:
 1983               	.L87:
 1984 009e C401      		movw r24,r8
 1985 00a0 8C0D      		add r24,r12
 1986 00a2 9D1D      		adc r25,r13
 1987               	.LBB78:
 120:main.c        **** 					address++;
 1988               		.loc 3 120 0 discriminator 3
 1989 00a4 00D0      		rcall read_8bit_data
 1990               	.LVL146:
 1991 00a6 00D0      		rcall USART_Transmit
 1992               	.LVL147:
 1993 00a8 8FEF      		ldi r24,-1
 1994 00aa 881A      		sub r8,r24
 1995 00ac 980A      		sbc r9,r24
 1996               	.LVL148:
 119:main.c        **** 					USART_Transmit(read_8bit_data(address));
 1997               		.loc 3 119 0 discriminator 3
 1998 00ae 90E4      		ldi r25,64
 1999 00b0 8916      		cp r8,r25
 2000 00b2 9104      		cpc r9,__zero_reg__
 2001 00b4 01F4      		brne .L87
 2002 00b6 E0E4      		ldi r30,64
 2003 00b8 CE0E      		add r12,r30
 2004 00ba D11C      		adc r13,__zero_reg__
 2005 00bc E11C      		adc r14,__zero_reg__
 2006 00be F11C      		adc r15,__zero_reg__
 2007               	.LBE78:
 124:main.c        **** 				receivedChar = USART_Receive();
 2008               		.loc 3 124 0
 2009 00c0 9398      		cbi 0x12,3
 2010               		.loc 3 125 0
 2011 00c2 00D0      		rcall USART_Receive
 2012               	.LVL149:
 2013 00c4 00C0      		rjmp .L180
 2014               	.LVL150:
 2015               	.L85:
 126:main.c        **** 			}
 127:main.c        **** 		}
 128:main.c        **** 		
 129:main.c        **** 		// Write 64 bytes to RAM on address (and increment)
 130:main.c        **** 		else if (receivedChar == WRITE_RAM) {
 2016               		.loc 3 130 0
 2017 00c6 9735      		cpi r25,lo8(87)
 2018 00c8 01F4      		brne .L89
 131:main.c        **** 			gb_mode();
 2019               		.loc 3 131 0
 2020 00ca 00D0      		rcall gb_mode
 2021               	.LVL151:
 132:main.c        **** 			
 133:main.c        **** 			// Read 64 bytes first as CH340G sends them all at once
 134:main.c        **** 			usart_read_bytes(64);
 2022               		.loc 3 134 0
 2023 00cc 80E4      		ldi r24,lo8(64)
 2024 00ce 00D0      		rcall usart_read_bytes
 2025               	.LVL152:
 135:main.c        **** 			
 136:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 2026               		.loc 3 136 0
 2027 00d0 939A      		sbi 0x12,3
 2028               	.LVL153:
 2029 00d2 60E0      		ldi r22,lo8(receivedBuffer)
 2030 00d4 662E      		mov r6,r22
 2031 00d6 60E0      		ldi r22,hi8(receivedBuffer)
 2032 00d8 762E      		mov r7,r22
 2033 00da 812C      		mov r8,__zero_reg__
 2034 00dc 912C      		mov r9,__zero_reg__
 2035               	.LVL154:
 2036               	.L90:
 2037               	.LBB79:
 137:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 138:main.c        **** 				write_8bit_data(address, receivedBuffer[x], MEMORY_WRITE);
 2038               		.loc 3 138 0 discriminator 3
 2039 00de F301      		movw r30,r6
 2040 00e0 6191      		ld r22,Z+
 2041 00e2 3F01      		movw r6,r30
 2042 00e4 C401      		movw r24,r8
 2043 00e6 8C0D      		add r24,r12
 2044 00e8 9D1D      		adc r25,r13
 2045 00ea 41E0      		ldi r20,lo8(1)
 2046 00ec 00D0      		rcall write_8bit_data
 2047               	.LVL155:
 2048 00ee FFEF      		ldi r31,-1
 2049 00f0 8F1A      		sub r8,r31
 2050 00f2 9F0A      		sbc r9,r31
 2051               	.LVL156:
 137:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 2052               		.loc 3 137 0 discriminator 3
 2053 00f4 20E4      		ldi r18,64
 2054 00f6 8216      		cp r8,r18
 2055 00f8 9104      		cpc r9,__zero_reg__
 2056 00fa 01F4      		brne .L90
 2057 00fc 80E4      		ldi r24,64
 2058 00fe C80E      		add r12,r24
 2059 0100 D11C      		adc r13,__zero_reg__
 2060 0102 E11C      		adc r14,__zero_reg__
 2061 0104 F11C      		adc r15,__zero_reg__
 2062 0106 00C0      		rjmp .L119
 2063               	.LVL157:
 2064               	.L89:
 2065               	.LBE79:
 139:main.c        **** 				address++;
 140:main.c        **** 			}
 141:main.c        **** 			
 142:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 143:main.c        **** 			USART_Transmit('1'); // Send back acknowledgement
 144:main.c        **** 		}
 145:main.c        **** 		
 146:main.c        **** 		// Set bank address and write a byte
 147:main.c        **** 		else if (receivedChar == SET_BANK) {
 2066               		.loc 3 147 0
 2067 0108 9234      		cpi r25,lo8(66)
 2068 010a 01F4      		brne .L91
 2069               	.LBB80:
 148:main.c        **** 			gb_mode();
 2070               		.loc 3 148 0
 2071 010c 00D0      		rcall gb_mode
 2072               	.LVL158:
 149:main.c        **** 			
 150:main.c        **** 			usart_read_chars(); // Read start address
 2073               		.loc 3 150 0
 2074 010e 00D0      		rcall usart_read_chars
 2075               	.LVL159:
 151:main.c        **** 			uint16_t bankaddress = strtol(receivedBuffer, NULL, 16); // Convert address string in hex to dec
 2076               		.loc 3 151 0
 2077 0110 40E1      		ldi r20,lo8(16)
 2078 0112 50E0      		ldi r21,0
 2079 0114 60E0      		ldi r22,0
 2080 0116 70E0      		ldi r23,0
 2081 0118 80E0      		ldi r24,lo8(receivedBuffer)
 2082 011a 90E0      		ldi r25,hi8(receivedBuffer)
 2083 011c 00D0      		rcall strtol
 2084               	.LVL160:
 2085 011e 2B01      		movw r4,r22
 2086 0120 3C01      		movw r6,r24
 2087               	.LVL161:
 152:main.c        **** 			
 153:main.c        **** 			receivedChar = USART_Receive(); // Wait for bank number
 2088               		.loc 3 153 0
 2089 0122 00D0      		rcall USART_Receive
 2090               	.LVL162:
 2091 0124 8093 0000 		sts receivedChar,r24
 154:main.c        **** 			if (receivedChar == 'B') {
 2092               		.loc 3 154 0
 2093 0128 8234      		cpi r24,lo8(66)
 2094 012a 01F0      		breq .+2
 2095 012c 00C0      		rjmp .L76
 2096               	.LBB81:
 155:main.c        **** 				usart_read_chars(); // Read data
 2097               		.loc 3 155 0
 2098 012e 00D0      		rcall usart_read_chars
 2099               	.LVL163:
 156:main.c        **** 				uint8_t data = atoi(receivedBuffer); // Convert data string to dec
 2100               		.loc 3 156 0
 2101 0130 80E0      		ldi r24,lo8(receivedBuffer)
 2102 0132 90E0      		ldi r25,hi8(receivedBuffer)
 2103 0134 00D0      		rcall atoi
 2104               	.LVL164:
 157:main.c        **** 				
 158:main.c        **** 				write_8bit_data(bankaddress, data, BANK_WRITE);
 2105               		.loc 3 158 0
 2106 0136 40E0      		ldi r20,0
 2107 0138 682F      		mov r22,r24
 2108 013a C201      		movw r24,r4
 2109               	.LVL165:
 2110 013c 00D0      		rcall write_8bit_data
 2111               	.LVL166:
 2112 013e 00C0      		rjmp .L76
 2113               	.LVL167:
 2114               	.L91:
 2115               	.LBE81:
 2116               	.LBE80:
 159:main.c        **** 			}
 160:main.c        **** 		}
 161:main.c        **** 		
 162:main.c        **** 		
 163:main.c        **** 		// ****** Gameboy Advance ******
 164:main.c        **** 		
 165:main.c        **** 		// ---------- ROM ----------
 166:main.c        **** 		// Read one 16bit byte from ROM using address (and increment) until anything but 1 is received
 167:main.c        **** 		else if (receivedChar == GBA_READ_ROM) {
 2117               		.loc 3 167 0
 2118 0140 9237      		cpi r25,lo8(114)
 2119 0142 01F4      		brne .L92
 168:main.c        **** 			gba_mode(); 
 2120               		.loc 3 168 0
 2121 0144 00D0      		rcall gba_mode
 2122               	.LVL168:
 169:main.c        **** 			
 170:main.c        **** 			receivedChar = '1';
 2123               		.loc 3 170 0
 2124 0146 81E3      		ldi r24,lo8(49)
 2125               	.LVL169:
 2126               	.L181:
 171:main.c        **** 			while (receivedChar == '1') {
 172:main.c        **** 				PORTD |= (1<<ACTIVITY_LED);
 173:main.c        **** 				for (uint8_t x = 0; x < 32; x++) {
 174:main.c        **** 					uint16_t dataRead = gba_read_16bit_data(address);
 175:main.c        **** 					
 176:main.c        **** 					// Low byte & High byte
 177:main.c        **** 					USART_Transmit(dataRead & 0xFF);
 178:main.c        **** 					USART_Transmit(dataRead >> 8);
 179:main.c        **** 					
 180:main.c        **** 					address++;
 181:main.c        **** 				}
 182:main.c        **** 				
 183:main.c        **** 				PORTD &= ~(1<<ACTIVITY_LED);
 184:main.c        **** 				receivedChar = USART_Receive();
 2127               		.loc 3 184 0
 2128 0148 8093 0000 		sts receivedChar,r24
 2129               	.LVL170:
 171:main.c        **** 			while (receivedChar == '1') {
 2130               		.loc 3 171 0
 2131 014c 8091 0000 		lds r24,receivedChar
 2132 0150 8133      		cpi r24,lo8(49)
 2133 0152 01F0      		breq .+2
 2134 0154 00C0      		rjmp .L76
 172:main.c        **** 				for (uint8_t x = 0; x < 32; x++) {
 2135               		.loc 3 172 0
 2136 0156 939A      		sbi 0x12,3
 2137               	.LVL171:
 2138 0158 2601      		movw r4,r12
 2139 015a 3701      		movw r6,r14
 2140 015c 50E2      		ldi r21,lo8(32)
 2141 015e 952E      		mov r9,r21
 2142 0160 9C0C      		add r9,r12
 2143               	.LVL172:
 2144               	.L94:
 2145               	.LBB82:
 2146               	.LBB83:
 174:main.c        **** 					
 2147               		.loc 3 174 0 discriminator 3
 2148 0162 C301      		movw r24,r6
 2149 0164 B201      		movw r22,r4
 2150 0166 00D0      		rcall gba_read_16bit_data
 2151               	.LVL173:
 177:main.c        **** 					USART_Transmit(dataRead >> 8);
 2152               		.loc 3 177 0 discriminator 3
 2153 0168 9B83      		std Y+3,r25
 2154 016a 00D0      		rcall USART_Transmit
 2155               	.LVL174:
 178:main.c        **** 					
 2156               		.loc 3 178 0 discriminator 3
 2157 016c 9B81      		ldd r25,Y+3
 2158 016e 892F      		mov r24,r25
 2159 0170 00D0      		rcall USART_Transmit
 2160               	.LVL175:
 180:main.c        **** 				}
 2161               		.loc 3 180 0 discriminator 3
 2162 0172 9FEF      		ldi r25,-1
 2163 0174 491A      		sub r4,r25
 2164 0176 590A      		sbc r5,r25
 2165 0178 690A      		sbc r6,r25
 2166 017a 790A      		sbc r7,r25
 2167               	.LVL176:
 2168               	.LBE83:
 173:main.c        **** 					uint16_t dataRead = gba_read_16bit_data(address);
 2169               		.loc 3 173 0 discriminator 3
 2170 017c 9410      		cpse r9,r4
 2171 017e 00C0      		rjmp .L94
 2172 0180 E0E2      		ldi r30,32
 2173 0182 CE0E      		add r12,r30
 2174 0184 D11C      		adc r13,__zero_reg__
 2175 0186 E11C      		adc r14,__zero_reg__
 2176 0188 F11C      		adc r15,__zero_reg__
 2177               	.LVL177:
 2178               	.LBE82:
 183:main.c        **** 				receivedChar = USART_Receive();
 2179               		.loc 3 183 0
 2180 018a 9398      		cbi 0x12,3
 2181               		.loc 3 184 0
 2182 018c 00D0      		rcall USART_Receive
 2183               	.LVL178:
 2184 018e 00C0      		rjmp .L181
 2185               	.LVL179:
 2186               	.L92:
 185:main.c        **** 			}
 186:main.c        **** 		}
 187:main.c        **** 		
 188:main.c        **** 		
 189:main.c        **** 		// ---------- SRAM ----------
 190:main.c        **** 		// Read RAM from address (and increment) until anything but 1 is received
 191:main.c        **** 		else if (receivedChar == GBA_READ_SRAM) {
 2187               		.loc 3 191 0
 2188 0190 9D36      		cpi r25,lo8(109)
 2189 0192 01F4      		brne .L96
 192:main.c        **** 			gb_mode(); // Set GB mode as it uses 16 bit address with 8 bit data
 2190               		.loc 3 192 0
 2191 0194 00D0      		rcall gb_mode
 2192               	.LVL180:
 193:main.c        **** 			
 194:main.c        **** 			receivedChar = '1';
 2193               		.loc 3 194 0
 2194 0196 81E3      		ldi r24,lo8(49)
 2195               	.LVL181:
 2196               	.L182:
 195:main.c        **** 			while (receivedChar == '1') {
 196:main.c        **** 				PORTD |= (1<<ACTIVITY_LED);
 197:main.c        **** 				for (uint8_t x = 0; x < 64; x++) {
 198:main.c        **** 					USART_Transmit(gba_read_ram_8bit_data(address));
 199:main.c        **** 					address++;
 200:main.c        **** 				}
 201:main.c        **** 				
 202:main.c        **** 				PORTD &= ~(1<<ACTIVITY_LED);
 203:main.c        **** 				receivedChar = USART_Receive();
 2197               		.loc 3 203 0
 2198 0198 8093 0000 		sts receivedChar,r24
 2199               	.LVL182:
 195:main.c        **** 			while (receivedChar == '1') {
 2200               		.loc 3 195 0
 2201 019c 8091 0000 		lds r24,receivedChar
 2202 01a0 8133      		cpi r24,lo8(49)
 2203 01a2 01F4      		brne .L176
 196:main.c        **** 				for (uint8_t x = 0; x < 64; x++) {
 2204               		.loc 3 196 0
 2205 01a4 939A      		sbi 0x12,3
 2206               	.LVL183:
 2207 01a6 812C      		mov r8,__zero_reg__
 2208 01a8 912C      		mov r9,__zero_reg__
 2209               	.LVL184:
 2210               	.L98:
 2211 01aa C401      		movw r24,r8
 2212 01ac 8C0D      		add r24,r12
 2213 01ae 9D1D      		adc r25,r13
 2214               	.LBB84:
 198:main.c        **** 					address++;
 2215               		.loc 3 198 0 discriminator 3
 2216 01b0 00D0      		rcall gba_read_ram_8bit_data
 2217               	.LVL185:
 2218 01b2 00D0      		rcall USART_Transmit
 2219               	.LVL186:
 2220 01b4 FFEF      		ldi r31,-1
 2221 01b6 8F1A      		sub r8,r31
 2222 01b8 9F0A      		sbc r9,r31
 2223               	.LVL187:
 197:main.c        **** 					USART_Transmit(gba_read_ram_8bit_data(address));
 2224               		.loc 3 197 0 discriminator 3
 2225 01ba 20E4      		ldi r18,64
 2226 01bc 8216      		cp r8,r18
 2227 01be 9104      		cpc r9,__zero_reg__
 2228 01c0 01F4      		brne .L98
 2229 01c2 80E4      		ldi r24,64
 2230 01c4 C80E      		add r12,r24
 2231 01c6 D11C      		adc r13,__zero_reg__
 2232 01c8 E11C      		adc r14,__zero_reg__
 2233 01ca F11C      		adc r15,__zero_reg__
 2234               	.LBE84:
 202:main.c        **** 				receivedChar = USART_Receive();
 2235               		.loc 3 202 0
 2236 01cc 9398      		cbi 0x12,3
 2237               		.loc 3 203 0
 2238 01ce 00D0      		rcall USART_Receive
 2239               	.LVL188:
 2240 01d0 00C0      		rjmp .L182
 2241               	.LVL189:
 2242               	.L96:
 204:main.c        **** 			}
 205:main.c        **** 			
 206:main.c        **** 			gba_mode(); // Set back
 207:main.c        **** 		}
 208:main.c        **** 		
 209:main.c        **** 		// Write to RAM on address (and increment) with 64 bytes of data
 210:main.c        **** 		else if (receivedChar == GBA_WRITE_SRAM) {
 2243               		.loc 3 210 0
 2244 01d2 9737      		cpi r25,lo8(119)
 2245 01d4 01F4      		brne .L100
 211:main.c        **** 			gb_mode();
 2246               		.loc 3 211 0
 2247 01d6 00D0      		rcall gb_mode
 2248               	.LVL190:
 212:main.c        **** 			
 213:main.c        **** 			usart_read_bytes(64);
 2249               		.loc 3 213 0
 2250 01d8 80E4      		ldi r24,lo8(64)
 2251 01da 00D0      		rcall usart_read_bytes
 2252               	.LVL191:
 214:main.c        **** 			
 215:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 2253               		.loc 3 215 0
 2254 01dc 939A      		sbi 0x12,3
 2255               	.LVL192:
 2256 01de 40E0      		ldi r20,lo8(receivedBuffer)
 2257 01e0 642E      		mov r6,r20
 2258 01e2 40E0      		ldi r20,hi8(receivedBuffer)
 2259 01e4 742E      		mov r7,r20
 2260 01e6 812C      		mov r8,__zero_reg__
 2261 01e8 912C      		mov r9,__zero_reg__
 2262               	.LVL193:
 2263               	.L101:
 2264               	.LBB85:
 216:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 217:main.c        **** 				gba_write_ram_8bit_data(address, receivedBuffer[x]);
 2265               		.loc 3 217 0 discriminator 3
 2266 01ea F301      		movw r30,r6
 2267 01ec 6191      		ld r22,Z+
 2268 01ee 3F01      		movw r6,r30
 2269 01f0 C401      		movw r24,r8
 2270 01f2 8C0D      		add r24,r12
 2271 01f4 9D1D      		adc r25,r13
 2272 01f6 00D0      		rcall gba_write_ram_8bit_data
 2273               	.LVL194:
 2274 01f8 FFEF      		ldi r31,-1
 2275 01fa 8F1A      		sub r8,r31
 2276 01fc 9F0A      		sbc r9,r31
 2277               	.LVL195:
 216:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 2278               		.loc 3 216 0 discriminator 3
 2279 01fe 20E4      		ldi r18,64
 2280 0200 8216      		cp r8,r18
 2281 0202 9104      		cpc r9,__zero_reg__
 2282 0204 01F4      		brne .L101
 2283               	.LVL196:
 2284               	.L179:
 2285 0206 80E4      		ldi r24,64
 2286 0208 C80E      		add r12,r24
 2287 020a D11C      		adc r13,__zero_reg__
 2288 020c E11C      		adc r14,__zero_reg__
 2289 020e F11C      		adc r15,__zero_reg__
 2290               	.L178:
 2291               	.LBE85:
 218:main.c        **** 				address++;
 219:main.c        **** 			}
 220:main.c        **** 			USART_Transmit('1'); // Send back acknowledgement
 2292               		.loc 3 220 0
 2293 0210 81E3      		ldi r24,lo8(49)
 2294 0212 00D0      		rcall USART_Transmit
 2295               	.LVL197:
 221:main.c        **** 			
 222:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 2296               		.loc 3 222 0
 2297 0214 9398      		cbi 0x12,3
 2298               	.L176:
 223:main.c        **** 			gba_mode(); // Set back
 2299               		.loc 3 223 0
 2300 0216 00D0      		rcall gba_mode
 2301               	.LVL198:
 2302 0218 00C0      		rjmp .L76
 2303               	.LVL199:
 2304               	.L100:
 224:main.c        **** 		}
 225:main.c        **** 		
 226:main.c        **** 		// 'o' - Write 1 byte to SRAM address
 227:main.c        **** 		else if (receivedChar == GBA_WRITE_ONE_BYTE_SRAM) {
 2305               		.loc 3 227 0
 2306 021a 9F36      		cpi r25,lo8(111)
 2307 021c 01F4      		brne .L102
 2308               	.LBB86:
 228:main.c        **** 			gb_mode();
 2309               		.loc 3 228 0
 2310 021e 00D0      		rcall gb_mode
 2311               	.LVL200:
 229:main.c        **** 			
 230:main.c        **** 			uint8_t data = USART_Receive();
 2312               		.loc 3 230 0
 2313 0220 00D0      		rcall USART_Receive
 2314               	.LVL201:
 231:main.c        **** 			gba_write_ram_8bit_data(address, data);
 2315               		.loc 3 231 0
 2316 0222 682F      		mov r22,r24
 2317 0224 C601      		movw r24,r12
 2318               	.LVL202:
 2319 0226 00D0      		rcall gba_write_ram_8bit_data
 2320               	.LVL203:
 2321 0228 00C0      		rjmp .L184
 2322               	.LVL204:
 2323               	.L102:
 2324               	.LBE86:
 232:main.c        **** 			USART_Transmit('1'); // Send back acknowledgement
 233:main.c        **** 			
 234:main.c        **** 			gba_mode(); // Set back
 235:main.c        **** 		}
 236:main.c        **** 		
 237:main.c        **** 		
 238:main.c        **** 		// ---------- FLASH ----------
 239:main.c        **** 		// Read the Flash Manufacturer and Device ID
 240:main.c        **** 		else if (receivedChar == GBA_FLASH_READ_ID) {
 2325               		.loc 3 240 0
 2326 022a 9936      		cpi r25,lo8(105)
 2327 022c 01F4      		brne .L103
 241:main.c        **** 			gb_mode();
 2328               		.loc 3 241 0
 2329 022e 00D0      		rcall gb_mode
 2330               	.LVL205:
 242:main.c        **** 			
 243:main.c        **** 			flash_read_chip_id();
 2331               		.loc 3 243 0
 2332 0230 00D0      		rcall flash_read_chip_id
 2333               	.LVL206:
 244:main.c        **** 			USART_Transmit(flashChipIdBuffer[0]);
 2334               		.loc 3 244 0
 2335 0232 8091 0000 		lds r24,flashChipIdBuffer
 2336 0236 00D0      		rcall USART_Transmit
 2337               	.LVL207:
 245:main.c        **** 			USART_Transmit(flashChipIdBuffer[1]);
 2338               		.loc 3 245 0
 2339 0238 8091 0000 		lds r24,flashChipIdBuffer+1
 2340               	.L183:
 2341 023c 00D0      		rcall USART_Transmit
 2342               	.LVL208:
 2343 023e 00C0      		rjmp .L176
 2344               	.LVL209:
 2345               	.L103:
 246:main.c        **** 			
 247:main.c        **** 			gba_mode(); // Set back
 248:main.c        **** 		}
 249:main.c        **** 		
 250:main.c        **** 		// Change bank
 251:main.c        **** 		else if (receivedChar == GBA_FLASH_SET_BANK) {
 2346               		.loc 3 251 0
 2347 0240 9B36      		cpi r25,lo8(107)
 2348 0242 01F4      		brne .L104
 2349               	.LBB87:
 252:main.c        **** 			usart_read_chars(); // Read data
 2350               		.loc 3 252 0
 2351 0244 00D0      		rcall usart_read_chars
 2352               	.LVL210:
 253:main.c        **** 			uint8_t bank = atoi(receivedBuffer); // Convert data string to dec
 2353               		.loc 3 253 0
 2354 0246 80E0      		ldi r24,lo8(receivedBuffer)
 2355 0248 90E0      		ldi r25,hi8(receivedBuffer)
 2356 024a 00D0      		rcall atoi
 2357               	.LVL211:
 254:main.c        **** 			
 255:main.c        **** 			gb_mode();
 2358               		.loc 3 255 0
 2359 024c 8B83      		std Y+3,r24
 2360 024e 00D0      		rcall gb_mode
 2361               	.LVL212:
 256:main.c        **** 			flash_switch_bank(bank);
 2362               		.loc 3 256 0
 2363 0250 8B81      		ldd r24,Y+3
 2364 0252 00D0      		rcall flash_switch_bank
 2365               	.LVL213:
 2366 0254 00C0      		rjmp .L176
 2367               	.LVL214:
 2368               	.L104:
 2369               	.LBE87:
 257:main.c        **** 			
 258:main.c        **** 			gba_mode(); // Set back
 259:main.c        **** 		}
 260:main.c        **** 		
 261:main.c        **** 		// Erase 4K sector on Flash (sector 0 to 15 for 512Kbit)
 262:main.c        **** 		else if (receivedChar == GBA_FLASH_4K_SECTOR_ERASE) {
 2370               		.loc 3 262 0
 2371 0256 9337      		cpi r25,lo8(115)
 2372 0258 01F4      		brne .L105
 2373               	.LBB88:
 263:main.c        **** 			gb_mode();
 2374               		.loc 3 263 0
 2375 025a 00D0      		rcall gb_mode
 2376               	.LVL215:
 264:main.c        **** 			
 265:main.c        **** 			usart_read_chars(); // Read sector
 2377               		.loc 3 265 0
 2378 025c 00D0      		rcall usart_read_chars
 2379               	.LVL216:
 266:main.c        **** 			uint8_t sectorAddress = strtol(receivedBuffer, NULL, 16); // Convert address string in hex to de
 2380               		.loc 3 266 0
 2381 025e 40E1      		ldi r20,lo8(16)
 2382 0260 50E0      		ldi r21,0
 2383 0262 60E0      		ldi r22,0
 2384 0264 70E0      		ldi r23,0
 2385 0266 80E0      		ldi r24,lo8(receivedBuffer)
 2386 0268 90E0      		ldi r25,hi8(receivedBuffer)
 2387 026a 00D0      		rcall strtol
 2388               	.LVL217:
 2389 026c 862F      		mov r24,r22
 2390               	.LVL218:
 267:main.c        **** 			
 268:main.c        **** 			flash_erase_4k_sector(sectorAddress);
 2391               		.loc 3 268 0
 2392 026e 00D0      		rcall flash_erase_4k_sector
 2393               	.LVL219:
 2394               	.L184:
 269:main.c        **** 			USART_Transmit('1'); // Send back acknowledgement
 2395               		.loc 3 269 0
 2396 0270 81E3      		ldi r24,lo8(49)
 2397 0272 00C0      		rjmp .L183
 2398               	.LVL220:
 2399               	.L105:
 2400               	.LBE88:
 270:main.c        **** 			
 271:main.c        **** 			gba_mode(); // Set back
 272:main.c        **** 		}
 273:main.c        **** 		
 274:main.c        **** 		// Write 64 bytes to Flash address one byte write at a time (and increment)
 275:main.c        **** 		else if (receivedChar == GBA_FLASH_WRITE_BYTE) {
 2401               		.loc 3 275 0
 2402 0274 9236      		cpi r25,lo8(98)
 2403 0276 01F4      		brne .L106
 276:main.c        **** 			gb_mode();
 2404               		.loc 3 276 0
 2405 0278 00D0      		rcall gb_mode
 2406               	.LVL221:
 277:main.c        **** 			
 278:main.c        **** 			usart_read_bytes(64);
 2407               		.loc 3 278 0
 2408 027a 80E4      		ldi r24,lo8(64)
 2409 027c 00D0      		rcall usart_read_bytes
 2410               	.LVL222:
 279:main.c        **** 			
 280:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 2411               		.loc 3 280 0
 2412 027e 939A      		sbi 0x12,3
 2413               	.LVL223:
 2414 0280 30E0      		ldi r19,lo8(receivedBuffer)
 2415 0282 832E      		mov r8,r19
 2416 0284 30E0      		ldi r19,hi8(receivedBuffer)
 2417 0286 932E      		mov r9,r19
 2418 0288 612C      		mov r6,__zero_reg__
 2419 028a 712C      		mov r7,__zero_reg__
 2420               	.LVL224:
 2421               	.L107:
 2422               	.LBB89:
 281:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 282:main.c        **** 				flash_write_byte(address, receivedBuffer[x]);
 2423               		.loc 3 282 0 discriminator 3
 2424 028c F401      		movw r30,r8
 2425 028e 6191      		ld r22,Z+
 2426 0290 4F01      		movw r8,r30
 2427 0292 C301      		movw r24,r6
 2428 0294 8C0D      		add r24,r12
 2429 0296 9D1D      		adc r25,r13
 2430 0298 00D0      		rcall flash_write_byte
 2431               	.LVL225:
 2432 029a FFEF      		ldi r31,-1
 2433 029c 6F1A      		sub r6,r31
 2434 029e 7F0A      		sbc r7,r31
 2435               	.LVL226:
 281:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 2436               		.loc 3 281 0 discriminator 3
 2437 02a0 20E4      		ldi r18,64
 2438 02a2 6216      		cp r6,r18
 2439 02a4 7104      		cpc r7,__zero_reg__
 2440 02a6 01F4      		brne .L107
 2441 02a8 00C0      		rjmp .L179
 2442               	.LVL227:
 2443               	.L106:
 2444               	.LBE89:
 283:main.c        **** 				address++;
 284:main.c        **** 			}
 285:main.c        **** 			USART_Transmit('1'); // Send back acknowledgement
 286:main.c        **** 			
 287:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 288:main.c        **** 			gba_mode(); // Set back
 289:main.c        **** 		}
 290:main.c        **** 		
 291:main.c        **** 		// Write 128 bytes to flash sector for Atmel flash (and increment)
 292:main.c        **** 		else if (receivedChar == GBA_FLASH_WRITE_ATMEL) {
 2445               		.loc 3 292 0
 2446 02aa 9136      		cpi r25,lo8(97)
 2447 02ac 01F4      		brne .L108
 293:main.c        **** 			gb_mode();
 2448               		.loc 3 293 0
 2449 02ae 00D0      		rcall gb_mode
 2450               	.LVL228:
 294:main.c        **** 			
 295:main.c        **** 			usart_read_bytes(128);
 2451               		.loc 3 295 0
 2452 02b0 80E8      		ldi r24,lo8(-128)
 2453 02b2 00D0      		rcall usart_read_bytes
 2454               	.LVL229:
 296:main.c        **** 			
 297:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 2455               		.loc 3 297 0
 2456 02b4 939A      		sbi 0x12,3
 298:main.c        **** 			flash_write_sector(address); // Address used as sector number
 2457               		.loc 3 298 0
 2458 02b6 C601      		movw r24,r12
 2459 02b8 00D0      		rcall flash_write_sector
 2460               	.LVL230:
 299:main.c        **** 			address++;
 2461               		.loc 3 299 0
 2462 02ba 9FEF      		ldi r25,-1
 2463 02bc C91A      		sub r12,r25
 2464 02be D90A      		sbc r13,r25
 2465 02c0 E90A      		sbc r14,r25
 2466 02c2 F90A      		sbc r15,r25
 2467               	.LVL231:
 2468 02c4 00C0      		rjmp .L178
 2469               	.LVL232:
 2470               	.L108:
 300:main.c        **** 			USART_Transmit('1'); // Send back acknowledgement
 301:main.c        **** 			
 302:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 303:main.c        **** 			gba_mode(); // Set back
 304:main.c        **** 		}
 305:main.c        **** 		
 306:main.c        **** 		
 307:main.c        **** 		// ---------- EEPROM ----------
 308:main.c        **** 		// Set EEPROM size
 309:main.c        **** 		else if (receivedChar == GBA_SET_EEPROM_SIZE) {
 2471               		.loc 3 309 0
 2472 02c6 9335      		cpi r25,lo8(83)
 2473 02c8 01F4      		brne .L109
 310:main.c        **** 			usart_read_chars(); // Read size
 2474               		.loc 3 310 0
 2475 02ca 00D0      		rcall usart_read_chars
 2476               	.LVL233:
 311:main.c        **** 			eepromSize = strtol(receivedBuffer, NULL, 16); // Convert size to dec
 2477               		.loc 3 311 0
 2478 02cc 40E1      		ldi r20,lo8(16)
 2479 02ce 50E0      		ldi r21,0
 2480 02d0 60E0      		ldi r22,0
 2481 02d2 70E0      		ldi r23,0
 2482 02d4 80E0      		ldi r24,lo8(receivedBuffer)
 2483 02d6 90E0      		ldi r25,hi8(receivedBuffer)
 2484 02d8 00D0      		rcall strtol
 2485               	.LVL234:
 2486 02da 062F      		mov r16,r22
 2487               	.LVL235:
 2488 02dc 00C0      		rjmp .L76
 2489               	.LVL236:
 2490               	.L109:
 312:main.c        **** 		}
 313:main.c        **** 		
 314:main.c        **** 		// Read the EEPROM on address (and increment) until anything but 1 is received
 315:main.c        **** 		else if (receivedChar == GBA_READ_EEPROM) {
 2491               		.loc 3 315 0
 2492 02de 9536      		cpi r25,lo8(101)
 2493 02e0 01F4      		brne .L110
 316:main.c        **** 			gba_eeprom_mode();
 2494               		.loc 3 316 0
 2495 02e2 00D0      		rcall gba_eeprom_mode
 2496               	.LVL237:
 317:main.c        **** 			
 318:main.c        **** 			receivedChar = '1';
 2497               		.loc 3 318 0
 2498 02e4 81E3      		ldi r24,lo8(49)
 2499               	.L185:
 319:main.c        **** 			while (receivedChar == '1') {
 320:main.c        **** 				PORTD |= (1<<ACTIVITY_LED);
 321:main.c        **** 				gba_eeprom_read(address, eepromSize);
 322:main.c        **** 				
 323:main.c        **** 				// Send back the 8 bytes of data
 324:main.c        **** 				for (uint8_t c = 0; c < 8; c++) {
 325:main.c        **** 					USART_Transmit(eepromBuffer[c]);
 326:main.c        **** 				}
 327:main.c        **** 				address++; // Increment to next 8 bytes
 328:main.c        **** 				
 329:main.c        **** 				PORTD &= ~(1<<ACTIVITY_LED);
 330:main.c        **** 				receivedChar = USART_Receive();
 2500               		.loc 3 330 0
 2501 02e6 8093 0000 		sts receivedChar,r24
 319:main.c        **** 			while (receivedChar == '1') {
 2502               		.loc 3 319 0
 2503 02ea 8091 0000 		lds r24,receivedChar
 2504 02ee 8133      		cpi r24,lo8(49)
 2505 02f0 01F0      		breq .+2
 2506 02f2 00C0      		rjmp .L176
 320:main.c        **** 				gba_eeprom_read(address, eepromSize);
 2507               		.loc 3 320 0
 2508 02f4 939A      		sbi 0x12,3
 321:main.c        **** 				
 2509               		.loc 3 321 0
 2510 02f6 602F      		mov r22,r16
 2511 02f8 C601      		movw r24,r12
 2512 02fa 00D0      		rcall gba_eeprom_read
 2513               	.LVL238:
 2514 02fc 20E0      		ldi r18,lo8(eepromBuffer)
 2515 02fe 822E      		mov r8,r18
 2516 0300 20E0      		ldi r18,hi8(eepromBuffer)
 2517 0302 922E      		mov r9,r18
 2518               	.LVL239:
 2519               	.L112:
 2520               	.LBB90:
 325:main.c        **** 				}
 2521               		.loc 3 325 0 discriminator 3
 2522 0304 F401      		movw r30,r8
 2523 0306 8191      		ld r24,Z+
 2524 0308 4F01      		movw r8,r30
 2525               	.LVL240:
 2526 030a 00D0      		rcall USART_Transmit
 2527               	.LVL241:
 324:main.c        **** 					USART_Transmit(eepromBuffer[c]);
 2528               		.loc 3 324 0 discriminator 3
 2529 030c 1811      		cpse r17,r8
 2530 030e 00C0      		rjmp .L112
 2531               	.LBE90:
 327:main.c        **** 				
 2532               		.loc 3 327 0
 2533 0310 FFEF      		ldi r31,-1
 2534 0312 CF1A      		sub r12,r31
 2535 0314 DF0A      		sbc r13,r31
 2536 0316 EF0A      		sbc r14,r31
 2537 0318 FF0A      		sbc r15,r31
 2538               	.LVL242:
 329:main.c        **** 				receivedChar = USART_Receive();
 2539               		.loc 3 329 0
 2540 031a 9398      		cbi 0x12,3
 2541               		.loc 3 330 0
 2542 031c 00D0      		rcall USART_Receive
 2543               	.LVL243:
 2544 031e 00C0      		rjmp .L185
 2545               	.LVL244:
 2546               	.L110:
 331:main.c        **** 			}
 332:main.c        **** 			
 333:main.c        **** 			gba_mode(); // Set back
 334:main.c        **** 		}
 335:main.c        **** 		
 336:main.c        **** 		// Write 8 bytes to the EEPROM address (and increment)
 337:main.c        **** 		else if (receivedChar == GBA_WRITE_EEPROM) {
 2547               		.loc 3 337 0
 2548 0320 9037      		cpi r25,lo8(112)
 2549 0322 01F4      		brne .L114
 338:main.c        **** 			gba_eeprom_mode();
 2550               		.loc 3 338 0
 2551 0324 00D0      		rcall gba_eeprom_mode
 2552               	.LVL245:
 2553 0326 90E0      		ldi r25,lo8(eepromBuffer)
 2554 0328 892E      		mov r8,r25
 2555 032a 90E0      		ldi r25,hi8(eepromBuffer)
 2556 032c 992E      		mov r9,r25
 2557               	.LVL246:
 2558               	.L115:
 2559               	.LBB91:
 339:main.c        **** 			
 340:main.c        **** 			// Read 8 bytes from USART and place in buffer
 341:main.c        **** 			for (uint8_t x = 0; x < 8; x++) {
 342:main.c        **** 				eepromBuffer[x] = USART_Receive();
 2560               		.loc 3 342 0 discriminator 3
 2561 032e 00D0      		rcall USART_Receive
 2562               	.LVL247:
 2563 0330 F401      		movw r30,r8
 2564 0332 8193      		st Z+,r24
 2565 0334 4F01      		movw r8,r30
 2566               	.LVL248:
 341:main.c        **** 				eepromBuffer[x] = USART_Receive();
 2567               		.loc 3 341 0 discriminator 3
 2568 0336 1E13      		cpse r17,r30
 2569 0338 00C0      		rjmp .L115
 2570               	.LBE91:
 343:main.c        **** 			}
 344:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 2571               		.loc 3 344 0
 2572 033a 939A      		sbi 0x12,3
 345:main.c        **** 			
 346:main.c        **** 			gba_eeprom_write(address, eepromSize);
 2573               		.loc 3 346 0
 2574 033c 602F      		mov r22,r16
 2575 033e C601      		movw r24,r12
 2576 0340 00D0      		rcall gba_eeprom_write
 2577               	.LVL249:
 347:main.c        **** 			address++;
 2578               		.loc 3 347 0
 2579 0342 FFEF      		ldi r31,-1
 2580 0344 CF1A      		sub r12,r31
 2581 0346 DF0A      		sbc r13,r31
 2582 0348 EF0A      		sbc r14,r31
 2583 034a FF0A      		sbc r15,r31
 2584               	.LVL250:
 2585               	.LBB92:
 2586               	.LBB93:
 187:c:\winavr-20100110\avr\include\util\delay.h **** 
 2587               		.loc 2 187 0
 2588 034c 8FE7      		ldi r24,lo8(15999)
 2589 034e 9EE3      		ldi r25,hi8(15999)
 2590 0350 0197      	1:	sbiw r24,1
 2591 0352 01F4      		brne 1b
 2592 0354 00C0      		rjmp .
 2593 0356 0000      		nop
 2594 0358 00C0      		rjmp .L178
 2595               	.LVL251:
 2596               	.L114:
 2597               	.LBE93:
 2598               	.LBE92:
 348:main.c        **** 			
 349:main.c        **** 			_delay_ms(8); // Wait for EEPROM to write data (8ms)
 350:main.c        **** 			USART_Transmit('1'); // Send back acknowledgement
 351:main.c        **** 			
 352:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 353:main.c        **** 			gba_mode(); // Set back
 354:main.c        **** 		}
 355:main.c        **** 		
 356:main.c        **** 		
 357:main.c        **** 		// ---------- FLASH CARTS ----------
 358:main.c        **** 		
 359:main.c        **** 		// Write address, one byte and pulse a pin
 360:main.c        **** 		else if (receivedChar == GB_FLASH_WRITE_BYTE) {
 2599               		.loc 3 360 0
 2600 035a 9634      		cpi r25,lo8(70)
 2601 035c 01F4      		brne .L116
 2602               	.LBB94:
 361:main.c        **** 			usart_read_chars(); // Read address
 2603               		.loc 3 361 0
 2604 035e 00D0      		rcall usart_read_chars
 2605               	.LVL252:
 362:main.c        **** 			uint16_t flashAddress = strtol(receivedBuffer, NULL, 16); // Convert address string in hex to de
 2606               		.loc 3 362 0
 2607 0360 40E1      		ldi r20,lo8(16)
 2608 0362 50E0      		ldi r21,0
 2609 0364 60E0      		ldi r22,0
 2610 0366 70E0      		ldi r23,0
 2611 0368 80E0      		ldi r24,lo8(receivedBuffer)
 2612 036a 90E0      		ldi r25,hi8(receivedBuffer)
 2613 036c 00D0      		rcall strtol
 2614               	.LVL253:
 2615 036e 1B01      		movw r2,r22
 2616 0370 2C01      		movw r4,r24
 2617               	.LVL254:
 363:main.c        **** 			
 364:main.c        **** 			receivedChar = USART_Receive(); // Wait for byte
 2618               		.loc 3 364 0
 2619 0372 00D0      		rcall USART_Receive
 2620               	.LVL255:
 2621 0374 8093 0000 		sts receivedChar,r24
 365:main.c        **** 			if (receivedChar == GB_AUDIO_FLASH_WRITE || receivedChar == GB_BV5_FLASH_WRITE) {
 2622               		.loc 3 365 0
 2623 0378 8535      		cpi r24,lo8(85)
 2624 037a 01F0      		breq .L117
 2625               		.loc 3 365 0 is_stmt 0 discriminator 1
 2626 037c 8533      		cpi r24,lo8(53)
 2627 037e 01F0      		breq .+2
 2628 0380 00C0      		rjmp .L76
 2629               	.L117:
 2630               	.LBB95:
 366:main.c        **** 				usart_read_chars(); // Read data
 2631               		.loc 3 366 0 is_stmt 1
 2632 0382 00D0      		rcall usart_read_chars
 2633               	.LVL256:
 367:main.c        **** 				uint8_t flashByte = strtol(receivedBuffer, NULL, 16); // Convert data byte in hex to dec
 2634               		.loc 3 367 0
 2635 0384 40E1      		ldi r20,lo8(16)
 2636 0386 50E0      		ldi r21,0
 2637 0388 60E0      		ldi r22,0
 2638 038a 70E0      		ldi r23,0
 2639 038c 80E0      		ldi r24,lo8(receivedBuffer)
 2640 038e 90E0      		ldi r25,hi8(receivedBuffer)
 2641 0390 00D0      		rcall strtol
 2642               	.LVL257:
 368:main.c        **** 				
 369:main.c        **** 				PORTD |= (1<<ACTIVITY_LED);
 2643               		.loc 3 369 0
 2644 0392 939A      		sbi 0x12,3
 370:main.c        **** 				if (receivedChar == GB_AUDIO_FLASH_WRITE) { // Pulse audio pin
 2645               		.loc 3 370 0
 2646 0394 8091 0000 		lds r24,receivedChar
 2647 0398 8535      		cpi r24,lo8(85)
 2648 039a 01F4      		brne .L118
 371:main.c        **** 					audio_flash_write_bus_cycle(flashAddress, flashByte);
 2649               		.loc 3 371 0
 2650 039c C101      		movw r24,r2
 2651 039e 00D0      		rcall audio_flash_write_bus_cycle
 2652               	.LVL258:
 2653 03a0 00C0      		rjmp .L119
 2654               	.LVL259:
 2655               	.L118:
 372:main.c        **** 				}
 373:main.c        **** 				else if (receivedChar == GB_BV5_FLASH_WRITE) { // Pulse WR pin
 2656               		.loc 3 373 0
 2657 03a2 8533      		cpi r24,lo8(53)
 2658 03a4 01F4      		brne .L119
 374:main.c        **** 					bv5_flash_write_bus_cycle(flashAddress, flashByte);
 2659               		.loc 3 374 0
 2660 03a6 C101      		movw r24,r2
 2661 03a8 00D0      		rcall bv5_flash_write_bus_cycle
 2662               	.LVL260:
 2663               	.L119:
 375:main.c        **** 				}
 376:main.c        **** 				PORTD &= ~(1<<ACTIVITY_LED);
 2664               		.loc 3 376 0
 2665 03aa 9398      		cbi 0x12,3
 377:main.c        **** 				
 378:main.c        **** 				USART_Transmit('1'); // Send back acknowledgement
 2666               		.loc 3 378 0
 2667 03ac 81E3      		ldi r24,lo8(49)
 2668 03ae 00C0      		rjmp .L174
 2669               	.LVL261:
 2670               	.L116:
 2671               	.LBE95:
 2672               	.LBE94:
 379:main.c        **** 			}
 380:main.c        **** 		}
 381:main.c        **** 		
 382:main.c        **** 		// Write 64 bytes to Flash address one byte write at a time (and increment), pulse a pin
 383:main.c        **** 		else if (receivedChar == GB_FLASH_WRITE_64BYTE) {
 2673               		.loc 3 383 0
 2674 03b0 9435      		cpi r25,lo8(84)
 2675 03b2 01F4      		brne .L120
 384:main.c        **** 			receivedChar = USART_Receive(); // Wait for byte
 2676               		.loc 3 384 0
 2677 03b4 00D0      		rcall USART_Receive
 2678               	.LVL262:
 2679 03b6 8093 0000 		sts receivedChar,r24
 385:main.c        **** 			usart_read_bytes(64);
 2680               		.loc 3 385 0
 2681 03ba 80E4      		ldi r24,lo8(64)
 2682 03bc 00D0      		rcall usart_read_bytes
 2683               	.LVL263:
 386:main.c        **** 			
 387:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 2684               		.loc 3 387 0
 2685 03be 939A      		sbi 0x12,3
 2686               	.LVL264:
 2687 03c0 80E0      		ldi r24,lo8(receivedBuffer)
 2688 03c2 682E      		mov r6,r24
 2689 03c4 80E0      		ldi r24,hi8(receivedBuffer)
 2690 03c6 782E      		mov r7,r24
 2691 03c8 F601      		movw r30,r12
 2692 03ca E050      		subi r30,lo8(receivedBuffer)
 2693 03cc F040      		sbci r31,hi8(receivedBuffer)
 2694 03ce 4F01      		movw r8,r30
 2695               	.LVL265:
 2696               	.L123:
 2697               	.LBB96:
 388:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 389:main.c        **** 				if (receivedChar == GB_AUDIO_FLASH_WRITE) { // Pulse audio pin
 2698               		.loc 3 389 0
 2699 03d0 8091 0000 		lds r24,receivedChar
 2700 03d4 8535      		cpi r24,lo8(85)
 2701 03d6 01F4      		brne .L121
 390:main.c        **** 					audio_flash_write_byte(address, receivedBuffer[x]);
 2702               		.loc 3 390 0
 2703 03d8 F301      		movw r30,r6
 2704 03da 6081      		ld r22,Z
 2705 03dc C401      		movw r24,r8
 2706 03de 860D      		add r24,r6
 2707 03e0 971D      		adc r25,r7
 2708 03e2 00D0      		rcall audio_flash_write_byte
 2709               	.LVL266:
 2710 03e4 00C0      		rjmp .L122
 2711               	.L121:
 391:main.c        **** 				}
 392:main.c        **** 				else if (receivedChar == GB_BV5_FLASH_WRITE) { // Pulse WR pin
 2712               		.loc 3 392 0
 2713 03e6 8533      		cpi r24,lo8(53)
 2714 03e8 01F4      		brne .L122
 393:main.c        **** 					bv5_flash_write_byte(address, receivedBuffer[x]);
 2715               		.loc 3 393 0
 2716 03ea F301      		movw r30,r6
 2717 03ec 6081      		ld r22,Z
 2718 03ee C401      		movw r24,r8
 2719 03f0 860D      		add r24,r6
 2720 03f2 971D      		adc r25,r7
 2721 03f4 00D0      		rcall bv5_flash_write_byte
 2722               	.LVL267:
 2723               	.L122:
 2724 03f6 FFEF      		ldi r31,-1
 2725 03f8 6F1A      		sub r6,r31
 2726 03fa 7F0A      		sbc r7,r31
 2727               	.LVL268:
 388:main.c        **** 				if (receivedChar == GB_AUDIO_FLASH_WRITE) { // Pulse audio pin
 2728               		.loc 3 388 0 discriminator 2
 2729 03fc 2A81      		ldd r18,Y+2
 2730 03fe 2611      		cpse r18,r6
 2731 0400 00C0      		rjmp .L123
 2732 0402 80E4      		ldi r24,64
 2733 0404 C80E      		add r12,r24
 2734 0406 D11C      		adc r13,__zero_reg__
 2735 0408 E11C      		adc r14,__zero_reg__
 2736 040a F11C      		adc r15,__zero_reg__
 2737               	.LBE96:
 394:main.c        **** 				}
 395:main.c        **** 				
 396:main.c        **** 				address++;
 397:main.c        **** 			}
 398:main.c        **** 			USART_Transmit('1'); // Send back acknowledgement
 2738               		.loc 3 398 0
 2739 040c 81E3      		ldi r24,lo8(49)
 2740 040e 00C0      		rjmp .L177
 2741               	.LVL269:
 2742               	.L120:
 399:main.c        **** 			
 400:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 401:main.c        **** 		}
 402:main.c        **** 		
 403:main.c        **** 		
 404:main.c        **** 		/*else if (receivedChar == GB_AUDIO_FLASH_WRITE) {
 405:main.c        **** 			usart_read_bytes(64);
 406:main.c        **** 			
 407:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 408:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 409:main.c        **** 				audio_flash_write_byte(address, receivedBuffer[x]);
 410:main.c        **** 				address++;
 411:main.c        **** 			}
 412:main.c        **** 			USART_Transmit('1'); // Send back acknowledgement
 413:main.c        **** 			
 414:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 415:main.c        **** 		}*/
 416:main.c        **** 		
 417:main.c        **** 		
 418:main.c        **** 		
 419:main.c        **** 		// Write address and byte
 420:main.c        **** 		/*else if (receivedChar == GB_BV5_FLASH_WRITE_BYTE) {
 421:main.c        **** 			usart_read_chars(); // Read address
 422:main.c        **** 			uint16_t flashAddress = strtol(receivedBuffer, NULL, 16); // Convert address string in hex to de
 423:main.c        **** 			
 424:main.c        **** 			receivedChar = USART_Receive(); // Wait for byte
 425:main.c        **** 			if (receivedChar == GB_FLASH_WRITE_BYTE) {
 426:main.c        **** 				usart_read_chars(); // Read data
 427:main.c        **** 				uint8_t flashByte = strtol(receivedBuffer, NULL, 16); // Convert data byte in hex to dec
 428:main.c        **** 				
 429:main.c        **** 				PORTD |= (1<<ACTIVITY_LED);
 430:main.c        **** 				test_flash_write_bus_cycle(flashAddress, flashByte);
 431:main.c        **** 				PORTD &= ~(1<<ACTIVITY_LED);
 432:main.c        **** 				
 433:main.c        **** 				USART_Transmit('1'); // Send back acknowledgement
 434:main.c        **** 			}
 435:main.c        **** 		}
 436:main.c        **** 		*/
 437:main.c        **** 		
 438:main.c        **** 		
 439:main.c        **** 		// ---------- General commands ----------
 440:main.c        **** 		// Set any pin as input/output
 441:main.c        **** 		// Reads the DDR/PORT (e.g. DDRB/PORTB is 'B') and the hex value that represents pins to set to a
 442:main.c        **** 		else if (receivedChar == SET_INPUT || receivedChar == SET_OUTPUT) {
 2743               		.loc 3 442 0
 2744 0410 9934      		cpi r25,lo8(73)
 2745 0412 01F0      		breq .L124
 2746               		.loc 3 442 0 is_stmt 0 discriminator 1
 2747 0414 9F34      		cpi r25,lo8(79)
 2748 0416 01F0      		breq .+2
 2749 0418 00C0      		rjmp .L125
 2750               	.L124:
 2751               	.LBB97:
 443:main.c        **** 			char portChar = USART_Receive();
 2752               		.loc 3 443 0 is_stmt 1
 2753 041a 00D0      		rcall USART_Receive
 2754               	.LVL270:
 444:main.c        **** 			usart_read_chars();
 2755               		.loc 3 444 0
 2756 041c 8B83      		std Y+3,r24
 2757 041e 00D0      		rcall usart_read_chars
 2758               	.LVL271:
 445:main.c        **** 			uint8_t setValue = strtol(receivedBuffer, NULL, 16);
 2759               		.loc 3 445 0
 2760 0420 40E1      		ldi r20,lo8(16)
 2761 0422 50E0      		ldi r21,0
 2762 0424 60E0      		ldi r22,0
 2763 0426 70E0      		ldi r23,0
 2764 0428 80E0      		ldi r24,lo8(receivedBuffer)
 2765 042a 90E0      		ldi r25,hi8(receivedBuffer)
 2766 042c 00D0      		rcall strtol
 2767               	.LVL272:
 446:main.c        **** 			
 447:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 2768               		.loc 3 447 0
 2769 042e 939A      		sbi 0x12,3
 448:main.c        **** 			if (receivedChar == SET_INPUT) {
 2770               		.loc 3 448 0
 2771 0430 8091 0000 		lds r24,receivedChar
 2772 0434 2B81      		ldd r18,Y+3
 2773 0436 8934      		cpi r24,lo8(73)
 2774 0438 01F4      		brne .L126
 449:main.c        **** 				if (portChar == 'A') {
 2775               		.loc 3 449 0
 2776 043a 2134      		cpi r18,lo8(65)
 2777 043c 01F4      		brne .L127
 450:main.c        **** 					DDRA &= ~(setValue);
 2778               		.loc 3 450 0
 2779 043e 8AB3      		in r24,0x1a
 2780 0440 6095      		com r22
 2781               	.LVL273:
 2782 0442 6823      		and r22,r24
 2783               	.LVL274:
 2784 0444 00C0      		rjmp .L187
 2785               	.LVL275:
 2786               	.L127:
 451:main.c        **** 				}
 452:main.c        **** 				else if (portChar == 'B') {
 2787               		.loc 3 452 0
 2788 0446 2234      		cpi r18,lo8(66)
 2789 0448 01F4      		brne .L129
 453:main.c        **** 					DDRB &= ~(setValue);
 2790               		.loc 3 453 0
 2791 044a 87B3      		in r24,0x17
 2792 044c 6095      		com r22
 2793               	.LVL276:
 2794 044e 6823      		and r22,r24
 2795               	.LVL277:
 2796 0450 00C0      		rjmp .L188
 2797               	.LVL278:
 2798               	.L129:
 454:main.c        **** 				}
 455:main.c        **** 				else if (portChar == 'C') {
 2799               		.loc 3 455 0
 2800 0452 2334      		cpi r18,lo8(67)
 2801 0454 01F4      		brne .L130
 456:main.c        **** 					DDRC &= ~(setValue);
 2802               		.loc 3 456 0
 2803 0456 84B3      		in r24,0x14
 2804 0458 6095      		com r22
 2805               	.LVL279:
 2806 045a 6823      		and r22,r24
 2807               	.LVL280:
 2808 045c 00C0      		rjmp .L193
 2809               	.LVL281:
 2810               	.L130:
 457:main.c        **** 				}
 458:main.c        **** 				else if (portChar == 'D') {
 2811               		.loc 3 458 0
 2812 045e 2434      		cpi r18,lo8(68)
 2813 0460 01F4      		brne .L131
 459:main.c        **** 					DDRD &= ~(setValue);
 2814               		.loc 3 459 0
 2815 0462 81B3      		in r24,0x11
 2816 0464 6095      		com r22
 2817               	.LVL282:
 2818 0466 6823      		and r22,r24
 2819               	.LVL283:
 2820 0468 00C0      		rjmp .L194
 2821               	.LVL284:
 2822               	.L131:
 460:main.c        **** 				}
 461:main.c        **** 				else if (portChar == 'E') {
 2823               		.loc 3 461 0
 2824 046a 2534      		cpi r18,lo8(69)
 2825 046c 01F0      		breq .+2
 2826 046e 00C0      		rjmp .L150
 462:main.c        **** 					DDRE &= ~(setValue);
 2827               		.loc 3 462 0
 2828 0470 86B1      		in r24,0x6
 2829 0472 6095      		com r22
 2830               	.LVL285:
 2831 0474 6823      		and r22,r24
 2832               	.LVL286:
 2833 0476 00C0      		rjmp .L195
 2834               	.LVL287:
 2835               	.L126:
 463:main.c        **** 				}
 464:main.c        **** 			}
 465:main.c        **** 			else if (receivedChar == SET_OUTPUT) {
 2836               		.loc 3 465 0
 2837 0478 8F34      		cpi r24,lo8(79)
 2838 047a 01F0      		breq .+2
 2839 047c 00C0      		rjmp .L150
 466:main.c        **** 				if (portChar == 'A') {
 2840               		.loc 3 466 0
 2841 047e 2134      		cpi r18,lo8(65)
 2842 0480 01F4      		brne .L132
 467:main.c        **** 					DDRA |= (setValue);
 2843               		.loc 3 467 0
 2844 0482 8AB3      		in r24,0x1a
 2845 0484 682B      		or r22,r24
 2846               	.LVL288:
 2847               	.L187:
 2848 0486 6ABB      		out 0x1a,r22
 2849 0488 00C0      		rjmp .L150
 2850               	.LVL289:
 2851               	.L132:
 468:main.c        **** 				}
 469:main.c        **** 				else if (portChar == 'B') {
 2852               		.loc 3 469 0
 2853 048a 2234      		cpi r18,lo8(66)
 2854 048c 01F4      		brne .L133
 470:main.c        **** 					DDRB |= (setValue);
 2855               		.loc 3 470 0
 2856 048e 87B3      		in r24,0x17
 2857 0490 682B      		or r22,r24
 2858               	.LVL290:
 2859               	.L188:
 2860 0492 67BB      		out 0x17,r22
 2861 0494 00C0      		rjmp .L150
 2862               	.LVL291:
 2863               	.L133:
 471:main.c        **** 				}
 472:main.c        **** 				else if (portChar == 'C') {
 2864               		.loc 3 472 0
 2865 0496 2334      		cpi r18,lo8(67)
 2866 0498 01F4      		brne .L134
 473:main.c        **** 					DDRC |= (setValue);
 2867               		.loc 3 473 0
 2868 049a 84B3      		in r24,0x14
 2869 049c 682B      		or r22,r24
 2870               	.LVL292:
 2871               	.L193:
 2872 049e 64BB      		out 0x14,r22
 2873 04a0 00C0      		rjmp .L150
 2874               	.LVL293:
 2875               	.L134:
 474:main.c        **** 				}
 475:main.c        **** 				else if (portChar == 'D') {
 2876               		.loc 3 475 0
 2877 04a2 2434      		cpi r18,lo8(68)
 2878 04a4 01F4      		brne .L135
 476:main.c        **** 					DDRD |= (setValue);
 2879               		.loc 3 476 0
 2880 04a6 81B3      		in r24,0x11
 2881 04a8 682B      		or r22,r24
 2882               	.LVL294:
 2883               	.L194:
 2884 04aa 61BB      		out 0x11,r22
 2885 04ac 00C0      		rjmp .L150
 2886               	.LVL295:
 2887               	.L135:
 477:main.c        **** 				}
 478:main.c        **** 				else if (portChar == 'E') {
 2888               		.loc 3 478 0
 2889 04ae 2534      		cpi r18,lo8(69)
 2890 04b0 01F0      		breq .+2
 2891 04b2 00C0      		rjmp .L150
 479:main.c        **** 					DDRE |= (setValue);
 2892               		.loc 3 479 0
 2893 04b4 86B1      		in r24,0x6
 2894 04b6 682B      		or r22,r24
 2895               	.LVL296:
 2896               	.L195:
 2897 04b8 66B9      		out 0x6,r22
 2898 04ba 00C0      		rjmp .L150
 2899               	.LVL297:
 2900               	.L125:
 2901               	.LBE97:
 480:main.c        **** 				}
 481:main.c        **** 			}
 482:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 483:main.c        **** 		}
 484:main.c        **** 		
 485:main.c        **** 		// Set pin output as low
 486:main.c        **** 		else if (receivedChar == SET_OUTPUT_LOW) {
 2902               		.loc 3 486 0
 2903 04bc 9C34      		cpi r25,lo8(76)
 2904 04be 01F4      		brne .L136
 2905               	.LBB98:
 487:main.c        **** 			char portChar = USART_Receive();			
 2906               		.loc 3 487 0
 2907 04c0 00D0      		rcall USART_Receive
 2908               	.LVL298:
 488:main.c        **** 			usart_read_chars();
 2909               		.loc 3 488 0
 2910 04c2 8B83      		std Y+3,r24
 2911 04c4 00D0      		rcall usart_read_chars
 2912               	.LVL299:
 489:main.c        **** 			uint8_t setValue = strtol(receivedBuffer, NULL, 16);
 2913               		.loc 3 489 0
 2914 04c6 40E1      		ldi r20,lo8(16)
 2915 04c8 50E0      		ldi r21,0
 2916 04ca 60E0      		ldi r22,0
 2917 04cc 70E0      		ldi r23,0
 2918 04ce 80E0      		ldi r24,lo8(receivedBuffer)
 2919 04d0 90E0      		ldi r25,hi8(receivedBuffer)
 2920 04d2 00D0      		rcall strtol
 2921               	.LVL300:
 490:main.c        **** 			
 491:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 2922               		.loc 3 491 0
 2923 04d4 939A      		sbi 0x12,3
 492:main.c        **** 			if (portChar == 'A') {
 2924               		.loc 3 492 0
 2925 04d6 2B81      		ldd r18,Y+3
 2926 04d8 2134      		cpi r18,lo8(65)
 2927 04da 01F4      		brne .L137
 493:main.c        **** 				PORTA &= ~(setValue);
 2928               		.loc 3 493 0
 2929 04dc 8BB3      		in r24,0x1b
 2930 04de 6095      		com r22
 2931               	.LVL301:
 2932 04e0 6823      		and r22,r24
 2933               	.LVL302:
 2934 04e2 00C0      		rjmp .L192
 2935               	.LVL303:
 2936               	.L137:
 494:main.c        **** 			}
 495:main.c        **** 			else if (portChar == 'B') {
 2937               		.loc 3 495 0
 2938 04e4 2234      		cpi r18,lo8(66)
 2939 04e6 01F4      		brne .L139
 496:main.c        **** 				PORTB &= ~(setValue);
 2940               		.loc 3 496 0
 2941 04e8 88B3      		in r24,0x18
 2942 04ea 6095      		com r22
 2943               	.LVL304:
 2944 04ec 6823      		and r22,r24
 2945               	.LVL305:
 2946 04ee 00C0      		rjmp .L191
 2947               	.LVL306:
 2948               	.L139:
 497:main.c        **** 			}
 498:main.c        **** 			else if (portChar == 'C') {
 2949               		.loc 3 498 0
 2950 04f0 2334      		cpi r18,lo8(67)
 2951 04f2 01F4      		brne .L140
 499:main.c        **** 				PORTC &= ~(setValue);
 2952               		.loc 3 499 0
 2953 04f4 85B3      		in r24,0x15
 2954 04f6 6095      		com r22
 2955               	.LVL307:
 2956 04f8 6823      		and r22,r24
 2957               	.LVL308:
 2958 04fa 00C0      		rjmp .L190
 2959               	.LVL309:
 2960               	.L140:
 500:main.c        **** 			}
 501:main.c        **** 			else if (portChar == 'D') {
 2961               		.loc 3 501 0
 2962 04fc 2434      		cpi r18,lo8(68)
 2963 04fe 01F4      		brne .L141
 502:main.c        **** 				PORTD &= ~(setValue);
 2964               		.loc 3 502 0
 2965 0500 82B3      		in r24,0x12
 2966 0502 6095      		com r22
 2967               	.LVL310:
 2968 0504 6823      		and r22,r24
 2969               	.LVL311:
 2970 0506 00C0      		rjmp .L189
 2971               	.LVL312:
 2972               	.L141:
 503:main.c        **** 			}
 504:main.c        **** 			else if (portChar == 'E') {
 2973               		.loc 3 504 0
 2974 0508 2534      		cpi r18,lo8(69)
 2975 050a 01F0      		breq .+2
 2976 050c 00C0      		rjmp .L150
 505:main.c        **** 				PORTE &= ~(setValue);
 2977               		.loc 3 505 0
 2978 050e 87B1      		in r24,0x7
 2979 0510 6095      		com r22
 2980               	.LVL313:
 2981 0512 6823      		and r22,r24
 2982               	.LVL314:
 2983 0514 00C0      		rjmp .L186
 2984               	.LVL315:
 2985               	.L136:
 2986               	.LBE98:
 506:main.c        **** 			}
 507:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 508:main.c        **** 		}
 509:main.c        **** 		
 510:main.c        **** 		// Set pin output as high
 511:main.c        **** 		else if (receivedChar == SET_OUTPUT_HIGH) {
 2987               		.loc 3 511 0
 2988 0516 9834      		cpi r25,lo8(72)
 2989 0518 01F4      		brne .L142
 2990               	.LBB99:
 512:main.c        **** 			char portChar = USART_Receive();			
 2991               		.loc 3 512 0
 2992 051a 00D0      		rcall USART_Receive
 2993               	.LVL316:
 513:main.c        **** 			usart_read_chars();
 2994               		.loc 3 513 0
 2995 051c 8B83      		std Y+3,r24
 2996 051e 00D0      		rcall usart_read_chars
 2997               	.LVL317:
 514:main.c        **** 			uint8_t setValue = strtol(receivedBuffer, NULL, 16);
 2998               		.loc 3 514 0
 2999 0520 40E1      		ldi r20,lo8(16)
 3000 0522 50E0      		ldi r21,0
 3001 0524 60E0      		ldi r22,0
 3002 0526 70E0      		ldi r23,0
 3003 0528 80E0      		ldi r24,lo8(receivedBuffer)
 3004 052a 90E0      		ldi r25,hi8(receivedBuffer)
 3005 052c 00D0      		rcall strtol
 3006               	.LVL318:
 515:main.c        **** 			
 516:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 3007               		.loc 3 516 0
 3008 052e 939A      		sbi 0x12,3
 517:main.c        **** 			if (portChar == 'A') {
 3009               		.loc 3 517 0
 3010 0530 2B81      		ldd r18,Y+3
 3011 0532 2134      		cpi r18,lo8(65)
 3012 0534 01F4      		brne .L143
 518:main.c        **** 				PORTA |= (setValue);
 3013               		.loc 3 518 0
 3014 0536 8BB3      		in r24,0x1b
 3015 0538 682B      		or r22,r24
 3016               	.LVL319:
 3017               	.L192:
 3018 053a 6BBB      		out 0x1b,r22
 3019 053c 00C0      		rjmp .L150
 3020               	.LVL320:
 3021               	.L143:
 519:main.c        **** 			}
 520:main.c        **** 			else if (portChar == 'B') {
 3022               		.loc 3 520 0
 3023 053e 2234      		cpi r18,lo8(66)
 3024 0540 01F4      		brne .L145
 521:main.c        **** 				PORTB |= (setValue);
 3025               		.loc 3 521 0
 3026 0542 88B3      		in r24,0x18
 3027 0544 682B      		or r22,r24
 3028               	.LVL321:
 3029               	.L191:
 3030 0546 68BB      		out 0x18,r22
 3031 0548 00C0      		rjmp .L150
 3032               	.LVL322:
 3033               	.L145:
 522:main.c        **** 			}
 523:main.c        **** 			else if (portChar == 'C') {
 3034               		.loc 3 523 0
 3035 054a 2334      		cpi r18,lo8(67)
 3036 054c 01F4      		brne .L146
 524:main.c        **** 				PORTC |= (setValue);
 3037               		.loc 3 524 0
 3038 054e 85B3      		in r24,0x15
 3039 0550 682B      		or r22,r24
 3040               	.LVL323:
 3041               	.L190:
 3042 0552 65BB      		out 0x15,r22
 3043 0554 00C0      		rjmp .L150
 3044               	.LVL324:
 3045               	.L146:
 525:main.c        **** 			}
 526:main.c        **** 			else if (portChar == 'D') {
 3046               		.loc 3 526 0
 3047 0556 2434      		cpi r18,lo8(68)
 3048 0558 01F4      		brne .L147
 527:main.c        **** 				PORTD |= (setValue);
 3049               		.loc 3 527 0
 3050 055a 82B3      		in r24,0x12
 3051 055c 682B      		or r22,r24
 3052               	.LVL325:
 3053               	.L189:
 3054 055e 62BB      		out 0x12,r22
 3055 0560 00C0      		rjmp .L150
 3056               	.LVL326:
 3057               	.L147:
 528:main.c        **** 			}
 529:main.c        **** 			else if (portChar == 'E') {
 3058               		.loc 3 529 0
 3059 0562 2534      		cpi r18,lo8(69)
 3060 0564 01F4      		brne .L150
 530:main.c        **** 				PORTE |= (setValue);
 3061               		.loc 3 530 0
 3062 0566 87B1      		in r24,0x7
 3063 0568 682B      		or r22,r24
 3064               	.LVL327:
 3065               	.L186:
 3066 056a 67B9      		out 0x7,r22
 3067 056c 00C0      		rjmp .L150
 3068               	.LVL328:
 3069               	.L142:
 3070               	.LBE99:
 531:main.c        **** 			}
 532:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 533:main.c        **** 		}
 534:main.c        **** 		
 535:main.c        **** 		// Read all pins of a PORT and return the value
 536:main.c        **** 		else if (receivedChar == READ_INPUT) {
 3071               		.loc 3 536 0
 3072 056e 9434      		cpi r25,lo8(68)
 3073 0570 01F4      		brne .L148
 3074               	.LBB100:
 537:main.c        **** 			char portChar = USART_Receive();			
 3075               		.loc 3 537 0
 3076 0572 00D0      		rcall USART_Receive
 3077               	.LVL329:
 538:main.c        **** 			
 539:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 3078               		.loc 3 539 0
 3079 0574 939A      		sbi 0x12,3
 540:main.c        **** 			if (portChar == 'A') {
 3080               		.loc 3 540 0
 3081 0576 8134      		cpi r24,lo8(65)
 3082 0578 01F4      		brne .L149
 541:main.c        **** 				USART_Transmit(PINA);
 3083               		.loc 3 541 0
 3084 057a 89B3      		in r24,0x19
 3085               	.LVL330:
 3086 057c 00C0      		rjmp .L177
 3087               	.LVL331:
 3088               	.L149:
 542:main.c        **** 			}
 543:main.c        **** 			else if (portChar == 'B') {
 3089               		.loc 3 543 0
 3090 057e 8234      		cpi r24,lo8(66)
 3091 0580 01F4      		brne .L151
 544:main.c        **** 				USART_Transmit(PINB);
 3092               		.loc 3 544 0
 3093 0582 86B3      		in r24,0x16
 3094               	.LVL332:
 3095 0584 00C0      		rjmp .L177
 3096               	.LVL333:
 3097               	.L151:
 545:main.c        **** 			}
 546:main.c        **** 			else if (portChar == 'C') {
 3098               		.loc 3 546 0
 3099 0586 8334      		cpi r24,lo8(67)
 3100 0588 01F4      		brne .L152
 547:main.c        **** 				USART_Transmit(PINC);
 3101               		.loc 3 547 0
 3102 058a 83B3      		in r24,0x13
 3103               	.LVL334:
 3104 058c 00C0      		rjmp .L177
 3105               	.LVL335:
 3106               	.L152:
 548:main.c        **** 			}
 549:main.c        **** 			else if (portChar == 'D') {
 3107               		.loc 3 549 0
 3108 058e 8434      		cpi r24,lo8(68)
 3109 0590 01F4      		brne .L153
 550:main.c        **** 				USART_Transmit(PIND);
 3110               		.loc 3 550 0
 3111 0592 80B3      		in r24,0x10
 3112               	.LVL336:
 3113 0594 00C0      		rjmp .L177
 3114               	.LVL337:
 3115               	.L153:
 551:main.c        **** 			}
 552:main.c        **** 			else if (portChar == 'E') {
 3116               		.loc 3 552 0
 3117 0596 8534      		cpi r24,lo8(69)
 3118 0598 01F4      		brne .L150
 553:main.c        **** 				USART_Transmit(PINE);
 3119               		.loc 3 553 0
 3120 059a 85B1      		in r24,0x5
 3121               	.LVL338:
 3122               	.L177:
 3123 059c 00D0      		rcall USART_Transmit
 3124               	.LVL339:
 3125               	.L150:
 554:main.c        **** 			}
 555:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 3126               		.loc 3 555 0
 3127 059e 9398      		cbi 0x12,3
 3128               	.LBE100:
 3129 05a0 00C0      		rjmp .L76
 3130               	.LVL340:
 3131               	.L148:
 556:main.c        **** 		}
 557:main.c        **** 		
 558:main.c        **** 		// Set the reset common lines variable on or off, useful if you are controlling all the pins dire
 559:main.c        **** 		else if (receivedChar == RESET_COMMON_LINES) {
 3132               		.loc 3 559 0
 3133 05a2 9D34      		cpi r25,lo8(77)
 3134 05a4 01F4      		brne .L154
 3135               	.LBB101:
 560:main.c        **** 			char commonChar = USART_Receive();
 3136               		.loc 3 560 0
 3137 05a6 00D0      		rcall USART_Receive
 3138               	.LVL341:
 561:main.c        **** 			if (commonChar == '1') {
 3139               		.loc 3 561 0
 3140 05a8 8133      		cpi r24,lo8(49)
 3141 05aa 01F4      		brne .L196
 562:main.c        **** 				resetCommonLines = 1;
 3142               		.loc 3 562 0
 3143 05ac 21E0      		ldi r18,lo8(1)
 3144 05ae 2983      		std Y+1,r18
 3145 05b0 00C0      		rjmp .L173
 3146               	.L196:
 563:main.c        **** 			}
 564:main.c        **** 			else if (commonChar == '0') {
 3147               		.loc 3 564 0
 3148 05b2 8033      		cpi r24,lo8(48)
 3149 05b4 01F0      		breq .+2
 3150 05b6 00C0      		rjmp .L76
 565:main.c        **** 				resetCommonLines = 0;
 3151               		.loc 3 565 0
 3152 05b8 1982      		std Y+1,__zero_reg__
 3153 05ba 00C0      		rjmp .L77
 3154               	.LVL342:
 3155               	.L154:
 3156               	.LBE101:
 566:main.c        **** 			}
 567:main.c        **** 		}
 568:main.c        **** 		
 569:main.c        **** 		// Send back the PCB version number
 570:main.c        **** 		else if (receivedChar == READ_PCB_VERSION) {
 3157               		.loc 3 570 0
 3158 05bc 9836      		cpi r25,lo8(104)
 3159 05be 01F4      		brne .L155
 571:main.c        **** 			USART_Transmit(PCB_VERSION);
 3160               		.loc 3 571 0
 3161 05c0 82E0      		ldi r24,lo8(2)
 3162               	.LVL343:
 3163 05c2 00C0      		rjmp .L174
 3164               	.LVL344:
 3165               	.L155:
 572:main.c        **** 		}
 573:main.c        **** 		
 574:main.c        **** 		// Send back the firmware version number
 575:main.c        **** 		else if (receivedChar == READ_FIRMWARE_VERSION) {
 3166               		.loc 3 575 0
 3167 05c4 9635      		cpi r25,lo8(86)
 3168 05c6 01F4      		brne .L156
 576:main.c        **** 			USART_Transmit(FIRMWARE_VERSION);
 3169               		.loc 3 576 0
 3170 05c8 84E0      		ldi r24,lo8(4)
 3171               	.LVL345:
 3172               	.L174:
 3173 05ca 00D0      		rcall USART_Transmit
 3174               	.LVL346:
 3175 05cc 00C0      		rjmp .L76
 3176               	.LVL347:
 3177               	.L156:
 577:main.c        **** 		}
 578:main.c        **** 		
 579:main.c        **** 		// Reset the AVR if it matches the number
 580:main.c        **** 		else if (receivedChar == RESET_AVR) {
 3178               		.loc 3 580 0
 3179 05ce 9A32      		cpi r25,lo8(42)
 3180 05d0 01F0      		breq .+2
 3181 05d2 00C0      		rjmp .L76
 3182               	.LBB102:
 581:main.c        **** 			usart_read_chars();
 3183               		.loc 3 581 0
 3184 05d4 00D0      		rcall usart_read_chars
 3185               	.LVL348:
 582:main.c        **** 			uint32_t resetValue = strtol(receivedBuffer, NULL, 16);
 3186               		.loc 3 582 0
 3187 05d6 40E1      		ldi r20,lo8(16)
 3188 05d8 50E0      		ldi r21,0
 3189 05da 60E0      		ldi r22,0
 3190 05dc 70E0      		ldi r23,0
 3191 05de 80E0      		ldi r24,lo8(receivedBuffer)
 3192 05e0 90E0      		ldi r25,hi8(receivedBuffer)
 3193 05e2 00D0      		rcall strtol
 3194               	.LVL349:
 583:main.c        **** 			if (resetValue == RESET_VALUE) {
 3195               		.loc 3 583 0
 3196 05e4 613E      		cpi r22,-31
 3197 05e6 754E      		sbci r23,-27
 3198 05e8 8740      		sbci r24,7
 3199 05ea 9105      		cpc r25,__zero_reg__
 3200 05ec 01F0      		breq .+2
 3201 05ee 00C0      		rjmp .L76
 584:main.c        **** 				// Clear watchdog flag
 585:main.c        **** 				MCUCSR &= ~(1<<WDRF);
 3202               		.loc 3 585 0
 3203 05f0 84B7      		in r24,0x34
 3204 05f2 877F      		andi r24,lo8(-9)
 3205 05f4 84BF      		out 0x34,r24
 586:main.c        **** 				
 587:main.c        **** 				// Start timed sequence
 588:main.c        **** 				WDTCR = (1<<WDCE) | (1<<WDE);
 3206               		.loc 3 588 0
 3207 05f6 88E1      		ldi r24,lo8(24)
 3208 05f8 81BD      		out 0x21,r24
 589:main.c        **** 				
 590:main.c        **** 				// Reset in 250 ms
 591:main.c        **** 				WDTCR = (1<<WDP2) | (1<<WDE);
 3209               		.loc 3 591 0
 3210 05fa 8CE0      		ldi r24,lo8(12)
 3211 05fc 81BD      		out 0x21,r24
 3212               	.LVL350:
 3213               	.LBB77:
 3214               	.LBB76:
 3215               		.loc 4 105 0
 3216 05fe C501      		movw r24,r10
 3217               	/* #APP */
 3218               	 ;  105 "c:\winavr-20100110\avr\include\util\delay_basic.h" 1
 3219 0600 0197      		1: sbiw r24,1
 3220 0602 01F4      		brne 1b
 3221               	 ;  0 "" 2
 3222               	.LVL351:
 3223               	/* #NOAPP */
 3224 0604 00C0      		rjmp .L76
 3225               	.LBE76:
 3226               	.LBE77:
 3227               	.LBE102:
 3228               		.cfi_endproc
 3229               	.LFE41:
 3231               		.comm	flashChipIdBuffer,2,1
 3232               		.comm	eepromBuffer,8,1
 3233               		.comm	receivedChar,1,1
 3234               		.comm	receivedBuffer,129,1
 3235               		.text
 3236               	.Letext0:
 3237               		.file 5 "c:\\winavr-20100110\\avr\\include\\stdint.h"
 3238               		.file 6 "c:\\winavr-20100110\\avr\\include\\stdlib.h"
DEFINED SYMBOLS
                            *ABS*:00000000 main.c
C:\Users\Alex\AppData\Local\Temp\cc9DSVA3.s:2      *ABS*:0000003e __SP_H__
C:\Users\Alex\AppData\Local\Temp\cc9DSVA3.s:3      *ABS*:0000003d __SP_L__
C:\Users\Alex\AppData\Local\Temp\cc9DSVA3.s:4      *ABS*:0000003f __SREG__
C:\Users\Alex\AppData\Local\Temp\cc9DSVA3.s:5      *ABS*:00000000 __tmp_reg__
C:\Users\Alex\AppData\Local\Temp\cc9DSVA3.s:6      *ABS*:00000001 __zero_reg__
C:\Users\Alex\AppData\Local\Temp\cc9DSVA3.s:12     .text:00000000 USART_Receive
C:\Users\Alex\AppData\Local\Temp\cc9DSVA3.s:34     .text:00000008 USART_Transmit
C:\Users\Alex\AppData\Local\Temp\cc9DSVA3.s:55     .text:00000010 usart_read_bytes
                            *COM*:00000081 receivedBuffer
C:\Users\Alex\AppData\Local\Temp\cc9DSVA3.s:124    .text:00000040 usart_read_chars
C:\Users\Alex\AppData\Local\Temp\cc9DSVA3.s:168    .text:0000005c rd_wr_csmreq_cs2_reset
C:\Users\Alex\AppData\Local\Temp\cc9DSVA3.s:190    .text:00000066 gb_mode
C:\Users\Alex\AppData\Local\Temp\cc9DSVA3.s:217    .text:00000076 set_16bit_address
C:\Users\Alex\AppData\Local\Temp\cc9DSVA3.s:236    .text:0000007c read_8bit_data
C:\Users\Alex\AppData\Local\Temp\cc9DSVA3.s:276    .text:0000008e write_8bit_data
C:\Users\Alex\AppData\Local\Temp\cc9DSVA3.s:350    .text:000000c8 gba_mode
C:\Users\Alex\AppData\Local\Temp\cc9DSVA3.s:377    .text:000000d8 gba_set_24bit_address
C:\Users\Alex\AppData\Local\Temp\cc9DSVA3.s:430    .text:00000104 gba_read_16bit_data
C:\Users\Alex\AppData\Local\Temp\cc9DSVA3.s:478    .text:00000122 gba_read_ram_8bit_data
C:\Users\Alex\AppData\Local\Temp\cc9DSVA3.s:518    .text:00000134 gba_write_ram_8bit_data
C:\Users\Alex\AppData\Local\Temp\cc9DSVA3.s:585    .text:00000162 gba_eeprom_mode
C:\Users\Alex\AppData\Local\Temp\cc9DSVA3.s:613    .text:00000174 gba_eeprom_set_address
C:\Users\Alex\AppData\Local\Temp\cc9DSVA3.s:752    .text:000001dc gba_eeprom_read
                            *COM*:00000008 eepromBuffer
C:\Users\Alex\AppData\Local\Temp\cc9DSVA3.s:884    .text:00000236 gba_eeprom_write
C:\Users\Alex\AppData\Local\Temp\cc9DSVA3.s:1000   .text:0000028a flash_write_bus_cycle
C:\Users\Alex\AppData\Local\Temp\cc9DSVA3.s:1059   .text:000002b2 flash_read_chip_id
                            *COM*:00000002 flashChipIdBuffer
C:\Users\Alex\AppData\Local\Temp\cc9DSVA3.s:1162   .text:0000031c flash_switch_bank
C:\Users\Alex\AppData\Local\Temp\cc9DSVA3.s:1211   .text:00000342 flash_erase_4k_sector
C:\Users\Alex\AppData\Local\Temp\cc9DSVA3.s:1285   .text:0000038a flash_write_byte
C:\Users\Alex\AppData\Local\Temp\cc9DSVA3.s:1355   .text:000003c2 flash_write_sector
C:\Users\Alex\AppData\Local\Temp\cc9DSVA3.s:1467   .text:0000042e audio_flash_write_bus_cycle
C:\Users\Alex\AppData\Local\Temp\cc9DSVA3.s:1530   .text:00000456 audio_flash_write_byte
C:\Users\Alex\AppData\Local\Temp\cc9DSVA3.s:1600   .text:0000048e bv5_flash_write_bus_cycle
C:\Users\Alex\AppData\Local\Temp\cc9DSVA3.s:1663   .text:000004b6 bv5_flash_write_byte
C:\Users\Alex\AppData\Local\Temp\cc9DSVA3.s:1733   .text:000004ee setup
C:\Users\Alex\AppData\Local\Temp\cc9DSVA3.s:1827   .text.startup:00000000 main
                            *COM*:00000001 receivedChar

UNDEFINED SYMBOLS
strtol
atoi
__do_clear_bss
