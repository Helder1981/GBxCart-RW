   1               		.file	"main.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               	.global	USART_Receive
  12               	USART_Receive:
  13               	.LFB12:
  14               		.file 1 "setup.c"
   1:setup.c       **** /*
   2:setup.c       ****  GBxCart RW
   3:setup.c       ****  PCB version: 1.1
   4:setup.c       ****  Firmware version: R6
   5:setup.c       ****  Author: Alex from insideGadgets (www.insidegadgets.com)
   6:setup.c       ****  Created: 7/11/2016
   7:setup.c       ****  Last Modified: 26/12/2017
   8:setup.c       ****  
   9:setup.c       ****  */
  10:setup.c       ****  
  11:setup.c       **** #ifndef cbi
  12:setup.c       **** #define cbi(sfr, bit) (_SFR_BYTE(sfr) &= ~_BV(bit))
  13:setup.c       **** #endif
  14:setup.c       **** #ifndef sbi
  15:setup.c       **** #define sbi(sfr, bit) (_SFR_BYTE(sfr) |= _BV(bit))
  16:setup.c       **** #endif
  17:setup.c       **** 
  18:setup.c       **** #ifndef NULL
  19:setup.c       **** #define NULL ((void *)0)
  20:setup.c       **** #endif
  21:setup.c       **** 
  22:setup.c       **** #define LOW 0
  23:setup.c       **** #define HIGH 1
  24:setup.c       **** #define false 0
  25:setup.c       **** #define true 1
  26:setup.c       **** 
  27:setup.c       **** #define SWITCH_DETECT PD2
  28:setup.c       **** #define ACTIVITY_LED PD3
  29:setup.c       **** #define LED_5V PD7
  30:setup.c       **** #define LED_3V PE0
  31:setup.c       **** 
  32:setup.c       **** #define WR_PIN PD6
  33:setup.c       **** #define RD_PIN PD5
  34:setup.c       **** #define CS_MREQ_PIN PD4
  35:setup.c       **** #define CS2_PIN PE2
  36:setup.c       **** #define AUDIO_PIN PE1
  37:setup.c       **** 
  38:setup.c       **** #define wrPin_high	PORTD |= (1<<WR_PIN);
  39:setup.c       **** #define wrPin_low		PORTD &= ~(1<<WR_PIN);
  40:setup.c       **** #define rdPin_high	PORTD |= (1<<RD_PIN);
  41:setup.c       **** #define rdPin_low		PORTD &= ~(1<<RD_PIN);
  42:setup.c       **** #define cs_mreqPin_high		PORTD |= (1<<CS_MREQ_PIN);
  43:setup.c       **** #define cs_mreqPin_low		PORTD &= ~(1<<CS_MREQ_PIN);
  44:setup.c       **** #define cs2Pin_high		PORTE |= (1<<CS2_PIN);
  45:setup.c       **** #define cs2Pin_low		PORTE &= ~(1<<CS2_PIN);
  46:setup.c       **** #define audioPin_high		PORTE |= (1<<AUDIO_PIN);
  47:setup.c       **** #define audioPin_low		PORTE &= ~(1<<AUDIO_PIN);
  48:setup.c       **** 
  49:setup.c       **** #define GB_MODE 1
  50:setup.c       **** #define GBA_MODE 2
  51:setup.c       **** 
  52:setup.c       **** // GB/GBC
  53:setup.c       **** #define PORT_ADDR7_0 PORTB
  54:setup.c       **** #define PORT_ADDR15_8 PORTA
  55:setup.c       **** #define PORT_DATA7_0 PORTC
  56:setup.c       **** 
  57:setup.c       **** #define DDR_ADDR7_0 DDRB
  58:setup.c       **** #define DDR_ADDR15_8 DDRA
  59:setup.c       **** #define DDR_DATA7_0 DDRC
  60:setup.c       **** 
  61:setup.c       **** #define PIN_ADDR7_0 PINB
  62:setup.c       **** #define PIN_ADDR15_8 PINA
  63:setup.c       **** #define PIN_DATA7_0 PINC
  64:setup.c       **** 
  65:setup.c       **** #define BANK_WRITE 0
  66:setup.c       **** #define MEMORY_WRITE 1
  67:setup.c       **** 
  68:setup.c       **** // GBA
  69:setup.c       **** #define EEPROM_WRITE 1
  70:setup.c       **** #define EEPROM_READ 0
  71:setup.c       **** 
  72:setup.c       **** #define EEPROM_NONE 0
  73:setup.c       **** #define EEPROM_4KBIT 1
  74:setup.c       **** #define EEPROM_64KBIT 2
  75:setup.c       **** 
  76:setup.c       **** #define AD0 PB0
  77:setup.c       **** #define ad0Pin_high		PORTB |= (1<<AD0);
  78:setup.c       **** #define ad0Pin_low		PORTB &= ~(1<<AD0);
  79:setup.c       **** 
  80:setup.c       **** #define A23 PC7
  81:setup.c       **** #define a23Pin_high		PORTC |= (1<<A23);
  82:setup.c       **** #define a23Pin_low		PORTC &= ~(1<<A23);
  83:setup.c       **** 
  84:setup.c       **** #define GBA_DDR_ROM_ADDR7_0 DDRB
  85:setup.c       **** #define GBA_DDR_ROM_ADDR15_8 DDRA
  86:setup.c       **** #define GBA_DDR_ROM_ADDR23_16 DDRC
  87:setup.c       **** #define GBA_DDR_ROM_DATA7_0 DDRB
  88:setup.c       **** #define GBA_DDR_ROM_DATA15_8 DDRA
  89:setup.c       **** #define GBA_DDR_RAM_DATA7_0 DDRC
  90:setup.c       **** #define GBA_DDR_EEPROM_DATA7_0 DDRB
  91:setup.c       **** 
  92:setup.c       **** #define GBA_PORT_ROM_ADDR7_0 PORTB
  93:setup.c       **** #define GBA_PORT_ROM_ADDR15_8 PORTA
  94:setup.c       **** #define GBA_PORT_ROM_ADDR23_16 PORTC
  95:setup.c       **** #define GBA_PORT_ROM_DATA7_0 PORTB
  96:setup.c       **** #define GBA_PORT_ROM_DATA15_8 PORTA
  97:setup.c       **** #define GBA_PORT_RAM_DATA7_0 PORTC
  98:setup.c       **** #define GBA_PORT_EEPROM_DATA7_0 PORTB
  99:setup.c       **** 
 100:setup.c       **** #define GBA_PIN_ROM_DATA7_0 PINB
 101:setup.c       **** #define GBA_PIN_ROM_DATA15_8 PINA
 102:setup.c       **** #define GBA_PIN_RAM_DATA7_0 PINC
 103:setup.c       **** #define GBA_PIN_EEPROM_DATA7_0 PINB
 104:setup.c       **** 
 105:setup.c       **** // GB/GBC commands
 106:setup.c       **** #define SET_START_ADDRESS 'A'
 107:setup.c       **** #define READ_ROM_RAM 'R'
 108:setup.c       **** #define WRITE_RAM 'W'
 109:setup.c       **** #define SET_BANK 'B'
 110:setup.c       **** #define GB_CART_MODE 'G'
 111:setup.c       **** 
 112:setup.c       **** // GBA commands
 113:setup.c       **** #define GBA_READ_ROM 'r'
 114:setup.c       **** #define GBA_READ_SRAM 'm'
 115:setup.c       **** #define GBA_WRITE_SRAM 'w'
 116:setup.c       **** #define GBA_WRITE_ONE_BYTE_SRAM 'o'
 117:setup.c       **** #define GBA_CART_MODE 'g'
 118:setup.c       **** 
 119:setup.c       **** #define GBA_FLASH_READ_ID 'i'
 120:setup.c       **** #define GBA_FLASH_SET_BANK 'k'
 121:setup.c       **** #define GBA_FLASH_4K_SECTOR_ERASE 's'
 122:setup.c       **** #define GBA_FLASH_WRITE_BYTE 'b'
 123:setup.c       **** #define GBA_FLASH_WRITE_ATMEL 'a'
 124:setup.c       **** 
 125:setup.c       **** #define GBA_SET_EEPROM_SIZE 'S'
 126:setup.c       **** #define GBA_READ_EEPROM 'e'
 127:setup.c       **** #define GBA_WRITE_EEPROM 'p'
 128:setup.c       **** 
 129:setup.c       **** // Flash Cart commands
 130:setup.c       **** #define GB_FLASH_WRITE_BYTE 'F'
 131:setup.c       **** #define GB_FLASH_WRITE_64BYTE 'T'
 132:setup.c       **** #define GB_AUDIO_FLASH_WRITE 'U'
 133:setup.c       **** #define GB_BV5_FLASH_WRITE '5'
 134:setup.c       **** 
 135:setup.c       **** #define GBA_FLASH_CART_WRITE_BYTE 'n'
 136:setup.c       **** #define GBA_FLASH_WRITE_64BYTE 'q'
 137:setup.c       **** 
 138:setup.c       **** // General commands
 139:setup.c       **** #define CART_MODE 'C'
 140:setup.c       **** #define SET_INPUT 'I'
 141:setup.c       **** #define SET_OUTPUT 'O'
 142:setup.c       **** #define SET_OUTPUT_LOW 'L'
 143:setup.c       **** #define SET_OUTPUT_HIGH 'H'
 144:setup.c       **** #define READ_INPUT 'D'
 145:setup.c       **** #define RESET_COMMON_LINES 'M'
 146:setup.c       **** #define READ_FIRMWARE_VERSION 'V'
 147:setup.c       **** #define READ_PCB_VERSION 'h'
 148:setup.c       **** 
 149:setup.c       **** #define RESET_AVR '*'
 150:setup.c       **** #define RESET_VALUE 0x7E5E1
 151:setup.c       **** 
 152:setup.c       **** 
 153:setup.c       **** char receivedBuffer[129];
 154:setup.c       **** char receivedChar;
 155:setup.c       **** uint8_t eepromBuffer[8];
 156:setup.c       **** uint8_t flashChipIdBuffer[2];
 157:setup.c       **** 
 158:setup.c       **** // Receive USART data
 159:setup.c       **** uint8_t USART_Receive(void) {
  15               		.loc 1 159 0
  16               		.cfi_startproc
  17               	/* prologue: function */
  18               	/* frame size = 0 */
  19               	/* stack size = 0 */
  20               	.L__stack_usage = 0
  21               	.L2:
 160:setup.c       **** 	while ( !(UCSRA & (1<<RXC)) ); // Wait for data to be received
  22               		.loc 1 160 0 discriminator 1
  23 0000 5F9B      		sbis 0xb,7
  24 0002 00C0      		rjmp .L2
 161:setup.c       **** 	return UDR; // Get and return received data from buffer
  25               		.loc 1 161 0
  26 0004 8CB1      		in r24,0xc
 162:setup.c       **** }
  27               		.loc 1 162 0
  28 0006 0895      		ret
  29               		.cfi_endproc
  30               	.LFE12:
  32               	.global	USART_Transmit
  34               	USART_Transmit:
  35               	.LFB13:
 163:setup.c       **** 
 164:setup.c       **** // Transmit USART data
 165:setup.c       **** void USART_Transmit(unsigned char data) {
  36               		.loc 1 165 0
  37               		.cfi_startproc
  38               	/* prologue: function */
  39               	/* frame size = 0 */
  40               	/* stack size = 0 */
  41               	.L__stack_usage = 0
  42               	.LVL0:
  43               	.L6:
 166:setup.c       **** 	while ( !( UCSRA & (1<<UDRE)) ); // Wait for empty transmit buffer
  44               		.loc 1 166 0 discriminator 1
  45 0008 5D9B      		sbis 0xb,5
  46 000a 00C0      		rjmp .L6
 167:setup.c       **** 	UDR = data;
  47               		.loc 1 167 0
  48 000c 8CB9      		out 0xc,r24
  49 000e 0895      		ret
  50               		.cfi_endproc
  51               	.LFE13:
  53               	.global	usart_read_bytes
  55               	usart_read_bytes:
  56               	.LFB14:
 168:setup.c       **** }
 169:setup.c       **** 
 170:setup.c       **** // Read 1-128 bytes from the USART 
 171:setup.c       **** void usart_read_bytes(uint8_t count) {
  57               		.loc 1 171 0
  58               		.cfi_startproc
  59               	.LVL1:
  60 0010 0F93      		push r16
  61               	.LCFI0:
  62               		.cfi_def_cfa_offset 3
  63               		.cfi_offset 16, -2
  64 0012 1F93      		push r17
  65               	.LCFI1:
  66               		.cfi_def_cfa_offset 4
  67               		.cfi_offset 17, -3
  68 0014 CF93      		push r28
  69               	.LCFI2:
  70               		.cfi_def_cfa_offset 5
  71               		.cfi_offset 28, -4
  72 0016 DF93      		push r29
  73               	.LCFI3:
  74               		.cfi_def_cfa_offset 6
  75               		.cfi_offset 29, -5
  76               	/* prologue: function */
  77               	/* frame size = 0 */
  78               	/* stack size = 4 */
  79               	.L__stack_usage = 4
  80 0018 D82F      		mov r29,r24
  81               	.LVL2:
  82 001a 00E0      		ldi r16,lo8(receivedBuffer)
  83 001c 10E0      		ldi r17,hi8(receivedBuffer)
  84               	.LBB58:
 172:setup.c       **** 	for (uint8_t x = 0; x < count; x++) {
  85               		.loc 1 172 0
  86 001e C0E0      		ldi r28,0
  87               	.LVL3:
  88               	.L10:
  89               		.loc 1 172 0 is_stmt 0 discriminator 1
  90 0020 CD17      		cp r28,r29
  91 0022 01F0      		breq .L12
 173:setup.c       **** 		receivedBuffer[x] = USART_Receive();
  92               		.loc 1 173 0 is_stmt 1 discriminator 3
  93 0024 00D0      		rcall USART_Receive
  94               	.LVL4:
  95 0026 F801      		movw r30,r16
  96 0028 8193      		st Z+,r24
  97 002a 8F01      		movw r16,r30
 172:setup.c       **** 	for (uint8_t x = 0; x < count; x++) {
  98               		.loc 1 172 0 discriminator 3
  99 002c CF5F      		subi r28,lo8(-(1))
 100               	.LVL5:
 101 002e 00C0      		rjmp .L10
 102               	.L12:
 103               	/* epilogue start */
 104               	.LBE58:
 174:setup.c       **** 	}
 175:setup.c       **** }
 105               		.loc 1 175 0
 106 0030 DF91      		pop r29
 107               	.LVL6:
 108 0032 CF91      		pop r28
 109               	.LVL7:
 110 0034 1F91      		pop r17
 111 0036 0F91      		pop r16
 112 0038 0895      		ret
 113               		.cfi_endproc
 114               	.LFE14:
 116               	.global	usart_read_chars
 118               	usart_read_chars:
 119               	.LFB15:
 176:setup.c       **** 
 177:setup.c       **** // Read the USART until a 0 (string terminator byte) is received
 178:setup.c       **** void usart_read_chars(void) {
 120               		.loc 1 178 0
 121               		.cfi_startproc
 122 003a CF93      		push r28
 123               	.LCFI4:
 124               		.cfi_def_cfa_offset 3
 125               		.cfi_offset 28, -2
 126               	/* prologue: function */
 127               	/* frame size = 0 */
 128               	/* stack size = 1 */
 129               	.L__stack_usage = 1
 130               	.LVL8:
 179:setup.c       **** 	uint8_t x = 0;
 131               		.loc 1 179 0
 132 003c C0E0      		ldi r28,0
 133               	.LVL9:
 134               	.L15:
 180:setup.c       **** 	while (1) {
 181:setup.c       **** 		receivedBuffer[x] = USART_Receive();
 135               		.loc 1 181 0
 136 003e 00D0      		rcall USART_Receive
 137               	.LVL10:
 138 0040 EC2F      		mov r30,r28
 139 0042 F0E0      		ldi r31,0
 140 0044 E050      		subi r30,lo8(-(receivedBuffer))
 141 0046 F040      		sbci r31,hi8(-(receivedBuffer))
 142 0048 8083      		st Z,r24
 182:setup.c       **** 		if (receivedBuffer[x] == 0) {
 143               		.loc 1 182 0
 144 004a 8823      		tst r24
 145 004c 01F0      		breq .L13
 183:setup.c       **** 			break;
 184:setup.c       **** 		}
 185:setup.c       **** 		x++;
 146               		.loc 1 185 0
 147 004e CF5F      		subi r28,lo8(-(1))
 148               	.LVL11:
 186:setup.c       **** 	}
 149               		.loc 1 186 0
 150 0050 00C0      		rjmp .L15
 151               	.L13:
 152               	/* epilogue start */
 187:setup.c       **** }
 153               		.loc 1 187 0
 154 0052 CF91      		pop r28
 155               	.LVL12:
 156 0054 0895      		ret
 157               		.cfi_endproc
 158               	.LFE15:
 160               	.global	rd_wr_csmreq_cs2_reset
 162               	rd_wr_csmreq_cs2_reset:
 163               	.LFB16:
 188:setup.c       **** 
 189:setup.c       **** // Turn RD, WR, CS/MREQ and CS2 to high so they are deselected (reset state)
 190:setup.c       **** void rd_wr_csmreq_cs2_reset(void) {
 164               		.loc 1 190 0
 165               		.cfi_startproc
 166               	/* prologue: function */
 167               	/* frame size = 0 */
 168               	/* stack size = 0 */
 169               	.L__stack_usage = 0
 191:setup.c       **** 	cs2Pin_high; // CS2 off
 170               		.loc 1 191 0
 171 0056 3A9A      		sbi 0x7,2
 192:setup.c       **** 	cs_mreqPin_high; // CS/MREQ off
 172               		.loc 1 192 0
 173 0058 949A      		sbi 0x12,4
 193:setup.c       **** 	rdPin_high; // RD off
 174               		.loc 1 193 0
 175 005a 959A      		sbi 0x12,5
 194:setup.c       **** 	wrPin_high; // WR off
 176               		.loc 1 194 0
 177 005c 969A      		sbi 0x12,6
 178 005e 0895      		ret
 179               		.cfi_endproc
 180               	.LFE16:
 182               	.global	gb_mode
 184               	gb_mode:
 185               	.LFB17:
 195:setup.c       **** }
 196:setup.c       **** 
 197:setup.c       **** 
 198:setup.c       **** 
 199:setup.c       **** // ****** Gameboy / Gameboy Colour functions ******
 200:setup.c       **** 
 201:setup.c       **** // Set Gameboy mode
 202:setup.c       **** void gb_mode(void) {
 186               		.loc 1 202 0
 187               		.cfi_startproc
 188               	/* prologue: function */
 189               	/* frame size = 0 */
 190               	/* stack size = 0 */
 191               	.L__stack_usage = 0
 203:setup.c       **** 	// Set inputs
 204:setup.c       **** 	PORT_DATA7_0 = 0;
 192               		.loc 1 204 0
 193 0060 15BA      		out 0x15,__zero_reg__
 205:setup.c       **** 	DDR_DATA7_0 = 0;
 194               		.loc 1 205 0
 195 0062 14BA      		out 0x14,__zero_reg__
 206:setup.c       **** 	
 207:setup.c       **** 	// Set outputs
 208:setup.c       **** 	PORT_ADDR7_0 = 0;
 196               		.loc 1 208 0
 197 0064 18BA      		out 0x18,__zero_reg__
 209:setup.c       **** 	PORT_ADDR15_8 = 0;
 198               		.loc 1 209 0
 199 0066 1BBA      		out 0x1b,__zero_reg__
 210:setup.c       **** 	DDR_ADDR7_0 = 0xFF;
 200               		.loc 1 210 0
 201 0068 8FEF      		ldi r24,lo8(-1)
 202 006a 87BB      		out 0x17,r24
 211:setup.c       **** 	DDR_ADDR15_8 = 0xFF;
 203               		.loc 1 211 0
 204 006c 8ABB      		out 0x1a,r24
 205 006e 0895      		ret
 206               		.cfi_endproc
 207               	.LFE17:
 209               	.global	set_16bit_address
 211               	set_16bit_address:
 212               	.LFB18:
 212:setup.c       **** }
 213:setup.c       **** 
 214:setup.c       **** // Set the 16 bit address on A15-0
 215:setup.c       **** void set_16bit_address(uint16_t address) {
 213               		.loc 1 215 0
 214               		.cfi_startproc
 215               	.LVL13:
 216               	/* prologue: function */
 217               	/* frame size = 0 */
 218               	/* stack size = 0 */
 219               	.L__stack_usage = 0
 216:setup.c       **** 	PORT_ADDR15_8 = (address >> 8);
 220               		.loc 1 216 0
 221 0070 9BBB      		out 0x1b,r25
 217:setup.c       **** 	PORT_ADDR7_0 = (address & 0xFF);
 222               		.loc 1 217 0
 223 0072 88BB      		out 0x18,r24
 224 0074 0895      		ret
 225               		.cfi_endproc
 226               	.LFE18:
 228               	.global	read_8bit_data
 230               	read_8bit_data:
 231               	.LFB19:
 218:setup.c       **** }
 219:setup.c       **** 
 220:setup.c       **** // Set the address and read a byte from the 8 bit data line
 221:setup.c       **** uint8_t read_8bit_data(uint16_t address) {
 232               		.loc 1 221 0
 233               		.cfi_startproc
 234               	.LVL14:
 235               	/* prologue: function */
 236               	/* frame size = 0 */
 237               	/* stack size = 0 */
 238               	.L__stack_usage = 0
 222:setup.c       **** 	set_16bit_address(address);
 239               		.loc 1 222 0
 240 0076 00D0      		rcall set_16bit_address
 241               	.LVL15:
 223:setup.c       **** 	
 224:setup.c       **** 	cs_mreqPin_low;
 242               		.loc 1 224 0
 243 0078 9498      		cbi 0x12,4
 225:setup.c       **** 	rdPin_low;
 244               		.loc 1 225 0
 245 007a 9598      		cbi 0x12,5
 226:setup.c       **** 	
 227:setup.c       **** 	asm volatile("nop"); // Delay a little (minimum needed is 1 nops, 2 nops for GB camera)
 246               		.loc 1 227 0
 247               	/* #APP */
 248               	 ;  227 "setup.c" 1
 249 007c 0000      		nop
 250               	 ;  0 "" 2
 228:setup.c       **** 	asm volatile("nop");
 251               		.loc 1 228 0
 252               	 ;  228 "setup.c" 1
 253 007e 0000      		nop
 254               	 ;  0 "" 2
 229:setup.c       **** 	uint8_t data = PIN_DATA7_0; // Read data
 255               		.loc 1 229 0
 256               	/* #NOAPP */
 257 0080 83B3      		in r24,0x13
 258               	.LVL16:
 230:setup.c       **** 	
 231:setup.c       **** 	rdPin_high;
 259               		.loc 1 231 0
 260 0082 959A      		sbi 0x12,5
 232:setup.c       **** 	cs_mreqPin_high;
 261               		.loc 1 232 0
 262 0084 949A      		sbi 0x12,4
 233:setup.c       **** 	
 234:setup.c       **** 	return data;
 235:setup.c       **** }
 263               		.loc 1 235 0
 264 0086 0895      		ret
 265               		.cfi_endproc
 266               	.LFE19:
 268               	.global	write_8bit_data
 270               	write_8bit_data:
 271               	.LFB20:
 236:setup.c       **** 
 237:setup.c       **** // Set the address and write a byte to the 8 bit data line and pulse cs/mREQ if writing to RAM
 238:setup.c       **** void write_8bit_data(uint16_t address, uint8_t data, uint8_t type) {
 272               		.loc 1 238 0
 273               		.cfi_startproc
 274               	.LVL17:
 275 0088 CF93      		push r28
 276               	.LCFI5:
 277               		.cfi_def_cfa_offset 3
 278               		.cfi_offset 28, -2
 279 008a DF93      		push r29
 280               	.LCFI6:
 281               		.cfi_def_cfa_offset 4
 282               		.cfi_offset 29, -3
 283               	/* prologue: function */
 284               	/* frame size = 0 */
 285               	/* stack size = 2 */
 286               	.L__stack_usage = 2
 287 008c D62F      		mov r29,r22
 288 008e C42F      		mov r28,r20
 239:setup.c       **** 	set_16bit_address(address);
 289               		.loc 1 239 0
 290 0090 00D0      		rcall set_16bit_address
 291               	.LVL18:
 240:setup.c       **** 	
 241:setup.c       **** 	DDR_DATA7_0 = 0xFF; // Set data pins as outputs
 292               		.loc 1 241 0
 293 0092 8FEF      		ldi r24,lo8(-1)
 294 0094 84BB      		out 0x14,r24
 242:setup.c       **** 	PORT_DATA7_0 = data; // Set data
 295               		.loc 1 242 0
 296 0096 D5BB      		out 0x15,r29
 243:setup.c       **** 	
 244:setup.c       **** 	// Pulse WR and mREQ if the type matches
 245:setup.c       **** 	wrPin_low;
 297               		.loc 1 245 0
 298 0098 9698      		cbi 0x12,6
 246:setup.c       **** 	if (type == MEMORY_WRITE) {
 299               		.loc 1 246 0
 300 009a C130      		cpi r28,lo8(1)
 301 009c 01F4      		brne .L21
 247:setup.c       **** 		cs_mreqPin_low;
 302               		.loc 1 247 0
 303 009e 9498      		cbi 0x12,4
 304               	.L21:
 248:setup.c       **** 	}
 249:setup.c       **** 	
 250:setup.c       **** 	asm volatile("nop");
 305               		.loc 1 250 0
 306               	/* #APP */
 307               	 ;  250 "setup.c" 1
 308 00a0 0000      		nop
 309               	 ;  0 "" 2
 251:setup.c       **** 	
 252:setup.c       **** 	if (type == MEMORY_WRITE) {
 310               		.loc 1 252 0
 311               	/* #NOAPP */
 312 00a2 C130      		cpi r28,lo8(1)
 313 00a4 01F4      		brne .L22
 253:setup.c       **** 		cs_mreqPin_high;
 314               		.loc 1 253 0
 315 00a6 949A      		sbi 0x12,4
 316               	.L22:
 254:setup.c       **** 	}
 255:setup.c       **** 	wrPin_high;
 317               		.loc 1 255 0
 318 00a8 969A      		sbi 0x12,6
 256:setup.c       **** 	
 257:setup.c       **** 	// Clear data outputs and set data pins as inputs
 258:setup.c       **** 	PORT_DATA7_0 = 0;
 319               		.loc 1 258 0
 320 00aa 15BA      		out 0x15,__zero_reg__
 259:setup.c       **** 	DDR_DATA7_0 = 0;
 321               		.loc 1 259 0
 322 00ac 14BA      		out 0x14,__zero_reg__
 323               	/* epilogue start */
 260:setup.c       **** }
 324               		.loc 1 260 0
 325 00ae DF91      		pop r29
 326               	.LVL19:
 327 00b0 CF91      		pop r28
 328               	.LVL20:
 329 00b2 0895      		ret
 330               		.cfi_endproc
 331               	.LFE20:
 333               	.global	gba_mode
 335               	gba_mode:
 336               	.LFB21:
 261:setup.c       **** 
 262:setup.c       **** 
 263:setup.c       **** 
 264:setup.c       **** // ****** Gameboy Advance functions ****** 
 265:setup.c       **** 
 266:setup.c       **** // Set GBA mode
 267:setup.c       **** void gba_mode(void) {
 337               		.loc 1 267 0
 338               		.cfi_startproc
 339               	/* prologue: function */
 340               	/* frame size = 0 */
 341               	/* stack size = 0 */
 342               	.L__stack_usage = 0
 268:setup.c       **** 	// Set outputs for reading ROM addresses as default
 269:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = 0;
 343               		.loc 1 269 0
 344 00b4 18BA      		out 0x18,__zero_reg__
 270:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = 0;
 345               		.loc 1 270 0
 346 00b6 1BBA      		out 0x1b,__zero_reg__
 271:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = 0;
 347               		.loc 1 271 0
 348 00b8 15BA      		out 0x15,__zero_reg__
 272:setup.c       **** 	GBA_DDR_ROM_ADDR7_0 = 0xFF;
 349               		.loc 1 272 0
 350 00ba 8FEF      		ldi r24,lo8(-1)
 351 00bc 87BB      		out 0x17,r24
 273:setup.c       **** 	GBA_DDR_ROM_ADDR15_8 = 0xFF;
 352               		.loc 1 273 0
 353 00be 8ABB      		out 0x1a,r24
 274:setup.c       **** 	GBA_DDR_ROM_ADDR23_16 = 0xFF;
 354               		.loc 1 274 0
 355 00c0 84BB      		out 0x14,r24
 356 00c2 0895      		ret
 357               		.cfi_endproc
 358               	.LFE21:
 360               	.global	gba_set_24bit_address
 362               	gba_set_24bit_address:
 363               	.LFB22:
 275:setup.c       **** }
 276:setup.c       **** 
 277:setup.c       **** // Set the 24 bit address on A23-0
 278:setup.c       **** void gba_set_24bit_address(uint32_t address) {	
 364               		.loc 1 278 0
 365               		.cfi_startproc
 366               	.LVL21:
 367 00c4 0F93      		push r16
 368               	.LCFI7:
 369               		.cfi_def_cfa_offset 3
 370               		.cfi_offset 16, -2
 371 00c6 1F93      		push r17
 372               	.LCFI8:
 373               		.cfi_def_cfa_offset 4
 374               		.cfi_offset 17, -3
 375               	/* prologue: function */
 376               	/* frame size = 0 */
 377               	/* stack size = 2 */
 378               	.L__stack_usage = 2
 279:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = 0; // Set 0-23 address lines low and set as outputs
 379               		.loc 1 279 0
 380 00c8 15BA      		out 0x15,__zero_reg__
 280:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = 0;
 381               		.loc 1 280 0
 382 00ca 1BBA      		out 0x1b,__zero_reg__
 281:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = 0;
 383               		.loc 1 281 0
 384 00cc 18BA      		out 0x18,__zero_reg__
 282:setup.c       **** 	GBA_DDR_ROM_ADDR23_16 = 0xFF;
 385               		.loc 1 282 0
 386 00ce 2FEF      		ldi r18,lo8(-1)
 387 00d0 24BB      		out 0x14,r18
 283:setup.c       **** 	GBA_DDR_ROM_ADDR15_8 = 0xFF;
 388               		.loc 1 283 0
 389 00d2 2ABB      		out 0x1a,r18
 284:setup.c       **** 	GBA_DDR_ROM_ADDR7_0 = 0xFF;
 390               		.loc 1 284 0
 391 00d4 27BB      		out 0x17,r18
 285:setup.c       **** 	
 286:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = (address >> 16);
 392               		.loc 1 286 0
 393 00d6 8C01      		movw r16,r24
 394 00d8 2227      		clr r18
 395 00da 3327      		clr r19
 396 00dc 05BB      		out 0x15,r16
 287:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = (address >> 8);
 397               		.loc 1 287 0
 398 00de 072F      		mov r16,r23
 399 00e0 182F      		mov r17,r24
 400 00e2 292F      		mov r18,r25
 401 00e4 3327      		clr r19
 402 00e6 0BBB      		out 0x1b,r16
 288:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = (address & 0xFF);
 403               		.loc 1 288 0
 404 00e8 68BB      		out 0x18,r22
 405               	/* epilogue start */
 289:setup.c       **** }
 406               		.loc 1 289 0
 407 00ea 1F91      		pop r17
 408 00ec 0F91      		pop r16
 409 00ee 0895      		ret
 410               		.cfi_endproc
 411               	.LFE22:
 413               	.global	gba_read_16bit_data
 415               	gba_read_16bit_data:
 416               	.LFB23:
 290:setup.c       **** 
 291:setup.c       **** 
 292:setup.c       **** 
 293:setup.c       **** // ---------- ROM/SRAM ----------
 294:setup.c       **** 
 295:setup.c       **** // Read a byte from the 16 bit data line non-sequentially
 296:setup.c       **** uint16_t gba_read_16bit_data(uint32_t address) {
 417               		.loc 1 296 0
 418               		.cfi_startproc
 419               	.LVL22:
 420               	/* prologue: function */
 421               	/* frame size = 0 */
 422               	/* stack size = 0 */
 423               	.L__stack_usage = 0
 297:setup.c       **** 	gba_set_24bit_address(address);
 424               		.loc 1 297 0
 425 00f0 00D0      		rcall gba_set_24bit_address
 426               	.LVL23:
 298:setup.c       **** 	
 299:setup.c       **** 	cs_mreqPin_low;
 427               		.loc 1 299 0
 428 00f2 9498      		cbi 0x12,4
 300:setup.c       **** 	
 301:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = 0; // Set address lines low and set as inputs
 429               		.loc 1 301 0
 430 00f4 1BBA      		out 0x1b,__zero_reg__
 302:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = 0;
 431               		.loc 1 302 0
 432 00f6 18BA      		out 0x18,__zero_reg__
 303:setup.c       **** 	GBA_DDR_ROM_ADDR15_8 = 0;
 433               		.loc 1 303 0
 434 00f8 1ABA      		out 0x1a,__zero_reg__
 304:setup.c       **** 	GBA_DDR_ROM_ADDR7_0 = 0;
 435               		.loc 1 304 0
 436 00fa 17BA      		out 0x17,__zero_reg__
 305:setup.c       **** 	
 306:setup.c       **** 	rdPin_low;
 437               		.loc 1 306 0
 438 00fc 9598      		cbi 0x12,5
 307:setup.c       **** 	asm volatile("nop");
 439               		.loc 1 307 0
 440               	/* #APP */
 441               	 ;  307 "setup.c" 1
 442 00fe 0000      		nop
 443               	 ;  0 "" 2
 308:setup.c       **** 	
 309:setup.c       **** 	uint16_t data = (GBA_PIN_ROM_DATA15_8 << 8) | GBA_PIN_ROM_DATA7_0; // Read data
 444               		.loc 1 309 0
 445               	/* #NOAPP */
 446 0100 29B3      		in r18,0x19
 447 0102 86B3      		in r24,0x16
 448               	.LVL24:
 310:setup.c       **** 	
 311:setup.c       **** 	rdPin_high;
 449               		.loc 1 311 0
 450 0104 959A      		sbi 0x12,5
 312:setup.c       **** 	cs_mreqPin_high;
 451               		.loc 1 312 0
 452 0106 949A      		sbi 0x12,4
 313:setup.c       **** 	
 314:setup.c       **** 	return data;
 453               		.loc 1 314 0
 454 0108 90E0      		ldi r25,0
 315:setup.c       **** }
 455               		.loc 1 315 0
 456 010a 922B      		or r25,r18
 457 010c 0895      		ret
 458               		.cfi_endproc
 459               	.LFE23:
 461               	.global	gba_read_ram_8bit_data
 463               	gba_read_ram_8bit_data:
 464               	.LFB24:
 316:setup.c       **** 
 317:setup.c       **** // Set the address and read a byte from the 8 bit data line
 318:setup.c       **** uint8_t gba_read_ram_8bit_data(uint16_t address) {
 465               		.loc 1 318 0
 466               		.cfi_startproc
 467               	.LVL25:
 468               	/* prologue: function */
 469               	/* frame size = 0 */
 470               	/* stack size = 0 */
 471               	.L__stack_usage = 0
 319:setup.c       **** 	set_16bit_address(address);
 472               		.loc 1 319 0
 473 010e 00D0      		rcall set_16bit_address
 474               	.LVL26:
 320:setup.c       **** 	
 321:setup.c       **** 	rdPin_low;
 475               		.loc 1 321 0
 476 0110 9598      		cbi 0x12,5
 322:setup.c       **** 	cs2Pin_low; // CS2 pin low for SRAM/Flash select
 477               		.loc 1 322 0
 478 0112 3A98      		cbi 0x7,2
 323:setup.c       **** 	
 324:setup.c       **** 	asm volatile("nop"); // Delay a little (minimum needed is 2)
 479               		.loc 1 324 0
 480               	/* #APP */
 481               	 ;  324 "setup.c" 1
 482 0114 0000      		nop
 483               	 ;  0 "" 2
 325:setup.c       **** 	asm volatile("nop");
 484               		.loc 1 325 0
 485               	 ;  325 "setup.c" 1
 486 0116 0000      		nop
 487               	 ;  0 "" 2
 326:setup.c       **** 	
 327:setup.c       **** 	uint8_t data = GBA_PIN_RAM_DATA7_0; // Read data
 488               		.loc 1 327 0
 489               	/* #NOAPP */
 490 0118 83B3      		in r24,0x13
 491               	.LVL27:
 328:setup.c       **** 	
 329:setup.c       **** 	cs2Pin_high;
 492               		.loc 1 329 0
 493 011a 3A9A      		sbi 0x7,2
 330:setup.c       **** 	rdPin_high;
 494               		.loc 1 330 0
 495 011c 959A      		sbi 0x12,5
 331:setup.c       **** 	
 332:setup.c       **** 	return data;
 333:setup.c       **** }
 496               		.loc 1 333 0
 497 011e 0895      		ret
 498               		.cfi_endproc
 499               	.LFE24:
 501               	.global	gba_write_ram_8bit_data
 503               	gba_write_ram_8bit_data:
 504               	.LFB25:
 334:setup.c       **** 
 335:setup.c       **** // Set the address and write a byte to the 8 bit data line 
 336:setup.c       **** void gba_write_ram_8bit_data(uint16_t address, uint8_t data) {
 505               		.loc 1 336 0
 506               		.cfi_startproc
 507               	.LVL28:
 508 0120 CF93      		push r28
 509               	.LCFI9:
 510               		.cfi_def_cfa_offset 3
 511               		.cfi_offset 28, -2
 512               	/* prologue: function */
 513               	/* frame size = 0 */
 514               	/* stack size = 1 */
 515               	.L__stack_usage = 1
 516 0122 C62F      		mov r28,r22
 337:setup.c       **** 	set_16bit_address(address);
 517               		.loc 1 337 0
 518 0124 00D0      		rcall set_16bit_address
 519               	.LVL29:
 338:setup.c       **** 	
 339:setup.c       **** 	GBA_DDR_RAM_DATA7_0 = 0xFF; // Set data pins as outputs
 520               		.loc 1 339 0
 521 0126 8FEF      		ldi r24,lo8(-1)
 522 0128 84BB      		out 0x14,r24
 340:setup.c       **** 	GBA_PORT_RAM_DATA7_0 = data; // Set data
 523               		.loc 1 340 0
 524 012a C5BB      		out 0x15,r28
 341:setup.c       **** 	
 342:setup.c       **** 	// Pulse WR
 343:setup.c       **** 	wrPin_low;
 525               		.loc 1 343 0
 526 012c 9698      		cbi 0x12,6
 344:setup.c       **** 	cs2Pin_low; // CS2 pin low for SRAM/Flash select
 527               		.loc 1 344 0
 528 012e 3A98      		cbi 0x7,2
 345:setup.c       **** 	
 346:setup.c       **** 	asm volatile("nop");
 529               		.loc 1 346 0
 530               	/* #APP */
 531               	 ;  346 "setup.c" 1
 532 0130 0000      		nop
 533               	 ;  0 "" 2
 347:setup.c       **** 	asm volatile("nop");
 534               		.loc 1 347 0
 535               	 ;  347 "setup.c" 1
 536 0132 0000      		nop
 537               	 ;  0 "" 2
 348:setup.c       **** 	
 349:setup.c       **** 	cs2Pin_high;
 538               		.loc 1 349 0
 539               	/* #NOAPP */
 540 0134 3A9A      		sbi 0x7,2
 350:setup.c       **** 	wrPin_high;
 541               		.loc 1 350 0
 542 0136 969A      		sbi 0x12,6
 351:setup.c       **** 	
 352:setup.c       **** 	// Clear data outputs and set data pins as inputs
 353:setup.c       **** 	GBA_PORT_RAM_DATA7_0 = 0;
 543               		.loc 1 353 0
 544 0138 15BA      		out 0x15,__zero_reg__
 354:setup.c       **** 	GBA_DDR_RAM_DATA7_0 = 0;
 545               		.loc 1 354 0
 546 013a 14BA      		out 0x14,__zero_reg__
 547               	/* epilogue start */
 355:setup.c       **** }
 548               		.loc 1 355 0
 549 013c CF91      		pop r28
 550               	.LVL30:
 551 013e 0895      		ret
 552               		.cfi_endproc
 553               	.LFE25:
 555               	.global	gba_eeprom_mode
 557               	gba_eeprom_mode:
 558               	.LFB26:
 356:setup.c       **** 
 357:setup.c       **** 
 358:setup.c       **** 
 359:setup.c       **** // ---------- EEPROM ----------
 360:setup.c       **** 
 361:setup.c       **** // Set address/data all high (includes AD0/A23)
 362:setup.c       **** void gba_eeprom_mode (void) {
 559               		.loc 1 362 0
 560               		.cfi_startproc
 561               	/* prologue: function */
 562               	/* frame size = 0 */
 563               	/* stack size = 0 */
 564               	.L__stack_usage = 0
 363:setup.c       **** 	GBA_DDR_ROM_ADDR7_0 = 0xFF;
 565               		.loc 1 363 0
 566 0140 8FEF      		ldi r24,lo8(-1)
 567 0142 87BB      		out 0x17,r24
 364:setup.c       **** 	GBA_DDR_ROM_ADDR15_8 = 0xFF;
 568               		.loc 1 364 0
 569 0144 8ABB      		out 0x1a,r24
 365:setup.c       **** 	GBA_DDR_ROM_ADDR23_16 = 0xFF;
 570               		.loc 1 365 0
 571 0146 84BB      		out 0x14,r24
 366:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = 0x80;
 572               		.loc 1 366 0
 573 0148 90E8      		ldi r25,lo8(-128)
 574 014a 98BB      		out 0x18,r25
 367:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = 0xFF;
 575               		.loc 1 367 0
 576 014c 8BBB      		out 0x1b,r24
 368:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = 0xFF;
 577               		.loc 1 368 0
 578 014e 85BB      		out 0x15,r24
 579 0150 0895      		ret
 580               		.cfi_endproc
 581               	.LFE26:
 583               	.global	gba_eeprom_set_address
 585               	gba_eeprom_set_address:
 586               	.LFB27:
 369:setup.c       **** }
 370:setup.c       **** 
 371:setup.c       **** // Send out EEPROM address serially (WR clock, AD0 data out)
 372:setup.c       **** void gba_eeprom_set_address(uint16_t address, uint8_t eepromSize, uint8_t command) {
 587               		.loc 1 372 0
 588               		.cfi_startproc
 589               	.LVL31:
 590               	/* prologue: function */
 591               	/* frame size = 0 */
 592               	/* stack size = 0 */
 593               	.L__stack_usage = 0
 373:setup.c       **** 	cs_mreqPin_low;
 594               		.loc 1 373 0
 595 0152 9498      		cbi 0x12,4
 596               	.LVL32:
 374:setup.c       **** 	
 375:setup.c       **** 	int8_t x = 0;
 376:setup.c       **** 	if (eepromSize == EEPROM_64KBIT) {
 597               		.loc 1 376 0
 598 0154 6230      		cpi r22,lo8(2)
 599 0156 01F4      		brne .L30
 377:setup.c       **** 		if (command == EEPROM_READ) {
 600               		.loc 1 377 0
 601 0158 4111      		cpse r20,__zero_reg__
 602 015a 00C0      		rjmp .L31
 378:setup.c       **** 			address |= (1<<15) | (1<<14); // Set upper 2 bits high for read request
 603               		.loc 1 378 0
 604 015c 906C      		ori r25,192
 605               	.LVL33:
 606               	.L40:
 379:setup.c       **** 		}
 380:setup.c       **** 		else {
 381:setup.c       **** 			address |= (1<<15); // Set upper 1 bit high for write request
 382:setup.c       **** 		}
 383:setup.c       **** 		x = 15;
 607               		.loc 1 383 0
 608 015e 2FE0      		ldi r18,lo8(15)
 609               	.L33:
 610               	.LVL34:
 384:setup.c       **** 	}
 385:setup.c       **** 	else {
 386:setup.c       **** 		if (command == EEPROM_READ) {
 387:setup.c       **** 			address |= (1<<7) | (1<<6);
 388:setup.c       **** 		}
 389:setup.c       **** 		else {
 390:setup.c       **** 			address |= (1<<7);
 391:setup.c       **** 		}
 392:setup.c       **** 		x = 7;
 393:setup.c       **** 	}
 394:setup.c       **** 	
 395:setup.c       **** 	// Loop through address, 8 or 16 bits depending on EEPROM (includes the 2 bits for request type)
 396:setup.c       **** 	while (x >= 0) {
 397:setup.c       **** 		if (address & (1<<x)) {
 611               		.loc 1 397 0
 612 0160 E1E0      		ldi r30,lo8(1)
 613 0162 F0E0      		ldi r31,0
 614 0164 00C0      		rjmp .L32
 615               	.LVL35:
 616               	.L31:
 381:setup.c       **** 		}
 617               		.loc 1 381 0
 618 0166 9068      		ori r25,128
 619               	.LVL36:
 620 0168 00C0      		rjmp .L40
 621               	.L30:
 386:setup.c       **** 			address |= (1<<7) | (1<<6);
 622               		.loc 1 386 0
 623 016a 4111      		cpse r20,__zero_reg__
 624 016c 00C0      		rjmp .L34
 387:setup.c       **** 		}
 625               		.loc 1 387 0
 626 016e 806C      		ori r24,192
 627               	.LVL37:
 628 0170 00C0      		rjmp .L39
 629               	.L34:
 390:setup.c       **** 		}
 630               		.loc 1 390 0
 631 0172 8068      		ori r24,128
 632               	.LVL38:
 633               	.L39:
 392:setup.c       **** 	}
 634               		.loc 1 392 0
 635 0174 27E0      		ldi r18,lo8(7)
 636 0176 00C0      		rjmp .L33
 637               	.LVL39:
 638               	.L35:
 398:setup.c       **** 			ad0Pin_high;
 399:setup.c       **** 		}
 400:setup.c       **** 		else {
 401:setup.c       **** 			ad0Pin_low;
 639               		.loc 1 401 0
 640 0178 C098      		cbi 0x18,0
 641               	.L36:
 402:setup.c       **** 		}
 403:setup.c       **** 		
 404:setup.c       **** 		wrPin_low; // CLK
 642               		.loc 1 404 0
 643 017a 9698      		cbi 0x12,6
 405:setup.c       **** 		asm ("nop");
 644               		.loc 1 405 0
 645               	/* #APP */
 646               	 ;  405 "setup.c" 1
 647 017c 0000      		nop
 648               	 ;  0 "" 2
 406:setup.c       **** 		asm ("nop");
 649               		.loc 1 406 0
 650               	 ;  406 "setup.c" 1
 651 017e 0000      		nop
 652               	 ;  0 "" 2
 407:setup.c       **** 		wrPin_high; 
 653               		.loc 1 407 0
 654               	/* #NOAPP */
 655 0180 969A      		sbi 0x12,6
 408:setup.c       **** 		asm ("nop");
 656               		.loc 1 408 0
 657               	/* #APP */
 658               	 ;  408 "setup.c" 1
 659 0182 0000      		nop
 660               	 ;  0 "" 2
 409:setup.c       **** 		asm ("nop");
 661               		.loc 1 409 0
 662               	 ;  409 "setup.c" 1
 663 0184 0000      		nop
 664               	 ;  0 "" 2
 665               	/* #NOAPP */
 666 0186 2150      		subi r18,lo8(-(-1))
 667               	.LVL40:
 396:setup.c       **** 		if (address & (1<<x)) {
 668               		.loc 1 396 0
 669 0188 27FD      		sbrc r18,7
 670 018a 00C0      		rjmp .L41
 671               	.L32:
 397:setup.c       **** 			ad0Pin_high;
 672               		.loc 1 397 0
 673 018c BF01      		movw r22,r30
 674 018e 022E      		mov r0,r18
 675 0190 00C0      		rjmp 2f
 676               		1:
 677 0192 660F      		lsl r22
 678 0194 771F      		rol r23
 679               		2:
 680 0196 0A94      		dec r0
 681 0198 02F4      		brpl 1b
 682 019a 6823      		and r22,r24
 683 019c 7923      		and r23,r25
 684 019e 672B      		or r22,r23
 685 01a0 01F0      		breq .L35
 398:setup.c       **** 		}
 686               		.loc 1 398 0
 687 01a2 C09A      		sbi 0x18,0
 688 01a4 00C0      		rjmp .L36
 689               	.L41:
 410:setup.c       **** 		
 411:setup.c       **** 		x--;
 412:setup.c       **** 	}
 413:setup.c       **** 	
 414:setup.c       **** 	// Only send stop bit (0) and WR/CS high if reading, as writing is done in 1 continuous chunk
 415:setup.c       **** 	if (command == EEPROM_READ) {  
 690               		.loc 1 415 0
 691 01a6 4111      		cpse r20,__zero_reg__
 692 01a8 00C0      		rjmp .L29
 416:setup.c       **** 		ad0Pin_low;
 693               		.loc 1 416 0
 694 01aa C098      		cbi 0x18,0
 417:setup.c       **** 		asm ("nop");
 695               		.loc 1 417 0
 696               	/* #APP */
 697               	 ;  417 "setup.c" 1
 698 01ac 0000      		nop
 699               	 ;  0 "" 2
 418:setup.c       **** 		wrPin_low;
 700               		.loc 1 418 0
 701               	/* #NOAPP */
 702 01ae 9698      		cbi 0x12,6
 419:setup.c       **** 		asm ("nop");
 703               		.loc 1 419 0
 704               	/* #APP */
 705               	 ;  419 "setup.c" 1
 706 01b0 0000      		nop
 707               	 ;  0 "" 2
 420:setup.c       **** 		asm ("nop");
 708               		.loc 1 420 0
 709               	 ;  420 "setup.c" 1
 710 01b2 0000      		nop
 711               	 ;  0 "" 2
 421:setup.c       **** 		
 422:setup.c       **** 		wrPin_high;
 712               		.loc 1 422 0
 713               	/* #NOAPP */
 714 01b4 969A      		sbi 0x12,6
 423:setup.c       **** 		cs_mreqPin_high;
 715               		.loc 1 423 0
 716 01b6 949A      		sbi 0x12,4
 717               	.L29:
 718 01b8 0895      		ret
 719               		.cfi_endproc
 720               	.LFE27:
 722               	.global	gba_eeprom_read
 724               	gba_eeprom_read:
 725               	.LFB28:
 424:setup.c       **** 	}
 425:setup.c       **** }
 426:setup.c       **** 
 427:setup.c       **** // Read 8 bytes from the EEPROM address, data is valid on rising edge
 428:setup.c       **** void gba_eeprom_read(uint16_t address, uint8_t eepromSize) {
 726               		.loc 1 428 0
 727               		.cfi_startproc
 728               	.LVL41:
 729               	/* prologue: function */
 730               	/* frame size = 0 */
 731               	/* stack size = 0 */
 732               	.L__stack_usage = 0
 429:setup.c       **** 	gba_eeprom_set_address(address, eepromSize, EEPROM_READ);
 733               		.loc 1 429 0
 734 01ba 40E0      		ldi r20,0
 735 01bc 00D0      		rcall gba_eeprom_set_address
 736               	.LVL42:
 430:setup.c       **** 	
 431:setup.c       **** 	// Set AD0 pin as input
 432:setup.c       **** 	GBA_PORT_EEPROM_DATA7_0 &= ~(1<<AD0);
 737               		.loc 1 432 0
 738 01be C098      		cbi 0x18,0
 433:setup.c       **** 	GBA_DDR_EEPROM_DATA7_0 &= ~(1<<AD0);
 739               		.loc 1 433 0
 740 01c0 B898      		cbi 0x17,0
 434:setup.c       **** 	
 435:setup.c       **** 	cs_mreqPin_low;
 741               		.loc 1 435 0
 742 01c2 9498      		cbi 0x12,4
 743               	.LVL43:
 744 01c4 84E0      		ldi r24,lo8(4)
 745               	.LVL44:
 746               	.L43:
 747               	.LBB59:
 436:setup.c       **** 	
 437:setup.c       **** 	// Ignore first 4 bits
 438:setup.c       **** 	for (int8_t x = 0; x < 4; x++) {
 439:setup.c       **** 		rdPin_low; // CLK
 748               		.loc 1 439 0 discriminator 3
 749 01c6 9598      		cbi 0x12,5
 440:setup.c       **** 		asm ("nop");
 750               		.loc 1 440 0 discriminator 3
 751               	/* #APP */
 752               	 ;  440 "setup.c" 1
 753 01c8 0000      		nop
 754               	 ;  0 "" 2
 441:setup.c       **** 		asm ("nop");
 755               		.loc 1 441 0 discriminator 3
 756               	 ;  441 "setup.c" 1
 757 01ca 0000      		nop
 758               	 ;  0 "" 2
 442:setup.c       **** 		rdPin_high; 
 759               		.loc 1 442 0 discriminator 3
 760               	/* #NOAPP */
 761 01cc 959A      		sbi 0x12,5
 443:setup.c       **** 		asm ("nop");
 762               		.loc 1 443 0 discriminator 3
 763               	/* #APP */
 764               	 ;  443 "setup.c" 1
 765 01ce 0000      		nop
 766               	 ;  0 "" 2
 444:setup.c       **** 		asm ("nop");
 767               		.loc 1 444 0 discriminator 3
 768               	 ;  444 "setup.c" 1
 769 01d0 0000      		nop
 770               	 ;  0 "" 2
 771               	.LVL45:
 772               	/* #NOAPP */
 773 01d2 8150      		subi r24,lo8(-(-1))
 774               	.LVL46:
 438:setup.c       **** 		rdPin_low; // CLK
 775               		.loc 1 438 0 discriminator 3
 776 01d4 01F4      		brne .L43
 777 01d6 E0E0      		ldi r30,lo8(eepromBuffer)
 778 01d8 F0E0      		ldi r31,hi8(eepromBuffer)
 779               	.LBE59:
 780               	.LBB60:
 781               	.LBB61:
 782               	.LBB62:
 445:setup.c       **** 	}
 446:setup.c       **** 	
 447:setup.c       **** 	// Read out 64 bits
 448:setup.c       **** 	for (uint8_t c = 0; c < 8; c++) {
 449:setup.c       **** 		uint8_t data = 0;
 450:setup.c       **** 		for (int8_t x = 7; x >= 0; x--) {
 451:setup.c       **** 			rdPin_low; // CLK
 452:setup.c       **** 			asm ("nop");
 453:setup.c       **** 			asm ("nop");
 454:setup.c       **** 			rdPin_high;
 455:setup.c       **** 			
 456:setup.c       **** 			if (GBA_PIN_EEPROM_DATA7_0 & (1<<AD0)) {
 457:setup.c       **** 				data |= (1<<x);
 783               		.loc 1 457 0
 784 01da 41E0      		ldi r20,lo8(1)
 785 01dc 50E0      		ldi r21,0
 786               	.LVL47:
 787               	.L44:
 788               	.LBE62:
 789               	.LBE61:
 790               	.LBE60:
 435:setup.c       **** 	
 791               		.loc 1 435 0
 792 01de 87E0      		ldi r24,lo8(7)
 793 01e0 90E0      		ldi r25,0
 794 01e2 20E0      		ldi r18,0
 795               	.LVL48:
 796               	.L46:
 797               	.LBB65:
 798               	.LBB64:
 799               	.LBB63:
 451:setup.c       **** 			asm ("nop");
 800               		.loc 1 451 0
 801 01e4 9598      		cbi 0x12,5
 452:setup.c       **** 			asm ("nop");
 802               		.loc 1 452 0
 803               	/* #APP */
 804               	 ;  452 "setup.c" 1
 805 01e6 0000      		nop
 806               	 ;  0 "" 2
 453:setup.c       **** 			rdPin_high;
 807               		.loc 1 453 0
 808               	 ;  453 "setup.c" 1
 809 01e8 0000      		nop
 810               	 ;  0 "" 2
 454:setup.c       **** 			
 811               		.loc 1 454 0
 812               	/* #NOAPP */
 813 01ea 959A      		sbi 0x12,5
 456:setup.c       **** 				data |= (1<<x);
 814               		.loc 1 456 0
 815 01ec B09B      		sbis 0x16,0
 816 01ee 00C0      		rjmp .L45
 817               		.loc 1 457 0
 818 01f0 BA01      		movw r22,r20
 819 01f2 082E      		mov r0,r24
 820 01f4 00C0      		rjmp 2f
 821               		1:
 822 01f6 660F      		lsl r22
 823               		2:
 824 01f8 0A94      		dec r0
 825 01fa 02F4      		brpl 1b
 826 01fc 262B      		or r18,r22
 827               	.LVL49:
 828               	.L45:
 829               	.LVL50:
 830 01fe 0197      		sbiw r24,1
 831 0200 00F4      		brcc .L46
 832               	.LBE63:
 458:setup.c       **** 			}
 459:setup.c       **** 		}
 460:setup.c       **** 		eepromBuffer[c] = data;
 833               		.loc 1 460 0 discriminator 2
 834 0202 2193      		st Z+,r18
 835               	.LVL51:
 836               	.LBE64:
 448:setup.c       **** 		uint8_t data = 0;
 837               		.loc 1 448 0 discriminator 2
 838 0204 80E0      		ldi r24,hi8(eepromBuffer+8)
 839 0206 E030      		cpi r30,lo8(eepromBuffer+8)
 840 0208 F807      		cpc r31,r24
 841               	.LVL52:
 842 020a 01F4      		brne .L44
 843               	.LBE65:
 461:setup.c       **** 	}
 462:setup.c       **** 	
 463:setup.c       **** 	cs_mreqPin_high;
 844               		.loc 1 463 0
 845 020c 949A      		sbi 0x12,4
 464:setup.c       **** 	
 465:setup.c       **** 	// Set AD0 pin as output
 466:setup.c       **** 	GBA_PORT_EEPROM_DATA7_0 |= (1<<AD0);
 846               		.loc 1 466 0
 847 020e C09A      		sbi 0x18,0
 467:setup.c       **** 	GBA_DDR_EEPROM_DATA7_0 |= (1<<AD0);
 848               		.loc 1 467 0
 849 0210 B89A      		sbi 0x17,0
 850 0212 0895      		ret
 851               		.cfi_endproc
 852               	.LFE28:
 854               	.global	gba_eeprom_write
 856               	gba_eeprom_write:
 857               	.LFB29:
 468:setup.c       **** }
 469:setup.c       **** 
 470:setup.c       **** // Write 8 bytes to the EEPROM address
 471:setup.c       **** void gba_eeprom_write(uint16_t address, uint8_t eepromSize) {
 858               		.loc 1 471 0
 859               		.cfi_startproc
 860               	.LVL53:
 861               	/* prologue: function */
 862               	/* frame size = 0 */
 863               	/* stack size = 0 */
 864               	.L__stack_usage = 0
 472:setup.c       **** 	gba_eeprom_set_address(address, eepromSize, EEPROM_WRITE);
 865               		.loc 1 472 0
 866 0214 41E0      		ldi r20,lo8(1)
 867 0216 00D0      		rcall gba_eeprom_set_address
 868               	.LVL54:
 869 0218 E0E0      		ldi r30,lo8(eepromBuffer)
 870 021a F0E0      		ldi r31,hi8(eepromBuffer)
 871 021c 48E0      		ldi r20,lo8(8)
 872               	.LVL55:
 873               	.L54:
 471:setup.c       **** 	gba_eeprom_set_address(address, eepromSize, EEPROM_WRITE);
 874               		.loc 1 471 0
 875 021e 27E0      		ldi r18,lo8(7)
 876 0220 30E0      		ldi r19,0
 877               	.LVL56:
 878               	.L57:
 879               	.LBB66:
 880               	.LBB67:
 473:setup.c       **** 	
 474:setup.c       **** 	// Write 64 bits
 475:setup.c       **** 	for (uint8_t c = 0; c < 8; c++) {
 476:setup.c       **** 		for (int8_t x = 7; x >= 0; x--) {
 477:setup.c       **** 			if (eepromBuffer[c] & (1<<x)) {
 881               		.loc 1 477 0
 882 0222 8081      		ld r24,Z
 883 0224 90E0      		ldi r25,0
 884 0226 022E      		mov r0,r18
 885 0228 00C0      		rjmp 2f
 886               		1:
 887 022a 9595      		asr r25
 888 022c 8795      		ror r24
 889               		2:
 890 022e 0A94      		dec r0
 891 0230 02F4      		brpl 1b
 892 0232 80FF      		sbrs r24,0
 893 0234 00C0      		rjmp .L55
 478:setup.c       **** 				ad0Pin_high;
 894               		.loc 1 478 0
 895 0236 C09A      		sbi 0x18,0
 896 0238 00C0      		rjmp .L56
 897               	.L55:
 479:setup.c       **** 			}
 480:setup.c       **** 			else {
 481:setup.c       **** 				ad0Pin_low;
 898               		.loc 1 481 0
 899 023a C098      		cbi 0x18,0
 900               	.L56:
 482:setup.c       **** 			}
 483:setup.c       **** 			
 484:setup.c       **** 			wrPin_low; // CLK
 901               		.loc 1 484 0 discriminator 2
 902 023c 9698      		cbi 0x12,6
 485:setup.c       **** 			asm ("nop");
 903               		.loc 1 485 0 discriminator 2
 904               	/* #APP */
 905               	 ;  485 "setup.c" 1
 906 023e 0000      		nop
 907               	 ;  0 "" 2
 486:setup.c       **** 			asm ("nop");
 908               		.loc 1 486 0 discriminator 2
 909               	 ;  486 "setup.c" 1
 910 0240 0000      		nop
 911               	 ;  0 "" 2
 487:setup.c       **** 			wrPin_high; 
 912               		.loc 1 487 0 discriminator 2
 913               	/* #NOAPP */
 914 0242 969A      		sbi 0x12,6
 488:setup.c       **** 			asm ("nop");
 915               		.loc 1 488 0 discriminator 2
 916               	/* #APP */
 917               	 ;  488 "setup.c" 1
 918 0244 0000      		nop
 919               	 ;  0 "" 2
 489:setup.c       **** 			asm ("nop");
 920               		.loc 1 489 0 discriminator 2
 921               	 ;  489 "setup.c" 1
 922 0246 0000      		nop
 923               	 ;  0 "" 2
 924               	.LVL57:
 925               	/* #NOAPP */
 926               	.LVL58:
 927 0248 2150      		subi r18,1
 928 024a 3109      		sbc r19,__zero_reg__
 929 024c 00F4      		brcc .L57
 930 024e 4150      		subi r20,lo8(-(-1))
 931 0250 3196      		adiw r30,1
 932               	.LVL59:
 933               	.LBE67:
 475:setup.c       **** 		for (int8_t x = 7; x >= 0; x--) {
 934               		.loc 1 475 0 discriminator 2
 935 0252 4111      		cpse r20,__zero_reg__
 936 0254 00C0      		rjmp .L54
 937               	.LBE66:
 490:setup.c       **** 		}
 491:setup.c       **** 	}
 492:setup.c       **** 	
 493:setup.c       **** 	// Last bit low
 494:setup.c       **** 	ad0Pin_low;
 938               		.loc 1 494 0
 939 0256 C098      		cbi 0x18,0
 495:setup.c       **** 	wrPin_low; // CLK
 940               		.loc 1 495 0
 941 0258 9698      		cbi 0x12,6
 496:setup.c       **** 	asm ("nop");
 942               		.loc 1 496 0
 943               	/* #APP */
 944               	 ;  496 "setup.c" 1
 945 025a 0000      		nop
 946               	 ;  0 "" 2
 497:setup.c       **** 	asm ("nop");
 947               		.loc 1 497 0
 948               	 ;  497 "setup.c" 1
 949 025c 0000      		nop
 950               	 ;  0 "" 2
 498:setup.c       **** 	wrPin_high; 
 951               		.loc 1 498 0
 952               	/* #NOAPP */
 953 025e 969A      		sbi 0x12,6
 499:setup.c       **** 	asm ("nop");
 954               		.loc 1 499 0
 955               	/* #APP */
 956               	 ;  499 "setup.c" 1
 957 0260 0000      		nop
 958               	 ;  0 "" 2
 500:setup.c       **** 	asm ("nop");
 959               		.loc 1 500 0
 960               	 ;  500 "setup.c" 1
 961 0262 0000      		nop
 962               	 ;  0 "" 2
 501:setup.c       **** 	
 502:setup.c       **** 	cs_mreqPin_high;
 963               		.loc 1 502 0
 964               	/* #NOAPP */
 965 0264 949A      		sbi 0x12,4
 966 0266 0895      		ret
 967               		.cfi_endproc
 968               	.LFE29:
 970               	.global	flash_write_bus_cycle
 972               	flash_write_bus_cycle:
 973               	.LFB30:
 503:setup.c       **** }
 504:setup.c       **** 
 505:setup.c       **** 
 506:setup.c       **** 
 507:setup.c       **** // ---------- FLASH ----------
 508:setup.c       **** 
 509:setup.c       **** // Set the address and data for the write byte cycle to the flash
 510:setup.c       **** void flash_write_bus_cycle(uint16_t address, uint8_t data) {
 974               		.loc 1 510 0
 975               		.cfi_startproc
 976               	.LVL60:
 977 0268 CF93      		push r28
 978               	.LCFI10:
 979               		.cfi_def_cfa_offset 3
 980               		.cfi_offset 28, -2
 981               	/* prologue: function */
 982               	/* frame size = 0 */
 983               	/* stack size = 1 */
 984               	.L__stack_usage = 1
 985 026a C62F      		mov r28,r22
 511:setup.c       **** 	GBA_DDR_RAM_DATA7_0 = 0xFF; // Set data pins as outputs
 986               		.loc 1 511 0
 987 026c 2FEF      		ldi r18,lo8(-1)
 988 026e 24BB      		out 0x14,r18
 512:setup.c       **** 	set_16bit_address(address);
 989               		.loc 1 512 0
 990 0270 00D0      		rcall set_16bit_address
 991               	.LVL61:
 513:setup.c       **** 	GBA_PORT_RAM_DATA7_0 = data;
 992               		.loc 1 513 0
 993 0272 C5BB      		out 0x15,r28
 514:setup.c       **** 	
 515:setup.c       **** 	wrPin_low;
 994               		.loc 1 515 0
 995 0274 9698      		cbi 0x12,6
 516:setup.c       **** 	cs2Pin_low;
 996               		.loc 1 516 0
 997 0276 3A98      		cbi 0x7,2
 517:setup.c       **** 	asm volatile("nop");
 998               		.loc 1 517 0
 999               	/* #APP */
 1000               	 ;  517 "setup.c" 1
 1001 0278 0000      		nop
 1002               	 ;  0 "" 2
 518:setup.c       **** 	wrPin_high;
 1003               		.loc 1 518 0
 1004               	/* #NOAPP */
 1005 027a 969A      		sbi 0x12,6
 519:setup.c       **** 	cs2Pin_high;
 1006               		.loc 1 519 0
 1007 027c 3A9A      		sbi 0x7,2
 1008               	/* epilogue start */
 520:setup.c       **** }
 1009               		.loc 1 520 0
 1010 027e CF91      		pop r28
 1011               	.LVL62:
 1012 0280 0895      		ret
 1013               		.cfi_endproc
 1014               	.LFE30:
 1016               	.global	flash_read_chip_id
 1018               	flash_read_chip_id:
 1019               	.LFB31:
 521:setup.c       **** 
 522:setup.c       **** // Read the flash manufacturer and device ID (Software ID)
 523:setup.c       **** void flash_read_chip_id(void) {
 1020               		.loc 1 523 0
 1021               		.cfi_startproc
 1022 0282 CF93      		push r28
 1023               	.LCFI11:
 1024               		.cfi_def_cfa_offset 3
 1025               		.cfi_offset 28, -2
 1026 0284 DF93      		push r29
 1027               	.LCFI12:
 1028               		.cfi_def_cfa_offset 4
 1029               		.cfi_offset 29, -3
 1030               	/* prologue: function */
 1031               	/* frame size = 0 */
 1032               	/* stack size = 2 */
 1033               	.L__stack_usage = 2
 524:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xAA);
 1034               		.loc 1 524 0
 1035 0286 6AEA      		ldi r22,lo8(-86)
 1036 0288 85E5      		ldi r24,lo8(85)
 1037 028a 95E5      		ldi r25,lo8(85)
 1038 028c 00D0      		rcall flash_write_bus_cycle
 1039               	.LVL63:
 525:setup.c       **** 	flash_write_bus_cycle(0x2AAA, 0x55);
 1040               		.loc 1 525 0
 1041 028e 65E5      		ldi r22,lo8(85)
 1042 0290 8AEA      		ldi r24,lo8(-86)
 1043 0292 9AE2      		ldi r25,lo8(42)
 1044 0294 00D0      		rcall flash_write_bus_cycle
 1045               	.LVL64:
 526:setup.c       **** 	flash_write_bus_cycle(0x5555, 0x90); // Software ID entry
 1046               		.loc 1 526 0
 1047 0296 60E9      		ldi r22,lo8(-112)
 1048 0298 85E5      		ldi r24,lo8(85)
 1049 029a 95E5      		ldi r25,lo8(85)
 1050 029c 00D0      		rcall flash_write_bus_cycle
 1051               	.LVL65:
 1052               	.LBB68:
 1053               	.LBB69:
 1054               		.file 2 "c:\\winavr-20100110\\avr\\include\\util\\delay.h"
   1:c:\winavr-20100110\avr\include\util\delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:c:\winavr-20100110\avr\include\util\delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:c:\winavr-20100110\avr\include\util\delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:c:\winavr-20100110\avr\include\util\delay.h ****    All rights reserved.
   5:c:\winavr-20100110\avr\include\util\delay.h **** 
   6:c:\winavr-20100110\avr\include\util\delay.h ****    Redistribution and use in source and binary forms, with or without
   7:c:\winavr-20100110\avr\include\util\delay.h ****    modification, are permitted provided that the following conditions are met:
   8:c:\winavr-20100110\avr\include\util\delay.h **** 
   9:c:\winavr-20100110\avr\include\util\delay.h ****    * Redistributions of source code must retain the above copyright
  10:c:\winavr-20100110\avr\include\util\delay.h ****      notice, this list of conditions and the following disclaimer.
  11:c:\winavr-20100110\avr\include\util\delay.h **** 
  12:c:\winavr-20100110\avr\include\util\delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:c:\winavr-20100110\avr\include\util\delay.h ****      notice, this list of conditions and the following disclaimer in
  14:c:\winavr-20100110\avr\include\util\delay.h ****      the documentation and/or other materials provided with the
  15:c:\winavr-20100110\avr\include\util\delay.h ****      distribution.
  16:c:\winavr-20100110\avr\include\util\delay.h **** 
  17:c:\winavr-20100110\avr\include\util\delay.h ****    * Neither the name of the copyright holders nor the names of
  18:c:\winavr-20100110\avr\include\util\delay.h ****      contributors may be used to endorse or promote products derived
  19:c:\winavr-20100110\avr\include\util\delay.h ****      from this software without specific prior written permission.
  20:c:\winavr-20100110\avr\include\util\delay.h **** 
  21:c:\winavr-20100110\avr\include\util\delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:c:\winavr-20100110\avr\include\util\delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:c:\winavr-20100110\avr\include\util\delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:c:\winavr-20100110\avr\include\util\delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:c:\winavr-20100110\avr\include\util\delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:c:\winavr-20100110\avr\include\util\delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:c:\winavr-20100110\avr\include\util\delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:c:\winavr-20100110\avr\include\util\delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:c:\winavr-20100110\avr\include\util\delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:c:\winavr-20100110\avr\include\util\delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:c:\winavr-20100110\avr\include\util\delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:c:\winavr-20100110\avr\include\util\delay.h **** 
  33:c:\winavr-20100110\avr\include\util\delay.h **** /* $Id$ */
  34:c:\winavr-20100110\avr\include\util\delay.h **** 
  35:c:\winavr-20100110\avr\include\util\delay.h **** #ifndef _UTIL_DELAY_H_
  36:c:\winavr-20100110\avr\include\util\delay.h **** #define _UTIL_DELAY_H_ 1
  37:c:\winavr-20100110\avr\include\util\delay.h **** 
  38:c:\winavr-20100110\avr\include\util\delay.h **** #ifndef __DOXYGEN__
  39:c:\winavr-20100110\avr\include\util\delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:c:\winavr-20100110\avr\include\util\delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:c:\winavr-20100110\avr\include\util\delay.h **** #  endif
  42:c:\winavr-20100110\avr\include\util\delay.h **** #endif  /* __DOXYGEN__ */
  43:c:\winavr-20100110\avr\include\util\delay.h **** 
  44:c:\winavr-20100110\avr\include\util\delay.h **** #include <inttypes.h>
  45:c:\winavr-20100110\avr\include\util\delay.h **** #include <util/delay_basic.h>
  46:c:\winavr-20100110\avr\include\util\delay.h **** #include <math.h>
  47:c:\winavr-20100110\avr\include\util\delay.h **** 
  48:c:\winavr-20100110\avr\include\util\delay.h **** /** \file */
  49:c:\winavr-20100110\avr\include\util\delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:c:\winavr-20100110\avr\include\util\delay.h ****     \code
  51:c:\winavr-20100110\avr\include\util\delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:c:\winavr-20100110\avr\include\util\delay.h ****     //#define F_CPU 14.7456E6
  53:c:\winavr-20100110\avr\include\util\delay.h ****     #include <util/delay.h>
  54:c:\winavr-20100110\avr\include\util\delay.h ****     \endcode
  55:c:\winavr-20100110\avr\include\util\delay.h **** 
  56:c:\winavr-20100110\avr\include\util\delay.h ****     \note As an alternative method, it is possible to pass the
  57:c:\winavr-20100110\avr\include\util\delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:c:\winavr-20100110\avr\include\util\delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:c:\winavr-20100110\avr\include\util\delay.h ****     used.
  60:c:\winavr-20100110\avr\include\util\delay.h **** 
  61:c:\winavr-20100110\avr\include\util\delay.h ****     The functions in this header file are wrappers around the basic
  62:c:\winavr-20100110\avr\include\util\delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:c:\winavr-20100110\avr\include\util\delay.h ****     convenience functions where actual time values can be specified
  64:c:\winavr-20100110\avr\include\util\delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:c:\winavr-20100110\avr\include\util\delay.h ****     that compile-time constant expressions will be eliminated by
  66:c:\winavr-20100110\avr\include\util\delay.h ****     compiler optimization so floating-point expressions can be used
  67:c:\winavr-20100110\avr\include\util\delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:c:\winavr-20100110\avr\include\util\delay.h ****     frequency passed by the macro F_CPU.
  69:c:\winavr-20100110\avr\include\util\delay.h **** 
  70:c:\winavr-20100110\avr\include\util\delay.h ****     \note In order for these functions to work as intended, compiler
  71:c:\winavr-20100110\avr\include\util\delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:c:\winavr-20100110\avr\include\util\delay.h ****     <em>must</em> be an expression that is a known constant at
  73:c:\winavr-20100110\avr\include\util\delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:c:\winavr-20100110\avr\include\util\delay.h ****     delay will be much longer (and basically unpredictable), and
  75:c:\winavr-20100110\avr\include\util\delay.h ****     applications that otherwise do not use floating-point calculations
  76:c:\winavr-20100110\avr\include\util\delay.h ****     will experience severe code bloat by the floating-point library
  77:c:\winavr-20100110\avr\include\util\delay.h ****     routines linked into the application.
  78:c:\winavr-20100110\avr\include\util\delay.h **** 
  79:c:\winavr-20100110\avr\include\util\delay.h ****     The functions available allow the specification of microsecond, and
  80:c:\winavr-20100110\avr\include\util\delay.h ****     millisecond delays directly, using the application-supplied macro
  81:c:\winavr-20100110\avr\include\util\delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:c:\winavr-20100110\avr\include\util\delay.h **** 
  83:c:\winavr-20100110\avr\include\util\delay.h **** */
  84:c:\winavr-20100110\avr\include\util\delay.h **** 
  85:c:\winavr-20100110\avr\include\util\delay.h **** #if !defined(__DOXYGEN__)
  86:c:\winavr-20100110\avr\include\util\delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:c:\winavr-20100110\avr\include\util\delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:c:\winavr-20100110\avr\include\util\delay.h **** #endif
  89:c:\winavr-20100110\avr\include\util\delay.h **** 
  90:c:\winavr-20100110\avr\include\util\delay.h **** #ifndef F_CPU
  91:c:\winavr-20100110\avr\include\util\delay.h **** /* prevent compiler error by supplying a default */
  92:c:\winavr-20100110\avr\include\util\delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:c:\winavr-20100110\avr\include\util\delay.h **** /** \ingroup util_delay
  94:c:\winavr-20100110\avr\include\util\delay.h ****     \def F_CPU
  95:c:\winavr-20100110\avr\include\util\delay.h ****     \brief CPU frequency in Hz
  96:c:\winavr-20100110\avr\include\util\delay.h **** 
  97:c:\winavr-20100110\avr\include\util\delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:c:\winavr-20100110\avr\include\util\delay.h ****     the delay macros.  This macro is normally supplied by the
  99:c:\winavr-20100110\avr\include\util\delay.h ****     environment (e.g. from within a project header, or the project's
 100:c:\winavr-20100110\avr\include\util\delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:c:\winavr-20100110\avr\include\util\delay.h ****     fallback if no such user-provided definition could be found.
 102:c:\winavr-20100110\avr\include\util\delay.h **** 
 103:c:\winavr-20100110\avr\include\util\delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:c:\winavr-20100110\avr\include\util\delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:c:\winavr-20100110\avr\include\util\delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:c:\winavr-20100110\avr\include\util\delay.h ****     integer value.
 107:c:\winavr-20100110\avr\include\util\delay.h ****  */
 108:c:\winavr-20100110\avr\include\util\delay.h **** # define F_CPU 1000000UL
 109:c:\winavr-20100110\avr\include\util\delay.h **** #endif
 110:c:\winavr-20100110\avr\include\util\delay.h **** 
 111:c:\winavr-20100110\avr\include\util\delay.h **** #ifndef __OPTIMIZE__
 112:c:\winavr-20100110\avr\include\util\delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:c:\winavr-20100110\avr\include\util\delay.h **** #endif
 114:c:\winavr-20100110\avr\include\util\delay.h **** 
 115:c:\winavr-20100110\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:c:\winavr-20100110\avr\include\util\delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:c:\winavr-20100110\avr\include\util\delay.h ****   __STDC_HOSTED__
 118:c:\winavr-20100110\avr\include\util\delay.h **** #  include <math.h>
 119:c:\winavr-20100110\avr\include\util\delay.h **** #endif
 120:c:\winavr-20100110\avr\include\util\delay.h **** 
 121:c:\winavr-20100110\avr\include\util\delay.h **** /**
 122:c:\winavr-20100110\avr\include\util\delay.h ****    \ingroup util_delay
 123:c:\winavr-20100110\avr\include\util\delay.h **** 
 124:c:\winavr-20100110\avr\include\util\delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:c:\winavr-20100110\avr\include\util\delay.h **** 
 126:c:\winavr-20100110\avr\include\util\delay.h ****    The macro F_CPU is supposed to be defined to a
 127:c:\winavr-20100110\avr\include\util\delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:c:\winavr-20100110\avr\include\util\delay.h **** 
 129:c:\winavr-20100110\avr\include\util\delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:c:\winavr-20100110\avr\include\util\delay.h **** 
 131:c:\winavr-20100110\avr\include\util\delay.h ****    When the user request delay which exceed the maximum possible one,
 132:c:\winavr-20100110\avr\include\util\delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:c:\winavr-20100110\avr\include\util\delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:c:\winavr-20100110\avr\include\util\delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:c:\winavr-20100110\avr\include\util\delay.h ****    user will not be informed about decreased resolution.
 136:c:\winavr-20100110\avr\include\util\delay.h **** 
 137:c:\winavr-20100110\avr\include\util\delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:c:\winavr-20100110\avr\include\util\delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:c:\winavr-20100110\avr\include\util\delay.h ****    values greater than the maximal possible delay, overflows results in
 140:c:\winavr-20100110\avr\include\util\delay.h ****    no delay i.e., 0ms.
 141:c:\winavr-20100110\avr\include\util\delay.h **** 
 142:c:\winavr-20100110\avr\include\util\delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:c:\winavr-20100110\avr\include\util\delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:c:\winavr-20100110\avr\include\util\delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:c:\winavr-20100110\avr\include\util\delay.h ****    microseconds of delay.
 146:c:\winavr-20100110\avr\include\util\delay.h **** 
 147:c:\winavr-20100110\avr\include\util\delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:c:\winavr-20100110\avr\include\util\delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:c:\winavr-20100110\avr\include\util\delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:c:\winavr-20100110\avr\include\util\delay.h ****    respectively.
 151:c:\winavr-20100110\avr\include\util\delay.h **** 
 152:c:\winavr-20100110\avr\include\util\delay.h ****    \note
 153:c:\winavr-20100110\avr\include\util\delay.h **** 
 154:c:\winavr-20100110\avr\include\util\delay.h ****    The implementation of _delay_ms() based on
 155:c:\winavr-20100110\avr\include\util\delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:c:\winavr-20100110\avr\include\util\delay.h ****    implementations.  In order to get functionality backward compatible
 157:c:\winavr-20100110\avr\include\util\delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:c:\winavr-20100110\avr\include\util\delay.h ****    must be defined before including this header file. Also, the
 159:c:\winavr-20100110\avr\include\util\delay.h ****    backward compatible algorithm will be chosen if the code is
 160:c:\winavr-20100110\avr\include\util\delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:c:\winavr-20100110\avr\include\util\delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:c:\winavr-20100110\avr\include\util\delay.h ****    not available to the compiler then.
 163:c:\winavr-20100110\avr\include\util\delay.h **** 
 164:c:\winavr-20100110\avr\include\util\delay.h ****  */
 165:c:\winavr-20100110\avr\include\util\delay.h **** void
 166:c:\winavr-20100110\avr\include\util\delay.h **** _delay_ms(double __ms)
 167:c:\winavr-20100110\avr\include\util\delay.h **** {
 168:c:\winavr-20100110\avr\include\util\delay.h **** 	double __tmp ;
 169:c:\winavr-20100110\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:c:\winavr-20100110\avr\include\util\delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:c:\winavr-20100110\avr\include\util\delay.h ****   __STDC_HOSTED__
 172:c:\winavr-20100110\avr\include\util\delay.h **** 	uint32_t __ticks_dc;
 173:c:\winavr-20100110\avr\include\util\delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 174:c:\winavr-20100110\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 175:c:\winavr-20100110\avr\include\util\delay.h **** 
 176:c:\winavr-20100110\avr\include\util\delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:c:\winavr-20100110\avr\include\util\delay.h **** 
 179:c:\winavr-20100110\avr\include\util\delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:c:\winavr-20100110\avr\include\util\delay.h **** 
 182:c:\winavr-20100110\avr\include\util\delay.h **** 	#else
 183:c:\winavr-20100110\avr\include\util\delay.h **** 		//round up by default
 184:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 185:c:\winavr-20100110\avr\include\util\delay.h **** 	#endif
 186:c:\winavr-20100110\avr\include\util\delay.h **** 
 187:c:\winavr-20100110\avr\include\util\delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 1055               		.loc 2 187 0
 1056 029e 8FE3      		ldi r24,lo8(-25537)
 1057 02a0 9CE9      		ldi r25,hi8(-25537)
 1058 02a2 0197      	1:	sbiw r24,1
 1059 02a4 01F4      		brne 1b
 1060 02a6 00C0      		rjmp .
 1061 02a8 0000      		nop
 1062               	.LVL66:
 1063               	.LBE69:
 1064               	.LBE68:
 527:setup.c       **** 	_delay_ms(20); // Wait a little (for Atmel chip)
 528:setup.c       **** 	
 529:setup.c       **** 	// Set data as inputs
 530:setup.c       **** 	GBA_PORT_RAM_DATA7_0 = 0;
 1065               		.loc 1 530 0
 1066 02aa 15BA      		out 0x15,__zero_reg__
 531:setup.c       **** 	GBA_DDR_RAM_DATA7_0 = 0;
 1067               		.loc 1 531 0
 1068 02ac 14BA      		out 0x14,__zero_reg__
 532:setup.c       **** 	
 533:setup.c       **** 	// Read and transmit the 2 bytes
 534:setup.c       **** 	flashChipIdBuffer[0] = gba_read_ram_8bit_data(0x0000);
 1069               		.loc 1 534 0
 1070 02ae 80E0      		ldi r24,0
 1071 02b0 90E0      		ldi r25,0
 1072 02b2 00D0      		rcall gba_read_ram_8bit_data
 1073               	.LVL67:
 1074 02b4 C0E0      		ldi r28,lo8(flashChipIdBuffer)
 1075 02b6 D0E0      		ldi r29,hi8(flashChipIdBuffer)
 1076 02b8 8883      		st Y,r24
 535:setup.c       **** 	flashChipIdBuffer[1] = gba_read_ram_8bit_data(0x0001);
 1077               		.loc 1 535 0
 1078 02ba 81E0      		ldi r24,lo8(1)
 1079 02bc 90E0      		ldi r25,0
 1080 02be 00D0      		rcall gba_read_ram_8bit_data
 1081               	.LVL68:
 1082 02c0 8983      		std Y+1,r24
 536:setup.c       **** 	
 537:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xAA);
 1083               		.loc 1 537 0
 1084 02c2 6AEA      		ldi r22,lo8(-86)
 1085 02c4 85E5      		ldi r24,lo8(85)
 1086 02c6 95E5      		ldi r25,lo8(85)
 1087 02c8 00D0      		rcall flash_write_bus_cycle
 1088               	.LVL69:
 538:setup.c       **** 	flash_write_bus_cycle(0x2AAA, 0x55);
 1089               		.loc 1 538 0
 1090 02ca 65E5      		ldi r22,lo8(85)
 1091 02cc 8AEA      		ldi r24,lo8(-86)
 1092 02ce 9AE2      		ldi r25,lo8(42)
 1093 02d0 00D0      		rcall flash_write_bus_cycle
 1094               	.LVL70:
 539:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xF0); // Software ID exit
 1095               		.loc 1 539 0
 1096 02d2 60EF      		ldi r22,lo8(-16)
 1097 02d4 85E5      		ldi r24,lo8(85)
 1098 02d6 95E5      		ldi r25,lo8(85)
 1099 02d8 00D0      		rcall flash_write_bus_cycle
 1100               	.LVL71:
 1101               	.LBB70:
 1102               	.LBB71:
 1103               		.loc 2 187 0
 1104 02da 8FE3      		ldi r24,lo8(-25537)
 1105 02dc 9CE9      		ldi r25,hi8(-25537)
 1106 02de 0197      	1:	sbiw r24,1
 1107 02e0 01F4      		brne 1b
 1108 02e2 00C0      		rjmp .
 1109 02e4 0000      		nop
 1110               	.LVL72:
 1111               	/* epilogue start */
 1112               	.LBE71:
 1113               	.LBE70:
 540:setup.c       **** 	_delay_ms(20); // Wait a little (for Atmel chip)
 541:setup.c       **** }
 1114               		.loc 1 541 0
 1115 02e6 DF91      		pop r29
 1116 02e8 CF91      		pop r28
 1117 02ea 0895      		ret
 1118               		.cfi_endproc
 1119               	.LFE31:
 1121               	.global	flash_switch_bank
 1123               	flash_switch_bank:
 1124               	.LFB32:
 542:setup.c       **** 
 543:setup.c       **** // Switch banks on the Flash
 544:setup.c       **** void flash_switch_bank(uint8_t bank) {
 1125               		.loc 1 544 0
 1126               		.cfi_startproc
 1127               	.LVL73:
 1128 02ec CF93      		push r28
 1129               	.LCFI13:
 1130               		.cfi_def_cfa_offset 3
 1131               		.cfi_offset 28, -2
 1132               	/* prologue: function */
 1133               	/* frame size = 0 */
 1134               	/* stack size = 1 */
 1135               	.L__stack_usage = 1
 1136 02ee C82F      		mov r28,r24
 545:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xAA);
 1137               		.loc 1 545 0
 1138 02f0 6AEA      		ldi r22,lo8(-86)
 1139 02f2 85E5      		ldi r24,lo8(85)
 1140 02f4 95E5      		ldi r25,lo8(85)
 1141               	.LVL74:
 1142 02f6 00D0      		rcall flash_write_bus_cycle
 1143               	.LVL75:
 546:setup.c       **** 	flash_write_bus_cycle(0x2AAA, 0x55);
 1144               		.loc 1 546 0
 1145 02f8 65E5      		ldi r22,lo8(85)
 1146 02fa 8AEA      		ldi r24,lo8(-86)
 1147 02fc 9AE2      		ldi r25,lo8(42)
 1148 02fe 00D0      		rcall flash_write_bus_cycle
 1149               	.LVL76:
 547:setup.c       **** 	
 548:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xB0);
 1150               		.loc 1 548 0
 1151 0300 60EB      		ldi r22,lo8(-80)
 1152 0302 85E5      		ldi r24,lo8(85)
 1153 0304 95E5      		ldi r25,lo8(85)
 1154 0306 00D0      		rcall flash_write_bus_cycle
 1155               	.LVL77:
 549:setup.c       **** 	flash_write_bus_cycle(0x0000, bank);
 1156               		.loc 1 549 0
 1157 0308 6C2F      		mov r22,r28
 1158 030a 80E0      		ldi r24,0
 1159 030c 90E0      		ldi r25,0
 1160               	/* epilogue start */
 550:setup.c       **** }
 1161               		.loc 1 550 0
 1162 030e CF91      		pop r28
 1163               	.LVL78:
 549:setup.c       **** 	flash_write_bus_cycle(0x0000, bank);
 1164               		.loc 1 549 0
 1165 0310 00C0      		rjmp flash_write_bus_cycle
 1166               	.LVL79:
 1167               		.cfi_endproc
 1168               	.LFE32:
 1170               	.global	flash_erase_4k_sector
 1172               	flash_erase_4k_sector:
 1173               	.LFB33:
 551:setup.c       **** 
 552:setup.c       **** // Erase 4K sector on Flash, expects first sector to start at 0, left shifts by 12 (A15-A12 to sele
 553:setup.c       **** // Takes 25ms after last command to erase sector
 554:setup.c       **** void flash_erase_4k_sector(uint8_t sector) {
 1174               		.loc 1 554 0
 1175               		.cfi_startproc
 1176               	.LVL80:
 1177 0312 CF93      		push r28
 1178               	.LCFI14:
 1179               		.cfi_def_cfa_offset 3
 1180               		.cfi_offset 28, -2
 1181               	/* prologue: function */
 1182               	/* frame size = 0 */
 1183               	/* stack size = 1 */
 1184               	.L__stack_usage = 1
 1185 0314 C82F      		mov r28,r24
 555:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xAA);
 1186               		.loc 1 555 0
 1187 0316 6AEA      		ldi r22,lo8(-86)
 1188 0318 85E5      		ldi r24,lo8(85)
 1189 031a 95E5      		ldi r25,lo8(85)
 1190               	.LVL81:
 1191 031c 00D0      		rcall flash_write_bus_cycle
 1192               	.LVL82:
 556:setup.c       **** 	flash_write_bus_cycle(0x2AAA, 0x55);
 1193               		.loc 1 556 0
 1194 031e 65E5      		ldi r22,lo8(85)
 1195 0320 8AEA      		ldi r24,lo8(-86)
 1196 0322 9AE2      		ldi r25,lo8(42)
 1197 0324 00D0      		rcall flash_write_bus_cycle
 1198               	.LVL83:
 557:setup.c       **** 	flash_write_bus_cycle(0x5555, 0x80);
 1199               		.loc 1 557 0
 1200 0326 60E8      		ldi r22,lo8(-128)
 1201 0328 85E5      		ldi r24,lo8(85)
 1202 032a 95E5      		ldi r25,lo8(85)
 1203 032c 00D0      		rcall flash_write_bus_cycle
 1204               	.LVL84:
 558:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xAA);
 1205               		.loc 1 558 0
 1206 032e 6AEA      		ldi r22,lo8(-86)
 1207 0330 85E5      		ldi r24,lo8(85)
 1208 0332 95E5      		ldi r25,lo8(85)
 1209 0334 00D0      		rcall flash_write_bus_cycle
 1210               	.LVL85:
 559:setup.c       **** 	flash_write_bus_cycle(0x2AAA, 0x55);
 1211               		.loc 1 559 0
 1212 0336 65E5      		ldi r22,lo8(85)
 1213 0338 8AEA      		ldi r24,lo8(-86)
 1214 033a 9AE2      		ldi r25,lo8(42)
 1215 033c 00D0      		rcall flash_write_bus_cycle
 1216               	.LVL86:
 560:setup.c       **** 	
 561:setup.c       **** 	flash_write_bus_cycle((uint16_t) sector << 12, 0x30);
 1217               		.loc 1 561 0
 1218 033e 60E3      		ldi r22,lo8(48)
 1219 0340 80E0      		ldi r24,0
 1220 0342 9C2F      		mov r25,r28
 1221 0344 9295      		swap r25
 1222 0346 907F      		andi r25,lo8(-16)
 1223 0348 00D0      		rcall flash_write_bus_cycle
 1224               	.LVL87:
 1225               	.LBB72:
 1226               	.LBB73:
 1227               		.loc 2 187 0
 1228 034a 8FE4      		ldi r24,lo8(-15537)
 1229 034c 93EC      		ldi r25,hi8(-15537)
 1230 034e 0197      	1:	sbiw r24,1
 1231 0350 01F4      		brne 1b
 1232 0352 00C0      		rjmp .
 1233 0354 0000      		nop
 1234               	.LVL88:
 1235               	/* epilogue start */
 1236               	.LBE73:
 1237               	.LBE72:
 562:setup.c       **** 	_delay_ms(25); // Wait 25ms for sector erase
 563:setup.c       **** }
 1238               		.loc 1 563 0
 1239 0356 CF91      		pop r28
 1240               	.LVL89:
 1241 0358 0895      		ret
 1242               		.cfi_endproc
 1243               	.LFE33:
 1245               	.global	flash_write_byte
 1247               	flash_write_byte:
 1248               	.LFB34:
 564:setup.c       **** 
 565:setup.c       **** // Write a single byte to the Flash address
 566:setup.c       **** // Takes 20us to program Flash
 567:setup.c       **** void flash_write_byte(uint16_t address, uint8_t data) {
 1249               		.loc 1 567 0
 1250               		.cfi_startproc
 1251               	.LVL90:
 1252 035a 1F93      		push r17
 1253               	.LCFI15:
 1254               		.cfi_def_cfa_offset 3
 1255               		.cfi_offset 17, -2
 1256 035c CF93      		push r28
 1257               	.LCFI16:
 1258               		.cfi_def_cfa_offset 4
 1259               		.cfi_offset 28, -3
 1260 035e DF93      		push r29
 1261               	.LCFI17:
 1262               		.cfi_def_cfa_offset 5
 1263               		.cfi_offset 29, -4
 1264               	/* prologue: function */
 1265               	/* frame size = 0 */
 1266               	/* stack size = 3 */
 1267               	.L__stack_usage = 3
 1268 0360 EC01      		movw r28,r24
 1269 0362 162F      		mov r17,r22
 568:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xAA);
 1270               		.loc 1 568 0
 1271 0364 6AEA      		ldi r22,lo8(-86)
 1272               	.LVL91:
 1273 0366 85E5      		ldi r24,lo8(85)
 1274 0368 95E5      		ldi r25,lo8(85)
 1275               	.LVL92:
 1276 036a 00D0      		rcall flash_write_bus_cycle
 1277               	.LVL93:
 569:setup.c       **** 	flash_write_bus_cycle(0x2AAA, 0x55);
 1278               		.loc 1 569 0
 1279 036c 65E5      		ldi r22,lo8(85)
 1280 036e 8AEA      		ldi r24,lo8(-86)
 1281 0370 9AE2      		ldi r25,lo8(42)
 1282 0372 00D0      		rcall flash_write_bus_cycle
 1283               	.LVL94:
 570:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xA0);
 1284               		.loc 1 570 0
 1285 0374 60EA      		ldi r22,lo8(-96)
 1286 0376 85E5      		ldi r24,lo8(85)
 1287 0378 95E5      		ldi r25,lo8(85)
 1288 037a 00D0      		rcall flash_write_bus_cycle
 1289               	.LVL95:
 571:setup.c       **** 	
 572:setup.c       **** 	flash_write_bus_cycle(address, data);
 1290               		.loc 1 572 0
 1291 037c 612F      		mov r22,r17
 1292 037e CE01      		movw r24,r28
 1293 0380 00D0      		rcall flash_write_bus_cycle
 1294               	.LVL96:
 1295               	.LBB74:
 1296               	.LBB75:
 188:c:\winavr-20100110\avr\include\util\delay.h **** 
 189:c:\winavr-20100110\avr\include\util\delay.h **** #else
 190:c:\winavr-20100110\avr\include\util\delay.h **** 	uint16_t __ticks;
 191:c:\winavr-20100110\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 4e3) * __ms;
 192:c:\winavr-20100110\avr\include\util\delay.h **** 	if (__tmp < 1.0)
 193:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks = 1;
 194:c:\winavr-20100110\avr\include\util\delay.h **** 	else if (__tmp > 65535)
 195:c:\winavr-20100110\avr\include\util\delay.h **** 	{
 196:c:\winavr-20100110\avr\include\util\delay.h **** 		//	__ticks = requested delay in 1/10 ms
 197:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 198:c:\winavr-20100110\avr\include\util\delay.h **** 		while(__ticks)
 199:c:\winavr-20100110\avr\include\util\delay.h **** 		{
 200:c:\winavr-20100110\avr\include\util\delay.h **** 			// wait 1/10 ms
 201:c:\winavr-20100110\avr\include\util\delay.h **** 			_delay_loop_2(((F_CPU) / 4e3) / 10);
 202:c:\winavr-20100110\avr\include\util\delay.h **** 			__ticks --;
 203:c:\winavr-20100110\avr\include\util\delay.h **** 		}
 204:c:\winavr-20100110\avr\include\util\delay.h **** 		return;
 205:c:\winavr-20100110\avr\include\util\delay.h **** 	}
 206:c:\winavr-20100110\avr\include\util\delay.h **** 	else
 207:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks = (uint16_t)__tmp;
 208:c:\winavr-20100110\avr\include\util\delay.h **** 	_delay_loop_2(__ticks);
 209:c:\winavr-20100110\avr\include\util\delay.h **** #endif
 210:c:\winavr-20100110\avr\include\util\delay.h **** }
 211:c:\winavr-20100110\avr\include\util\delay.h **** 
 212:c:\winavr-20100110\avr\include\util\delay.h **** /**
 213:c:\winavr-20100110\avr\include\util\delay.h ****    \ingroup util_delay
 214:c:\winavr-20100110\avr\include\util\delay.h **** 
 215:c:\winavr-20100110\avr\include\util\delay.h ****    Perform a delay of \c __us microseconds, using _delay_loop_1().
 216:c:\winavr-20100110\avr\include\util\delay.h **** 
 217:c:\winavr-20100110\avr\include\util\delay.h ****    The macro F_CPU is supposed to be defined to a
 218:c:\winavr-20100110\avr\include\util\delay.h ****    constant defining the CPU clock frequency (in Hertz).
 219:c:\winavr-20100110\avr\include\util\delay.h **** 
 220:c:\winavr-20100110\avr\include\util\delay.h ****    The maximal possible delay is 768 us / F_CPU in MHz.
 221:c:\winavr-20100110\avr\include\util\delay.h **** 
 222:c:\winavr-20100110\avr\include\util\delay.h ****    If the user requests a delay greater than the maximal possible one,
 223:c:\winavr-20100110\avr\include\util\delay.h ****    _delay_us() will automatically call _delay_ms() instead.  The user
 224:c:\winavr-20100110\avr\include\util\delay.h ****    will not be informed about this case.
 225:c:\winavr-20100110\avr\include\util\delay.h **** 
 226:c:\winavr-20100110\avr\include\util\delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 227:c:\winavr-20100110\avr\include\util\delay.h ****    support, maximal possible delay is 4294967.295 us/ F_CPU in MHz. For
 228:c:\winavr-20100110\avr\include\util\delay.h ****    values greater than the maximal possible delay, overflow results in
 229:c:\winavr-20100110\avr\include\util\delay.h ****    no delay i.e., 0us.
 230:c:\winavr-20100110\avr\include\util\delay.h **** 
 231:c:\winavr-20100110\avr\include\util\delay.h ****    Conversion of \c __us into clock cycles may not always result in
 232:c:\winavr-20100110\avr\include\util\delay.h ****    integer.  By default, the clock cycles rounded up to next
 233:c:\winavr-20100110\avr\include\util\delay.h ****    integer. This ensures that the user gets at least \c __us
 234:c:\winavr-20100110\avr\include\util\delay.h ****    microseconds of delay.
 235:c:\winavr-20100110\avr\include\util\delay.h **** 
 236:c:\winavr-20100110\avr\include\util\delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 237:c:\winavr-20100110\avr\include\util\delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 238:c:\winavr-20100110\avr\include\util\delay.h ****    algorithm can be made to round down, or round to closest integer,
 239:c:\winavr-20100110\avr\include\util\delay.h ****    respectively.
 240:c:\winavr-20100110\avr\include\util\delay.h **** 
 241:c:\winavr-20100110\avr\include\util\delay.h ****    \note
 242:c:\winavr-20100110\avr\include\util\delay.h **** 
 243:c:\winavr-20100110\avr\include\util\delay.h ****    The implementation of _delay_ms() based on
 244:c:\winavr-20100110\avr\include\util\delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 245:c:\winavr-20100110\avr\include\util\delay.h ****    implementations.  In order to get functionality backward compatible
 246:c:\winavr-20100110\avr\include\util\delay.h ****    with previous versions, the macro \c __DELAY_BACKWARD_COMPATIBLE__
 247:c:\winavr-20100110\avr\include\util\delay.h ****    must be defined before including this header file. Also, the
 248:c:\winavr-20100110\avr\include\util\delay.h ****    backward compatible algorithm will be chosen if the code is
 249:c:\winavr-20100110\avr\include\util\delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 250:c:\winavr-20100110\avr\include\util\delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 251:c:\winavr-20100110\avr\include\util\delay.h ****    not available to the compiler then.
 252:c:\winavr-20100110\avr\include\util\delay.h **** 
 253:c:\winavr-20100110\avr\include\util\delay.h ****  */
 254:c:\winavr-20100110\avr\include\util\delay.h **** void
 255:c:\winavr-20100110\avr\include\util\delay.h **** _delay_us(double __us)
 256:c:\winavr-20100110\avr\include\util\delay.h **** {
 257:c:\winavr-20100110\avr\include\util\delay.h **** 	double __tmp ;
 258:c:\winavr-20100110\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 259:c:\winavr-20100110\avr\include\util\delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 260:c:\winavr-20100110\avr\include\util\delay.h ****   __STDC_HOSTED__
 261:c:\winavr-20100110\avr\include\util\delay.h **** 	uint32_t __ticks_dc;
 262:c:\winavr-20100110\avr\include\util\delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 263:c:\winavr-20100110\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 264:c:\winavr-20100110\avr\include\util\delay.h **** 
 265:c:\winavr-20100110\avr\include\util\delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 266:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 267:c:\winavr-20100110\avr\include\util\delay.h **** 
 268:c:\winavr-20100110\avr\include\util\delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 269:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 270:c:\winavr-20100110\avr\include\util\delay.h **** 
 271:c:\winavr-20100110\avr\include\util\delay.h **** 	#else
 272:c:\winavr-20100110\avr\include\util\delay.h **** 		//round up by default
 273:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 274:c:\winavr-20100110\avr\include\util\delay.h **** 	#endif
 275:c:\winavr-20100110\avr\include\util\delay.h **** 
 276:c:\winavr-20100110\avr\include\util\delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 1297               		.loc 2 276 0
 1298 0382 85E3      		ldi r24,lo8(53)
 1299 0384 8A95      	1:	dec r24
 1300 0386 01F4      		brne 1b
 1301 0388 0000      		nop
 1302               	.LVL97:
 1303               	/* epilogue start */
 1304               	.LBE75:
 1305               	.LBE74:
 573:setup.c       **** 	_delay_us(20); // Wait byte program time
 574:setup.c       **** }
 1306               		.loc 1 574 0
 1307 038a DF91      		pop r29
 1308 038c CF91      		pop r28
 1309               	.LVL98:
 1310 038e 1F91      		pop r17
 1311               	.LVL99:
 1312 0390 0895      		ret
 1313               		.cfi_endproc
 1314               	.LFE34:
 1316               	.global	flash_write_sector
 1318               	flash_write_sector:
 1319               	.LFB35:
 575:setup.c       **** 
 576:setup.c       **** // Write a sector (128 bytes) to the Atmel flash
 577:setup.c       **** // Takes 20ms for write cycle
 578:setup.c       **** void flash_write_sector(uint16_t sector) {
 1320               		.loc 1 578 0
 1321               		.cfi_startproc
 1322               	.LVL100:
 1323 0392 EF92      		push r14
 1324               	.LCFI18:
 1325               		.cfi_def_cfa_offset 3
 1326               		.cfi_offset 14, -2
 1327 0394 FF92      		push r15
 1328               	.LCFI19:
 1329               		.cfi_def_cfa_offset 4
 1330               		.cfi_offset 15, -3
 1331 0396 0F93      		push r16
 1332               	.LCFI20:
 1333               		.cfi_def_cfa_offset 5
 1334               		.cfi_offset 16, -4
 1335 0398 1F93      		push r17
 1336               	.LCFI21:
 1337               		.cfi_def_cfa_offset 6
 1338               		.cfi_offset 17, -5
 1339 039a CF93      		push r28
 1340               	.LCFI22:
 1341               		.cfi_def_cfa_offset 7
 1342               		.cfi_offset 28, -6
 1343 039c DF93      		push r29
 1344               	.LCFI23:
 1345               		.cfi_def_cfa_offset 8
 1346               		.cfi_offset 29, -7
 1347               	/* prologue: function */
 1348               	/* frame size = 0 */
 1349               	/* stack size = 6 */
 1350               	.L__stack_usage = 6
 1351 039e 8C01      		movw r16,r24
 579:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xAA);
 1352               		.loc 1 579 0
 1353 03a0 6AEA      		ldi r22,lo8(-86)
 1354 03a2 85E5      		ldi r24,lo8(85)
 1355 03a4 95E5      		ldi r25,lo8(85)
 1356               	.LVL101:
 1357 03a6 00D0      		rcall flash_write_bus_cycle
 1358               	.LVL102:
 580:setup.c       **** 	flash_write_bus_cycle(0x2AAA, 0x55);
 1359               		.loc 1 580 0
 1360 03a8 65E5      		ldi r22,lo8(85)
 1361 03aa 8AEA      		ldi r24,lo8(-86)
 1362 03ac 9AE2      		ldi r25,lo8(42)
 1363 03ae 00D0      		rcall flash_write_bus_cycle
 1364               	.LVL103:
 581:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xA0);
 1365               		.loc 1 581 0
 1366 03b0 60EA      		ldi r22,lo8(-96)
 1367 03b2 85E5      		ldi r24,lo8(85)
 1368 03b4 95E5      		ldi r25,lo8(85)
 1369 03b6 00D0      		rcall flash_write_bus_cycle
 1370               	.LVL104:
 1371               	.LBB76:
 582:setup.c       **** 	
 583:setup.c       **** 	// Write the bytes (A0-A6 byte address, A7-A15 sector address)
 584:setup.c       **** 	for (uint8_t x = 0; x < 128; x++) {
 585:setup.c       **** 		flash_write_bus_cycle((uint16_t) (sector << 7) | (uint16_t) x, receivedBuffer[x]);
 1372               		.loc 1 585 0
 1373 03b8 1695      		lsr r17
 1374 03ba 102F      		mov r17,r16
 1375 03bc 0027      		clr r16
 1376 03be 1795      		ror r17
 1377 03c0 0795      		ror r16
 1378               	.LVL105:
 1379 03c2 90E0      		ldi r25,lo8(receivedBuffer)
 1380 03c4 E92E      		mov r14,r25
 1381 03c6 90E0      		ldi r25,hi8(receivedBuffer)
 1382 03c8 F92E      		mov r15,r25
 1383 03ca C0E0      		ldi r28,0
 1384 03cc D0E0      		ldi r29,0
 1385               	.LVL106:
 1386               	.L66:
 1387               		.loc 1 585 0 is_stmt 0 discriminator 3
 1388 03ce F701      		movw r30,r14
 1389 03d0 6191      		ld r22,Z+
 1390 03d2 7F01      		movw r14,r30
 1391 03d4 CE01      		movw r24,r28
 1392 03d6 802B      		or r24,r16
 1393 03d8 912B      		or r25,r17
 1394 03da 00D0      		rcall flash_write_bus_cycle
 1395               	.LVL107:
 1396 03dc 2196      		adiw r28,1
 1397               	.LVL108:
 584:setup.c       **** 		flash_write_bus_cycle((uint16_t) (sector << 7) | (uint16_t) x, receivedBuffer[x]);
 1398               		.loc 1 584 0 is_stmt 1 discriminator 3
 1399 03de C038      		cpi r28,-128
 1400 03e0 D105      		cpc r29,__zero_reg__
 1401 03e2 01F4      		brne .L66
 1402               	.LVL109:
 1403               	.LBE76:
 1404               	.LBB77:
 1405               	.LBB78:
 187:c:\winavr-20100110\avr\include\util\delay.h **** 
 1406               		.loc 2 187 0
 1407 03e4 8FE3      		ldi r24,lo8(-25537)
 1408 03e6 9CE9      		ldi r25,hi8(-25537)
 1409 03e8 0197      	1:	sbiw r24,1
 1410 03ea 01F4      		brne 1b
 1411 03ec 00C0      		rjmp .
 1412 03ee 0000      		nop
 1413               	.LVL110:
 1414               	/* epilogue start */
 1415               	.LBE78:
 1416               	.LBE77:
 586:setup.c       **** 	}
 587:setup.c       **** 	_delay_ms(20); // Wait sector program time
 588:setup.c       **** }
 1417               		.loc 1 588 0
 1418 03f0 DF91      		pop r29
 1419 03f2 CF91      		pop r28
 1420               	.LVL111:
 1421 03f4 1F91      		pop r17
 1422 03f6 0F91      		pop r16
 1423 03f8 FF90      		pop r15
 1424 03fa EF90      		pop r14
 1425 03fc 0895      		ret
 1426               		.cfi_endproc
 1427               	.LFE35:
 1429               	.global	audio_flash_write_bus_cycle
 1431               	audio_flash_write_bus_cycle:
 1432               	.LFB36:
 589:setup.c       **** 
 590:setup.c       **** 
 591:setup.c       **** 
 592:setup.c       **** // ---------- GB FLASH CARTS ----------
 593:setup.c       **** 
 594:setup.c       **** // 32K Audio WE - Set the address and data for the write byte cycle to the flash (pulsing audio pin
 595:setup.c       **** void audio_flash_write_bus_cycle(uint16_t address, uint8_t data) {
 1433               		.loc 1 595 0
 1434               		.cfi_startproc
 1435               	.LVL112:
 1436 03fe CF93      		push r28
 1437               	.LCFI24:
 1438               		.cfi_def_cfa_offset 3
 1439               		.cfi_offset 28, -2
 1440               	/* prologue: function */
 1441               	/* frame size = 0 */
 1442               	/* stack size = 1 */
 1443               	.L__stack_usage = 1
 1444 0400 C62F      		mov r28,r22
 596:setup.c       **** 	DDR_DATA7_0 = 0xFF; // Set data pins as outputs
 1445               		.loc 1 596 0
 1446 0402 2FEF      		ldi r18,lo8(-1)
 1447 0404 24BB      		out 0x14,r18
 597:setup.c       **** 	set_16bit_address(address);
 1448               		.loc 1 597 0
 1449 0406 00D0      		rcall set_16bit_address
 1450               	.LVL113:
 598:setup.c       **** 	PORT_DATA7_0 = data;
 1451               		.loc 1 598 0
 1452 0408 C5BB      		out 0x15,r28
 599:setup.c       **** 	
 600:setup.c       **** 	audioPin_low; // WE low
 1453               		.loc 1 600 0
 1454 040a 3998      		cbi 0x7,1
 601:setup.c       **** 	asm volatile("nop");
 1455               		.loc 1 601 0
 1456               	/* #APP */
 1457               	 ;  601 "setup.c" 1
 1458 040c 0000      		nop
 1459               	 ;  0 "" 2
 602:setup.c       **** 	asm volatile("nop");
 1460               		.loc 1 602 0
 1461               	 ;  602 "setup.c" 1
 1462 040e 0000      		nop
 1463               	 ;  0 "" 2
 603:setup.c       **** 	asm volatile("nop");
 1464               		.loc 1 603 0
 1465               	 ;  603 "setup.c" 1
 1466 0410 0000      		nop
 1467               	 ;  0 "" 2
 604:setup.c       **** 	audioPin_high; // WE high
 1468               		.loc 1 604 0
 1469               	/* #NOAPP */
 1470 0412 399A      		sbi 0x7,1
 1471               	/* epilogue start */
 605:setup.c       **** }
 1472               		.loc 1 605 0
 1473 0414 CF91      		pop r28
 1474               	.LVL114:
 1475 0416 0895      		ret
 1476               		.cfi_endproc
 1477               	.LFE36:
 1479               	.global	audio_flash_write_byte
 1481               	audio_flash_write_byte:
 1482               	.LFB37:
 606:setup.c       **** 
 607:setup.c       **** // 32K Audio WE - Write a single byte to the Flash address. Takes 20us to program Flash.
 608:setup.c       **** void audio_flash_write_byte(uint16_t address, uint8_t data) {
 1483               		.loc 1 608 0
 1484               		.cfi_startproc
 1485               	.LVL115:
 1486 0418 1F93      		push r17
 1487               	.LCFI25:
 1488               		.cfi_def_cfa_offset 3
 1489               		.cfi_offset 17, -2
 1490 041a CF93      		push r28
 1491               	.LCFI26:
 1492               		.cfi_def_cfa_offset 4
 1493               		.cfi_offset 28, -3
 1494 041c DF93      		push r29
 1495               	.LCFI27:
 1496               		.cfi_def_cfa_offset 5
 1497               		.cfi_offset 29, -4
 1498               	/* prologue: function */
 1499               	/* frame size = 0 */
 1500               	/* stack size = 3 */
 1501               	.L__stack_usage = 3
 1502 041e EC01      		movw r28,r24
 1503 0420 162F      		mov r17,r22
 609:setup.c       **** 	audio_flash_write_bus_cycle(0x555, 0xAA);
 1504               		.loc 1 609 0
 1505 0422 6AEA      		ldi r22,lo8(-86)
 1506               	.LVL116:
 1507 0424 85E5      		ldi r24,lo8(85)
 1508 0426 95E0      		ldi r25,lo8(5)
 1509               	.LVL117:
 1510 0428 00D0      		rcall audio_flash_write_bus_cycle
 1511               	.LVL118:
 610:setup.c       **** 	audio_flash_write_bus_cycle(0x2AA, 0x55);
 1512               		.loc 1 610 0
 1513 042a 65E5      		ldi r22,lo8(85)
 1514 042c 8AEA      		ldi r24,lo8(-86)
 1515 042e 92E0      		ldi r25,lo8(2)
 1516 0430 00D0      		rcall audio_flash_write_bus_cycle
 1517               	.LVL119:
 611:setup.c       **** 	audio_flash_write_bus_cycle(0x555, 0xA0);
 1518               		.loc 1 611 0
 1519 0432 60EA      		ldi r22,lo8(-96)
 1520 0434 85E5      		ldi r24,lo8(85)
 1521 0436 95E0      		ldi r25,lo8(5)
 1522 0438 00D0      		rcall audio_flash_write_bus_cycle
 1523               	.LVL120:
 612:setup.c       **** 	audio_flash_write_bus_cycle(address, data);
 1524               		.loc 1 612 0
 1525 043a 612F      		mov r22,r17
 1526 043c CE01      		movw r24,r28
 1527 043e 00D0      		rcall audio_flash_write_bus_cycle
 1528               	.LVL121:
 1529               	.LBB79:
 1530               	.LBB80:
 1531               		.loc 2 276 0
 1532 0440 85E3      		ldi r24,lo8(53)
 1533 0442 8A95      	1:	dec r24
 1534 0444 01F4      		brne 1b
 1535 0446 0000      		nop
 1536               	.LVL122:
 1537               	.LBE80:
 1538               	.LBE79:
 613:setup.c       **** 	_delay_us(20); // Wait byte program time
 614:setup.c       **** 	
 615:setup.c       **** 	// Set data pins inputs
 616:setup.c       **** 	PORT_DATA7_0 = 0;
 1539               		.loc 1 616 0
 1540 0448 15BA      		out 0x15,__zero_reg__
 617:setup.c       **** 	DDR_DATA7_0 = 0;
 1541               		.loc 1 617 0
 1542 044a 14BA      		out 0x14,__zero_reg__
 618:setup.c       **** 	
 619:setup.c       **** 	// Verify data
 620:setup.c       **** 	uint8_t dataVerify = read_8bit_data(address);
 1543               		.loc 1 620 0
 1544 044c CE01      		movw r24,r28
 1545 044e 00D0      		rcall read_8bit_data
 1546               	.LVL123:
 1547               	.L70:
 621:setup.c       **** 	while (data != dataVerify) {
 1548               		.loc 1 621 0
 1549 0450 8117      		cp r24,r17
 1550 0452 01F0      		breq .L72
 622:setup.c       **** 		dataVerify = read_8bit_data(address);
 1551               		.loc 1 622 0
 1552 0454 CE01      		movw r24,r28
 1553               	.LVL124:
 1554 0456 00D0      		rcall read_8bit_data
 1555               	.LVL125:
 1556               	.LBB81:
 1557               	.LBB82:
 1558               		.loc 2 276 0
 1559 0458 95E3      		ldi r25,lo8(53)
 1560 045a 9A95      	1:	dec r25
 1561 045c 01F4      		brne 1b
 1562 045e 0000      		nop
 1563 0460 00C0      		rjmp .L70
 1564               	.LVL126:
 1565               	.L72:
 1566               	/* epilogue start */
 1567               	.LBE82:
 1568               	.LBE81:
 623:setup.c       **** 		_delay_us(20);
 624:setup.c       **** 	}
 625:setup.c       **** }
 1569               		.loc 1 625 0
 1570 0462 DF91      		pop r29
 1571 0464 CF91      		pop r28
 1572               	.LVL127:
 1573 0466 1F91      		pop r17
 1574               	.LVL128:
 1575 0468 0895      		ret
 1576               		.cfi_endproc
 1577               	.LFE37:
 1579               	.global	bv5_flash_write_bus_cycle
 1581               	bv5_flash_write_bus_cycle:
 1582               	.LFB38:
 626:setup.c       **** 
 627:setup.c       **** // BV5 - Set the address and data for the write byte cycle to the flash (pulsing WR pin)
 628:setup.c       **** void bv5_flash_write_bus_cycle(uint16_t address, uint8_t data) {
 1583               		.loc 1 628 0
 1584               		.cfi_startproc
 1585               	.LVL129:
 1586 046a CF93      		push r28
 1587               	.LCFI28:
 1588               		.cfi_def_cfa_offset 3
 1589               		.cfi_offset 28, -2
 1590               	/* prologue: function */
 1591               	/* frame size = 0 */
 1592               	/* stack size = 1 */
 1593               	.L__stack_usage = 1
 1594 046c C62F      		mov r28,r22
 629:setup.c       **** 	DDR_DATA7_0 = 0xFF; // Set data pins as outputs
 1595               		.loc 1 629 0
 1596 046e 2FEF      		ldi r18,lo8(-1)
 1597 0470 24BB      		out 0x14,r18
 630:setup.c       **** 	set_16bit_address(address);
 1598               		.loc 1 630 0
 1599 0472 00D0      		rcall set_16bit_address
 1600               	.LVL130:
 631:setup.c       **** 	PORT_DATA7_0 = data;
 1601               		.loc 1 631 0
 1602 0474 C5BB      		out 0x15,r28
 632:setup.c       **** 	
 633:setup.c       **** 	wrPin_low;
 1603               		.loc 1 633 0
 1604 0476 9698      		cbi 0x12,6
 634:setup.c       **** 	asm volatile("nop");
 1605               		.loc 1 634 0
 1606               	/* #APP */
 1607               	 ;  634 "setup.c" 1
 1608 0478 0000      		nop
 1609               	 ;  0 "" 2
 635:setup.c       **** 	asm volatile("nop");
 1610               		.loc 1 635 0
 1611               	 ;  635 "setup.c" 1
 1612 047a 0000      		nop
 1613               	 ;  0 "" 2
 636:setup.c       **** 	asm volatile("nop");
 1614               		.loc 1 636 0
 1615               	 ;  636 "setup.c" 1
 1616 047c 0000      		nop
 1617               	 ;  0 "" 2
 637:setup.c       **** 	wrPin_high;
 1618               		.loc 1 637 0
 1619               	/* #NOAPP */
 1620 047e 969A      		sbi 0x12,6
 1621               	/* epilogue start */
 638:setup.c       **** }
 1622               		.loc 1 638 0
 1623 0480 CF91      		pop r28
 1624               	.LVL131:
 1625 0482 0895      		ret
 1626               		.cfi_endproc
 1627               	.LFE38:
 1629               	.global	bv5_flash_read_byte
 1631               	bv5_flash_read_byte:
 1632               	.LFB39:
 639:setup.c       **** 
 640:setup.c       **** // BV5 - Read a byte from the flash
 641:setup.c       **** uint8_t bv5_flash_read_byte(uint16_t address) {
 1633               		.loc 1 641 0
 1634               		.cfi_startproc
 1635               	.LVL132:
 1636               	/* prologue: function */
 1637               	/* frame size = 0 */
 1638               	/* stack size = 0 */
 1639               	.L__stack_usage = 0
 642:setup.c       **** 	PORT_DATA7_0 = 0;
 1640               		.loc 1 642 0
 1641 0484 15BA      		out 0x15,__zero_reg__
 643:setup.c       **** 	DDR_DATA7_0 = 0;
 1642               		.loc 1 643 0
 1643 0486 14BA      		out 0x14,__zero_reg__
 644:setup.c       **** 	
 645:setup.c       **** 	set_16bit_address(address);
 1644               		.loc 1 645 0
 1645 0488 00D0      		rcall set_16bit_address
 1646               	.LVL133:
 646:setup.c       **** 	
 647:setup.c       **** 	rdPin_low;
 1647               		.loc 1 647 0
 1648 048a 9598      		cbi 0x12,5
 648:setup.c       **** 	asm volatile("nop"); // Delay a little
 1649               		.loc 1 648 0
 1650               	/* #APP */
 1651               	 ;  648 "setup.c" 1
 1652 048c 0000      		nop
 1653               	 ;  0 "" 2
 649:setup.c       **** 	asm volatile("nop");
 1654               		.loc 1 649 0
 1655               	 ;  649 "setup.c" 1
 1656 048e 0000      		nop
 1657               	 ;  0 "" 2
 650:setup.c       **** 	uint8_t data = PIN_DATA7_0; // Read data
 1658               		.loc 1 650 0
 1659               	/* #NOAPP */
 1660 0490 83B3      		in r24,0x13
 1661               	.LVL134:
 651:setup.c       **** 	rdPin_high;
 1662               		.loc 1 651 0
 1663 0492 959A      		sbi 0x12,5
 652:setup.c       **** 	
 653:setup.c       **** 	return data;
 654:setup.c       **** }
 1664               		.loc 1 654 0
 1665 0494 0895      		ret
 1666               		.cfi_endproc
 1667               	.LFE39:
 1669               	.global	bv5_flash_write_byte
 1671               	bv5_flash_write_byte:
 1672               	.LFB40:
 655:setup.c       **** 
 656:setup.c       **** // BV5 - Write a single byte to the Flash address. Time to wait depends on Flash.
 657:setup.c       **** // Data byte's bit 0 & 1 are swapped for chip commands as D0 & D1 lines are swapped
 658:setup.c       **** void bv5_flash_write_byte(uint16_t address, uint8_t data) {
 1673               		.loc 1 658 0
 1674               		.cfi_startproc
 1675               	.LVL135:
 1676 0496 1F93      		push r17
 1677               	.LCFI29:
 1678               		.cfi_def_cfa_offset 3
 1679               		.cfi_offset 17, -2
 1680 0498 CF93      		push r28
 1681               	.LCFI30:
 1682               		.cfi_def_cfa_offset 4
 1683               		.cfi_offset 28, -3
 1684 049a DF93      		push r29
 1685               	.LCFI31:
 1686               		.cfi_def_cfa_offset 5
 1687               		.cfi_offset 29, -4
 1688               	/* prologue: function */
 1689               	/* frame size = 0 */
 1690               	/* stack size = 3 */
 1691               	.L__stack_usage = 3
 1692 049c EC01      		movw r28,r24
 1693 049e 162F      		mov r17,r22
 659:setup.c       **** 	bv5_flash_write_bus_cycle(0xAAA, 0xA9);
 1694               		.loc 1 659 0
 1695 04a0 69EA      		ldi r22,lo8(-87)
 1696               	.LVL136:
 1697 04a2 8AEA      		ldi r24,lo8(-86)
 1698 04a4 9AE0      		ldi r25,lo8(10)
 1699               	.LVL137:
 1700 04a6 00D0      		rcall bv5_flash_write_bus_cycle
 1701               	.LVL138:
 660:setup.c       **** 	bv5_flash_write_bus_cycle(0x555, 0x56);
 1702               		.loc 1 660 0
 1703 04a8 66E5      		ldi r22,lo8(86)
 1704 04aa 85E5      		ldi r24,lo8(85)
 1705 04ac 95E0      		ldi r25,lo8(5)
 1706 04ae 00D0      		rcall bv5_flash_write_bus_cycle
 1707               	.LVL139:
 661:setup.c       **** 	bv5_flash_write_bus_cycle(0xAAA, 0xA0);
 1708               		.loc 1 661 0
 1709 04b0 60EA      		ldi r22,lo8(-96)
 1710 04b2 8AEA      		ldi r24,lo8(-86)
 1711 04b4 9AE0      		ldi r25,lo8(10)
 1712 04b6 00D0      		rcall bv5_flash_write_bus_cycle
 1713               	.LVL140:
 662:setup.c       **** 	bv5_flash_write_bus_cycle(address, data);
 1714               		.loc 1 662 0
 1715 04b8 612F      		mov r22,r17
 1716 04ba CE01      		movw r24,r28
 1717 04bc 00D0      		rcall bv5_flash_write_bus_cycle
 1718               	.LVL141:
 1719               	.LBB83:
 1720               	.LBB84:
 1721               		.loc 2 276 0
 1722 04be 85E3      		ldi r24,lo8(53)
 1723 04c0 8A95      	1:	dec r24
 1724 04c2 01F4      		brne 1b
 1725 04c4 0000      		nop
 1726               	.LVL142:
 1727               	.LBE84:
 1728               	.LBE83:
 663:setup.c       **** 	_delay_us(20); // Wait byte program time
 664:setup.c       **** 	
 665:setup.c       **** 	// Verify data
 666:setup.c       **** 	uint8_t dataVerify = bv5_flash_read_byte(address);
 1729               		.loc 1 666 0
 1730 04c6 CE01      		movw r24,r28
 1731 04c8 00D0      		rcall bv5_flash_read_byte
 1732               	.LVL143:
 1733               	.L76:
 667:setup.c       **** 	while (data != dataVerify) {
 1734               		.loc 1 667 0
 1735 04ca 8117      		cp r24,r17
 1736 04cc 01F0      		breq .L78
 668:setup.c       **** 		dataVerify = bv5_flash_read_byte(address);
 1737               		.loc 1 668 0
 1738 04ce CE01      		movw r24,r28
 1739               	.LVL144:
 1740 04d0 00D0      		rcall bv5_flash_read_byte
 1741               	.LVL145:
 1742               	.LBB85:
 1743               	.LBB86:
 1744               		.loc 2 276 0
 1745 04d2 95E3      		ldi r25,lo8(53)
 1746 04d4 9A95      	1:	dec r25
 1747 04d6 01F4      		brne 1b
 1748 04d8 0000      		nop
 1749 04da 00C0      		rjmp .L76
 1750               	.LVL146:
 1751               	.L78:
 1752               	/* epilogue start */
 1753               	.LBE86:
 1754               	.LBE85:
 669:setup.c       **** 		_delay_us(20);
 670:setup.c       **** 	}
 671:setup.c       **** }
 1755               		.loc 1 671 0
 1756 04dc DF91      		pop r29
 1757 04de CF91      		pop r28
 1758               	.LVL147:
 1759 04e0 1F91      		pop r17
 1760               	.LVL148:
 1761 04e2 0895      		ret
 1762               		.cfi_endproc
 1763               	.LFE40:
 1765               	.global	gba_flash_write_bus_cycle
 1767               	gba_flash_write_bus_cycle:
 1768               	.LFB41:
 672:setup.c       **** 
 673:setup.c       **** 
 674:setup.c       **** // ---------- GBA FLASH CARTS ----------
 675:setup.c       **** 
 676:setup.c       **** // Set the 24 bit address and 16 bit data for the write byte cycle to the flash (pulse WR pin)
 677:setup.c       **** void gba_flash_write_bus_cycle(uint32_t address, uint16_t data) {
 1769               		.loc 1 677 0
 1770               		.cfi_startproc
 1771               	.LVL149:
 1772 04e4 CF93      		push r28
 1773               	.LCFI32:
 1774               		.cfi_def_cfa_offset 3
 1775               		.cfi_offset 28, -2
 1776 04e6 DF93      		push r29
 1777               	.LCFI33:
 1778               		.cfi_def_cfa_offset 4
 1779               		.cfi_offset 29, -3
 1780               	/* prologue: function */
 1781               	/* frame size = 0 */
 1782               	/* stack size = 2 */
 1783               	.L__stack_usage = 2
 1784 04e8 EA01      		movw r28,r20
 678:setup.c       **** 	gba_set_24bit_address(address);
 1785               		.loc 1 678 0
 1786 04ea 00D0      		rcall gba_set_24bit_address
 1787               	.LVL150:
 679:setup.c       **** 	
 680:setup.c       **** 	cs_mreqPin_low;
 1788               		.loc 1 680 0
 1789 04ec 9498      		cbi 0x12,4
 681:setup.c       **** 	
 682:setup.c       **** 	GBA_DDR_ROM_ADDR15_8 = 0xFF; // Set data pins as outputs
 1790               		.loc 1 682 0
 1791 04ee 8FEF      		ldi r24,lo8(-1)
 1792 04f0 8ABB      		out 0x1a,r24
 683:setup.c       **** 	GBA_DDR_ROM_ADDR7_0 = 0xFF;
 1793               		.loc 1 683 0
 1794 04f2 87BB      		out 0x17,r24
 684:setup.c       **** 	GBA_PORT_ROM_DATA15_8 = data >> 8; // Set data
 1795               		.loc 1 684 0
 1796 04f4 DBBB      		out 0x1b,r29
 685:setup.c       **** 	GBA_PORT_ROM_DATA7_0 = data & 0xFF;
 1797               		.loc 1 685 0
 1798 04f6 C8BB      		out 0x18,r28
 686:setup.c       **** 	
 687:setup.c       **** 	wrPin_low;
 1799               		.loc 1 687 0
 1800 04f8 9698      		cbi 0x12,6
 688:setup.c       **** 	asm volatile("nop");
 1801               		.loc 1 688 0
 1802               	/* #APP */
 1803               	 ;  688 "setup.c" 1
 1804 04fa 0000      		nop
 1805               	 ;  0 "" 2
 689:setup.c       **** 	asm volatile("nop");
 1806               		.loc 1 689 0
 1807               	 ;  689 "setup.c" 1
 1808 04fc 0000      		nop
 1809               	 ;  0 "" 2
 690:setup.c       **** 	asm volatile("nop");
 1810               		.loc 1 690 0
 1811               	 ;  690 "setup.c" 1
 1812 04fe 0000      		nop
 1813               	 ;  0 "" 2
 691:setup.c       **** 	wrPin_high;
 1814               		.loc 1 691 0
 1815               	/* #NOAPP */
 1816 0500 969A      		sbi 0x12,6
 692:setup.c       **** 	cs_mreqPin_high;
 1817               		.loc 1 692 0
 1818 0502 949A      		sbi 0x12,4
 1819               	/* epilogue start */
 693:setup.c       **** }
 1820               		.loc 1 693 0
 1821 0504 DF91      		pop r29
 1822 0506 CF91      		pop r28
 1823               	.LVL151:
 1824 0508 0895      		ret
 1825               		.cfi_endproc
 1826               	.LFE41:
 1828               	.global	gba_flash_write_byte_swapped
 1830               	gba_flash_write_byte_swapped:
 1831               	.LFB42:
 694:setup.c       **** 
 695:setup.c       **** // Write 2 bytes to the Flash address. Time to wait depends on Flash, we will query it to verify th
 696:setup.c       **** // Address is divided by 2 as we are in GBA mode. 
 697:setup.c       **** // Data byte's bit 0 & 1 are swapped for chip commands as D0 & D1 lines are swapped
 698:setup.c       **** void gba_flash_write_byte_swapped(uint32_t address, uint16_t data) {
 1832               		.loc 1 698 0
 1833               		.cfi_startproc
 1834               	.LVL152:
 1835 050a CF92      		push r12
 1836               	.LCFI34:
 1837               		.cfi_def_cfa_offset 3
 1838               		.cfi_offset 12, -2
 1839 050c DF92      		push r13
 1840               	.LCFI35:
 1841               		.cfi_def_cfa_offset 4
 1842               		.cfi_offset 13, -3
 1843 050e EF92      		push r14
 1844               	.LCFI36:
 1845               		.cfi_def_cfa_offset 5
 1846               		.cfi_offset 14, -4
 1847 0510 FF92      		push r15
 1848               	.LCFI37:
 1849               		.cfi_def_cfa_offset 6
 1850               		.cfi_offset 15, -5
 1851 0512 CF93      		push r28
 1852               	.LCFI38:
 1853               		.cfi_def_cfa_offset 7
 1854               		.cfi_offset 28, -6
 1855 0514 DF93      		push r29
 1856               	.LCFI39:
 1857               		.cfi_def_cfa_offset 8
 1858               		.cfi_offset 29, -7
 1859               	/* prologue: function */
 1860               	/* frame size = 0 */
 1861               	/* stack size = 6 */
 1862               	.L__stack_usage = 6
 1863 0516 6B01      		movw r12,r22
 1864 0518 7C01      		movw r14,r24
 1865 051a EA01      		movw r28,r20
 699:setup.c       **** 	gba_flash_write_bus_cycle(0xAAA / 2, 0xA9);
 1866               		.loc 1 699 0
 1867 051c 49EA      		ldi r20,lo8(-87)
 1868 051e 50E0      		ldi r21,0
 1869               	.LVL153:
 1870 0520 65E5      		ldi r22,lo8(85)
 1871 0522 75E0      		ldi r23,lo8(5)
 1872 0524 80E0      		ldi r24,0
 1873 0526 90E0      		ldi r25,0
 1874               	.LVL154:
 1875 0528 00D0      		rcall gba_flash_write_bus_cycle
 1876               	.LVL155:
 700:setup.c       **** 	gba_flash_write_bus_cycle(0x555 / 2, 0x56);
 1877               		.loc 1 700 0
 1878 052a 46E5      		ldi r20,lo8(86)
 1879 052c 50E0      		ldi r21,0
 1880 052e 6AEA      		ldi r22,lo8(-86)
 1881 0530 72E0      		ldi r23,lo8(2)
 1882 0532 80E0      		ldi r24,0
 1883 0534 90E0      		ldi r25,0
 1884 0536 00D0      		rcall gba_flash_write_bus_cycle
 1885               	.LVL156:
 701:setup.c       **** 	gba_flash_write_bus_cycle(0xAAA / 2, 0xA0);
 1886               		.loc 1 701 0
 1887 0538 40EA      		ldi r20,lo8(-96)
 1888 053a 50E0      		ldi r21,0
 1889 053c 65E5      		ldi r22,lo8(85)
 1890 053e 75E0      		ldi r23,lo8(5)
 1891 0540 80E0      		ldi r24,0
 1892 0542 90E0      		ldi r25,0
 1893 0544 00D0      		rcall gba_flash_write_bus_cycle
 1894               	.LVL157:
 702:setup.c       **** 	gba_flash_write_bus_cycle(address, data);
 1895               		.loc 1 702 0
 1896 0546 AE01      		movw r20,r28
 1897 0548 C701      		movw r24,r14
 1898 054a B601      		movw r22,r12
 1899 054c 00D0      		rcall gba_flash_write_bus_cycle
 1900               	.LVL158:
 1901               	.LBB87:
 1902               	.LBB88:
 1903               		.loc 2 276 0
 1904 054e 25E3      		ldi r18,lo8(53)
 1905 0550 2A95      	1:	dec r18
 1906 0552 01F4      		brne 1b
 1907 0554 0000      		nop
 1908               	.LVL159:
 1909               	.LBE88:
 1910               	.LBE87:
 703:setup.c       **** 	_delay_us(20); // Wait byte program time
 704:setup.c       **** 	
 705:setup.c       **** 	// Verify data
 706:setup.c       **** 	uint16_t dataVerify = gba_read_16bit_data(address);
 1911               		.loc 1 706 0
 1912 0556 C701      		movw r24,r14
 1913 0558 B601      		movw r22,r12
 1914 055a 00D0      		rcall gba_read_16bit_data
 1915               	.LVL160:
 1916               	.L81:
 707:setup.c       **** 	while (data != dataVerify) {
 1917               		.loc 1 707 0
 1918 055c 8C17      		cp r24,r28
 1919 055e 9D07      		cpc r25,r29
 1920 0560 01F0      		breq .L83
 708:setup.c       **** 		dataVerify = gba_read_16bit_data(address);
 1921               		.loc 1 708 0
 1922 0562 C701      		movw r24,r14
 1923 0564 B601      		movw r22,r12
 1924 0566 00D0      		rcall gba_read_16bit_data
 1925               	.LVL161:
 1926               	.LBB89:
 1927               	.LBB90:
 1928               		.loc 2 276 0
 1929 0568 25E3      		ldi r18,lo8(53)
 1930 056a 2A95      	1:	dec r18
 1931 056c 01F4      		brne 1b
 1932 056e 0000      		nop
 1933 0570 00C0      		rjmp .L81
 1934               	.LVL162:
 1935               	.L83:
 1936               	/* epilogue start */
 1937               	.LBE90:
 1938               	.LBE89:
 709:setup.c       **** 		_delay_us(20);
 710:setup.c       **** 	}
 711:setup.c       **** }
 1939               		.loc 1 711 0
 1940 0572 DF91      		pop r29
 1941 0574 CF91      		pop r28
 1942               	.LVL163:
 1943 0576 FF90      		pop r15
 1944 0578 EF90      		pop r14
 1945 057a DF90      		pop r13
 1946 057c CF90      		pop r12
 1947               	.LVL164:
 1948 057e 0895      		ret
 1949               		.cfi_endproc
 1950               	.LFE42:
 1952               	.global	setup
 1954               	setup:
 1955               	.LFB43:
 712:setup.c       **** 
 713:setup.c       **** 
 714:setup.c       **** // Setup
 715:setup.c       **** void setup(void) {
 1956               		.loc 1 715 0
 1957               		.cfi_startproc
 1958               	/* prologue: function */
 1959               	/* frame size = 0 */
 1960               	/* stack size = 0 */
 1961               	.L__stack_usage = 0
 716:setup.c       **** 	// Turn off watchdog
 717:setup.c       **** 	MCUCSR &= ~(1<<WDRF);
 1962               		.loc 1 717 0
 1963 0580 84B7      		in r24,0x34
 1964 0582 877F      		andi r24,lo8(-9)
 1965 0584 84BF      		out 0x34,r24
 718:setup.c       **** 	WDTCR = (1<<WDCE) | (1<<WDE);
 1966               		.loc 1 718 0
 1967 0586 88E1      		ldi r24,lo8(24)
 1968 0588 81BD      		out 0x21,r24
 719:setup.c       **** 	WDTCR = 0;
 1969               		.loc 1 719 0
 1970 058a 11BC      		out 0x21,__zero_reg__
 720:setup.c       **** 	
 721:setup.c       **** 	// Reset common lines
 722:setup.c       **** 	rd_wr_csmreq_cs2_reset();
 1971               		.loc 1 722 0
 1972 058c 00D0      		rcall rd_wr_csmreq_cs2_reset
 1973               	.LVL165:
 723:setup.c       **** 	
 724:setup.c       **** 	// Set outputs
 725:setup.c       **** 	DDRD |= (1<<ACTIVITY_LED) | (1<<WR_PIN) | (1<<RD_PIN) | (1<<CS_MREQ_PIN) | (1<<LED_5V);
 1974               		.loc 1 725 0
 1975 058e 81B3      		in r24,0x11
 1976 0590 886F      		ori r24,lo8(-8)
 1977 0592 81BB      		out 0x11,r24
 726:setup.c       **** 	DDRE |= (1<<CS2_PIN) | (1<<LED_3V);
 1978               		.loc 1 726 0
 1979 0594 86B1      		in r24,0x6
 1980 0596 8560      		ori r24,lo8(5)
 1981 0598 86B9      		out 0x6,r24
 727:setup.c       **** 	
 728:setup.c       **** 	// Set all pins as inputs
 729:setup.c       **** 	PORT_DATA7_0 = 0;
 1982               		.loc 1 729 0
 1983 059a 15BA      		out 0x15,__zero_reg__
 730:setup.c       **** 	DDR_DATA7_0 = 0;
 1984               		.loc 1 730 0
 1985 059c 14BA      		out 0x14,__zero_reg__
 731:setup.c       **** 	PORT_ADDR7_0 = 0;
 1986               		.loc 1 731 0
 1987 059e 18BA      		out 0x18,__zero_reg__
 732:setup.c       **** 	DDR_ADDR7_0 = 0;
 1988               		.loc 1 732 0
 1989 05a0 17BA      		out 0x17,__zero_reg__
 733:setup.c       **** 	PORT_ADDR15_8 = 0;
 1990               		.loc 1 733 0
 1991 05a2 1BBA      		out 0x1b,__zero_reg__
 734:setup.c       **** 	DDR_ADDR15_8 = 0;
 1992               		.loc 1 734 0
 1993 05a4 1ABA      		out 0x1a,__zero_reg__
 735:setup.c       **** 	
 736:setup.c       **** 	// Light up 3.3V or 5V
 737:setup.c       **** 	if (PIND & (1<<SWITCH_DETECT)) {
 1994               		.loc 1 737 0
 1995 05a6 829B      		sbis 0x10,2
 1996 05a8 00C0      		rjmp .L85
 738:setup.c       **** 		PORTD |= (1<<LED_5V);
 1997               		.loc 1 738 0
 1998 05aa 979A      		sbi 0x12,7
 739:setup.c       **** 		PORTE &= ~(1<<LED_3V);
 1999               		.loc 1 739 0
 2000 05ac 3898      		cbi 0x7,0
 2001 05ae 00C0      		rjmp .L86
 2002               	.L85:
 740:setup.c       **** 	}
 741:setup.c       **** 	else {
 742:setup.c       **** 		PORTE |= (1<<LED_3V);
 2003               		.loc 1 742 0
 2004 05b0 389A      		sbi 0x7,0
 743:setup.c       **** 		PORTD &= ~(1<<LED_5V);
 2005               		.loc 1 743 0
 2006 05b2 9798      		cbi 0x12,7
 2007               	.L86:
 744:setup.c       **** 	}
 745:setup.c       **** 	
 746:setup.c       **** 	// Light LED
 747:setup.c       **** 	PORTD |= (1<<ACTIVITY_LED);
 2008               		.loc 1 747 0
 2009 05b4 939A      		sbi 0x12,3
 2010               	.LVL166:
 2011               	.LBB91:
 2012               	.LBB92:
 187:c:\winavr-20100110\avr\include\util\delay.h **** 
 2013               		.loc 2 187 0
 2014 05b6 2FEF      		ldi r18,lo8(799999)
 2015 05b8 84E3      		ldi r24,hi8(799999)
 2016 05ba 9CE0      		ldi r25,hlo8(799999)
 2017 05bc 2150      	1:	subi r18,1
 2018 05be 8040      		sbci r24,0
 2019 05c0 9040      		sbci r25,0
 2020 05c2 01F4      		brne 1b
 2021 05c4 00C0      		rjmp .
 2022 05c6 0000      		nop
 2023               	.LVL167:
 2024               	.LBE92:
 2025               	.LBE91:
 748:setup.c       **** 	_delay_ms(500);
 749:setup.c       **** 	PORTD &= ~(1<<ACTIVITY_LED);
 2026               		.loc 1 749 0
 2027 05c8 9398      		cbi 0x12,3
 750:setup.c       **** 	
 751:setup.c       **** 	// Setup USART
 752:setup.c       **** 	UBRRL = 0; // 1Mbps Baud rate
 2028               		.loc 1 752 0
 2029 05ca 19B8      		out 0x9,__zero_reg__
 753:setup.c       **** 	sbi(UCSRA, U2X); // Double rate
 2030               		.loc 1 753 0
 2031 05cc 599A      		sbi 0xb,1
 754:setup.c       **** 	sbi(UCSRB, TXEN); // Transmitter enable
 2032               		.loc 1 754 0
 2033 05ce 539A      		sbi 0xa,3
 755:setup.c       **** 	sbi(UCSRB, RXEN); // Receiver enable
 2034               		.loc 1 755 0
 2035 05d0 549A      		sbi 0xa,4
 756:setup.c       **** 	
 757:setup.c       **** 	// Turn on interrupts
 758:setup.c       **** 	sei();
 2036               		.loc 1 758 0
 2037               	/* #APP */
 2038               	 ;  758 "setup.c" 1
 2039 05d2 7894      		sei
 2040               	 ;  0 "" 2
 2041               	/* #NOAPP */
 2042 05d4 0895      		ret
 2043               		.cfi_endproc
 2044               	.LFE43:
 2046               		.section	.text.startup,"ax",@progbits
 2047               	.global	main
 2049               	main:
 2050               	.LFB44:
 2051               		.file 3 "main.c"
   1:main.c        **** /*
   2:main.c        ****  GBxCart RW
   3:main.c        ****  PCB version: 1.1
   4:main.c        ****  Firmware version: R6
   5:main.c        ****  Author: Alex from insideGadgets (www.insidegadgets.com)
   6:main.c        ****  Created: 7/11/2016
   7:main.c        ****  Last Modified: 26/12/2017
   8:main.c        ****  
   9:main.c        ****  GBxCart RW allows you to dump your Gameboy/Gameboy Colour/Gameboy Advance games ROM, save the RAM 
  10:main.c        ****  
  11:main.c        ****  The ATmega8515L talks to the cartridge and interfaces with the CH340G serial to USB converter with
  12:main.c        ****  
  13:main.c        ****  
  14:main.c        ****  Set fuse bits: External 8MHz crystal, divide clock by 8 is off, boot loader is on (512 bytes), BOD
  15:main.c        ****  avrdude -p atmega8515 -c usbasp -U lfuse:w:0xaf:m -U hfuse:w:0xda:m
  16:main.c        ****  
  17:main.c        ****  Program the TinySafeBoot boot loader (modified ASM code, watchdog reset will act as a hardware res
  18:main.c        ****  avrdude -p atmega8515 -c usbasp -U flash:w:GBxCart_RW_v1.1_R3\tsb\tsb_m8515_d0d1_resetwdt.hex
  19:main.c        ****  
  20:main.c        ****  Program GBxCart RW through TinySafeBoot
  21:main.c        ****  tsb com16:57600 fw GBxCart_RW_v1.1_R3\main.hex
  22:main.c        ****  
  23:main.c        ****  Set TinySafeBoot delay time to 25 (T 25), gives ~0.5s in bootloader
  24:main.c        ****  tsb com16:9600 T 25
  25:main.c        ****  
  26:main.c        ****  
  27:main.c        ****  Programming shortcuts (if added in Programmers Notepad):
  28:main.c        ****  Alt + W - Program fuse
  29:main.c        ****  Alt + B - Burn bootloader
  30:main.c        ****  
  31:main.c        ****  Plug in USB then
  32:main.c        ****  Alt + T - Program
  33:main.c        ****  Alt + N - Program delay settings
  34:main.c        ****  
  35:main.c        ****  
  36:main.c        ****  */
  37:main.c        **** 
  38:main.c        **** // ATmega8515L Pin Map
  39:main.c        **** //
  40:main.c        **** // VCC (5)			GND (6)			XTAL (7 ,8)		Activity LED PD3 (9)				Switch sense PD2 (8)
  41:main.c        **** // SCK PB7 (3)		MOSI PB5 (1)	MISO PB6 (2)	RST (4)		RXD PD0 (5)			TXD PD1 (7)
  42:main.c        **** // 
  43:main.c        **** // Gameboy / Gameboy Colour
  44:main.c        **** // A0-A7 PB0-7 (40-44, 1-3) 		A8-A15 PA0-7 (37-30)			D0-D7 PC0-7 (18-25)		Audio PE1 (27)
  45:main.c        **** // 
  46:main.c        **** // Gameboy Advance
  47:main.c        **** // AD0-AD7 PB0-7 (40-44, 1-3) 	AD8-AD15 PA0-7 (37-30)		A16-23 / D0-D7 PC0-7 (19-26)
  48:main.c        **** // *WR PD6 (13)						*RD PD5 (14)					*MREQ/CS PD4 (15)			CS2/RST PE2 (16)
  49:main.c        **** 
  50:main.c        **** #define F_CPU 8000000 // 8 MHz
  51:main.c        **** #define PCB_VERSION 2
  52:main.c        **** #define FIRMWARE_VERSION 6
  53:main.c        **** 
  54:main.c        **** #include <avr/io.h>
  55:main.c        **** #include <avr/wdt.h>
  56:main.c        **** #include <avr/eeprom.h>
  57:main.c        **** #include <avr/interrupt.h>
  58:main.c        **** #include <avr/sleep.h>
  59:main.c        **** #include <util/delay.h>
  60:main.c        **** #include <stdlib.h>
  61:main.c        **** #include <string.h>
  62:main.c        **** #include "setup.c" // See defines, variables, constants, functions here
  63:main.c        **** 
  64:main.c        **** 
  65:main.c        **** int main(void) {
 2052               		.loc 3 65 0
 2053               		.cfi_startproc
 2054               	/* prologue: function */
 2055               	/* frame size = 0 */
 2056               	/* stack size = 0 */
 2057               	.L__stack_usage = 0
  66:main.c        **** 	setup();
 2058               		.loc 3 66 0
 2059 0000 00D0      		rcall setup
 2060               	.LVL168:
  67:main.c        **** 	
  68:main.c        **** 	uint32_t address = 0;
  69:main.c        **** 	uint8_t eepromSize = EEPROM_4KBIT;
  70:main.c        **** 	uint8_t cartMode = GB_MODE;
  71:main.c        **** 	uint8_t resetCommonLines = 1;
 2061               		.loc 3 71 0
 2062 0002 8824      		clr r8
 2063 0004 8394      		inc r8
  69:main.c        **** 	uint8_t cartMode = GB_MODE;
 2064               		.loc 3 69 0
 2065 0006 9924      		clr r9
 2066 0008 9394      		inc r9
  68:main.c        **** 	uint8_t eepromSize = EEPROM_4KBIT;
 2067               		.loc 3 68 0
 2068 000a C12C      		mov r12,__zero_reg__
 2069 000c D12C      		mov r13,__zero_reg__
 2070 000e 7601      		movw r14,r12
 2071 0010 30E0      		ldi r19,lo8(receivedBuffer+64)
 2072 0012 632E      		mov r6,r19
 2073 0014 30E0      		ldi r19,hi8(receivedBuffer+64)
 2074 0016 732E      		mov r7,r19
 2075 0018 00E0      		ldi r16,lo8(eepromBuffer+8)
 2076 001a 10E0      		ldi r17,hi8(eepromBuffer+8)
 2077               	.LVL169:
 2078               	.L88:
  72:main.c        **** 	
  73:main.c        **** 	while(1) {
  74:main.c        **** 		if (resetCommonLines == 1) {
 2079               		.loc 3 74 0
 2080 001c 21E0      		ldi r18,lo8(1)
 2081 001e 8212      		cpse r8,r18
 2082 0020 00C0      		rjmp .L89
 2083               	.LVL170:
 2084               	.L189:
  75:main.c        **** 			rd_wr_csmreq_cs2_reset();
 2085               		.loc 3 75 0
 2086 0022 00D0      		rcall rd_wr_csmreq_cs2_reset
 2087               	.LVL171:
 2088               	.L89:
  76:main.c        **** 		}
  77:main.c        **** 		receivedChar = USART_Receive(); // Wait for 1 byte of data
 2089               		.loc 3 77 0
 2090 0024 00D0      		rcall USART_Receive
 2091               	.LVL172:
 2092 0026 8093 0000 		sts receivedChar,r24
  78:main.c        **** 		
  79:main.c        **** 		// Read the pin to find out which mode we are in, if it reads high, we are powered by 5V
  80:main.c        **** 		if (PIND & (1<<SWITCH_DETECT)) {
 2093               		.loc 3 80 0
 2094 002a 829B      		sbis 0x10,2
 2095 002c 00C0      		rjmp .L90
 2096               	.LVL173:
  81:main.c        **** 			cartMode = GB_MODE;
  82:main.c        **** 			PORTD |= (1<<LED_5V);
 2097               		.loc 3 82 0
 2098 002e 979A      		sbi 0x12,7
  83:main.c        **** 			PORTE &= ~(1<<LED_3V);
 2099               		.loc 3 83 0
 2100 0030 3898      		cbi 0x7,0
  81:main.c        **** 			cartMode = GB_MODE;
 2101               		.loc 3 81 0
 2102 0032 81E0      		ldi r24,lo8(1)
 2103 0034 00C0      		rjmp .L91
 2104               	.LVL174:
 2105               	.L90:
  84:main.c        **** 		}
  85:main.c        **** 		else {
  86:main.c        **** 			cartMode = GBA_MODE;
  87:main.c        **** 			PORTE |= (1<<LED_3V);
 2106               		.loc 3 87 0
 2107 0036 389A      		sbi 0x7,0
  88:main.c        **** 			PORTD &= ~(1<<LED_5V);
 2108               		.loc 3 88 0
 2109 0038 9798      		cbi 0x12,7
  86:main.c        **** 			PORTE |= (1<<LED_3V);
 2110               		.loc 3 86 0
 2111 003a 82E0      		ldi r24,lo8(2)
 2112               	.LVL175:
 2113               	.L91:
  89:main.c        **** 		}
  90:main.c        **** 		
  91:main.c        **** 		// Return the cart mode in use
  92:main.c        **** 		if (receivedChar == CART_MODE) {
 2114               		.loc 3 92 0
 2115 003c 9091 0000 		lds r25,receivedChar
 2116 0040 9334      		cpi r25,lo8(67)
 2117 0042 01F4      		brne .+2
 2118 0044 00C0      		rjmp .L190
  93:main.c        **** 			USART_Transmit(cartMode);
  94:main.c        **** 		}
  95:main.c        **** 		
  96:main.c        **** 		// Change to GB mode or GBA mode if requested
  97:main.c        **** 		else if (receivedChar == GB_CART_MODE) {
 2119               		.loc 3 97 0
 2120 0046 9734      		cpi r25,lo8(71)
 2121 0048 01F4      		brne .L94
  98:main.c        **** 			gb_mode();
 2122               		.loc 3 98 0
 2123 004a 00D0      		rcall gb_mode
 2124               	.LVL176:
 2125 004c 00C0      		rjmp .L88
 2126               	.LVL177:
 2127               	.L94:
  99:main.c        **** 		}
 100:main.c        **** 		else if (receivedChar == GBA_CART_MODE) {
 2128               		.loc 3 100 0
 2129 004e 9736      		cpi r25,lo8(103)
 2130 0050 01F4      		brne .+2
 2131 0052 00C0      		rjmp .L192
 101:main.c        **** 			gba_mode();
 102:main.c        **** 		}
 103:main.c        **** 		
 104:main.c        **** 		// Set address
 105:main.c        **** 		else if (receivedChar == SET_START_ADDRESS) {
 2132               		.loc 3 105 0
 2133 0054 9134      		cpi r25,lo8(65)
 2134 0056 01F4      		brne .L96
 106:main.c        **** 			usart_read_chars(); // Read start address
 2135               		.loc 3 106 0
 2136 0058 00D0      		rcall usart_read_chars
 2137               	.LVL178:
 107:main.c        **** 			address = strtol(receivedBuffer, NULL, 16); // Convert address string in hex to dec
 2138               		.loc 3 107 0
 2139 005a 40E1      		ldi r20,lo8(16)
 2140 005c 50E0      		ldi r21,0
 2141 005e 60E0      		ldi r22,0
 2142 0060 70E0      		ldi r23,0
 2143 0062 80E0      		ldi r24,lo8(receivedBuffer)
 2144 0064 90E0      		ldi r25,hi8(receivedBuffer)
 2145 0066 00D0      		rcall strtol
 2146               	.LVL179:
 2147 0068 6B01      		movw r12,r22
 2148 006a 7C01      		movw r14,r24
 2149               	.LVL180:
 2150 006c 00C0      		rjmp .L88
 2151               	.LVL181:
 2152               	.L96:
 108:main.c        **** 		}
 109:main.c        **** 		
 110:main.c        **** 		
 111:main.c        **** 		// ****** Gameboy / Gameboy Colour ******
 112:main.c        **** 		
 113:main.c        **** 		// Read 64 bytes of ROM/RAM from address (and increment) until anything but 1 is received
 114:main.c        **** 		else if (receivedChar == READ_ROM_RAM) {
 2153               		.loc 3 114 0
 2154 006e 9235      		cpi r25,lo8(82)
 2155 0070 01F4      		brne .L97
 115:main.c        **** 			gb_mode();
 2156               		.loc 3 115 0
 2157 0072 00D0      		rcall gb_mode
 2158               	.LVL182:
 116:main.c        **** 			receivedChar = '1';
 2159               		.loc 3 116 0
 2160 0074 81E3      		ldi r24,lo8(49)
 2161               	.LVL183:
 2162               	.L195:
 117:main.c        **** 			while (receivedChar == '1') {
 118:main.c        **** 				PORTD |= (1<<ACTIVITY_LED);
 119:main.c        **** 				for (uint8_t x = 0; x < 64; x++) {
 120:main.c        **** 					USART_Transmit(read_8bit_data(address));
 121:main.c        **** 					address++;
 122:main.c        **** 				}
 123:main.c        **** 				
 124:main.c        **** 				PORTD &= ~(1<<ACTIVITY_LED);
 125:main.c        **** 				receivedChar = USART_Receive();
 2163               		.loc 3 125 0
 2164 0076 8093 0000 		sts receivedChar,r24
 2165               	.LVL184:
 117:main.c        **** 			while (receivedChar == '1') {
 2166               		.loc 3 117 0
 2167 007a 8091 0000 		lds r24,receivedChar
 2168 007e 8133      		cpi r24,lo8(49)
 2169 0080 01F4      		brne .L88
 118:main.c        **** 				for (uint8_t x = 0; x < 64; x++) {
 2170               		.loc 3 118 0
 2171 0082 939A      		sbi 0x12,3
 2172               	.LVL185:
 2173 0084 C0E0      		ldi r28,0
 2174 0086 D0E0      		ldi r29,0
 2175               	.LVL186:
 2176               	.L99:
 2177               	.LBB93:
 120:main.c        **** 					address++;
 2178               		.loc 3 120 0 discriminator 3
 2179 0088 CE01      		movw r24,r28
 2180 008a 8C0D      		add r24,r12
 2181 008c 9D1D      		adc r25,r13
 2182 008e 00D0      		rcall read_8bit_data
 2183               	.LVL187:
 2184 0090 00D0      		rcall USART_Transmit
 2185               	.LVL188:
 2186 0092 2196      		adiw r28,1
 2187               	.LVL189:
 119:main.c        **** 					USART_Transmit(read_8bit_data(address));
 2188               		.loc 3 119 0 discriminator 3
 2189 0094 C034      		cpi r28,64
 2190 0096 D105      		cpc r29,__zero_reg__
 2191 0098 01F4      		brne .L99
 2192 009a 80E4      		ldi r24,64
 2193 009c C80E      		add r12,r24
 2194 009e D11C      		adc r13,__zero_reg__
 2195 00a0 E11C      		adc r14,__zero_reg__
 2196 00a2 F11C      		adc r15,__zero_reg__
 2197               	.LBE93:
 124:main.c        **** 				receivedChar = USART_Receive();
 2198               		.loc 3 124 0
 2199 00a4 9398      		cbi 0x12,3
 2200               		.loc 3 125 0
 2201 00a6 00D0      		rcall USART_Receive
 2202               	.LVL190:
 2203 00a8 00C0      		rjmp .L195
 2204               	.LVL191:
 2205               	.L97:
 126:main.c        **** 			}
 127:main.c        **** 		}
 128:main.c        **** 		
 129:main.c        **** 		// Write 64 bytes to RAM on address (and increment)
 130:main.c        **** 		else if (receivedChar == WRITE_RAM) {
 2206               		.loc 3 130 0
 2207 00aa 9735      		cpi r25,lo8(87)
 2208 00ac 01F4      		brne .L101
 131:main.c        **** 			gb_mode();
 2209               		.loc 3 131 0
 2210 00ae 00D0      		rcall gb_mode
 2211               	.LVL192:
 132:main.c        **** 			
 133:main.c        **** 			// Read 64 bytes first as CH340G sends them all at once
 134:main.c        **** 			usart_read_bytes(64);
 2212               		.loc 3 134 0
 2213 00b0 80E4      		ldi r24,lo8(64)
 2214 00b2 00D0      		rcall usart_read_bytes
 2215               	.LVL193:
 135:main.c        **** 			
 136:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 2216               		.loc 3 136 0
 2217 00b4 939A      		sbi 0x12,3
 2218               	.LVL194:
 2219 00b6 C0E0      		ldi r28,lo8(receivedBuffer)
 2220 00b8 D0E0      		ldi r29,hi8(receivedBuffer)
 2221 00ba A12C      		mov r10,__zero_reg__
 2222 00bc B12C      		mov r11,__zero_reg__
 2223               	.LVL195:
 2224               	.L102:
 2225               	.LBB94:
 137:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 138:main.c        **** 				write_8bit_data(address, receivedBuffer[x], MEMORY_WRITE);
 2226               		.loc 3 138 0 discriminator 3
 2227 00be 6991      		ld r22,Y+
 2228 00c0 C501      		movw r24,r10
 2229 00c2 8C0D      		add r24,r12
 2230 00c4 9D1D      		adc r25,r13
 2231 00c6 41E0      		ldi r20,lo8(1)
 2232 00c8 00D0      		rcall write_8bit_data
 2233               	.LVL196:
 2234 00ca 9FEF      		ldi r25,-1
 2235 00cc A91A      		sub r10,r25
 2236 00ce B90A      		sbc r11,r25
 2237               	.LVL197:
 137:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 2238               		.loc 3 137 0 discriminator 3
 2239 00d0 E0E4      		ldi r30,64
 2240 00d2 AE16      		cp r10,r30
 2241 00d4 B104      		cpc r11,__zero_reg__
 2242 00d6 01F4      		brne .L102
 2243 00d8 F0E4      		ldi r31,64
 2244 00da CF0E      		add r12,r31
 2245 00dc D11C      		adc r13,__zero_reg__
 2246 00de E11C      		adc r14,__zero_reg__
 2247 00e0 F11C      		adc r15,__zero_reg__
 2248 00e2 00C0      		rjmp .L212
 2249               	.LVL198:
 2250               	.L101:
 2251               	.LBE94:
 139:main.c        **** 				address++;
 140:main.c        **** 			}
 141:main.c        **** 			
 142:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 143:main.c        **** 			USART_Transmit('1'); // Send back acknowledgement
 144:main.c        **** 		}
 145:main.c        **** 		
 146:main.c        **** 		// Set bank address and write a byte
 147:main.c        **** 		else if (receivedChar == SET_BANK) {
 2252               		.loc 3 147 0
 2253 00e4 9234      		cpi r25,lo8(66)
 2254 00e6 01F4      		brne .L103
 2255               	.LBB95:
 148:main.c        **** 			gb_mode();
 2256               		.loc 3 148 0
 2257 00e8 00D0      		rcall gb_mode
 2258               	.LVL199:
 149:main.c        **** 			
 150:main.c        **** 			usart_read_chars(); // Read start address
 2259               		.loc 3 150 0
 2260 00ea 00D0      		rcall usart_read_chars
 2261               	.LVL200:
 151:main.c        **** 			uint16_t bankaddress = strtol(receivedBuffer, NULL, 16); // Convert address string in hex to dec
 2262               		.loc 3 151 0
 2263 00ec 40E1      		ldi r20,lo8(16)
 2264 00ee 50E0      		ldi r21,0
 2265 00f0 60E0      		ldi r22,0
 2266 00f2 70E0      		ldi r23,0
 2267 00f4 80E0      		ldi r24,lo8(receivedBuffer)
 2268 00f6 90E0      		ldi r25,hi8(receivedBuffer)
 2269 00f8 00D0      		rcall strtol
 2270               	.LVL201:
 2271 00fa 1B01      		movw r2,r22
 2272 00fc 2C01      		movw r4,r24
 2273               	.LVL202:
 152:main.c        **** 			
 153:main.c        **** 			receivedChar = USART_Receive(); // Wait for bank number
 2274               		.loc 3 153 0
 2275 00fe 00D0      		rcall USART_Receive
 2276               	.LVL203:
 2277 0100 8093 0000 		sts receivedChar,r24
 154:main.c        **** 			if (receivedChar == 'B') {
 2278               		.loc 3 154 0
 2279 0104 8234      		cpi r24,lo8(66)
 2280 0106 01F0      		breq .+2
 2281 0108 00C0      		rjmp .L88
 2282               	.LBB96:
 155:main.c        **** 				usart_read_chars(); // Read data
 2283               		.loc 3 155 0
 2284 010a 00D0      		rcall usart_read_chars
 2285               	.LVL204:
 156:main.c        **** 				uint8_t data = atoi(receivedBuffer); // Convert data string to dec
 2286               		.loc 3 156 0
 2287 010c 80E0      		ldi r24,lo8(receivedBuffer)
 2288 010e 90E0      		ldi r25,hi8(receivedBuffer)
 2289 0110 00D0      		rcall atoi
 2290               	.LVL205:
 157:main.c        **** 				
 158:main.c        **** 				write_8bit_data(bankaddress, data, BANK_WRITE);
 2291               		.loc 3 158 0
 2292 0112 40E0      		ldi r20,0
 2293 0114 682F      		mov r22,r24
 2294 0116 C101      		movw r24,r2
 2295               	.LVL206:
 2296 0118 00D0      		rcall write_8bit_data
 2297               	.LVL207:
 2298 011a 00C0      		rjmp .L88
 2299               	.LVL208:
 2300               	.L103:
 2301               	.LBE96:
 2302               	.LBE95:
 159:main.c        **** 			}
 160:main.c        **** 		}
 161:main.c        **** 		
 162:main.c        **** 		
 163:main.c        **** 		// ****** Gameboy Advance ******
 164:main.c        **** 		
 165:main.c        **** 		// ---------- ROM ----------
 166:main.c        **** 		// Read one 16bit byte from ROM using address (and increment) until anything but 1 is received
 167:main.c        **** 		else if (receivedChar == GBA_READ_ROM) {
 2303               		.loc 3 167 0
 2304 011c 9237      		cpi r25,lo8(114)
 2305 011e 01F4      		brne .L104
 168:main.c        **** 			gba_mode(); 
 2306               		.loc 3 168 0
 2307 0120 00D0      		rcall gba_mode
 2308               	.LVL209:
 169:main.c        **** 			
 170:main.c        **** 			receivedChar = '1';
 2309               		.loc 3 170 0
 2310 0122 81E3      		ldi r24,lo8(49)
 2311               	.LVL210:
 2312               	.L196:
 171:main.c        **** 			while (receivedChar == '1') {
 172:main.c        **** 				PORTD |= (1<<ACTIVITY_LED);
 173:main.c        **** 				for (uint8_t x = 0; x < 32; x++) {
 174:main.c        **** 					uint16_t dataRead = gba_read_16bit_data(address);
 175:main.c        **** 					
 176:main.c        **** 					// Low byte & High byte
 177:main.c        **** 					USART_Transmit(dataRead & 0xFF);
 178:main.c        **** 					USART_Transmit(dataRead >> 8);
 179:main.c        **** 					
 180:main.c        **** 					address++;
 181:main.c        **** 				}
 182:main.c        **** 				
 183:main.c        **** 				PORTD &= ~(1<<ACTIVITY_LED);
 184:main.c        **** 				receivedChar = USART_Receive();
 2313               		.loc 3 184 0
 2314 0124 8093 0000 		sts receivedChar,r24
 2315               	.LVL211:
 171:main.c        **** 			while (receivedChar == '1') {
 2316               		.loc 3 171 0
 2317 0128 8091 0000 		lds r24,receivedChar
 2318 012c 8133      		cpi r24,lo8(49)
 2319 012e 01F0      		breq .+2
 2320 0130 00C0      		rjmp .L88
 172:main.c        **** 				for (uint8_t x = 0; x < 32; x++) {
 2321               		.loc 3 172 0
 2322 0132 939A      		sbi 0x12,3
 2323               	.LVL212:
 2324 0134 1601      		movw r2,r12
 2325 0136 2701      		movw r4,r14
 2326 0138 C0E2      		ldi r28,lo8(32)
 2327               	.LVL213:
 2328               	.L106:
 2329               	.LBB97:
 2330               	.LBB98:
 174:main.c        **** 					
 2331               		.loc 3 174 0 discriminator 3
 2332 013a C201      		movw r24,r4
 2333 013c B101      		movw r22,r2
 2334 013e 00D0      		rcall gba_read_16bit_data
 2335               	.LVL214:
 2336 0140 D92F      		mov r29,r25
 2337               	.LVL215:
 177:main.c        **** 					USART_Transmit(dataRead >> 8);
 2338               		.loc 3 177 0 discriminator 3
 2339 0142 00D0      		rcall USART_Transmit
 2340               	.LVL216:
 178:main.c        **** 					
 2341               		.loc 3 178 0 discriminator 3
 2342 0144 8D2F      		mov r24,r29
 2343 0146 00D0      		rcall USART_Transmit
 2344               	.LVL217:
 180:main.c        **** 				}
 2345               		.loc 3 180 0 discriminator 3
 2346 0148 2FEF      		ldi r18,-1
 2347 014a 221A      		sub r2,r18
 2348 014c 320A      		sbc r3,r18
 2349 014e 420A      		sbc r4,r18
 2350 0150 520A      		sbc r5,r18
 2351               	.LVL218:
 2352 0152 C150      		subi r28,lo8(-(-1))
 2353               	.LBE98:
 173:main.c        **** 					uint16_t dataRead = gba_read_16bit_data(address);
 2354               		.loc 3 173 0 discriminator 3
 2355 0154 01F4      		brne .L106
 2356 0156 80E2      		ldi r24,32
 2357 0158 C80E      		add r12,r24
 2358 015a D11C      		adc r13,__zero_reg__
 2359 015c E11C      		adc r14,__zero_reg__
 2360 015e F11C      		adc r15,__zero_reg__
 2361               	.LVL219:
 2362               	.LBE97:
 183:main.c        **** 				receivedChar = USART_Receive();
 2363               		.loc 3 183 0
 2364 0160 9398      		cbi 0x12,3
 2365               		.loc 3 184 0
 2366 0162 00D0      		rcall USART_Receive
 2367               	.LVL220:
 2368 0164 00C0      		rjmp .L196
 2369               	.LVL221:
 2370               	.L104:
 185:main.c        **** 			}
 186:main.c        **** 		}
 187:main.c        **** 		
 188:main.c        **** 		
 189:main.c        **** 		// ---------- SRAM ----------
 190:main.c        **** 		// Read RAM from address (and increment) until anything but 1 is received
 191:main.c        **** 		else if (receivedChar == GBA_READ_SRAM) {
 2371               		.loc 3 191 0
 2372 0166 9D36      		cpi r25,lo8(109)
 2373 0168 01F4      		brne .L108
 192:main.c        **** 			gb_mode(); // Set GB mode as it uses 16 bit address with 8 bit data
 2374               		.loc 3 192 0
 2375 016a 00D0      		rcall gb_mode
 2376               	.LVL222:
 193:main.c        **** 			
 194:main.c        **** 			receivedChar = '1';
 2377               		.loc 3 194 0
 2378 016c 81E3      		ldi r24,lo8(49)
 2379               	.LVL223:
 2380               	.L197:
 195:main.c        **** 			while (receivedChar == '1') {
 196:main.c        **** 				PORTD |= (1<<ACTIVITY_LED);
 197:main.c        **** 				for (uint8_t x = 0; x < 64; x++) {
 198:main.c        **** 					USART_Transmit(gba_read_ram_8bit_data(address));
 199:main.c        **** 					address++;
 200:main.c        **** 				}
 201:main.c        **** 				
 202:main.c        **** 				PORTD &= ~(1<<ACTIVITY_LED);
 203:main.c        **** 				receivedChar = USART_Receive();
 2381               		.loc 3 203 0
 2382 016e 8093 0000 		sts receivedChar,r24
 2383               	.LVL224:
 195:main.c        **** 			while (receivedChar == '1') {
 2384               		.loc 3 195 0
 2385 0172 8091 0000 		lds r24,receivedChar
 2386 0176 8133      		cpi r24,lo8(49)
 2387 0178 01F4      		brne .L192
 196:main.c        **** 				for (uint8_t x = 0; x < 64; x++) {
 2388               		.loc 3 196 0
 2389 017a 939A      		sbi 0x12,3
 2390               	.LVL225:
 2391 017c C0E0      		ldi r28,0
 2392 017e D0E0      		ldi r29,0
 2393               	.LVL226:
 2394               	.L110:
 2395               	.LBB99:
 198:main.c        **** 					address++;
 2396               		.loc 3 198 0 discriminator 3
 2397 0180 CE01      		movw r24,r28
 2398 0182 8C0D      		add r24,r12
 2399 0184 9D1D      		adc r25,r13
 2400 0186 00D0      		rcall gba_read_ram_8bit_data
 2401               	.LVL227:
 2402 0188 00D0      		rcall USART_Transmit
 2403               	.LVL228:
 2404 018a 2196      		adiw r28,1
 2405               	.LVL229:
 197:main.c        **** 					USART_Transmit(gba_read_ram_8bit_data(address));
 2406               		.loc 3 197 0 discriminator 3
 2407 018c C034      		cpi r28,64
 2408 018e D105      		cpc r29,__zero_reg__
 2409 0190 01F4      		brne .L110
 2410 0192 90E4      		ldi r25,64
 2411 0194 C90E      		add r12,r25
 2412 0196 D11C      		adc r13,__zero_reg__
 2413 0198 E11C      		adc r14,__zero_reg__
 2414 019a F11C      		adc r15,__zero_reg__
 2415               	.LBE99:
 202:main.c        **** 				receivedChar = USART_Receive();
 2416               		.loc 3 202 0
 2417 019c 9398      		cbi 0x12,3
 2418               		.loc 3 203 0
 2419 019e 00D0      		rcall USART_Receive
 2420               	.LVL230:
 2421 01a0 00C0      		rjmp .L197
 2422               	.LVL231:
 2423               	.L108:
 204:main.c        **** 			}
 205:main.c        **** 			
 206:main.c        **** 			gba_mode(); // Set back
 207:main.c        **** 		}
 208:main.c        **** 		
 209:main.c        **** 		// Write to RAM on address (and increment) with 64 bytes of data
 210:main.c        **** 		else if (receivedChar == GBA_WRITE_SRAM) {
 2424               		.loc 3 210 0
 2425 01a2 9737      		cpi r25,lo8(119)
 2426 01a4 01F4      		brne .L112
 211:main.c        **** 			gb_mode();
 2427               		.loc 3 211 0
 2428 01a6 00D0      		rcall gb_mode
 2429               	.LVL232:
 212:main.c        **** 			
 213:main.c        **** 			usart_read_bytes(64);
 2430               		.loc 3 213 0
 2431 01a8 80E4      		ldi r24,lo8(64)
 2432 01aa 00D0      		rcall usart_read_bytes
 2433               	.LVL233:
 214:main.c        **** 			
 215:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 2434               		.loc 3 215 0
 2435 01ac 939A      		sbi 0x12,3
 2436               	.LVL234:
 2437 01ae C0E0      		ldi r28,lo8(receivedBuffer)
 2438 01b0 D0E0      		ldi r29,hi8(receivedBuffer)
 2439 01b2 A12C      		mov r10,__zero_reg__
 2440 01b4 B12C      		mov r11,__zero_reg__
 2441               	.LVL235:
 2442               	.L113:
 2443               	.LBB100:
 216:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 217:main.c        **** 				gba_write_ram_8bit_data(address, receivedBuffer[x]);
 2444               		.loc 3 217 0 discriminator 3
 2445 01b6 6991      		ld r22,Y+
 2446 01b8 C501      		movw r24,r10
 2447 01ba 8C0D      		add r24,r12
 2448 01bc 9D1D      		adc r25,r13
 2449 01be 00D0      		rcall gba_write_ram_8bit_data
 2450               	.LVL236:
 2451 01c0 EFEF      		ldi r30,-1
 2452 01c2 AE1A      		sub r10,r30
 2453 01c4 BE0A      		sbc r11,r30
 2454               	.LVL237:
 216:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 2455               		.loc 3 216 0 discriminator 3
 2456 01c6 F0E4      		ldi r31,64
 2457 01c8 AF16      		cp r10,r31
 2458 01ca B104      		cpc r11,__zero_reg__
 2459 01cc 01F4      		brne .L113
 2460 01ce 20E4      		ldi r18,64
 2461 01d0 C20E      		add r12,r18
 2462 01d2 D11C      		adc r13,__zero_reg__
 2463 01d4 E11C      		adc r14,__zero_reg__
 2464 01d6 F11C      		adc r15,__zero_reg__
 2465               	.LVL238:
 2466               	.L194:
 2467               	.LBE100:
 218:main.c        **** 				address++;
 219:main.c        **** 			}
 220:main.c        **** 			USART_Transmit('1'); // Send back acknowledgement
 2468               		.loc 3 220 0
 2469 01d8 81E3      		ldi r24,lo8(49)
 2470 01da 00D0      		rcall USART_Transmit
 2471               	.LVL239:
 221:main.c        **** 			
 222:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 2472               		.loc 3 222 0
 2473 01dc 9398      		cbi 0x12,3
 2474               	.L192:
 223:main.c        **** 			gba_mode(); // Set back
 2475               		.loc 3 223 0
 2476 01de 00D0      		rcall gba_mode
 2477               	.LVL240:
 2478 01e0 00C0      		rjmp .L88
 2479               	.LVL241:
 2480               	.L112:
 224:main.c        **** 		}
 225:main.c        **** 		
 226:main.c        **** 		// Write 1 byte to SRAM address
 227:main.c        **** 		else if (receivedChar == GBA_WRITE_ONE_BYTE_SRAM) {
 2481               		.loc 3 227 0
 2482 01e2 9F36      		cpi r25,lo8(111)
 2483 01e4 01F4      		brne .L114
 2484               	.LBB101:
 228:main.c        **** 			gb_mode();
 2485               		.loc 3 228 0
 2486 01e6 00D0      		rcall gb_mode
 2487               	.LVL242:
 229:main.c        **** 			
 230:main.c        **** 			uint8_t data = USART_Receive();
 2488               		.loc 3 230 0
 2489 01e8 00D0      		rcall USART_Receive
 2490               	.LVL243:
 231:main.c        **** 			gba_write_ram_8bit_data(address, data);
 2491               		.loc 3 231 0
 2492 01ea 682F      		mov r22,r24
 2493 01ec C601      		movw r24,r12
 2494               	.LVL244:
 2495 01ee 00D0      		rcall gba_write_ram_8bit_data
 2496               	.LVL245:
 2497 01f0 00C0      		rjmp .L199
 2498               	.LVL246:
 2499               	.L114:
 2500               	.LBE101:
 232:main.c        **** 			USART_Transmit('1'); // Send back acknowledgement
 233:main.c        **** 			
 234:main.c        **** 			gba_mode(); // Set back
 235:main.c        **** 		}
 236:main.c        **** 		
 237:main.c        **** 		
 238:main.c        **** 		// ---------- FLASH ----------
 239:main.c        **** 		// Read the Flash Manufacturer and Device ID
 240:main.c        **** 		else if (receivedChar == GBA_FLASH_READ_ID) {
 2501               		.loc 3 240 0
 2502 01f2 9936      		cpi r25,lo8(105)
 2503 01f4 01F4      		brne .L115
 241:main.c        **** 			gb_mode();
 2504               		.loc 3 241 0
 2505 01f6 00D0      		rcall gb_mode
 2506               	.LVL247:
 242:main.c        **** 			
 243:main.c        **** 			flash_read_chip_id();
 2507               		.loc 3 243 0
 2508 01f8 00D0      		rcall flash_read_chip_id
 2509               	.LVL248:
 244:main.c        **** 			USART_Transmit(flashChipIdBuffer[0]);
 2510               		.loc 3 244 0
 2511 01fa 8091 0000 		lds r24,flashChipIdBuffer
 2512 01fe 00D0      		rcall USART_Transmit
 2513               	.LVL249:
 245:main.c        **** 			USART_Transmit(flashChipIdBuffer[1]);
 2514               		.loc 3 245 0
 2515 0200 8091 0000 		lds r24,flashChipIdBuffer+1
 2516               	.L198:
 2517 0204 00D0      		rcall USART_Transmit
 2518               	.LVL250:
 2519 0206 00C0      		rjmp .L192
 2520               	.LVL251:
 2521               	.L115:
 246:main.c        **** 			
 247:main.c        **** 			gba_mode(); // Set back
 248:main.c        **** 		}
 249:main.c        **** 		
 250:main.c        **** 		// Change bank
 251:main.c        **** 		else if (receivedChar == GBA_FLASH_SET_BANK) {
 2522               		.loc 3 251 0
 2523 0208 9B36      		cpi r25,lo8(107)
 2524 020a 01F4      		brne .L116
 2525               	.LBB102:
 252:main.c        **** 			usart_read_chars(); // Read data
 2526               		.loc 3 252 0
 2527 020c 00D0      		rcall usart_read_chars
 2528               	.LVL252:
 253:main.c        **** 			uint8_t bank = atoi(receivedBuffer); // Convert data string to dec
 2529               		.loc 3 253 0
 2530 020e 80E0      		ldi r24,lo8(receivedBuffer)
 2531 0210 90E0      		ldi r25,hi8(receivedBuffer)
 2532 0212 00D0      		rcall atoi
 2533               	.LVL253:
 2534 0214 C82F      		mov r28,r24
 2535               	.LVL254:
 254:main.c        **** 			
 255:main.c        **** 			gb_mode();
 2536               		.loc 3 255 0
 2537 0216 00D0      		rcall gb_mode
 2538               	.LVL255:
 256:main.c        **** 			flash_switch_bank(bank);
 2539               		.loc 3 256 0
 2540 0218 8C2F      		mov r24,r28
 2541 021a 00D0      		rcall flash_switch_bank
 2542               	.LVL256:
 2543 021c 00C0      		rjmp .L192
 2544               	.LVL257:
 2545               	.L116:
 2546               	.LBE102:
 257:main.c        **** 			
 258:main.c        **** 			gba_mode(); // Set back
 259:main.c        **** 		}
 260:main.c        **** 		
 261:main.c        **** 		// Erase 4K sector on Flash (sector 0 to 15 for 512Kbit)
 262:main.c        **** 		else if (receivedChar == GBA_FLASH_4K_SECTOR_ERASE) {
 2547               		.loc 3 262 0
 2548 021e 9337      		cpi r25,lo8(115)
 2549 0220 01F4      		brne .L117
 2550               	.LBB103:
 263:main.c        **** 			gb_mode();
 2551               		.loc 3 263 0
 2552 0222 00D0      		rcall gb_mode
 2553               	.LVL258:
 264:main.c        **** 			
 265:main.c        **** 			usart_read_chars(); // Read sector
 2554               		.loc 3 265 0
 2555 0224 00D0      		rcall usart_read_chars
 2556               	.LVL259:
 266:main.c        **** 			uint8_t sectorAddress = strtol(receivedBuffer, NULL, 16); // Convert address string in hex to de
 2557               		.loc 3 266 0
 2558 0226 40E1      		ldi r20,lo8(16)
 2559 0228 50E0      		ldi r21,0
 2560 022a 60E0      		ldi r22,0
 2561 022c 70E0      		ldi r23,0
 2562 022e 80E0      		ldi r24,lo8(receivedBuffer)
 2563 0230 90E0      		ldi r25,hi8(receivedBuffer)
 2564 0232 00D0      		rcall strtol
 2565               	.LVL260:
 2566 0234 862F      		mov r24,r22
 2567               	.LVL261:
 267:main.c        **** 			
 268:main.c        **** 			flash_erase_4k_sector(sectorAddress);
 2568               		.loc 3 268 0
 2569 0236 00D0      		rcall flash_erase_4k_sector
 2570               	.LVL262:
 2571               	.L199:
 269:main.c        **** 			USART_Transmit('1'); // Send back acknowledgement
 2572               		.loc 3 269 0
 2573 0238 81E3      		ldi r24,lo8(49)
 2574 023a 00C0      		rjmp .L198
 2575               	.LVL263:
 2576               	.L117:
 2577               	.LBE103:
 270:main.c        **** 			
 271:main.c        **** 			gba_mode(); // Set back
 272:main.c        **** 		}
 273:main.c        **** 		
 274:main.c        **** 		// Write 64 bytes to Flash address one byte write at a time (and increment)
 275:main.c        **** 		else if (receivedChar == GBA_FLASH_WRITE_BYTE) {
 2578               		.loc 3 275 0
 2579 023c 9236      		cpi r25,lo8(98)
 2580 023e 01F4      		brne .L118
 276:main.c        **** 			gb_mode();
 2581               		.loc 3 276 0
 2582 0240 00D0      		rcall gb_mode
 2583               	.LVL264:
 277:main.c        **** 			
 278:main.c        **** 			usart_read_bytes(64);
 2584               		.loc 3 278 0
 2585 0242 80E4      		ldi r24,lo8(64)
 2586 0244 00D0      		rcall usart_read_bytes
 2587               	.LVL265:
 279:main.c        **** 			
 280:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 2588               		.loc 3 280 0
 2589 0246 939A      		sbi 0x12,3
 2590               	.LVL266:
 2591 0248 20E0      		ldi r18,lo8(receivedBuffer)
 2592 024a A22E      		mov r10,r18
 2593 024c 20E0      		ldi r18,hi8(receivedBuffer)
 2594 024e B22E      		mov r11,r18
 2595 0250 C0E0      		ldi r28,0
 2596 0252 D0E0      		ldi r29,0
 2597               	.LVL267:
 2598               	.L119:
 2599               	.LBB104:
 281:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 282:main.c        **** 				flash_write_byte(address, receivedBuffer[x]);
 2600               		.loc 3 282 0 discriminator 3
 2601 0254 F501      		movw r30,r10
 2602 0256 6191      		ld r22,Z+
 2603 0258 5F01      		movw r10,r30
 2604 025a CE01      		movw r24,r28
 2605 025c 8C0D      		add r24,r12
 2606 025e 9D1D      		adc r25,r13
 2607 0260 00D0      		rcall flash_write_byte
 2608               	.LVL268:
 2609 0262 2196      		adiw r28,1
 2610               	.LVL269:
 281:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 2611               		.loc 3 281 0 discriminator 3
 2612 0264 C034      		cpi r28,64
 2613 0266 D105      		cpc r29,__zero_reg__
 2614 0268 01F4      		brne .L119
 2615 026a F0E4      		ldi r31,64
 2616 026c CF0E      		add r12,r31
 2617 026e D11C      		adc r13,__zero_reg__
 2618 0270 E11C      		adc r14,__zero_reg__
 2619 0272 F11C      		adc r15,__zero_reg__
 2620 0274 00C0      		rjmp .L194
 2621               	.LVL270:
 2622               	.L118:
 2623               	.LBE104:
 283:main.c        **** 				address++;
 284:main.c        **** 			}
 285:main.c        **** 			USART_Transmit('1'); // Send back acknowledgement
 286:main.c        **** 			
 287:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 288:main.c        **** 			gba_mode(); // Set back
 289:main.c        **** 		}
 290:main.c        **** 		
 291:main.c        **** 		// Write 128 bytes to flash sector for Atmel flash (and increment)
 292:main.c        **** 		else if (receivedChar == GBA_FLASH_WRITE_ATMEL) {
 2624               		.loc 3 292 0
 2625 0276 9136      		cpi r25,lo8(97)
 2626 0278 01F4      		brne .L120
 293:main.c        **** 			gb_mode();
 2627               		.loc 3 293 0
 2628 027a 00D0      		rcall gb_mode
 2629               	.LVL271:
 294:main.c        **** 			
 295:main.c        **** 			usart_read_bytes(128);
 2630               		.loc 3 295 0
 2631 027c 80E8      		ldi r24,lo8(-128)
 2632 027e 00D0      		rcall usart_read_bytes
 2633               	.LVL272:
 296:main.c        **** 			
 297:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 2634               		.loc 3 297 0
 2635 0280 939A      		sbi 0x12,3
 298:main.c        **** 			flash_write_sector(address); // Address used as sector number
 2636               		.loc 3 298 0
 2637 0282 C601      		movw r24,r12
 2638 0284 00D0      		rcall flash_write_sector
 2639               	.LVL273:
 299:main.c        **** 			address++;
 2640               		.loc 3 299 0
 2641 0286 2FEF      		ldi r18,-1
 2642 0288 C21A      		sub r12,r18
 2643 028a D20A      		sbc r13,r18
 2644 028c E20A      		sbc r14,r18
 2645 028e F20A      		sbc r15,r18
 2646               	.LVL274:
 2647 0290 00C0      		rjmp .L194
 2648               	.LVL275:
 2649               	.L120:
 300:main.c        **** 			USART_Transmit('1'); // Send back acknowledgement
 301:main.c        **** 			
 302:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 303:main.c        **** 			gba_mode(); // Set back
 304:main.c        **** 		}
 305:main.c        **** 		
 306:main.c        **** 		
 307:main.c        **** 		// ---------- EEPROM ----------
 308:main.c        **** 		// Set EEPROM size
 309:main.c        **** 		else if (receivedChar == GBA_SET_EEPROM_SIZE) {
 2650               		.loc 3 309 0
 2651 0292 9335      		cpi r25,lo8(83)
 2652 0294 01F4      		brne .L121
 310:main.c        **** 			usart_read_chars(); // Read size
 2653               		.loc 3 310 0
 2654 0296 00D0      		rcall usart_read_chars
 2655               	.LVL276:
 311:main.c        **** 			eepromSize = strtol(receivedBuffer, NULL, 16); // Convert size to dec
 2656               		.loc 3 311 0
 2657 0298 40E1      		ldi r20,lo8(16)
 2658 029a 50E0      		ldi r21,0
 2659 029c 60E0      		ldi r22,0
 2660 029e 70E0      		ldi r23,0
 2661 02a0 80E0      		ldi r24,lo8(receivedBuffer)
 2662 02a2 90E0      		ldi r25,hi8(receivedBuffer)
 2663 02a4 00D0      		rcall strtol
 2664               	.LVL277:
 2665 02a6 962E      		mov r9,r22
 2666               	.LVL278:
 2667 02a8 00C0      		rjmp .L88
 2668               	.LVL279:
 2669               	.L121:
 312:main.c        **** 		}
 313:main.c        **** 		
 314:main.c        **** 		// Read the EEPROM on address (and increment) until anything but 1 is received
 315:main.c        **** 		else if (receivedChar == GBA_READ_EEPROM) {
 2670               		.loc 3 315 0
 2671 02aa 9536      		cpi r25,lo8(101)
 2672 02ac 01F4      		brne .L122
 316:main.c        **** 			gba_eeprom_mode();
 2673               		.loc 3 316 0
 2674 02ae 00D0      		rcall gba_eeprom_mode
 2675               	.LVL280:
 317:main.c        **** 			
 318:main.c        **** 			receivedChar = '1';
 2676               		.loc 3 318 0
 2677 02b0 81E3      		ldi r24,lo8(49)
 2678               	.L200:
 319:main.c        **** 			while (receivedChar == '1') {
 320:main.c        **** 				PORTD |= (1<<ACTIVITY_LED);
 321:main.c        **** 				gba_eeprom_read(address, eepromSize);
 322:main.c        **** 				
 323:main.c        **** 				// Send back the 8 bytes of data
 324:main.c        **** 				for (uint8_t c = 0; c < 8; c++) {
 325:main.c        **** 					USART_Transmit(eepromBuffer[c]);
 326:main.c        **** 				}
 327:main.c        **** 				address++; // Increment to next 8 bytes
 328:main.c        **** 				
 329:main.c        **** 				PORTD &= ~(1<<ACTIVITY_LED);
 330:main.c        **** 				receivedChar = USART_Receive();
 2679               		.loc 3 330 0
 2680 02b2 8093 0000 		sts receivedChar,r24
 319:main.c        **** 			while (receivedChar == '1') {
 2681               		.loc 3 319 0
 2682 02b6 8091 0000 		lds r24,receivedChar
 2683 02ba 8133      		cpi r24,lo8(49)
 2684 02bc 01F0      		breq .+2
 2685 02be 00C0      		rjmp .L192
 320:main.c        **** 				gba_eeprom_read(address, eepromSize);
 2686               		.loc 3 320 0
 2687 02c0 939A      		sbi 0x12,3
 321:main.c        **** 				
 2688               		.loc 3 321 0
 2689 02c2 692D      		mov r22,r9
 2690 02c4 C601      		movw r24,r12
 2691 02c6 00D0      		rcall gba_eeprom_read
 2692               	.LVL281:
 2693 02c8 C0E0      		ldi r28,lo8(eepromBuffer)
 2694 02ca D0E0      		ldi r29,hi8(eepromBuffer)
 2695               	.LVL282:
 2696               	.L124:
 2697               	.LBB105:
 325:main.c        **** 				}
 2698               		.loc 3 325 0 discriminator 3
 2699 02cc 8991      		ld r24,Y+
 2700               	.LVL283:
 2701 02ce 00D0      		rcall USART_Transmit
 2702               	.LVL284:
 324:main.c        **** 					USART_Transmit(eepromBuffer[c]);
 2703               		.loc 3 324 0 discriminator 3
 2704 02d0 0C17      		cp r16,r28
 2705 02d2 1D07      		cpc r17,r29
 2706 02d4 01F4      		brne .L124
 2707               	.LBE105:
 327:main.c        **** 				
 2708               		.loc 3 327 0
 2709 02d6 8FEF      		ldi r24,-1
 2710 02d8 C81A      		sub r12,r24
 2711 02da D80A      		sbc r13,r24
 2712 02dc E80A      		sbc r14,r24
 2713 02de F80A      		sbc r15,r24
 2714               	.LVL285:
 329:main.c        **** 				receivedChar = USART_Receive();
 2715               		.loc 3 329 0
 2716 02e0 9398      		cbi 0x12,3
 2717               		.loc 3 330 0
 2718 02e2 00D0      		rcall USART_Receive
 2719               	.LVL286:
 2720 02e4 00C0      		rjmp .L200
 2721               	.LVL287:
 2722               	.L122:
 331:main.c        **** 			}
 332:main.c        **** 			
 333:main.c        **** 			gba_mode(); // Set back
 334:main.c        **** 		}
 335:main.c        **** 		
 336:main.c        **** 		// Write 8 bytes to the EEPROM address (and increment)
 337:main.c        **** 		else if (receivedChar == GBA_WRITE_EEPROM) {
 2723               		.loc 3 337 0
 2724 02e6 9037      		cpi r25,lo8(112)
 2725 02e8 01F4      		brne .L126
 338:main.c        **** 			gba_eeprom_mode();
 2726               		.loc 3 338 0
 2727 02ea 00D0      		rcall gba_eeprom_mode
 2728               	.LVL288:
 2729 02ec C0E0      		ldi r28,lo8(eepromBuffer)
 2730 02ee D0E0      		ldi r29,hi8(eepromBuffer)
 2731               	.LVL289:
 2732               	.L127:
 2733               	.LBB106:
 339:main.c        **** 			
 340:main.c        **** 			// Read 8 bytes from USART and place in buffer
 341:main.c        **** 			for (uint8_t x = 0; x < 8; x++) {
 342:main.c        **** 				eepromBuffer[x] = USART_Receive();
 2734               		.loc 3 342 0 discriminator 3
 2735 02f0 00D0      		rcall USART_Receive
 2736               	.LVL290:
 2737 02f2 8993      		st Y+,r24
 2738               	.LVL291:
 341:main.c        **** 				eepromBuffer[x] = USART_Receive();
 2739               		.loc 3 341 0 discriminator 3
 2740 02f4 0C17      		cp r16,r28
 2741 02f6 1D07      		cpc r17,r29
 2742 02f8 01F4      		brne .L127
 2743               	.LBE106:
 343:main.c        **** 			}
 344:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 2744               		.loc 3 344 0
 2745 02fa 939A      		sbi 0x12,3
 345:main.c        **** 			
 346:main.c        **** 			gba_eeprom_write(address, eepromSize);
 2746               		.loc 3 346 0
 2747 02fc 692D      		mov r22,r9
 2748 02fe C601      		movw r24,r12
 2749 0300 00D0      		rcall gba_eeprom_write
 2750               	.LVL292:
 347:main.c        **** 			address++;
 2751               		.loc 3 347 0
 2752 0302 9FEF      		ldi r25,-1
 2753 0304 C91A      		sub r12,r25
 2754 0306 D90A      		sbc r13,r25
 2755 0308 E90A      		sbc r14,r25
 2756 030a F90A      		sbc r15,r25
 2757               	.LVL293:
 2758               	.LBB107:
 2759               	.LBB108:
 187:c:\winavr-20100110\avr\include\util\delay.h **** 
 2760               		.loc 2 187 0
 2761 030c EFE7      		ldi r30,lo8(15999)
 2762 030e FEE3      		ldi r31,hi8(15999)
 2763 0310 3197      	1:	sbiw r30,1
 2764 0312 01F4      		brne 1b
 2765 0314 00C0      		rjmp .
 2766 0316 0000      		nop
 2767               	.LVL294:
 2768 0318 00C0      		rjmp .L194
 2769               	.LVL295:
 2770               	.L126:
 2771               	.LBE108:
 2772               	.LBE107:
 348:main.c        **** 			
 349:main.c        **** 			_delay_ms(8); // Wait for EEPROM to write data (8ms)
 350:main.c        **** 			USART_Transmit('1'); // Send back acknowledgement
 351:main.c        **** 			
 352:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 353:main.c        **** 			gba_mode(); // Set back
 354:main.c        **** 		}
 355:main.c        **** 		
 356:main.c        **** 		
 357:main.c        **** 		// ---------- GB FLASH CARTS ----------
 358:main.c        **** 		// Write address, one byte and pulse a pin
 359:main.c        **** 		else if (receivedChar == GB_FLASH_WRITE_BYTE) {
 2773               		.loc 3 359 0
 2774 031a 9634      		cpi r25,lo8(70)
 2775 031c 01F4      		brne .L128
 2776               	.LBB109:
 360:main.c        **** 			usart_read_chars(); // Read address
 2777               		.loc 3 360 0
 2778 031e 00D0      		rcall usart_read_chars
 2779               	.LVL296:
 361:main.c        **** 			uint16_t flashAddress = strtol(receivedBuffer, NULL, 16); // Convert address string in hex to de
 2780               		.loc 3 361 0
 2781 0320 40E1      		ldi r20,lo8(16)
 2782 0322 50E0      		ldi r21,0
 2783 0324 60E0      		ldi r22,0
 2784 0326 70E0      		ldi r23,0
 2785 0328 80E0      		ldi r24,lo8(receivedBuffer)
 2786 032a 90E0      		ldi r25,hi8(receivedBuffer)
 2787 032c 00D0      		rcall strtol
 2788               	.LVL297:
 2789 032e 1B01      		movw r2,r22
 2790 0330 2C01      		movw r4,r24
 2791               	.LVL298:
 362:main.c        **** 			
 363:main.c        **** 			receivedChar = USART_Receive(); // Wait for byte
 2792               		.loc 3 363 0
 2793 0332 00D0      		rcall USART_Receive
 2794               	.LVL299:
 2795 0334 8093 0000 		sts receivedChar,r24
 364:main.c        **** 			if (receivedChar == GB_AUDIO_FLASH_WRITE || receivedChar == GB_BV5_FLASH_WRITE) {
 2796               		.loc 3 364 0
 2797 0338 8535      		cpi r24,lo8(85)
 2798 033a 01F0      		breq .L129
 2799               		.loc 3 364 0 is_stmt 0 discriminator 1
 2800 033c 8533      		cpi r24,lo8(53)
 2801 033e 01F0      		breq .+2
 2802 0340 00C0      		rjmp .L88
 2803               	.L129:
 2804               	.LBB110:
 365:main.c        **** 				usart_read_chars(); // Read data
 2805               		.loc 3 365 0 is_stmt 1
 2806 0342 00D0      		rcall usart_read_chars
 2807               	.LVL300:
 366:main.c        **** 				uint8_t flashByte = strtol(receivedBuffer, NULL, 16); // Convert data byte in hex to dec
 2808               		.loc 3 366 0
 2809 0344 40E1      		ldi r20,lo8(16)
 2810 0346 50E0      		ldi r21,0
 2811 0348 60E0      		ldi r22,0
 2812 034a 70E0      		ldi r23,0
 2813 034c 80E0      		ldi r24,lo8(receivedBuffer)
 2814 034e 90E0      		ldi r25,hi8(receivedBuffer)
 2815 0350 00D0      		rcall strtol
 2816               	.LVL301:
 367:main.c        **** 				
 368:main.c        **** 				PORTD |= (1<<ACTIVITY_LED);
 2817               		.loc 3 368 0
 2818 0352 939A      		sbi 0x12,3
 369:main.c        **** 				if (receivedChar == GB_AUDIO_FLASH_WRITE) { // Pulse audio pin
 2819               		.loc 3 369 0
 2820 0354 8091 0000 		lds r24,receivedChar
 2821 0358 8535      		cpi r24,lo8(85)
 2822 035a 01F4      		brne .L130
 370:main.c        **** 					audio_flash_write_bus_cycle(flashAddress, flashByte);
 2823               		.loc 3 370 0
 2824 035c C101      		movw r24,r2
 2825 035e 00D0      		rcall audio_flash_write_bus_cycle
 2826               	.LVL302:
 2827 0360 00C0      		rjmp .L212
 2828               	.LVL303:
 2829               	.L130:
 371:main.c        **** 				}
 372:main.c        **** 				else if (receivedChar == GB_BV5_FLASH_WRITE) { // Pulse WR pin
 2830               		.loc 3 372 0
 2831 0362 8533      		cpi r24,lo8(53)
 2832 0364 01F0      		breq .+2
 2833 0366 00C0      		rjmp .L212
 373:main.c        **** 					bv5_flash_write_bus_cycle(flashAddress, flashByte);
 2834               		.loc 3 373 0
 2835 0368 C101      		movw r24,r2
 2836 036a 00D0      		rcall bv5_flash_write_bus_cycle
 2837               	.LVL304:
 2838 036c 00C0      		rjmp .L212
 2839               	.LVL305:
 2840               	.L128:
 2841               	.LBE110:
 2842               	.LBE109:
 374:main.c        **** 				}
 375:main.c        **** 				PORTD &= ~(1<<ACTIVITY_LED);
 376:main.c        **** 				
 377:main.c        **** 				USART_Transmit('1'); // Send back acknowledgement
 378:main.c        **** 			}
 379:main.c        **** 		}
 380:main.c        **** 		
 381:main.c        **** 		// Write 64 bytes to Flash address one byte write at a time (and increment), pulse a pin
 382:main.c        **** 		else if (receivedChar == GB_FLASH_WRITE_64BYTE) {
 2843               		.loc 3 382 0
 2844 036e 9435      		cpi r25,lo8(84)
 2845 0370 01F4      		brne .L132
 383:main.c        **** 			receivedChar = USART_Receive(); // Wait for byte
 2846               		.loc 3 383 0
 2847 0372 00D0      		rcall USART_Receive
 2848               	.LVL306:
 2849 0374 8093 0000 		sts receivedChar,r24
 384:main.c        **** 			usart_read_bytes(64);
 2850               		.loc 3 384 0
 2851 0378 80E4      		ldi r24,lo8(64)
 2852 037a 00D0      		rcall usart_read_bytes
 2853               	.LVL307:
 385:main.c        **** 			
 386:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 2854               		.loc 3 386 0
 2855 037c 939A      		sbi 0x12,3
 2856               	.LVL308:
 2857 037e C0E0      		ldi r28,lo8(receivedBuffer)
 2858 0380 D0E0      		ldi r29,hi8(receivedBuffer)
 2859 0382 90E4      		ldi r25,lo8(64)
 2860 0384 592E      		mov r5,r25
 2861               	.LBB111:
 387:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 388:main.c        **** 				if (receivedChar == GB_AUDIO_FLASH_WRITE) { // Pulse audio pin
 389:main.c        **** 					audio_flash_write_byte(address, receivedBuffer[x]);
 390:main.c        **** 				}
 391:main.c        **** 				else if (receivedChar == GB_BV5_FLASH_WRITE) { // Pulse WR pin
 392:main.c        **** 					bv5_flash_write_byte(address, receivedBuffer[x]);
 2862               		.loc 3 392 0
 2863 0386 C601      		movw r24,r12
 2864 0388 8050      		subi r24,lo8(receivedBuffer)
 2865 038a 9040      		sbci r25,hi8(receivedBuffer)
 2866 038c 5C01      		movw r10,r24
 2867               	.LVL309:
 2868               	.L135:
 388:main.c        **** 					audio_flash_write_byte(address, receivedBuffer[x]);
 2869               		.loc 3 388 0
 2870 038e 8091 0000 		lds r24,receivedChar
 2871 0392 8535      		cpi r24,lo8(85)
 2872 0394 01F4      		brne .L133
 389:main.c        **** 				}
 2873               		.loc 3 389 0
 2874 0396 6881      		ld r22,Y
 2875 0398 C501      		movw r24,r10
 2876 039a 8C0F      		add r24,r28
 2877 039c 9D1F      		adc r25,r29
 2878 039e 00D0      		rcall audio_flash_write_byte
 2879               	.LVL310:
 2880 03a0 00C0      		rjmp .L134
 2881               	.L133:
 391:main.c        **** 					bv5_flash_write_byte(address, receivedBuffer[x]);
 2882               		.loc 3 391 0
 2883 03a2 8533      		cpi r24,lo8(53)
 2884 03a4 01F4      		brne .L134
 2885               		.loc 3 392 0
 2886 03a6 6881      		ld r22,Y
 2887 03a8 C501      		movw r24,r10
 2888 03aa 8C0F      		add r24,r28
 2889 03ac 9D1F      		adc r25,r29
 2890 03ae 00D0      		rcall bv5_flash_write_byte
 2891               	.LVL311:
 2892               	.L134:
 2893 03b0 5A94      		dec r5
 2894 03b2 2196      		adiw r28,1
 2895               	.LVL312:
 387:main.c        **** 				if (receivedChar == GB_AUDIO_FLASH_WRITE) { // Pulse audio pin
 2896               		.loc 3 387 0 discriminator 2
 2897 03b4 5110      		cpse r5,__zero_reg__
 2898 03b6 00C0      		rjmp .L135
 2899 03b8 90E4      		ldi r25,64
 2900 03ba C90E      		add r12,r25
 2901 03bc D11C      		adc r13,__zero_reg__
 2902 03be E11C      		adc r14,__zero_reg__
 2903 03c0 F11C      		adc r15,__zero_reg__
 2904 03c2 00C0      		rjmp .L201
 2905               	.LVL313:
 2906               	.L132:
 2907               	.LBE111:
 393:main.c        **** 				}
 394:main.c        **** 				
 395:main.c        **** 				address++;
 396:main.c        **** 			}
 397:main.c        **** 			USART_Transmit('1'); // Send back acknowledgement
 398:main.c        **** 			
 399:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 400:main.c        **** 		}
 401:main.c        **** 		
 402:main.c        **** 		
 403:main.c        **** 		// ---------- GBA FLASH CARTS ----------
 404:main.c        **** 		// Write 24 bit address, 16 bit data and pulse a pin
 405:main.c        **** 		else if (receivedChar == GBA_FLASH_CART_WRITE_BYTE) {
 2908               		.loc 3 405 0
 2909 03c4 9E36      		cpi r25,lo8(110)
 2910 03c6 01F4      		brne .L136
 2911               	.LBB112:
 406:main.c        **** 			usart_read_chars(); // Read address
 2912               		.loc 3 406 0
 2913 03c8 00D0      		rcall usart_read_chars
 2914               	.LVL314:
 407:main.c        **** 			uint32_t flashAddress = strtol(receivedBuffer, NULL, 16); // Convert address string in hex to de
 2915               		.loc 3 407 0
 2916 03ca 40E1      		ldi r20,lo8(16)
 2917 03cc 50E0      		ldi r21,0
 2918 03ce 60E0      		ldi r22,0
 2919 03d0 70E0      		ldi r23,0
 2920 03d2 80E0      		ldi r24,lo8(receivedBuffer)
 2921 03d4 90E0      		ldi r25,hi8(receivedBuffer)
 2922 03d6 00D0      		rcall strtol
 2923               	.LVL315:
 2924 03d8 1B01      		movw r2,r22
 2925 03da 2C01      		movw r4,r24
 2926               	.LVL316:
 408:main.c        **** 			
 409:main.c        **** 			receivedChar = USART_Receive(); // Wait for byte
 2927               		.loc 3 409 0
 2928 03dc 00D0      		rcall USART_Receive
 2929               	.LVL317:
 2930 03de 8093 0000 		sts receivedChar,r24
 410:main.c        **** 			if (receivedChar == GBA_FLASH_CART_WRITE_BYTE) {
 2931               		.loc 3 410 0
 2932 03e2 8E36      		cpi r24,lo8(110)
 2933 03e4 01F0      		breq .+2
 2934 03e6 00C0      		rjmp .L88
 2935               	.LBB113:
 411:main.c        **** 				usart_read_chars(); // Read data
 2936               		.loc 3 411 0
 2937 03e8 00D0      		rcall usart_read_chars
 2938               	.LVL318:
 412:main.c        **** 				uint16_t flashByte = strtol(receivedBuffer, NULL, 16); // Convert data byte in hex to dec
 2939               		.loc 3 412 0
 2940 03ea 40E1      		ldi r20,lo8(16)
 2941 03ec 50E0      		ldi r21,0
 2942 03ee 60E0      		ldi r22,0
 2943 03f0 70E0      		ldi r23,0
 2944 03f2 80E0      		ldi r24,lo8(receivedBuffer)
 2945 03f4 90E0      		ldi r25,hi8(receivedBuffer)
 2946 03f6 00D0      		rcall strtol
 2947               	.LVL319:
 413:main.c        **** 				
 414:main.c        **** 				PORTD |= (1<<ACTIVITY_LED);
 2948               		.loc 3 414 0
 2949 03f8 939A      		sbi 0x12,3
 415:main.c        **** 				gba_flash_write_bus_cycle(flashAddress, flashByte);
 2950               		.loc 3 415 0
 2951 03fa AB01      		movw r20,r22
 2952 03fc C201      		movw r24,r4
 2953 03fe B101      		movw r22,r2
 2954               	.LVL320:
 2955 0400 00D0      		rcall gba_flash_write_bus_cycle
 2956               	.LVL321:
 2957               	.L212:
 416:main.c        **** 				PORTD &= ~(1<<ACTIVITY_LED);
 2958               		.loc 3 416 0
 2959 0402 9398      		cbi 0x12,3
 417:main.c        **** 				
 418:main.c        **** 				USART_Transmit('1'); // Send back acknowledgement
 2960               		.loc 3 418 0
 2961 0404 81E3      		ldi r24,lo8(49)
 2962 0406 00C0      		rjmp .L190
 2963               	.LVL322:
 2964               	.L136:
 2965               	.LBE113:
 2966               	.LBE112:
 419:main.c        **** 			}
 420:main.c        **** 		}
 421:main.c        **** 		
 422:main.c        **** 		// Write 64 bytes to Flash address, combine 2 bytes and write at a time (and increment address by
 423:main.c        **** 		else if (receivedChar == GBA_FLASH_WRITE_64BYTE) {
 2967               		.loc 3 423 0
 2968 0408 9137      		cpi r25,lo8(113)
 2969 040a 01F4      		brne .L137
 424:main.c        **** 			usart_read_bytes(64);
 2970               		.loc 3 424 0
 2971 040c 80E4      		ldi r24,lo8(64)
 2972               	.LVL323:
 2973 040e 00D0      		rcall usart_read_bytes
 2974               	.LVL324:
 425:main.c        **** 			
 426:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 2975               		.loc 3 426 0
 2976 0410 939A      		sbi 0x12,3
 2977               	.LVL325:
 2978 0412 C0E0      		ldi r28,lo8(receivedBuffer)
 2979 0414 D0E0      		ldi r29,hi8(receivedBuffer)
 2980 0416 1601      		movw r2,r12
 2981 0418 2701      		movw r4,r14
 2982               	.LVL326:
 2983               	.L138:
 2984               	.LBB114:
 2985               	.LBB115:
 427:main.c        **** 			for (uint8_t x = 0; x < 64; x += 2) {
 428:main.c        **** 				uint16_t combinedBytes = (uint16_t) receivedBuffer[x+1] << 8 | (uint16_t) receivedBuffer[x];
 429:main.c        **** 				gba_flash_write_byte_swapped(address, combinedBytes);
 2986               		.loc 3 429 0 discriminator 3
 2987 041a 4981      		ldd r20,Y+1
 2988 041c 50E0      		ldi r21,0
 2989 041e 542F      		mov r21,r20
 2990 0420 4427      		clr r20
 2991 0422 8881      		ld r24,Y
 2992 0424 482B      		or r20,r24
 2993 0426 C201      		movw r24,r4
 2994 0428 B101      		movw r22,r2
 2995 042a 00D0      		rcall gba_flash_write_byte_swapped
 2996               	.LVL327:
 430:main.c        **** 				address++;
 2997               		.loc 3 430 0 discriminator 3
 2998 042c EFEF      		ldi r30,-1
 2999 042e 2E1A      		sub r2,r30
 3000 0430 3E0A      		sbc r3,r30
 3001 0432 4E0A      		sbc r4,r30
 3002 0434 5E0A      		sbc r5,r30
 3003               	.LVL328:
 3004 0436 2296      		adiw r28,2
 3005               	.LVL329:
 3006               	.LBE115:
 427:main.c        **** 			for (uint8_t x = 0; x < 64; x += 2) {
 3007               		.loc 3 427 0 discriminator 3
 3008 0438 6C16      		cp r6,r28
 3009 043a 7D06      		cpc r7,r29
 3010 043c 01F4      		brne .L138
 3011 043e F0E2      		ldi r31,32
 3012 0440 CF0E      		add r12,r31
 3013 0442 D11C      		adc r13,__zero_reg__
 3014 0444 E11C      		adc r14,__zero_reg__
 3015 0446 F11C      		adc r15,__zero_reg__
 3016               	.LVL330:
 3017               	.L201:
 3018               	.LBE114:
 431:main.c        **** 			}
 432:main.c        **** 			USART_Transmit('1'); // Send back acknowledgement
 3019               		.loc 3 432 0
 3020 0448 81E3      		ldi r24,lo8(49)
 3021 044a 00C0      		rjmp .L193
 3022               	.LVL331:
 3023               	.L137:
 433:main.c        **** 			
 434:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 435:main.c        **** 		}
 436:main.c        **** 		
 437:main.c        **** 		
 438:main.c        **** 		// ---------- General commands ----------
 439:main.c        **** 		// Set any pin as input/output
 440:main.c        **** 		// Reads the DDR/PORT (e.g. DDRB/PORTB is 'B') and the hex value that represents pins to set to a
 441:main.c        **** 		else if (receivedChar == SET_INPUT || receivedChar == SET_OUTPUT) {
 3024               		.loc 3 441 0
 3025 044c 9934      		cpi r25,lo8(73)
 3026 044e 01F0      		breq .L139
 3027               		.loc 3 441 0 is_stmt 0 discriminator 1
 3028 0450 9F34      		cpi r25,lo8(79)
 3029 0452 01F0      		breq .+2
 3030 0454 00C0      		rjmp .L140
 3031               	.L139:
 3032               	.LBB116:
 442:main.c        **** 			char portChar = USART_Receive();
 3033               		.loc 3 442 0 is_stmt 1
 3034 0456 00D0      		rcall USART_Receive
 3035               	.LVL332:
 3036 0458 C82F      		mov r28,r24
 3037               	.LVL333:
 443:main.c        **** 			usart_read_chars();
 3038               		.loc 3 443 0
 3039 045a 00D0      		rcall usart_read_chars
 3040               	.LVL334:
 444:main.c        **** 			uint8_t setValue = strtol(receivedBuffer, NULL, 16);
 3041               		.loc 3 444 0
 3042 045c 40E1      		ldi r20,lo8(16)
 3043 045e 50E0      		ldi r21,0
 3044 0460 60E0      		ldi r22,0
 3045 0462 70E0      		ldi r23,0
 3046 0464 80E0      		ldi r24,lo8(receivedBuffer)
 3047 0466 90E0      		ldi r25,hi8(receivedBuffer)
 3048 0468 00D0      		rcall strtol
 3049               	.LVL335:
 445:main.c        **** 			
 446:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 3050               		.loc 3 446 0
 3051 046a 939A      		sbi 0x12,3
 447:main.c        **** 			if (receivedChar == SET_INPUT) {
 3052               		.loc 3 447 0
 3053 046c 8091 0000 		lds r24,receivedChar
 3054 0470 8934      		cpi r24,lo8(73)
 3055 0472 01F4      		brne .L141
 448:main.c        **** 				if (portChar == 'A') {
 3056               		.loc 3 448 0
 3057 0474 C134      		cpi r28,lo8(65)
 3058 0476 01F4      		brne .L142
 449:main.c        **** 					DDRA &= ~(setValue);
 3059               		.loc 3 449 0
 3060 0478 8AB3      		in r24,0x1a
 3061 047a 6095      		com r22
 3062               	.LVL336:
 3063 047c 6823      		and r22,r24
 3064               	.LVL337:
 3065 047e 00C0      		rjmp .L203
 3066               	.LVL338:
 3067               	.L142:
 450:main.c        **** 				}
 451:main.c        **** 				else if (portChar == 'B') {
 3068               		.loc 3 451 0
 3069 0480 C234      		cpi r28,lo8(66)
 3070 0482 01F4      		brne .L144
 452:main.c        **** 					DDRB &= ~(setValue);
 3071               		.loc 3 452 0
 3072 0484 87B3      		in r24,0x17
 3073 0486 6095      		com r22
 3074               	.LVL339:
 3075 0488 6823      		and r22,r24
 3076               	.LVL340:
 3077 048a 00C0      		rjmp .L204
 3078               	.LVL341:
 3079               	.L144:
 453:main.c        **** 				}
 454:main.c        **** 				else if (portChar == 'C') {
 3080               		.loc 3 454 0
 3081 048c C334      		cpi r28,lo8(67)
 3082 048e 01F4      		brne .L145
 455:main.c        **** 					DDRC &= ~(setValue);
 3083               		.loc 3 455 0
 3084 0490 84B3      		in r24,0x14
 3085 0492 6095      		com r22
 3086               	.LVL342:
 3087 0494 6823      		and r22,r24
 3088               	.LVL343:
 3089 0496 00C0      		rjmp .L209
 3090               	.LVL344:
 3091               	.L145:
 456:main.c        **** 				}
 457:main.c        **** 				else if (portChar == 'D') {
 3092               		.loc 3 457 0
 3093 0498 C434      		cpi r28,lo8(68)
 3094 049a 01F4      		brne .L146
 458:main.c        **** 					DDRD &= ~(setValue);
 3095               		.loc 3 458 0
 3096 049c 81B3      		in r24,0x11
 3097 049e 6095      		com r22
 3098               	.LVL345:
 3099 04a0 6823      		and r22,r24
 3100               	.LVL346:
 3101 04a2 00C0      		rjmp .L210
 3102               	.LVL347:
 3103               	.L146:
 459:main.c        **** 				}
 460:main.c        **** 				else if (portChar == 'E') {
 3104               		.loc 3 460 0
 3105 04a4 C534      		cpi r28,lo8(69)
 3106 04a6 01F0      		breq .+2
 3107 04a8 00C0      		rjmp .L165
 461:main.c        **** 					DDRE &= ~(setValue);
 3108               		.loc 3 461 0
 3109 04aa 86B1      		in r24,0x6
 3110 04ac 6095      		com r22
 3111               	.LVL348:
 3112 04ae 6823      		and r22,r24
 3113               	.LVL349:
 3114 04b0 00C0      		rjmp .L211
 3115               	.LVL350:
 3116               	.L141:
 462:main.c        **** 				}
 463:main.c        **** 			}
 464:main.c        **** 			else if (receivedChar == SET_OUTPUT) {
 3117               		.loc 3 464 0
 3118 04b2 8F34      		cpi r24,lo8(79)
 3119 04b4 01F0      		breq .+2
 3120 04b6 00C0      		rjmp .L165
 465:main.c        **** 				if (portChar == 'A') {
 3121               		.loc 3 465 0
 3122 04b8 C134      		cpi r28,lo8(65)
 3123 04ba 01F4      		brne .L147
 466:main.c        **** 					DDRA |= (setValue);
 3124               		.loc 3 466 0
 3125 04bc 8AB3      		in r24,0x1a
 3126 04be 682B      		or r22,r24
 3127               	.LVL351:
 3128               	.L203:
 3129 04c0 6ABB      		out 0x1a,r22
 3130 04c2 00C0      		rjmp .L165
 3131               	.LVL352:
 3132               	.L147:
 467:main.c        **** 				}
 468:main.c        **** 				else if (portChar == 'B') {
 3133               		.loc 3 468 0
 3134 04c4 C234      		cpi r28,lo8(66)
 3135 04c6 01F4      		brne .L148
 469:main.c        **** 					DDRB |= (setValue);
 3136               		.loc 3 469 0
 3137 04c8 87B3      		in r24,0x17
 3138 04ca 682B      		or r22,r24
 3139               	.LVL353:
 3140               	.L204:
 3141 04cc 67BB      		out 0x17,r22
 3142 04ce 00C0      		rjmp .L165
 3143               	.LVL354:
 3144               	.L148:
 470:main.c        **** 				}
 471:main.c        **** 				else if (portChar == 'C') {
 3145               		.loc 3 471 0
 3146 04d0 C334      		cpi r28,lo8(67)
 3147 04d2 01F4      		brne .L149
 472:main.c        **** 					DDRC |= (setValue);
 3148               		.loc 3 472 0
 3149 04d4 84B3      		in r24,0x14
 3150 04d6 682B      		or r22,r24
 3151               	.LVL355:
 3152               	.L209:
 3153 04d8 64BB      		out 0x14,r22
 3154 04da 00C0      		rjmp .L165
 3155               	.LVL356:
 3156               	.L149:
 473:main.c        **** 				}
 474:main.c        **** 				else if (portChar == 'D') {
 3157               		.loc 3 474 0
 3158 04dc C434      		cpi r28,lo8(68)
 3159 04de 01F4      		brne .L150
 475:main.c        **** 					DDRD |= (setValue);
 3160               		.loc 3 475 0
 3161 04e0 81B3      		in r24,0x11
 3162 04e2 682B      		or r22,r24
 3163               	.LVL357:
 3164               	.L210:
 3165 04e4 61BB      		out 0x11,r22
 3166 04e6 00C0      		rjmp .L165
 3167               	.LVL358:
 3168               	.L150:
 476:main.c        **** 				}
 477:main.c        **** 				else if (portChar == 'E') {
 3169               		.loc 3 477 0
 3170 04e8 C534      		cpi r28,lo8(69)
 3171 04ea 01F0      		breq .+2
 3172 04ec 00C0      		rjmp .L165
 478:main.c        **** 					DDRE |= (setValue);
 3173               		.loc 3 478 0
 3174 04ee 86B1      		in r24,0x6
 3175 04f0 682B      		or r22,r24
 3176               	.LVL359:
 3177               	.L211:
 3178 04f2 66B9      		out 0x6,r22
 3179 04f4 00C0      		rjmp .L165
 3180               	.LVL360:
 3181               	.L140:
 3182               	.LBE116:
 479:main.c        **** 				}
 480:main.c        **** 			}
 481:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 482:main.c        **** 		}
 483:main.c        **** 		
 484:main.c        **** 		// Set pin output as low
 485:main.c        **** 		else if (receivedChar == SET_OUTPUT_LOW) {
 3183               		.loc 3 485 0
 3184 04f6 9C34      		cpi r25,lo8(76)
 3185 04f8 01F4      		brne .L151
 3186               	.LBB117:
 486:main.c        **** 			char portChar = USART_Receive();			
 3187               		.loc 3 486 0
 3188 04fa 00D0      		rcall USART_Receive
 3189               	.LVL361:
 3190 04fc C82F      		mov r28,r24
 3191               	.LVL362:
 487:main.c        **** 			usart_read_chars();
 3192               		.loc 3 487 0
 3193 04fe 00D0      		rcall usart_read_chars
 3194               	.LVL363:
 488:main.c        **** 			uint8_t setValue = strtol(receivedBuffer, NULL, 16);
 3195               		.loc 3 488 0
 3196 0500 40E1      		ldi r20,lo8(16)
 3197 0502 50E0      		ldi r21,0
 3198 0504 60E0      		ldi r22,0
 3199 0506 70E0      		ldi r23,0
 3200 0508 80E0      		ldi r24,lo8(receivedBuffer)
 3201 050a 90E0      		ldi r25,hi8(receivedBuffer)
 3202 050c 00D0      		rcall strtol
 3203               	.LVL364:
 489:main.c        **** 			
 490:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 3204               		.loc 3 490 0
 3205 050e 939A      		sbi 0x12,3
 491:main.c        **** 			if (portChar == 'A') {
 3206               		.loc 3 491 0
 3207 0510 C134      		cpi r28,lo8(65)
 3208 0512 01F4      		brne .L152
 492:main.c        **** 				PORTA &= ~(setValue);
 3209               		.loc 3 492 0
 3210 0514 8BB3      		in r24,0x1b
 3211 0516 6095      		com r22
 3212               	.LVL365:
 3213 0518 6823      		and r22,r24
 3214               	.LVL366:
 3215 051a 00C0      		rjmp .L208
 3216               	.LVL367:
 3217               	.L152:
 493:main.c        **** 			}
 494:main.c        **** 			else if (portChar == 'B') {
 3218               		.loc 3 494 0
 3219 051c C234      		cpi r28,lo8(66)
 3220 051e 01F4      		brne .L154
 495:main.c        **** 				PORTB &= ~(setValue);
 3221               		.loc 3 495 0
 3222 0520 88B3      		in r24,0x18
 3223 0522 6095      		com r22
 3224               	.LVL368:
 3225 0524 6823      		and r22,r24
 3226               	.LVL369:
 3227 0526 00C0      		rjmp .L207
 3228               	.LVL370:
 3229               	.L154:
 496:main.c        **** 			}
 497:main.c        **** 			else if (portChar == 'C') {
 3230               		.loc 3 497 0
 3231 0528 C334      		cpi r28,lo8(67)
 3232 052a 01F4      		brne .L155
 498:main.c        **** 				PORTC &= ~(setValue);
 3233               		.loc 3 498 0
 3234 052c 85B3      		in r24,0x15
 3235 052e 6095      		com r22
 3236               	.LVL371:
 3237 0530 6823      		and r22,r24
 3238               	.LVL372:
 3239 0532 00C0      		rjmp .L206
 3240               	.LVL373:
 3241               	.L155:
 499:main.c        **** 			}
 500:main.c        **** 			else if (portChar == 'D') {
 3242               		.loc 3 500 0
 3243 0534 C434      		cpi r28,lo8(68)
 3244 0536 01F4      		brne .L156
 501:main.c        **** 				PORTD &= ~(setValue);
 3245               		.loc 3 501 0
 3246 0538 82B3      		in r24,0x12
 3247 053a 6095      		com r22
 3248               	.LVL374:
 3249 053c 6823      		and r22,r24
 3250               	.LVL375:
 3251 053e 00C0      		rjmp .L205
 3252               	.LVL376:
 3253               	.L156:
 502:main.c        **** 			}
 503:main.c        **** 			else if (portChar == 'E') {
 3254               		.loc 3 503 0
 3255 0540 C534      		cpi r28,lo8(69)
 3256 0542 01F0      		breq .+2
 3257 0544 00C0      		rjmp .L165
 504:main.c        **** 				PORTE &= ~(setValue);
 3258               		.loc 3 504 0
 3259 0546 87B1      		in r24,0x7
 3260 0548 6095      		com r22
 3261               	.LVL377:
 3262 054a 6823      		and r22,r24
 3263               	.LVL378:
 3264 054c 00C0      		rjmp .L202
 3265               	.LVL379:
 3266               	.L151:
 3267               	.LBE117:
 505:main.c        **** 			}
 506:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 507:main.c        **** 		}
 508:main.c        **** 		
 509:main.c        **** 		// Set pin output as high
 510:main.c        **** 		else if (receivedChar == SET_OUTPUT_HIGH) {
 3268               		.loc 3 510 0
 3269 054e 9834      		cpi r25,lo8(72)
 3270 0550 01F4      		brne .L157
 3271               	.LBB118:
 511:main.c        **** 			char portChar = USART_Receive();			
 3272               		.loc 3 511 0
 3273 0552 00D0      		rcall USART_Receive
 3274               	.LVL380:
 3275 0554 C82F      		mov r28,r24
 3276               	.LVL381:
 512:main.c        **** 			usart_read_chars();
 3277               		.loc 3 512 0
 3278 0556 00D0      		rcall usart_read_chars
 3279               	.LVL382:
 513:main.c        **** 			uint8_t setValue = strtol(receivedBuffer, NULL, 16);
 3280               		.loc 3 513 0
 3281 0558 40E1      		ldi r20,lo8(16)
 3282 055a 50E0      		ldi r21,0
 3283 055c 60E0      		ldi r22,0
 3284 055e 70E0      		ldi r23,0
 3285 0560 80E0      		ldi r24,lo8(receivedBuffer)
 3286 0562 90E0      		ldi r25,hi8(receivedBuffer)
 3287 0564 00D0      		rcall strtol
 3288               	.LVL383:
 514:main.c        **** 			
 515:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 3289               		.loc 3 515 0
 3290 0566 939A      		sbi 0x12,3
 516:main.c        **** 			if (portChar == 'A') {
 3291               		.loc 3 516 0
 3292 0568 C134      		cpi r28,lo8(65)
 3293 056a 01F4      		brne .L158
 517:main.c        **** 				PORTA |= (setValue);
 3294               		.loc 3 517 0
 3295 056c 8BB3      		in r24,0x1b
 3296 056e 682B      		or r22,r24
 3297               	.LVL384:
 3298               	.L208:
 3299 0570 6BBB      		out 0x1b,r22
 3300 0572 00C0      		rjmp .L165
 3301               	.LVL385:
 3302               	.L158:
 518:main.c        **** 			}
 519:main.c        **** 			else if (portChar == 'B') {
 3303               		.loc 3 519 0
 3304 0574 C234      		cpi r28,lo8(66)
 3305 0576 01F4      		brne .L160
 520:main.c        **** 				PORTB |= (setValue);
 3306               		.loc 3 520 0
 3307 0578 88B3      		in r24,0x18
 3308 057a 682B      		or r22,r24
 3309               	.LVL386:
 3310               	.L207:
 3311 057c 68BB      		out 0x18,r22
 3312 057e 00C0      		rjmp .L165
 3313               	.LVL387:
 3314               	.L160:
 521:main.c        **** 			}
 522:main.c        **** 			else if (portChar == 'C') {
 3315               		.loc 3 522 0
 3316 0580 C334      		cpi r28,lo8(67)
 3317 0582 01F4      		brne .L161
 523:main.c        **** 				PORTC |= (setValue);
 3318               		.loc 3 523 0
 3319 0584 85B3      		in r24,0x15
 3320 0586 682B      		or r22,r24
 3321               	.LVL388:
 3322               	.L206:
 3323 0588 65BB      		out 0x15,r22
 3324 058a 00C0      		rjmp .L165
 3325               	.LVL389:
 3326               	.L161:
 524:main.c        **** 			}
 525:main.c        **** 			else if (portChar == 'D') {
 3327               		.loc 3 525 0
 3328 058c C434      		cpi r28,lo8(68)
 3329 058e 01F4      		brne .L162
 526:main.c        **** 				PORTD |= (setValue);
 3330               		.loc 3 526 0
 3331 0590 82B3      		in r24,0x12
 3332 0592 682B      		or r22,r24
 3333               	.LVL390:
 3334               	.L205:
 3335 0594 62BB      		out 0x12,r22
 3336 0596 00C0      		rjmp .L165
 3337               	.LVL391:
 3338               	.L162:
 527:main.c        **** 			}
 528:main.c        **** 			else if (portChar == 'E') {
 3339               		.loc 3 528 0
 3340 0598 C534      		cpi r28,lo8(69)
 3341 059a 01F4      		brne .L165
 529:main.c        **** 				PORTE |= (setValue);
 3342               		.loc 3 529 0
 3343 059c 87B1      		in r24,0x7
 3344 059e 682B      		or r22,r24
 3345               	.LVL392:
 3346               	.L202:
 3347 05a0 67B9      		out 0x7,r22
 3348 05a2 00C0      		rjmp .L165
 3349               	.LVL393:
 3350               	.L157:
 3351               	.LBE118:
 530:main.c        **** 			}
 531:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 532:main.c        **** 		}
 533:main.c        **** 		
 534:main.c        **** 		// Read all pins of a PORT and return the value
 535:main.c        **** 		else if (receivedChar == READ_INPUT) {
 3352               		.loc 3 535 0
 3353 05a4 9434      		cpi r25,lo8(68)
 3354 05a6 01F4      		brne .L163
 3355               	.LBB119:
 536:main.c        **** 			char portChar = USART_Receive();			
 3356               		.loc 3 536 0
 3357 05a8 00D0      		rcall USART_Receive
 3358               	.LVL394:
 537:main.c        **** 			
 538:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 3359               		.loc 3 538 0
 3360 05aa 939A      		sbi 0x12,3
 539:main.c        **** 			if (portChar == 'A') {
 3361               		.loc 3 539 0
 3362 05ac 8134      		cpi r24,lo8(65)
 3363 05ae 01F4      		brne .L164
 540:main.c        **** 				USART_Transmit(PINA);
 3364               		.loc 3 540 0
 3365 05b0 89B3      		in r24,0x19
 3366               	.LVL395:
 3367 05b2 00C0      		rjmp .L193
 3368               	.LVL396:
 3369               	.L164:
 541:main.c        **** 			}
 542:main.c        **** 			else if (portChar == 'B') {
 3370               		.loc 3 542 0
 3371 05b4 8234      		cpi r24,lo8(66)
 3372 05b6 01F4      		brne .L166
 543:main.c        **** 				USART_Transmit(PINB);
 3373               		.loc 3 543 0
 3374 05b8 86B3      		in r24,0x16
 3375               	.LVL397:
 3376 05ba 00C0      		rjmp .L193
 3377               	.LVL398:
 3378               	.L166:
 544:main.c        **** 			}
 545:main.c        **** 			else if (portChar == 'C') {
 3379               		.loc 3 545 0
 3380 05bc 8334      		cpi r24,lo8(67)
 3381 05be 01F4      		brne .L167
 546:main.c        **** 				USART_Transmit(PINC);
 3382               		.loc 3 546 0
 3383 05c0 83B3      		in r24,0x13
 3384               	.LVL399:
 3385 05c2 00C0      		rjmp .L193
 3386               	.LVL400:
 3387               	.L167:
 547:main.c        **** 			}
 548:main.c        **** 			else if (portChar == 'D') {
 3388               		.loc 3 548 0
 3389 05c4 8434      		cpi r24,lo8(68)
 3390 05c6 01F4      		brne .L168
 549:main.c        **** 				USART_Transmit(PIND);
 3391               		.loc 3 549 0
 3392 05c8 80B3      		in r24,0x10
 3393               	.LVL401:
 3394 05ca 00C0      		rjmp .L193
 3395               	.LVL402:
 3396               	.L168:
 550:main.c        **** 			}
 551:main.c        **** 			else if (portChar == 'E') {
 3397               		.loc 3 551 0
 3398 05cc 8534      		cpi r24,lo8(69)
 3399 05ce 01F4      		brne .L165
 552:main.c        **** 				USART_Transmit(PINE);
 3400               		.loc 3 552 0
 3401 05d0 85B1      		in r24,0x5
 3402               	.LVL403:
 3403               	.L193:
 3404 05d2 00D0      		rcall USART_Transmit
 3405               	.LVL404:
 3406               	.L165:
 553:main.c        **** 			}
 554:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 3407               		.loc 3 554 0
 3408 05d4 9398      		cbi 0x12,3
 3409               	.LBE119:
 3410 05d6 00C0      		rjmp .L88
 3411               	.LVL405:
 3412               	.L163:
 555:main.c        **** 		}
 556:main.c        **** 		
 557:main.c        **** 		// Set the reset common lines variable on or off, useful if you are controlling all the pins dire
 558:main.c        **** 		else if (receivedChar == RESET_COMMON_LINES) {
 3413               		.loc 3 558 0
 3414 05d8 9D34      		cpi r25,lo8(77)
 3415 05da 01F4      		brne .L169
 3416               	.LBB120:
 559:main.c        **** 			char commonChar = USART_Receive();
 3417               		.loc 3 559 0
 3418 05dc 00D0      		rcall USART_Receive
 3419               	.LVL406:
 560:main.c        **** 			if (commonChar == '1') {
 3420               		.loc 3 560 0
 3421 05de 8133      		cpi r24,lo8(49)
 3422 05e0 01F4      		brne .L213
 561:main.c        **** 				resetCommonLines = 1;
 3423               		.loc 3 561 0
 3424 05e2 8824      		clr r8
 3425 05e4 8394      		inc r8
 3426 05e6 00C0      		rjmp .L189
 3427               	.L213:
 562:main.c        **** 			}
 563:main.c        **** 			else if (commonChar == '0') {
 3428               		.loc 3 563 0
 3429 05e8 8033      		cpi r24,lo8(48)
 3430 05ea 01F0      		breq .+2
 3431 05ec 00C0      		rjmp .L88
 564:main.c        **** 				resetCommonLines = 0;
 3432               		.loc 3 564 0
 3433 05ee 812C      		mov r8,__zero_reg__
 3434 05f0 00C0      		rjmp .L89
 3435               	.LVL407:
 3436               	.L169:
 3437               	.LBE120:
 565:main.c        **** 			}
 566:main.c        **** 		}
 567:main.c        **** 		
 568:main.c        **** 		// Send back the PCB version number
 569:main.c        **** 		else if (receivedChar == READ_PCB_VERSION) {
 3438               		.loc 3 569 0
 3439 05f2 9836      		cpi r25,lo8(104)
 3440 05f4 01F4      		brne .L170
 570:main.c        **** 			USART_Transmit(PCB_VERSION);
 3441               		.loc 3 570 0
 3442 05f6 82E0      		ldi r24,lo8(2)
 3443               	.LVL408:
 3444 05f8 00C0      		rjmp .L190
 3445               	.LVL409:
 3446               	.L170:
 571:main.c        **** 		}
 572:main.c        **** 		
 573:main.c        **** 		// Send back the firmware version number
 574:main.c        **** 		else if (receivedChar == READ_FIRMWARE_VERSION) {
 3447               		.loc 3 574 0
 3448 05fa 9635      		cpi r25,lo8(86)
 3449 05fc 01F4      		brne .L171
 575:main.c        **** 			USART_Transmit(FIRMWARE_VERSION);
 3450               		.loc 3 575 0
 3451 05fe 86E0      		ldi r24,lo8(6)
 3452               	.LVL410:
 3453               	.L190:
 3454 0600 00D0      		rcall USART_Transmit
 3455               	.LVL411:
 3456 0602 00C0      		rjmp .L88
 3457               	.LVL412:
 3458               	.L171:
 576:main.c        **** 		}
 577:main.c        **** 		
 578:main.c        **** 		// Reset the AVR if it matches the number
 579:main.c        **** 		else if (receivedChar == RESET_AVR) {
 3459               		.loc 3 579 0
 3460 0604 9A32      		cpi r25,lo8(42)
 3461 0606 01F0      		breq .+2
 3462 0608 00C0      		rjmp .L88
 3463               	.LBB121:
 580:main.c        **** 			usart_read_chars();
 3464               		.loc 3 580 0
 3465 060a 00D0      		rcall usart_read_chars
 3466               	.LVL413:
 581:main.c        **** 			uint32_t resetValue = strtol(receivedBuffer, NULL, 16);
 3467               		.loc 3 581 0
 3468 060c 40E1      		ldi r20,lo8(16)
 3469 060e 50E0      		ldi r21,0
 3470 0610 60E0      		ldi r22,0
 3471 0612 70E0      		ldi r23,0
 3472 0614 80E0      		ldi r24,lo8(receivedBuffer)
 3473 0616 90E0      		ldi r25,hi8(receivedBuffer)
 3474 0618 00D0      		rcall strtol
 3475               	.LVL414:
 582:main.c        **** 			if (resetValue == RESET_VALUE) {
 3476               		.loc 3 582 0
 3477 061a 613E      		cpi r22,-31
 3478 061c 754E      		sbci r23,-27
 3479 061e 8740      		sbci r24,7
 3480 0620 9105      		cpc r25,__zero_reg__
 3481 0622 01F0      		breq .+2
 3482 0624 00C0      		rjmp .L88
 583:main.c        **** 				// Clear watchdog flag
 584:main.c        **** 				MCUCSR &= ~(1<<WDRF);
 3483               		.loc 3 584 0
 3484 0626 84B7      		in r24,0x34
 3485 0628 877F      		andi r24,lo8(-9)
 3486 062a 84BF      		out 0x34,r24
 585:main.c        **** 				
 586:main.c        **** 				// Start timed sequence
 587:main.c        **** 				WDTCR = (1<<WDCE) | (1<<WDE);
 3487               		.loc 3 587 0
 3488 062c 88E1      		ldi r24,lo8(24)
 3489 062e 81BD      		out 0x21,r24
 588:main.c        **** 				
 589:main.c        **** 				// Reset in 250 ms
 590:main.c        **** 				WDTCR = (1<<WDP2) | (1<<WDE);
 3490               		.loc 3 590 0
 3491 0630 9CE0      		ldi r25,lo8(12)
 3492 0632 91BD      		out 0x21,r25
 3493               	.LVL415:
 3494               	.LBB122:
 3495               	.LBB123:
 3496               		.file 4 "c:\\winavr-20100110\\avr\\include\\util\\delay_basic.h"
   1:c:\winavr-20100110\avr\include\util\delay_basic.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:c:\winavr-20100110\avr\include\util\delay_basic.h ****    Copyright (c) 2007 Joerg Wunsch
   3:c:\winavr-20100110\avr\include\util\delay_basic.h ****    All rights reserved.
   4:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
   5:c:\winavr-20100110\avr\include\util\delay_basic.h ****    Redistribution and use in source and binary forms, with or without
   6:c:\winavr-20100110\avr\include\util\delay_basic.h ****    modification, are permitted provided that the following conditions are met:
   7:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
   8:c:\winavr-20100110\avr\include\util\delay_basic.h ****    * Redistributions of source code must retain the above copyright
   9:c:\winavr-20100110\avr\include\util\delay_basic.h ****      notice, this list of conditions and the following disclaimer.
  10:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  11:c:\winavr-20100110\avr\include\util\delay_basic.h ****    * Redistributions in binary form must reproduce the above copyright
  12:c:\winavr-20100110\avr\include\util\delay_basic.h ****      notice, this list of conditions and the following disclaimer in
  13:c:\winavr-20100110\avr\include\util\delay_basic.h ****      the documentation and/or other materials provided with the
  14:c:\winavr-20100110\avr\include\util\delay_basic.h ****      distribution.
  15:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  16:c:\winavr-20100110\avr\include\util\delay_basic.h ****    * Neither the name of the copyright holders nor the names of
  17:c:\winavr-20100110\avr\include\util\delay_basic.h ****      contributors may be used to endorse or promote products derived
  18:c:\winavr-20100110\avr\include\util\delay_basic.h ****      from this software without specific prior written permission.
  19:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  20:c:\winavr-20100110\avr\include\util\delay_basic.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  21:c:\winavr-20100110\avr\include\util\delay_basic.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  22:c:\winavr-20100110\avr\include\util\delay_basic.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  23:c:\winavr-20100110\avr\include\util\delay_basic.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  24:c:\winavr-20100110\avr\include\util\delay_basic.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  25:c:\winavr-20100110\avr\include\util\delay_basic.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  26:c:\winavr-20100110\avr\include\util\delay_basic.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  27:c:\winavr-20100110\avr\include\util\delay_basic.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  28:c:\winavr-20100110\avr\include\util\delay_basic.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  29:c:\winavr-20100110\avr\include\util\delay_basic.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  30:c:\winavr-20100110\avr\include\util\delay_basic.h ****   POSSIBILITY OF SUCH DAMAGE. */
  31:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  32:c:\winavr-20100110\avr\include\util\delay_basic.h **** /* $Id$ */
  33:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  34:c:\winavr-20100110\avr\include\util\delay_basic.h **** #ifndef _UTIL_DELAY_BASIC_H_
  35:c:\winavr-20100110\avr\include\util\delay_basic.h **** #define _UTIL_DELAY_BASIC_H_ 1
  36:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  37:c:\winavr-20100110\avr\include\util\delay_basic.h **** #include <inttypes.h>
  38:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  39:c:\winavr-20100110\avr\include\util\delay_basic.h **** #if !defined(__DOXYGEN__)
  40:c:\winavr-20100110\avr\include\util\delay_basic.h **** static __inline__ void _delay_loop_1(uint8_t __count) __attribute__((__always_inline__));
  41:c:\winavr-20100110\avr\include\util\delay_basic.h **** static __inline__ void _delay_loop_2(uint16_t __count) __attribute__((__always_inline__));
  42:c:\winavr-20100110\avr\include\util\delay_basic.h **** #endif
  43:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  44:c:\winavr-20100110\avr\include\util\delay_basic.h **** /** \file */
  45:c:\winavr-20100110\avr\include\util\delay_basic.h **** /** \defgroup util_delay_basic <util/delay_basic.h>: Basic busy-wait delay loops
  46:c:\winavr-20100110\avr\include\util\delay_basic.h ****     \code
  47:c:\winavr-20100110\avr\include\util\delay_basic.h ****     #include <util/delay_basic.h>
  48:c:\winavr-20100110\avr\include\util\delay_basic.h ****     \endcode
  49:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  50:c:\winavr-20100110\avr\include\util\delay_basic.h ****     The functions in this header file implement simple delay loops
  51:c:\winavr-20100110\avr\include\util\delay_basic.h ****     that perform a busy-waiting.  They are typically used to
  52:c:\winavr-20100110\avr\include\util\delay_basic.h ****     facilitate short delays in the program execution.  They are
  53:c:\winavr-20100110\avr\include\util\delay_basic.h ****     implemented as count-down loops with a well-known CPU cycle
  54:c:\winavr-20100110\avr\include\util\delay_basic.h ****     count per loop iteration.  As such, no other processing can
  55:c:\winavr-20100110\avr\include\util\delay_basic.h ****     occur simultaneously.  It should be kept in mind that the
  56:c:\winavr-20100110\avr\include\util\delay_basic.h ****     functions described here do not disable interrupts.
  57:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  58:c:\winavr-20100110\avr\include\util\delay_basic.h ****     In general, for long delays, the use of hardware timers is
  59:c:\winavr-20100110\avr\include\util\delay_basic.h ****     much preferrable, as they free the CPU, and allow for
  60:c:\winavr-20100110\avr\include\util\delay_basic.h ****     concurrent processing of other events while the timer is
  61:c:\winavr-20100110\avr\include\util\delay_basic.h ****     running.  However, in particular for very short delays, the
  62:c:\winavr-20100110\avr\include\util\delay_basic.h ****     overhead of setting up a hardware timer is too much compared
  63:c:\winavr-20100110\avr\include\util\delay_basic.h ****     to the overall delay time.
  64:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  65:c:\winavr-20100110\avr\include\util\delay_basic.h ****     Two inline functions are provided for the actual delay algorithms.
  66:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  67:c:\winavr-20100110\avr\include\util\delay_basic.h **** */
  68:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  69:c:\winavr-20100110\avr\include\util\delay_basic.h **** /** \ingroup util_delay_basic
  70:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  71:c:\winavr-20100110\avr\include\util\delay_basic.h ****     Delay loop using an 8-bit counter \c __count, so up to 256
  72:c:\winavr-20100110\avr\include\util\delay_basic.h ****     iterations are possible.  (The value 256 would have to be passed
  73:c:\winavr-20100110\avr\include\util\delay_basic.h ****     as 0.)  The loop executes three CPU cycles per iteration, not
  74:c:\winavr-20100110\avr\include\util\delay_basic.h ****     including the overhead the compiler needs to setup the counter
  75:c:\winavr-20100110\avr\include\util\delay_basic.h ****     register.
  76:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  77:c:\winavr-20100110\avr\include\util\delay_basic.h ****     Thus, at a CPU speed of 1 MHz, delays of up to 768 microseconds
  78:c:\winavr-20100110\avr\include\util\delay_basic.h ****     can be achieved.
  79:c:\winavr-20100110\avr\include\util\delay_basic.h **** */
  80:c:\winavr-20100110\avr\include\util\delay_basic.h **** void
  81:c:\winavr-20100110\avr\include\util\delay_basic.h **** _delay_loop_1(uint8_t __count)
  82:c:\winavr-20100110\avr\include\util\delay_basic.h **** {
  83:c:\winavr-20100110\avr\include\util\delay_basic.h **** 	__asm__ volatile (
  84:c:\winavr-20100110\avr\include\util\delay_basic.h **** 		"1: dec %0" "\n\t"
  85:c:\winavr-20100110\avr\include\util\delay_basic.h **** 		"brne 1b"
  86:c:\winavr-20100110\avr\include\util\delay_basic.h **** 		: "=r" (__count)
  87:c:\winavr-20100110\avr\include\util\delay_basic.h **** 		: "0" (__count)
  88:c:\winavr-20100110\avr\include\util\delay_basic.h **** 	);
  89:c:\winavr-20100110\avr\include\util\delay_basic.h **** }
  90:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  91:c:\winavr-20100110\avr\include\util\delay_basic.h **** /** \ingroup util_delay_basic
  92:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  93:c:\winavr-20100110\avr\include\util\delay_basic.h ****     Delay loop using a 16-bit counter \c __count, so up to 65536
  94:c:\winavr-20100110\avr\include\util\delay_basic.h ****     iterations are possible.  (The value 65536 would have to be
  95:c:\winavr-20100110\avr\include\util\delay_basic.h ****     passed as 0.)  The loop executes four CPU cycles per iteration,
  96:c:\winavr-20100110\avr\include\util\delay_basic.h ****     not including the overhead the compiler requires to setup the
  97:c:\winavr-20100110\avr\include\util\delay_basic.h ****     counter register pair.
  98:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  99:c:\winavr-20100110\avr\include\util\delay_basic.h ****     Thus, at a CPU speed of 1 MHz, delays of up to about 262.1
 100:c:\winavr-20100110\avr\include\util\delay_basic.h ****     milliseconds can be achieved.
 101:c:\winavr-20100110\avr\include\util\delay_basic.h ****  */
 102:c:\winavr-20100110\avr\include\util\delay_basic.h **** void
 103:c:\winavr-20100110\avr\include\util\delay_basic.h **** _delay_loop_2(uint16_t __count)
 104:c:\winavr-20100110\avr\include\util\delay_basic.h **** {
 105:c:\winavr-20100110\avr\include\util\delay_basic.h **** 	__asm__ volatile (
 3497               		.loc 4 105 0
 3498 0634 8FEF      		ldi r24,lo8(-1)
 3499 0636 9FEF      		ldi r25,lo8(-1)
 3500               	/* #APP */
 3501               	 ;  105 "c:\winavr-20100110\avr\include\util\delay_basic.h" 1
 3502 0638 0197      		1: sbiw r24,1
 3503 063a 01F4      		brne 1b
 3504               	 ;  0 "" 2
 3505               	.LVL416:
 3506               	/* #NOAPP */
 3507 063c 00C0      		rjmp .L88
 3508               	.LBE123:
 3509               	.LBE122:
 3510               	.LBE121:
 3511               		.cfi_endproc
 3512               	.LFE44:
 3514               		.comm	flashChipIdBuffer,2,1
 3515               		.comm	eepromBuffer,8,1
 3516               		.comm	receivedChar,1,1
 3517               		.comm	receivedBuffer,129,1
 3518               		.text
 3519               	.Letext0:
 3520               		.file 5 "c:\\winavr-20100110\\avr\\include\\stdint.h"
 3521               		.file 6 "c:\\winavr-20100110\\avr\\include\\stdlib.h"
DEFINED SYMBOLS
                            *ABS*:00000000 main.c
C:\Users\Alex\AppData\Local\Temp\ccSj9nU6.s:2      *ABS*:0000003e __SP_H__
C:\Users\Alex\AppData\Local\Temp\ccSj9nU6.s:3      *ABS*:0000003d __SP_L__
C:\Users\Alex\AppData\Local\Temp\ccSj9nU6.s:4      *ABS*:0000003f __SREG__
C:\Users\Alex\AppData\Local\Temp\ccSj9nU6.s:5      *ABS*:00000000 __tmp_reg__
C:\Users\Alex\AppData\Local\Temp\ccSj9nU6.s:6      *ABS*:00000001 __zero_reg__
C:\Users\Alex\AppData\Local\Temp\ccSj9nU6.s:12     .text:00000000 USART_Receive
C:\Users\Alex\AppData\Local\Temp\ccSj9nU6.s:34     .text:00000008 USART_Transmit
C:\Users\Alex\AppData\Local\Temp\ccSj9nU6.s:55     .text:00000010 usart_read_bytes
                            *COM*:00000081 receivedBuffer
C:\Users\Alex\AppData\Local\Temp\ccSj9nU6.s:118    .text:0000003a usart_read_chars
C:\Users\Alex\AppData\Local\Temp\ccSj9nU6.s:162    .text:00000056 rd_wr_csmreq_cs2_reset
C:\Users\Alex\AppData\Local\Temp\ccSj9nU6.s:184    .text:00000060 gb_mode
C:\Users\Alex\AppData\Local\Temp\ccSj9nU6.s:211    .text:00000070 set_16bit_address
C:\Users\Alex\AppData\Local\Temp\ccSj9nU6.s:230    .text:00000076 read_8bit_data
C:\Users\Alex\AppData\Local\Temp\ccSj9nU6.s:270    .text:00000088 write_8bit_data
C:\Users\Alex\AppData\Local\Temp\ccSj9nU6.s:335    .text:000000b4 gba_mode
C:\Users\Alex\AppData\Local\Temp\ccSj9nU6.s:362    .text:000000c4 gba_set_24bit_address
C:\Users\Alex\AppData\Local\Temp\ccSj9nU6.s:415    .text:000000f0 gba_read_16bit_data
C:\Users\Alex\AppData\Local\Temp\ccSj9nU6.s:463    .text:0000010e gba_read_ram_8bit_data
C:\Users\Alex\AppData\Local\Temp\ccSj9nU6.s:503    .text:00000120 gba_write_ram_8bit_data
C:\Users\Alex\AppData\Local\Temp\ccSj9nU6.s:557    .text:00000140 gba_eeprom_mode
C:\Users\Alex\AppData\Local\Temp\ccSj9nU6.s:585    .text:00000152 gba_eeprom_set_address
C:\Users\Alex\AppData\Local\Temp\ccSj9nU6.s:724    .text:000001ba gba_eeprom_read
                            *COM*:00000008 eepromBuffer
C:\Users\Alex\AppData\Local\Temp\ccSj9nU6.s:856    .text:00000214 gba_eeprom_write
C:\Users\Alex\AppData\Local\Temp\ccSj9nU6.s:972    .text:00000268 flash_write_bus_cycle
C:\Users\Alex\AppData\Local\Temp\ccSj9nU6.s:1018   .text:00000282 flash_read_chip_id
                            *COM*:00000002 flashChipIdBuffer
C:\Users\Alex\AppData\Local\Temp\ccSj9nU6.s:1123   .text:000002ec flash_switch_bank
C:\Users\Alex\AppData\Local\Temp\ccSj9nU6.s:1172   .text:00000312 flash_erase_4k_sector
C:\Users\Alex\AppData\Local\Temp\ccSj9nU6.s:1247   .text:0000035a flash_write_byte
C:\Users\Alex\AppData\Local\Temp\ccSj9nU6.s:1318   .text:00000392 flash_write_sector
C:\Users\Alex\AppData\Local\Temp\ccSj9nU6.s:1431   .text:000003fe audio_flash_write_bus_cycle
C:\Users\Alex\AppData\Local\Temp\ccSj9nU6.s:1481   .text:00000418 audio_flash_write_byte
C:\Users\Alex\AppData\Local\Temp\ccSj9nU6.s:1581   .text:0000046a bv5_flash_write_bus_cycle
C:\Users\Alex\AppData\Local\Temp\ccSj9nU6.s:1631   .text:00000484 bv5_flash_read_byte
C:\Users\Alex\AppData\Local\Temp\ccSj9nU6.s:1671   .text:00000496 bv5_flash_write_byte
C:\Users\Alex\AppData\Local\Temp\ccSj9nU6.s:1767   .text:000004e4 gba_flash_write_bus_cycle
C:\Users\Alex\AppData\Local\Temp\ccSj9nU6.s:1830   .text:0000050a gba_flash_write_byte_swapped
C:\Users\Alex\AppData\Local\Temp\ccSj9nU6.s:1954   .text:00000580 setup
C:\Users\Alex\AppData\Local\Temp\ccSj9nU6.s:2049   .text.startup:00000000 main
                            *COM*:00000001 receivedChar

UNDEFINED SYMBOLS
strtol
atoi
__do_clear_bss
