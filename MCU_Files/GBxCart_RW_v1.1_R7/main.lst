   1               		.file	"main.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               	.global	USART_Receive
  12               	USART_Receive:
  13               	.LFB12:
  14               		.file 1 "setup.c"
   1:setup.c       **** /*
   2:setup.c       ****  GBxCart RW
   3:setup.c       ****  PCB version: 1.1 or 1.2
   4:setup.c       ****  Firmware version: R7
   5:setup.c       ****  Author: Alex from insideGadgets (www.insidegadgets.com)
   6:setup.c       ****  Created: 7/11/2016
   7:setup.c       ****  Last Modified: 17/01/2018
   8:setup.c       ****  
   9:setup.c       ****  */
  10:setup.c       ****  
  11:setup.c       **** #ifndef cbi
  12:setup.c       **** #define cbi(sfr, bit) (_SFR_BYTE(sfr) &= ~_BV(bit))
  13:setup.c       **** #endif
  14:setup.c       **** #ifndef sbi
  15:setup.c       **** #define sbi(sfr, bit) (_SFR_BYTE(sfr) |= _BV(bit))
  16:setup.c       **** #endif
  17:setup.c       **** 
  18:setup.c       **** #ifndef NULL
  19:setup.c       **** #define NULL ((void *)0)
  20:setup.c       **** #endif
  21:setup.c       **** 
  22:setup.c       **** #define LOW 0
  23:setup.c       **** #define HIGH 1
  24:setup.c       **** #define false 0
  25:setup.c       **** #define true 1
  26:setup.c       **** 
  27:setup.c       **** #define SWITCH_DETECT PD2
  28:setup.c       **** #define ACTIVITY_LED PD3
  29:setup.c       **** #define LED_5V PD7
  30:setup.c       **** #define LED_3V PE0
  31:setup.c       **** 
  32:setup.c       **** #define WR_PIN PD6
  33:setup.c       **** #define RD_PIN PD5
  34:setup.c       **** #define CS_MREQ_PIN PD4
  35:setup.c       **** #define CS2_PIN PE2
  36:setup.c       **** #define AUDIO_PIN PE1
  37:setup.c       **** 
  38:setup.c       **** #define wrPin_high	PORTD |= (1<<WR_PIN);
  39:setup.c       **** #define wrPin_low		PORTD &= ~(1<<WR_PIN);
  40:setup.c       **** #define rdPin_high	PORTD |= (1<<RD_PIN);
  41:setup.c       **** #define rdPin_low		PORTD &= ~(1<<RD_PIN);
  42:setup.c       **** #define cs_mreqPin_high		PORTD |= (1<<CS_MREQ_PIN);
  43:setup.c       **** #define cs_mreqPin_low		PORTD &= ~(1<<CS_MREQ_PIN);
  44:setup.c       **** #define cs2Pin_high		PORTE |= (1<<CS2_PIN);
  45:setup.c       **** #define cs2Pin_low		PORTE &= ~(1<<CS2_PIN);
  46:setup.c       **** #define audioPin_high		PORTE |= (1<<AUDIO_PIN);
  47:setup.c       **** #define audioPin_low		PORTE &= ~(1<<AUDIO_PIN);
  48:setup.c       **** 
  49:setup.c       **** #define GB_MODE 1
  50:setup.c       **** #define GBA_MODE 2
  51:setup.c       **** 
  52:setup.c       **** // GB/GBC
  53:setup.c       **** #define PORT_ADDR7_0 PORTB
  54:setup.c       **** #define PORT_ADDR15_8 PORTA
  55:setup.c       **** #define PORT_DATA7_0 PORTC
  56:setup.c       **** 
  57:setup.c       **** #define DDR_ADDR7_0 DDRB
  58:setup.c       **** #define DDR_ADDR15_8 DDRA
  59:setup.c       **** #define DDR_DATA7_0 DDRC
  60:setup.c       **** 
  61:setup.c       **** #define PIN_ADDR7_0 PINB
  62:setup.c       **** #define PIN_ADDR15_8 PINA
  63:setup.c       **** #define PIN_DATA7_0 PINC
  64:setup.c       **** 
  65:setup.c       **** #define BANK_WRITE 0
  66:setup.c       **** #define MEMORY_WRITE 1
  67:setup.c       **** 
  68:setup.c       **** // GBA
  69:setup.c       **** #define EEPROM_WRITE 1
  70:setup.c       **** #define EEPROM_READ 0
  71:setup.c       **** 
  72:setup.c       **** #define EEPROM_NONE 0
  73:setup.c       **** #define EEPROM_4KBIT 1
  74:setup.c       **** #define EEPROM_64KBIT 2
  75:setup.c       **** 
  76:setup.c       **** #define AD0 PB0
  77:setup.c       **** #define ad0Pin_high		PORTB |= (1<<AD0);
  78:setup.c       **** #define ad0Pin_low		PORTB &= ~(1<<AD0);
  79:setup.c       **** 
  80:setup.c       **** #define A23 PC7
  81:setup.c       **** #define a23Pin_high		PORTC |= (1<<A23);
  82:setup.c       **** #define a23Pin_low		PORTC &= ~(1<<A23);
  83:setup.c       **** 
  84:setup.c       **** #define GBA_DDR_ROM_ADDR7_0 DDRB
  85:setup.c       **** #define GBA_DDR_ROM_ADDR15_8 DDRA
  86:setup.c       **** #define GBA_DDR_ROM_ADDR23_16 DDRC
  87:setup.c       **** #define GBA_DDR_ROM_DATA7_0 DDRB
  88:setup.c       **** #define GBA_DDR_ROM_DATA15_8 DDRA
  89:setup.c       **** #define GBA_DDR_RAM_DATA7_0 DDRC
  90:setup.c       **** #define GBA_DDR_EEPROM_DATA7_0 DDRB
  91:setup.c       **** 
  92:setup.c       **** #define GBA_PORT_ROM_ADDR7_0 PORTB
  93:setup.c       **** #define GBA_PORT_ROM_ADDR15_8 PORTA
  94:setup.c       **** #define GBA_PORT_ROM_ADDR23_16 PORTC
  95:setup.c       **** #define GBA_PORT_ROM_DATA7_0 PORTB
  96:setup.c       **** #define GBA_PORT_ROM_DATA15_8 PORTA
  97:setup.c       **** #define GBA_PORT_RAM_DATA7_0 PORTC
  98:setup.c       **** #define GBA_PORT_EEPROM_DATA7_0 PORTB
  99:setup.c       **** 
 100:setup.c       **** #define GBA_PIN_ROM_DATA7_0 PINB
 101:setup.c       **** #define GBA_PIN_ROM_DATA15_8 PINA
 102:setup.c       **** #define GBA_PIN_RAM_DATA7_0 PINC
 103:setup.c       **** #define GBA_PIN_EEPROM_DATA7_0 PINB
 104:setup.c       **** 
 105:setup.c       **** // GB/GBC commands
 106:setup.c       **** #define SET_START_ADDRESS 'A'
 107:setup.c       **** #define READ_ROM_RAM 'R'
 108:setup.c       **** #define WRITE_RAM 'W'
 109:setup.c       **** #define SET_BANK 'B'
 110:setup.c       **** #define GB_CART_MODE 'G'
 111:setup.c       **** 
 112:setup.c       **** // GBA commands
 113:setup.c       **** #define GBA_READ_ROM 'r'
 114:setup.c       **** #define GBA_READ_SRAM 'm'
 115:setup.c       **** #define GBA_WRITE_SRAM 'w'
 116:setup.c       **** #define GBA_WRITE_ONE_BYTE_SRAM 'o'
 117:setup.c       **** #define GBA_CART_MODE 'g'
 118:setup.c       **** 
 119:setup.c       **** #define GBA_FLASH_READ_ID 'i'
 120:setup.c       **** #define GBA_FLASH_SET_BANK 'k'
 121:setup.c       **** #define GBA_FLASH_4K_SECTOR_ERASE 's'
 122:setup.c       **** #define GBA_FLASH_WRITE_BYTE 'b'
 123:setup.c       **** #define GBA_FLASH_WRITE_ATMEL 'a'
 124:setup.c       **** 
 125:setup.c       **** #define GBA_SET_EEPROM_SIZE 'S'
 126:setup.c       **** #define GBA_READ_EEPROM 'e'
 127:setup.c       **** #define GBA_WRITE_EEPROM 'p'
 128:setup.c       **** 
 129:setup.c       **** // Flash Cart commands
 130:setup.c       **** #define GB_FLASH_WRITE_BYTE 'F'
 131:setup.c       **** #define GB_FLASH_WRITE_64BYTE 'T'
 132:setup.c       **** #define GB_AUDIO_FLASH_WRITE 'U'
 133:setup.c       **** #define GB_WR_FLASH_WRITE 'E'
 134:setup.c       **** #define GB_BV5_FLASH_WRITE '5'
 135:setup.c       **** #define GB_WORD_FLASH_WRITE 'Y'
 136:setup.c       **** 
 137:setup.c       **** #define GBA_FLASH_CART_WRITE_BYTE 'n'
 138:setup.c       **** #define GBA_FLASH_WRITE_64BYTE 'q'
 139:setup.c       **** 
 140:setup.c       **** // General commands
 141:setup.c       **** #define CART_MODE 'C'
 142:setup.c       **** #define SET_INPUT 'I'
 143:setup.c       **** #define SET_OUTPUT 'O'
 144:setup.c       **** #define SET_OUTPUT_LOW 'L'
 145:setup.c       **** #define SET_OUTPUT_HIGH 'H'
 146:setup.c       **** #define READ_INPUT 'D'
 147:setup.c       **** #define RESET_COMMON_LINES 'M'
 148:setup.c       **** #define READ_FIRMWARE_VERSION 'V'
 149:setup.c       **** #define READ_PCB_VERSION 'h'
 150:setup.c       **** 
 151:setup.c       **** #define RESET_AVR '*'
 152:setup.c       **** #define RESET_VALUE 0x7E5E1
 153:setup.c       **** 
 154:setup.c       **** 
 155:setup.c       **** char receivedBuffer[129];
 156:setup.c       **** char receivedChar;
 157:setup.c       **** uint8_t eepromBuffer[8];
 158:setup.c       **** uint8_t flashChipIdBuffer[2];
 159:setup.c       **** 
 160:setup.c       **** // Receive USART data
 161:setup.c       **** uint8_t USART_Receive(void) {
  15               		.loc 1 161 0
  16               		.cfi_startproc
  17               	/* prologue: function */
  18               	/* frame size = 0 */
  19               	/* stack size = 0 */
  20               	.L__stack_usage = 0
  21               	.L2:
 162:setup.c       **** 	while ( !(UCSRA & (1<<RXC)) ); // Wait for data to be received
  22               		.loc 1 162 0 discriminator 1
  23 0000 5F9B      		sbis 0xb,7
  24 0002 00C0      		rjmp .L2
 163:setup.c       **** 	return UDR; // Get and return received data from buffer
  25               		.loc 1 163 0
  26 0004 8CB1      		in r24,0xc
 164:setup.c       **** }
  27               		.loc 1 164 0
  28 0006 0895      		ret
  29               		.cfi_endproc
  30               	.LFE12:
  32               	.global	USART_Transmit
  34               	USART_Transmit:
  35               	.LFB13:
 165:setup.c       **** 
 166:setup.c       **** // Transmit USART data
 167:setup.c       **** void USART_Transmit(unsigned char data) {
  36               		.loc 1 167 0
  37               		.cfi_startproc
  38               	/* prologue: function */
  39               	/* frame size = 0 */
  40               	/* stack size = 0 */
  41               	.L__stack_usage = 0
  42               	.LVL0:
  43               	.L6:
 168:setup.c       **** 	while ( !( UCSRA & (1<<UDRE)) ); // Wait for empty transmit buffer
  44               		.loc 1 168 0 discriminator 1
  45 0008 5D9B      		sbis 0xb,5
  46 000a 00C0      		rjmp .L6
 169:setup.c       **** 	UDR = data;
  47               		.loc 1 169 0
  48 000c 8CB9      		out 0xc,r24
  49 000e 0895      		ret
  50               		.cfi_endproc
  51               	.LFE13:
  53               	.global	usart_read_bytes
  55               	usart_read_bytes:
  56               	.LFB14:
 170:setup.c       **** }
 171:setup.c       **** 
 172:setup.c       **** // Read 1-128 bytes from the USART 
 173:setup.c       **** void usart_read_bytes(uint8_t count) {
  57               		.loc 1 173 0
  58               		.cfi_startproc
  59               	.LVL1:
  60 0010 0F93      		push r16
  61               	.LCFI0:
  62               		.cfi_def_cfa_offset 3
  63               		.cfi_offset 16, -2
  64 0012 1F93      		push r17
  65               	.LCFI1:
  66               		.cfi_def_cfa_offset 4
  67               		.cfi_offset 17, -3
  68 0014 CF93      		push r28
  69               	.LCFI2:
  70               		.cfi_def_cfa_offset 5
  71               		.cfi_offset 28, -4
  72 0016 DF93      		push r29
  73               	.LCFI3:
  74               		.cfi_def_cfa_offset 6
  75               		.cfi_offset 29, -5
  76               	/* prologue: function */
  77               	/* frame size = 0 */
  78               	/* stack size = 4 */
  79               	.L__stack_usage = 4
  80 0018 D82F      		mov r29,r24
  81               	.LVL2:
  82 001a 00E0      		ldi r16,lo8(receivedBuffer)
  83 001c 10E0      		ldi r17,hi8(receivedBuffer)
  84               	.LBB65:
 174:setup.c       **** 	for (uint8_t x = 0; x < count; x++) {
  85               		.loc 1 174 0
  86 001e C0E0      		ldi r28,0
  87               	.LVL3:
  88               	.L10:
  89               		.loc 1 174 0 is_stmt 0 discriminator 1
  90 0020 CD17      		cp r28,r29
  91 0022 01F0      		breq .L12
 175:setup.c       **** 		receivedBuffer[x] = USART_Receive();
  92               		.loc 1 175 0 is_stmt 1 discriminator 3
  93 0024 00D0      		rcall USART_Receive
  94               	.LVL4:
  95 0026 F801      		movw r30,r16
  96 0028 8193      		st Z+,r24
  97 002a 8F01      		movw r16,r30
 174:setup.c       **** 	for (uint8_t x = 0; x < count; x++) {
  98               		.loc 1 174 0 discriminator 3
  99 002c CF5F      		subi r28,lo8(-(1))
 100               	.LVL5:
 101 002e 00C0      		rjmp .L10
 102               	.L12:
 103               	/* epilogue start */
 104               	.LBE65:
 176:setup.c       **** 	}
 177:setup.c       **** }
 105               		.loc 1 177 0
 106 0030 DF91      		pop r29
 107               	.LVL6:
 108 0032 CF91      		pop r28
 109               	.LVL7:
 110 0034 1F91      		pop r17
 111 0036 0F91      		pop r16
 112 0038 0895      		ret
 113               		.cfi_endproc
 114               	.LFE14:
 116               	.global	usart_read_chars
 118               	usart_read_chars:
 119               	.LFB15:
 178:setup.c       **** 
 179:setup.c       **** // Read the USART until a 0 (string terminator byte) is received
 180:setup.c       **** void usart_read_chars(void) {
 120               		.loc 1 180 0
 121               		.cfi_startproc
 122 003a CF93      		push r28
 123               	.LCFI4:
 124               		.cfi_def_cfa_offset 3
 125               		.cfi_offset 28, -2
 126               	/* prologue: function */
 127               	/* frame size = 0 */
 128               	/* stack size = 1 */
 129               	.L__stack_usage = 1
 130               	.LVL8:
 181:setup.c       **** 	uint8_t x = 0;
 131               		.loc 1 181 0
 132 003c C0E0      		ldi r28,0
 133               	.LVL9:
 134               	.L15:
 182:setup.c       **** 	while (1) {
 183:setup.c       **** 		receivedBuffer[x] = USART_Receive();
 135               		.loc 1 183 0
 136 003e 00D0      		rcall USART_Receive
 137               	.LVL10:
 138 0040 EC2F      		mov r30,r28
 139 0042 F0E0      		ldi r31,0
 140 0044 E050      		subi r30,lo8(-(receivedBuffer))
 141 0046 F040      		sbci r31,hi8(-(receivedBuffer))
 142 0048 8083      		st Z,r24
 184:setup.c       **** 		if (receivedBuffer[x] == 0) {
 143               		.loc 1 184 0
 144 004a 8823      		tst r24
 145 004c 01F0      		breq .L13
 185:setup.c       **** 			break;
 186:setup.c       **** 		}
 187:setup.c       **** 		x++;
 146               		.loc 1 187 0
 147 004e CF5F      		subi r28,lo8(-(1))
 148               	.LVL11:
 188:setup.c       **** 	}
 149               		.loc 1 188 0
 150 0050 00C0      		rjmp .L15
 151               	.L13:
 152               	/* epilogue start */
 189:setup.c       **** }
 153               		.loc 1 189 0
 154 0052 CF91      		pop r28
 155               	.LVL12:
 156 0054 0895      		ret
 157               		.cfi_endproc
 158               	.LFE15:
 160               	.global	rd_wr_csmreq_cs2_reset
 162               	rd_wr_csmreq_cs2_reset:
 163               	.LFB16:
 190:setup.c       **** 
 191:setup.c       **** // Turn RD, WR, CS/MREQ and CS2 to high so they are deselected (reset state)
 192:setup.c       **** void rd_wr_csmreq_cs2_reset(void) {
 164               		.loc 1 192 0
 165               		.cfi_startproc
 166               	/* prologue: function */
 167               	/* frame size = 0 */
 168               	/* stack size = 0 */
 169               	.L__stack_usage = 0
 193:setup.c       **** 	cs2Pin_high; // CS2 off
 170               		.loc 1 193 0
 171 0056 3A9A      		sbi 0x7,2
 194:setup.c       **** 	cs_mreqPin_high; // CS/MREQ off
 172               		.loc 1 194 0
 173 0058 949A      		sbi 0x12,4
 195:setup.c       **** 	rdPin_high; // RD off
 174               		.loc 1 195 0
 175 005a 959A      		sbi 0x12,5
 196:setup.c       **** 	wrPin_high; // WR off
 176               		.loc 1 196 0
 177 005c 969A      		sbi 0x12,6
 178 005e 0895      		ret
 179               		.cfi_endproc
 180               	.LFE16:
 182               	.global	gb_mode
 184               	gb_mode:
 185               	.LFB17:
 197:setup.c       **** }
 198:setup.c       **** 
 199:setup.c       **** 
 200:setup.c       **** 
 201:setup.c       **** // ****** Gameboy / Gameboy Colour functions ******
 202:setup.c       **** 
 203:setup.c       **** // Set Gameboy mode
 204:setup.c       **** void gb_mode(void) {
 186               		.loc 1 204 0
 187               		.cfi_startproc
 188               	/* prologue: function */
 189               	/* frame size = 0 */
 190               	/* stack size = 0 */
 191               	.L__stack_usage = 0
 205:setup.c       **** 	// Set inputs
 206:setup.c       **** 	PORT_DATA7_0 = 0;
 192               		.loc 1 206 0
 193 0060 15BA      		out 0x15,__zero_reg__
 207:setup.c       **** 	DDR_DATA7_0 = 0;
 194               		.loc 1 207 0
 195 0062 14BA      		out 0x14,__zero_reg__
 208:setup.c       **** 	
 209:setup.c       **** 	// Set outputs
 210:setup.c       **** 	PORT_ADDR7_0 = 0;
 196               		.loc 1 210 0
 197 0064 18BA      		out 0x18,__zero_reg__
 211:setup.c       **** 	PORT_ADDR15_8 = 0;
 198               		.loc 1 211 0
 199 0066 1BBA      		out 0x1b,__zero_reg__
 212:setup.c       **** 	DDR_ADDR7_0 = 0xFF;
 200               		.loc 1 212 0
 201 0068 8FEF      		ldi r24,lo8(-1)
 202 006a 87BB      		out 0x17,r24
 213:setup.c       **** 	DDR_ADDR15_8 = 0xFF;
 203               		.loc 1 213 0
 204 006c 8ABB      		out 0x1a,r24
 205 006e 0895      		ret
 206               		.cfi_endproc
 207               	.LFE17:
 209               	.global	set_16bit_address
 211               	set_16bit_address:
 212               	.LFB18:
 214:setup.c       **** }
 215:setup.c       **** 
 216:setup.c       **** // Set the 16 bit address on A15-0
 217:setup.c       **** void set_16bit_address(uint16_t address) {
 213               		.loc 1 217 0
 214               		.cfi_startproc
 215               	.LVL13:
 216               	/* prologue: function */
 217               	/* frame size = 0 */
 218               	/* stack size = 0 */
 219               	.L__stack_usage = 0
 218:setup.c       **** 	PORT_ADDR15_8 = (address >> 8);
 220               		.loc 1 218 0
 221 0070 9BBB      		out 0x1b,r25
 219:setup.c       **** 	PORT_ADDR7_0 = (address & 0xFF);
 222               		.loc 1 219 0
 223 0072 88BB      		out 0x18,r24
 224 0074 0895      		ret
 225               		.cfi_endproc
 226               	.LFE18:
 228               	.global	read_8bit_data
 230               	read_8bit_data:
 231               	.LFB19:
 220:setup.c       **** }
 221:setup.c       **** 
 222:setup.c       **** // Set the address and read a byte from the 8 bit data line
 223:setup.c       **** uint8_t read_8bit_data(uint16_t address) {
 232               		.loc 1 223 0
 233               		.cfi_startproc
 234               	.LVL14:
 235               	/* prologue: function */
 236               	/* frame size = 0 */
 237               	/* stack size = 0 */
 238               	.L__stack_usage = 0
 224:setup.c       **** 	set_16bit_address(address);
 239               		.loc 1 224 0
 240 0076 00D0      		rcall set_16bit_address
 241               	.LVL15:
 225:setup.c       **** 	
 226:setup.c       **** 	cs_mreqPin_low;
 242               		.loc 1 226 0
 243 0078 9498      		cbi 0x12,4
 227:setup.c       **** 	rdPin_low;
 244               		.loc 1 227 0
 245 007a 9598      		cbi 0x12,5
 228:setup.c       **** 	
 229:setup.c       **** 	asm volatile("nop"); // Delay a little (minimum needed is 1 nops, 2 nops for GB camera)
 246               		.loc 1 229 0
 247               	/* #APP */
 248               	 ;  229 "setup.c" 1
 249 007c 0000      		nop
 250               	 ;  0 "" 2
 230:setup.c       **** 	asm volatile("nop");
 251               		.loc 1 230 0
 252               	 ;  230 "setup.c" 1
 253 007e 0000      		nop
 254               	 ;  0 "" 2
 231:setup.c       **** 	uint8_t data = PIN_DATA7_0; // Read data
 255               		.loc 1 231 0
 256               	/* #NOAPP */
 257 0080 83B3      		in r24,0x13
 258               	.LVL16:
 232:setup.c       **** 	
 233:setup.c       **** 	rdPin_high;
 259               		.loc 1 233 0
 260 0082 959A      		sbi 0x12,5
 234:setup.c       **** 	cs_mreqPin_high;
 261               		.loc 1 234 0
 262 0084 949A      		sbi 0x12,4
 235:setup.c       **** 	
 236:setup.c       **** 	return data;
 237:setup.c       **** }
 263               		.loc 1 237 0
 264 0086 0895      		ret
 265               		.cfi_endproc
 266               	.LFE19:
 268               	.global	write_8bit_data
 270               	write_8bit_data:
 271               	.LFB20:
 238:setup.c       **** 
 239:setup.c       **** // Set the address and write a byte to the 8 bit data line and pulse cs/mREQ if writing to RAM
 240:setup.c       **** void write_8bit_data(uint16_t address, uint8_t data, uint8_t type) {
 272               		.loc 1 240 0
 273               		.cfi_startproc
 274               	.LVL17:
 275 0088 CF93      		push r28
 276               	.LCFI5:
 277               		.cfi_def_cfa_offset 3
 278               		.cfi_offset 28, -2
 279 008a DF93      		push r29
 280               	.LCFI6:
 281               		.cfi_def_cfa_offset 4
 282               		.cfi_offset 29, -3
 283               	/* prologue: function */
 284               	/* frame size = 0 */
 285               	/* stack size = 2 */
 286               	.L__stack_usage = 2
 287 008c D62F      		mov r29,r22
 288 008e C42F      		mov r28,r20
 241:setup.c       **** 	set_16bit_address(address);
 289               		.loc 1 241 0
 290 0090 00D0      		rcall set_16bit_address
 291               	.LVL18:
 242:setup.c       **** 	
 243:setup.c       **** 	DDR_DATA7_0 = 0xFF; // Set data pins as outputs
 292               		.loc 1 243 0
 293 0092 8FEF      		ldi r24,lo8(-1)
 294 0094 84BB      		out 0x14,r24
 244:setup.c       **** 	PORT_DATA7_0 = data; // Set data
 295               		.loc 1 244 0
 296 0096 D5BB      		out 0x15,r29
 245:setup.c       **** 	
 246:setup.c       **** 	// Pulse WR and mREQ if the type matches
 247:setup.c       **** 	wrPin_low;
 297               		.loc 1 247 0
 298 0098 9698      		cbi 0x12,6
 248:setup.c       **** 	if (type == MEMORY_WRITE) {
 299               		.loc 1 248 0
 300 009a C130      		cpi r28,lo8(1)
 301 009c 01F4      		brne .L21
 249:setup.c       **** 		cs_mreqPin_low;
 302               		.loc 1 249 0
 303 009e 9498      		cbi 0x12,4
 304               	.L21:
 250:setup.c       **** 	}
 251:setup.c       **** 	
 252:setup.c       **** 	asm volatile("nop");
 305               		.loc 1 252 0
 306               	/* #APP */
 307               	 ;  252 "setup.c" 1
 308 00a0 0000      		nop
 309               	 ;  0 "" 2
 253:setup.c       **** 	
 254:setup.c       **** 	if (type == MEMORY_WRITE) {
 310               		.loc 1 254 0
 311               	/* #NOAPP */
 312 00a2 C130      		cpi r28,lo8(1)
 313 00a4 01F4      		brne .L22
 255:setup.c       **** 		cs_mreqPin_high;
 314               		.loc 1 255 0
 315 00a6 949A      		sbi 0x12,4
 316               	.L22:
 256:setup.c       **** 	}
 257:setup.c       **** 	wrPin_high;
 317               		.loc 1 257 0
 318 00a8 969A      		sbi 0x12,6
 258:setup.c       **** 	
 259:setup.c       **** 	// Clear data outputs and set data pins as inputs
 260:setup.c       **** 	PORT_DATA7_0 = 0;
 319               		.loc 1 260 0
 320 00aa 15BA      		out 0x15,__zero_reg__
 261:setup.c       **** 	DDR_DATA7_0 = 0;
 321               		.loc 1 261 0
 322 00ac 14BA      		out 0x14,__zero_reg__
 323               	/* epilogue start */
 262:setup.c       **** }
 324               		.loc 1 262 0
 325 00ae DF91      		pop r29
 326               	.LVL19:
 327 00b0 CF91      		pop r28
 328               	.LVL20:
 329 00b2 0895      		ret
 330               		.cfi_endproc
 331               	.LFE20:
 333               	.global	gba_mode
 335               	gba_mode:
 336               	.LFB21:
 263:setup.c       **** 
 264:setup.c       **** 
 265:setup.c       **** 
 266:setup.c       **** // ****** Gameboy Advance functions ****** 
 267:setup.c       **** 
 268:setup.c       **** // Set GBA mode
 269:setup.c       **** void gba_mode(void) {
 337               		.loc 1 269 0
 338               		.cfi_startproc
 339               	/* prologue: function */
 340               	/* frame size = 0 */
 341               	/* stack size = 0 */
 342               	.L__stack_usage = 0
 270:setup.c       **** 	// Set outputs for reading ROM addresses as default
 271:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = 0;
 343               		.loc 1 271 0
 344 00b4 18BA      		out 0x18,__zero_reg__
 272:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = 0;
 345               		.loc 1 272 0
 346 00b6 1BBA      		out 0x1b,__zero_reg__
 273:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = 0;
 347               		.loc 1 273 0
 348 00b8 15BA      		out 0x15,__zero_reg__
 274:setup.c       **** 	GBA_DDR_ROM_ADDR7_0 = 0xFF;
 349               		.loc 1 274 0
 350 00ba 8FEF      		ldi r24,lo8(-1)
 351 00bc 87BB      		out 0x17,r24
 275:setup.c       **** 	GBA_DDR_ROM_ADDR15_8 = 0xFF;
 352               		.loc 1 275 0
 353 00be 8ABB      		out 0x1a,r24
 276:setup.c       **** 	GBA_DDR_ROM_ADDR23_16 = 0xFF;
 354               		.loc 1 276 0
 355 00c0 84BB      		out 0x14,r24
 356 00c2 0895      		ret
 357               		.cfi_endproc
 358               	.LFE21:
 360               	.global	gba_set_24bit_address
 362               	gba_set_24bit_address:
 363               	.LFB22:
 277:setup.c       **** }
 278:setup.c       **** 
 279:setup.c       **** // Set the 24 bit address on A23-0
 280:setup.c       **** void gba_set_24bit_address(uint32_t address) {	
 364               		.loc 1 280 0
 365               		.cfi_startproc
 366               	.LVL21:
 367 00c4 0F93      		push r16
 368               	.LCFI7:
 369               		.cfi_def_cfa_offset 3
 370               		.cfi_offset 16, -2
 371 00c6 1F93      		push r17
 372               	.LCFI8:
 373               		.cfi_def_cfa_offset 4
 374               		.cfi_offset 17, -3
 375               	/* prologue: function */
 376               	/* frame size = 0 */
 377               	/* stack size = 2 */
 378               	.L__stack_usage = 2
 281:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = 0; // Set 0-23 address lines low and set as outputs
 379               		.loc 1 281 0
 380 00c8 15BA      		out 0x15,__zero_reg__
 282:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = 0;
 381               		.loc 1 282 0
 382 00ca 1BBA      		out 0x1b,__zero_reg__
 283:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = 0;
 383               		.loc 1 283 0
 384 00cc 18BA      		out 0x18,__zero_reg__
 284:setup.c       **** 	GBA_DDR_ROM_ADDR23_16 = 0xFF;
 385               		.loc 1 284 0
 386 00ce 2FEF      		ldi r18,lo8(-1)
 387 00d0 24BB      		out 0x14,r18
 285:setup.c       **** 	GBA_DDR_ROM_ADDR15_8 = 0xFF;
 388               		.loc 1 285 0
 389 00d2 2ABB      		out 0x1a,r18
 286:setup.c       **** 	GBA_DDR_ROM_ADDR7_0 = 0xFF;
 390               		.loc 1 286 0
 391 00d4 27BB      		out 0x17,r18
 287:setup.c       **** 	
 288:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = (address >> 16);
 392               		.loc 1 288 0
 393 00d6 8C01      		movw r16,r24
 394 00d8 2227      		clr r18
 395 00da 3327      		clr r19
 396 00dc 05BB      		out 0x15,r16
 289:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = (address >> 8);
 397               		.loc 1 289 0
 398 00de 072F      		mov r16,r23
 399 00e0 182F      		mov r17,r24
 400 00e2 292F      		mov r18,r25
 401 00e4 3327      		clr r19
 402 00e6 0BBB      		out 0x1b,r16
 290:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = (address & 0xFF);
 403               		.loc 1 290 0
 404 00e8 68BB      		out 0x18,r22
 405               	/* epilogue start */
 291:setup.c       **** }
 406               		.loc 1 291 0
 407 00ea 1F91      		pop r17
 408 00ec 0F91      		pop r16
 409 00ee 0895      		ret
 410               		.cfi_endproc
 411               	.LFE22:
 413               	.global	gba_read_16bit_data
 415               	gba_read_16bit_data:
 416               	.LFB23:
 292:setup.c       **** 
 293:setup.c       **** 
 294:setup.c       **** 
 295:setup.c       **** // ---------- ROM/SRAM ----------
 296:setup.c       **** 
 297:setup.c       **** // Read a byte from the 16 bit data line non-sequentially
 298:setup.c       **** uint16_t gba_read_16bit_data(uint32_t address) {
 417               		.loc 1 298 0
 418               		.cfi_startproc
 419               	.LVL22:
 420               	/* prologue: function */
 421               	/* frame size = 0 */
 422               	/* stack size = 0 */
 423               	.L__stack_usage = 0
 299:setup.c       **** 	gba_set_24bit_address(address);
 424               		.loc 1 299 0
 425 00f0 00D0      		rcall gba_set_24bit_address
 426               	.LVL23:
 300:setup.c       **** 	
 301:setup.c       **** 	cs_mreqPin_low;
 427               		.loc 1 301 0
 428 00f2 9498      		cbi 0x12,4
 302:setup.c       **** 	
 303:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = 0; // Set address lines low and set as inputs
 429               		.loc 1 303 0
 430 00f4 1BBA      		out 0x1b,__zero_reg__
 304:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = 0;
 431               		.loc 1 304 0
 432 00f6 18BA      		out 0x18,__zero_reg__
 305:setup.c       **** 	GBA_DDR_ROM_ADDR15_8 = 0;
 433               		.loc 1 305 0
 434 00f8 1ABA      		out 0x1a,__zero_reg__
 306:setup.c       **** 	GBA_DDR_ROM_ADDR7_0 = 0;
 435               		.loc 1 306 0
 436 00fa 17BA      		out 0x17,__zero_reg__
 307:setup.c       **** 	
 308:setup.c       **** 	rdPin_low;
 437               		.loc 1 308 0
 438 00fc 9598      		cbi 0x12,5
 309:setup.c       **** 	asm volatile("nop");
 439               		.loc 1 309 0
 440               	/* #APP */
 441               	 ;  309 "setup.c" 1
 442 00fe 0000      		nop
 443               	 ;  0 "" 2
 310:setup.c       **** 	
 311:setup.c       **** 	uint16_t data = (GBA_PIN_ROM_DATA15_8 << 8) | GBA_PIN_ROM_DATA7_0; // Read data
 444               		.loc 1 311 0
 445               	/* #NOAPP */
 446 0100 29B3      		in r18,0x19
 447 0102 86B3      		in r24,0x16
 448               	.LVL24:
 312:setup.c       **** 	
 313:setup.c       **** 	rdPin_high;
 449               		.loc 1 313 0
 450 0104 959A      		sbi 0x12,5
 314:setup.c       **** 	cs_mreqPin_high;
 451               		.loc 1 314 0
 452 0106 949A      		sbi 0x12,4
 315:setup.c       **** 	
 316:setup.c       **** 	return data;
 453               		.loc 1 316 0
 454 0108 90E0      		ldi r25,0
 317:setup.c       **** }
 455               		.loc 1 317 0
 456 010a 922B      		or r25,r18
 457 010c 0895      		ret
 458               		.cfi_endproc
 459               	.LFE23:
 461               	.global	gba_read_ram_8bit_data
 463               	gba_read_ram_8bit_data:
 464               	.LFB24:
 318:setup.c       **** 
 319:setup.c       **** // Set the address and read a byte from the 8 bit data line
 320:setup.c       **** uint8_t gba_read_ram_8bit_data(uint16_t address) {
 465               		.loc 1 320 0
 466               		.cfi_startproc
 467               	.LVL25:
 468               	/* prologue: function */
 469               	/* frame size = 0 */
 470               	/* stack size = 0 */
 471               	.L__stack_usage = 0
 321:setup.c       **** 	set_16bit_address(address);
 472               		.loc 1 321 0
 473 010e 00D0      		rcall set_16bit_address
 474               	.LVL26:
 322:setup.c       **** 	
 323:setup.c       **** 	rdPin_low;
 475               		.loc 1 323 0
 476 0110 9598      		cbi 0x12,5
 324:setup.c       **** 	cs2Pin_low; // CS2 pin low for SRAM/Flash select
 477               		.loc 1 324 0
 478 0112 3A98      		cbi 0x7,2
 325:setup.c       **** 	
 326:setup.c       **** 	asm volatile("nop"); // Delay a little (minimum needed is 2)
 479               		.loc 1 326 0
 480               	/* #APP */
 481               	 ;  326 "setup.c" 1
 482 0114 0000      		nop
 483               	 ;  0 "" 2
 327:setup.c       **** 	asm volatile("nop");
 484               		.loc 1 327 0
 485               	 ;  327 "setup.c" 1
 486 0116 0000      		nop
 487               	 ;  0 "" 2
 328:setup.c       **** 	
 329:setup.c       **** 	uint8_t data = GBA_PIN_RAM_DATA7_0; // Read data
 488               		.loc 1 329 0
 489               	/* #NOAPP */
 490 0118 83B3      		in r24,0x13
 491               	.LVL27:
 330:setup.c       **** 	
 331:setup.c       **** 	cs2Pin_high;
 492               		.loc 1 331 0
 493 011a 3A9A      		sbi 0x7,2
 332:setup.c       **** 	rdPin_high;
 494               		.loc 1 332 0
 495 011c 959A      		sbi 0x12,5
 333:setup.c       **** 	
 334:setup.c       **** 	return data;
 335:setup.c       **** }
 496               		.loc 1 335 0
 497 011e 0895      		ret
 498               		.cfi_endproc
 499               	.LFE24:
 501               	.global	gba_write_ram_8bit_data
 503               	gba_write_ram_8bit_data:
 504               	.LFB25:
 336:setup.c       **** 
 337:setup.c       **** // Set the address and write a byte to the 8 bit data line 
 338:setup.c       **** void gba_write_ram_8bit_data(uint16_t address, uint8_t data) {
 505               		.loc 1 338 0
 506               		.cfi_startproc
 507               	.LVL28:
 508 0120 CF93      		push r28
 509               	.LCFI9:
 510               		.cfi_def_cfa_offset 3
 511               		.cfi_offset 28, -2
 512               	/* prologue: function */
 513               	/* frame size = 0 */
 514               	/* stack size = 1 */
 515               	.L__stack_usage = 1
 516 0122 C62F      		mov r28,r22
 339:setup.c       **** 	set_16bit_address(address);
 517               		.loc 1 339 0
 518 0124 00D0      		rcall set_16bit_address
 519               	.LVL29:
 340:setup.c       **** 	
 341:setup.c       **** 	GBA_DDR_RAM_DATA7_0 = 0xFF; // Set data pins as outputs
 520               		.loc 1 341 0
 521 0126 8FEF      		ldi r24,lo8(-1)
 522 0128 84BB      		out 0x14,r24
 342:setup.c       **** 	GBA_PORT_RAM_DATA7_0 = data; // Set data
 523               		.loc 1 342 0
 524 012a C5BB      		out 0x15,r28
 343:setup.c       **** 	
 344:setup.c       **** 	// Pulse WR
 345:setup.c       **** 	wrPin_low;
 525               		.loc 1 345 0
 526 012c 9698      		cbi 0x12,6
 346:setup.c       **** 	cs2Pin_low; // CS2 pin low for SRAM/Flash select
 527               		.loc 1 346 0
 528 012e 3A98      		cbi 0x7,2
 347:setup.c       **** 	
 348:setup.c       **** 	asm volatile("nop");
 529               		.loc 1 348 0
 530               	/* #APP */
 531               	 ;  348 "setup.c" 1
 532 0130 0000      		nop
 533               	 ;  0 "" 2
 349:setup.c       **** 	asm volatile("nop");
 534               		.loc 1 349 0
 535               	 ;  349 "setup.c" 1
 536 0132 0000      		nop
 537               	 ;  0 "" 2
 350:setup.c       **** 	
 351:setup.c       **** 	cs2Pin_high;
 538               		.loc 1 351 0
 539               	/* #NOAPP */
 540 0134 3A9A      		sbi 0x7,2
 352:setup.c       **** 	wrPin_high;
 541               		.loc 1 352 0
 542 0136 969A      		sbi 0x12,6
 353:setup.c       **** 	
 354:setup.c       **** 	// Clear data outputs and set data pins as inputs
 355:setup.c       **** 	GBA_PORT_RAM_DATA7_0 = 0;
 543               		.loc 1 355 0
 544 0138 15BA      		out 0x15,__zero_reg__
 356:setup.c       **** 	GBA_DDR_RAM_DATA7_0 = 0;
 545               		.loc 1 356 0
 546 013a 14BA      		out 0x14,__zero_reg__
 547               	/* epilogue start */
 357:setup.c       **** }
 548               		.loc 1 357 0
 549 013c CF91      		pop r28
 550               	.LVL30:
 551 013e 0895      		ret
 552               		.cfi_endproc
 553               	.LFE25:
 555               	.global	gba_eeprom_mode
 557               	gba_eeprom_mode:
 558               	.LFB26:
 358:setup.c       **** 
 359:setup.c       **** 
 360:setup.c       **** 
 361:setup.c       **** // ---------- EEPROM ----------
 362:setup.c       **** 
 363:setup.c       **** // Set address/data all high (includes AD0/A23)
 364:setup.c       **** void gba_eeprom_mode (void) {
 559               		.loc 1 364 0
 560               		.cfi_startproc
 561               	/* prologue: function */
 562               	/* frame size = 0 */
 563               	/* stack size = 0 */
 564               	.L__stack_usage = 0
 365:setup.c       **** 	GBA_DDR_ROM_ADDR7_0 = 0xFF;
 565               		.loc 1 365 0
 566 0140 8FEF      		ldi r24,lo8(-1)
 567 0142 87BB      		out 0x17,r24
 366:setup.c       **** 	GBA_DDR_ROM_ADDR15_8 = 0xFF;
 568               		.loc 1 366 0
 569 0144 8ABB      		out 0x1a,r24
 367:setup.c       **** 	GBA_DDR_ROM_ADDR23_16 = 0xFF;
 570               		.loc 1 367 0
 571 0146 84BB      		out 0x14,r24
 368:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = 0x80;
 572               		.loc 1 368 0
 573 0148 90E8      		ldi r25,lo8(-128)
 574 014a 98BB      		out 0x18,r25
 369:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = 0xFF;
 575               		.loc 1 369 0
 576 014c 8BBB      		out 0x1b,r24
 370:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = 0xFF;
 577               		.loc 1 370 0
 578 014e 85BB      		out 0x15,r24
 579 0150 0895      		ret
 580               		.cfi_endproc
 581               	.LFE26:
 583               	.global	gba_eeprom_set_address
 585               	gba_eeprom_set_address:
 586               	.LFB27:
 371:setup.c       **** }
 372:setup.c       **** 
 373:setup.c       **** // Send out EEPROM address serially (WR clock, AD0 data out)
 374:setup.c       **** void gba_eeprom_set_address(uint16_t address, uint8_t eepromSize, uint8_t command) {
 587               		.loc 1 374 0
 588               		.cfi_startproc
 589               	.LVL31:
 590               	/* prologue: function */
 591               	/* frame size = 0 */
 592               	/* stack size = 0 */
 593               	.L__stack_usage = 0
 375:setup.c       **** 	cs_mreqPin_low;
 594               		.loc 1 375 0
 595 0152 9498      		cbi 0x12,4
 596               	.LVL32:
 376:setup.c       **** 	
 377:setup.c       **** 	int8_t x = 0;
 378:setup.c       **** 	if (eepromSize == EEPROM_64KBIT) {
 597               		.loc 1 378 0
 598 0154 6230      		cpi r22,lo8(2)
 599 0156 01F4      		brne .L30
 379:setup.c       **** 		if (command == EEPROM_READ) {
 600               		.loc 1 379 0
 601 0158 4111      		cpse r20,__zero_reg__
 602 015a 00C0      		rjmp .L31
 380:setup.c       **** 			address |= (1<<15) | (1<<14); // Set upper 2 bits high for read request
 603               		.loc 1 380 0
 604 015c 906C      		ori r25,192
 605               	.LVL33:
 606               	.L40:
 381:setup.c       **** 		}
 382:setup.c       **** 		else {
 383:setup.c       **** 			address |= (1<<15); // Set upper 1 bit high for write request
 384:setup.c       **** 		}
 385:setup.c       **** 		x = 15;
 607               		.loc 1 385 0
 608 015e 2FE0      		ldi r18,lo8(15)
 609               	.L33:
 610               	.LVL34:
 386:setup.c       **** 	}
 387:setup.c       **** 	else {
 388:setup.c       **** 		if (command == EEPROM_READ) {
 389:setup.c       **** 			address |= (1<<7) | (1<<6);
 390:setup.c       **** 		}
 391:setup.c       **** 		else {
 392:setup.c       **** 			address |= (1<<7);
 393:setup.c       **** 		}
 394:setup.c       **** 		x = 7;
 395:setup.c       **** 	}
 396:setup.c       **** 	
 397:setup.c       **** 	// Loop through address, 8 or 16 bits depending on EEPROM (includes the 2 bits for request type)
 398:setup.c       **** 	while (x >= 0) {
 399:setup.c       **** 		if (address & (1<<x)) {
 611               		.loc 1 399 0
 612 0160 E1E0      		ldi r30,lo8(1)
 613 0162 F0E0      		ldi r31,0
 614 0164 00C0      		rjmp .L32
 615               	.LVL35:
 616               	.L31:
 383:setup.c       **** 		}
 617               		.loc 1 383 0
 618 0166 9068      		ori r25,128
 619               	.LVL36:
 620 0168 00C0      		rjmp .L40
 621               	.L30:
 388:setup.c       **** 			address |= (1<<7) | (1<<6);
 622               		.loc 1 388 0
 623 016a 4111      		cpse r20,__zero_reg__
 624 016c 00C0      		rjmp .L34
 389:setup.c       **** 		}
 625               		.loc 1 389 0
 626 016e 806C      		ori r24,192
 627               	.LVL37:
 628 0170 00C0      		rjmp .L39
 629               	.L34:
 392:setup.c       **** 		}
 630               		.loc 1 392 0
 631 0172 8068      		ori r24,128
 632               	.LVL38:
 633               	.L39:
 394:setup.c       **** 	}
 634               		.loc 1 394 0
 635 0174 27E0      		ldi r18,lo8(7)
 636 0176 00C0      		rjmp .L33
 637               	.LVL39:
 638               	.L35:
 400:setup.c       **** 			ad0Pin_high;
 401:setup.c       **** 		}
 402:setup.c       **** 		else {
 403:setup.c       **** 			ad0Pin_low;
 639               		.loc 1 403 0
 640 0178 C098      		cbi 0x18,0
 641               	.L36:
 404:setup.c       **** 		}
 405:setup.c       **** 		
 406:setup.c       **** 		wrPin_low; // CLK
 642               		.loc 1 406 0
 643 017a 9698      		cbi 0x12,6
 407:setup.c       **** 		asm ("nop");
 644               		.loc 1 407 0
 645               	/* #APP */
 646               	 ;  407 "setup.c" 1
 647 017c 0000      		nop
 648               	 ;  0 "" 2
 408:setup.c       **** 		asm ("nop");
 649               		.loc 1 408 0
 650               	 ;  408 "setup.c" 1
 651 017e 0000      		nop
 652               	 ;  0 "" 2
 409:setup.c       **** 		wrPin_high; 
 653               		.loc 1 409 0
 654               	/* #NOAPP */
 655 0180 969A      		sbi 0x12,6
 410:setup.c       **** 		asm ("nop");
 656               		.loc 1 410 0
 657               	/* #APP */
 658               	 ;  410 "setup.c" 1
 659 0182 0000      		nop
 660               	 ;  0 "" 2
 411:setup.c       **** 		asm ("nop");
 661               		.loc 1 411 0
 662               	 ;  411 "setup.c" 1
 663 0184 0000      		nop
 664               	 ;  0 "" 2
 665               	/* #NOAPP */
 666 0186 2150      		subi r18,lo8(-(-1))
 667               	.LVL40:
 398:setup.c       **** 		if (address & (1<<x)) {
 668               		.loc 1 398 0
 669 0188 27FD      		sbrc r18,7
 670 018a 00C0      		rjmp .L41
 671               	.L32:
 399:setup.c       **** 			ad0Pin_high;
 672               		.loc 1 399 0
 673 018c BF01      		movw r22,r30
 674 018e 022E      		mov r0,r18
 675 0190 00C0      		rjmp 2f
 676               		1:
 677 0192 660F      		lsl r22
 678 0194 771F      		rol r23
 679               		2:
 680 0196 0A94      		dec r0
 681 0198 02F4      		brpl 1b
 682 019a 6823      		and r22,r24
 683 019c 7923      		and r23,r25
 684 019e 672B      		or r22,r23
 685 01a0 01F0      		breq .L35
 400:setup.c       **** 		}
 686               		.loc 1 400 0
 687 01a2 C09A      		sbi 0x18,0
 688 01a4 00C0      		rjmp .L36
 689               	.L41:
 412:setup.c       **** 		
 413:setup.c       **** 		x--;
 414:setup.c       **** 	}
 415:setup.c       **** 	
 416:setup.c       **** 	// Only send stop bit (0) and WR/CS high if reading, as writing is done in 1 continuous chunk
 417:setup.c       **** 	if (command == EEPROM_READ) {  
 690               		.loc 1 417 0
 691 01a6 4111      		cpse r20,__zero_reg__
 692 01a8 00C0      		rjmp .L29
 418:setup.c       **** 		ad0Pin_low;
 693               		.loc 1 418 0
 694 01aa C098      		cbi 0x18,0
 419:setup.c       **** 		asm ("nop");
 695               		.loc 1 419 0
 696               	/* #APP */
 697               	 ;  419 "setup.c" 1
 698 01ac 0000      		nop
 699               	 ;  0 "" 2
 420:setup.c       **** 		wrPin_low;
 700               		.loc 1 420 0
 701               	/* #NOAPP */
 702 01ae 9698      		cbi 0x12,6
 421:setup.c       **** 		asm ("nop");
 703               		.loc 1 421 0
 704               	/* #APP */
 705               	 ;  421 "setup.c" 1
 706 01b0 0000      		nop
 707               	 ;  0 "" 2
 422:setup.c       **** 		asm ("nop");
 708               		.loc 1 422 0
 709               	 ;  422 "setup.c" 1
 710 01b2 0000      		nop
 711               	 ;  0 "" 2
 423:setup.c       **** 		
 424:setup.c       **** 		wrPin_high;
 712               		.loc 1 424 0
 713               	/* #NOAPP */
 714 01b4 969A      		sbi 0x12,6
 425:setup.c       **** 		cs_mreqPin_high;
 715               		.loc 1 425 0
 716 01b6 949A      		sbi 0x12,4
 717               	.L29:
 718 01b8 0895      		ret
 719               		.cfi_endproc
 720               	.LFE27:
 722               	.global	gba_eeprom_read
 724               	gba_eeprom_read:
 725               	.LFB28:
 426:setup.c       **** 	}
 427:setup.c       **** }
 428:setup.c       **** 
 429:setup.c       **** // Read 8 bytes from the EEPROM address, data is valid on rising edge
 430:setup.c       **** void gba_eeprom_read(uint16_t address, uint8_t eepromSize) {
 726               		.loc 1 430 0
 727               		.cfi_startproc
 728               	.LVL41:
 729               	/* prologue: function */
 730               	/* frame size = 0 */
 731               	/* stack size = 0 */
 732               	.L__stack_usage = 0
 431:setup.c       **** 	gba_eeprom_set_address(address, eepromSize, EEPROM_READ);
 733               		.loc 1 431 0
 734 01ba 40E0      		ldi r20,0
 735 01bc 00D0      		rcall gba_eeprom_set_address
 736               	.LVL42:
 432:setup.c       **** 	
 433:setup.c       **** 	// Set AD0 pin as input
 434:setup.c       **** 	GBA_PORT_EEPROM_DATA7_0 &= ~(1<<AD0);
 737               		.loc 1 434 0
 738 01be C098      		cbi 0x18,0
 435:setup.c       **** 	GBA_DDR_EEPROM_DATA7_0 &= ~(1<<AD0);
 739               		.loc 1 435 0
 740 01c0 B898      		cbi 0x17,0
 436:setup.c       **** 	
 437:setup.c       **** 	cs_mreqPin_low;
 741               		.loc 1 437 0
 742 01c2 9498      		cbi 0x12,4
 743               	.LVL43:
 744 01c4 84E0      		ldi r24,lo8(4)
 745               	.LVL44:
 746               	.L43:
 747               	.LBB66:
 438:setup.c       **** 	
 439:setup.c       **** 	// Ignore first 4 bits
 440:setup.c       **** 	for (int8_t x = 0; x < 4; x++) {
 441:setup.c       **** 		rdPin_low; // CLK
 748               		.loc 1 441 0 discriminator 3
 749 01c6 9598      		cbi 0x12,5
 442:setup.c       **** 		asm ("nop");
 750               		.loc 1 442 0 discriminator 3
 751               	/* #APP */
 752               	 ;  442 "setup.c" 1
 753 01c8 0000      		nop
 754               	 ;  0 "" 2
 443:setup.c       **** 		asm ("nop");
 755               		.loc 1 443 0 discriminator 3
 756               	 ;  443 "setup.c" 1
 757 01ca 0000      		nop
 758               	 ;  0 "" 2
 444:setup.c       **** 		rdPin_high; 
 759               		.loc 1 444 0 discriminator 3
 760               	/* #NOAPP */
 761 01cc 959A      		sbi 0x12,5
 445:setup.c       **** 		asm ("nop");
 762               		.loc 1 445 0 discriminator 3
 763               	/* #APP */
 764               	 ;  445 "setup.c" 1
 765 01ce 0000      		nop
 766               	 ;  0 "" 2
 446:setup.c       **** 		asm ("nop");
 767               		.loc 1 446 0 discriminator 3
 768               	 ;  446 "setup.c" 1
 769 01d0 0000      		nop
 770               	 ;  0 "" 2
 771               	.LVL45:
 772               	/* #NOAPP */
 773 01d2 8150      		subi r24,lo8(-(-1))
 774               	.LVL46:
 440:setup.c       **** 		rdPin_low; // CLK
 775               		.loc 1 440 0 discriminator 3
 776 01d4 01F4      		brne .L43
 777 01d6 E0E0      		ldi r30,lo8(eepromBuffer)
 778 01d8 F0E0      		ldi r31,hi8(eepromBuffer)
 779               	.LBE66:
 780               	.LBB67:
 781               	.LBB68:
 782               	.LBB69:
 447:setup.c       **** 	}
 448:setup.c       **** 	
 449:setup.c       **** 	// Read out 64 bits
 450:setup.c       **** 	for (uint8_t c = 0; c < 8; c++) {
 451:setup.c       **** 		uint8_t data = 0;
 452:setup.c       **** 		for (int8_t x = 7; x >= 0; x--) {
 453:setup.c       **** 			rdPin_low; // CLK
 454:setup.c       **** 			asm ("nop");
 455:setup.c       **** 			asm ("nop");
 456:setup.c       **** 			rdPin_high;
 457:setup.c       **** 			
 458:setup.c       **** 			if (GBA_PIN_EEPROM_DATA7_0 & (1<<AD0)) {
 459:setup.c       **** 				data |= (1<<x);
 783               		.loc 1 459 0
 784 01da 41E0      		ldi r20,lo8(1)
 785 01dc 50E0      		ldi r21,0
 786               	.LVL47:
 787               	.L44:
 788               	.LBE69:
 789               	.LBE68:
 790               	.LBE67:
 437:setup.c       **** 	
 791               		.loc 1 437 0
 792 01de 87E0      		ldi r24,lo8(7)
 793 01e0 90E0      		ldi r25,0
 794 01e2 20E0      		ldi r18,0
 795               	.LVL48:
 796               	.L46:
 797               	.LBB72:
 798               	.LBB71:
 799               	.LBB70:
 453:setup.c       **** 			asm ("nop");
 800               		.loc 1 453 0
 801 01e4 9598      		cbi 0x12,5
 454:setup.c       **** 			asm ("nop");
 802               		.loc 1 454 0
 803               	/* #APP */
 804               	 ;  454 "setup.c" 1
 805 01e6 0000      		nop
 806               	 ;  0 "" 2
 455:setup.c       **** 			rdPin_high;
 807               		.loc 1 455 0
 808               	 ;  455 "setup.c" 1
 809 01e8 0000      		nop
 810               	 ;  0 "" 2
 456:setup.c       **** 			
 811               		.loc 1 456 0
 812               	/* #NOAPP */
 813 01ea 959A      		sbi 0x12,5
 458:setup.c       **** 				data |= (1<<x);
 814               		.loc 1 458 0
 815 01ec B09B      		sbis 0x16,0
 816 01ee 00C0      		rjmp .L45
 817               		.loc 1 459 0
 818 01f0 BA01      		movw r22,r20
 819 01f2 082E      		mov r0,r24
 820 01f4 00C0      		rjmp 2f
 821               		1:
 822 01f6 660F      		lsl r22
 823               		2:
 824 01f8 0A94      		dec r0
 825 01fa 02F4      		brpl 1b
 826 01fc 262B      		or r18,r22
 827               	.LVL49:
 828               	.L45:
 829               	.LVL50:
 830 01fe 0197      		sbiw r24,1
 831 0200 00F4      		brcc .L46
 832               	.LBE70:
 460:setup.c       **** 			}
 461:setup.c       **** 		}
 462:setup.c       **** 		eepromBuffer[c] = data;
 833               		.loc 1 462 0 discriminator 2
 834 0202 2193      		st Z+,r18
 835               	.LVL51:
 836               	.LBE71:
 450:setup.c       **** 		uint8_t data = 0;
 837               		.loc 1 450 0 discriminator 2
 838 0204 80E0      		ldi r24,hi8(eepromBuffer+8)
 839 0206 E030      		cpi r30,lo8(eepromBuffer+8)
 840 0208 F807      		cpc r31,r24
 841               	.LVL52:
 842 020a 01F4      		brne .L44
 843               	.LBE72:
 463:setup.c       **** 	}
 464:setup.c       **** 	
 465:setup.c       **** 	cs_mreqPin_high;
 844               		.loc 1 465 0
 845 020c 949A      		sbi 0x12,4
 466:setup.c       **** 	
 467:setup.c       **** 	// Set AD0 pin as output
 468:setup.c       **** 	GBA_PORT_EEPROM_DATA7_0 |= (1<<AD0);
 846               		.loc 1 468 0
 847 020e C09A      		sbi 0x18,0
 469:setup.c       **** 	GBA_DDR_EEPROM_DATA7_0 |= (1<<AD0);
 848               		.loc 1 469 0
 849 0210 B89A      		sbi 0x17,0
 850 0212 0895      		ret
 851               		.cfi_endproc
 852               	.LFE28:
 854               	.global	gba_eeprom_write
 856               	gba_eeprom_write:
 857               	.LFB29:
 470:setup.c       **** }
 471:setup.c       **** 
 472:setup.c       **** // Write 8 bytes to the EEPROM address
 473:setup.c       **** void gba_eeprom_write(uint16_t address, uint8_t eepromSize) {
 858               		.loc 1 473 0
 859               		.cfi_startproc
 860               	.LVL53:
 861               	/* prologue: function */
 862               	/* frame size = 0 */
 863               	/* stack size = 0 */
 864               	.L__stack_usage = 0
 474:setup.c       **** 	gba_eeprom_set_address(address, eepromSize, EEPROM_WRITE);
 865               		.loc 1 474 0
 866 0214 41E0      		ldi r20,lo8(1)
 867 0216 00D0      		rcall gba_eeprom_set_address
 868               	.LVL54:
 869 0218 E0E0      		ldi r30,lo8(eepromBuffer)
 870 021a F0E0      		ldi r31,hi8(eepromBuffer)
 871 021c 48E0      		ldi r20,lo8(8)
 872               	.LVL55:
 873               	.L54:
 473:setup.c       **** 	gba_eeprom_set_address(address, eepromSize, EEPROM_WRITE);
 874               		.loc 1 473 0
 875 021e 27E0      		ldi r18,lo8(7)
 876 0220 30E0      		ldi r19,0
 877               	.LVL56:
 878               	.L57:
 879               	.LBB73:
 880               	.LBB74:
 475:setup.c       **** 	
 476:setup.c       **** 	// Write 64 bits
 477:setup.c       **** 	for (uint8_t c = 0; c < 8; c++) {
 478:setup.c       **** 		for (int8_t x = 7; x >= 0; x--) {
 479:setup.c       **** 			if (eepromBuffer[c] & (1<<x)) {
 881               		.loc 1 479 0
 882 0222 8081      		ld r24,Z
 883 0224 90E0      		ldi r25,0
 884 0226 022E      		mov r0,r18
 885 0228 00C0      		rjmp 2f
 886               		1:
 887 022a 9595      		asr r25
 888 022c 8795      		ror r24
 889               		2:
 890 022e 0A94      		dec r0
 891 0230 02F4      		brpl 1b
 892 0232 80FF      		sbrs r24,0
 893 0234 00C0      		rjmp .L55
 480:setup.c       **** 				ad0Pin_high;
 894               		.loc 1 480 0
 895 0236 C09A      		sbi 0x18,0
 896 0238 00C0      		rjmp .L56
 897               	.L55:
 481:setup.c       **** 			}
 482:setup.c       **** 			else {
 483:setup.c       **** 				ad0Pin_low;
 898               		.loc 1 483 0
 899 023a C098      		cbi 0x18,0
 900               	.L56:
 484:setup.c       **** 			}
 485:setup.c       **** 			
 486:setup.c       **** 			wrPin_low; // CLK
 901               		.loc 1 486 0 discriminator 2
 902 023c 9698      		cbi 0x12,6
 487:setup.c       **** 			asm ("nop");
 903               		.loc 1 487 0 discriminator 2
 904               	/* #APP */
 905               	 ;  487 "setup.c" 1
 906 023e 0000      		nop
 907               	 ;  0 "" 2
 488:setup.c       **** 			asm ("nop");
 908               		.loc 1 488 0 discriminator 2
 909               	 ;  488 "setup.c" 1
 910 0240 0000      		nop
 911               	 ;  0 "" 2
 489:setup.c       **** 			wrPin_high; 
 912               		.loc 1 489 0 discriminator 2
 913               	/* #NOAPP */
 914 0242 969A      		sbi 0x12,6
 490:setup.c       **** 			asm ("nop");
 915               		.loc 1 490 0 discriminator 2
 916               	/* #APP */
 917               	 ;  490 "setup.c" 1
 918 0244 0000      		nop
 919               	 ;  0 "" 2
 491:setup.c       **** 			asm ("nop");
 920               		.loc 1 491 0 discriminator 2
 921               	 ;  491 "setup.c" 1
 922 0246 0000      		nop
 923               	 ;  0 "" 2
 924               	.LVL57:
 925               	/* #NOAPP */
 926               	.LVL58:
 927 0248 2150      		subi r18,1
 928 024a 3109      		sbc r19,__zero_reg__
 929 024c 00F4      		brcc .L57
 930 024e 4150      		subi r20,lo8(-(-1))
 931 0250 3196      		adiw r30,1
 932               	.LVL59:
 933               	.LBE74:
 477:setup.c       **** 		for (int8_t x = 7; x >= 0; x--) {
 934               		.loc 1 477 0 discriminator 2
 935 0252 4111      		cpse r20,__zero_reg__
 936 0254 00C0      		rjmp .L54
 937               	.LBE73:
 492:setup.c       **** 		}
 493:setup.c       **** 	}
 494:setup.c       **** 	
 495:setup.c       **** 	// Last bit low
 496:setup.c       **** 	ad0Pin_low;
 938               		.loc 1 496 0
 939 0256 C098      		cbi 0x18,0
 497:setup.c       **** 	wrPin_low; // CLK
 940               		.loc 1 497 0
 941 0258 9698      		cbi 0x12,6
 498:setup.c       **** 	asm ("nop");
 942               		.loc 1 498 0
 943               	/* #APP */
 944               	 ;  498 "setup.c" 1
 945 025a 0000      		nop
 946               	 ;  0 "" 2
 499:setup.c       **** 	asm ("nop");
 947               		.loc 1 499 0
 948               	 ;  499 "setup.c" 1
 949 025c 0000      		nop
 950               	 ;  0 "" 2
 500:setup.c       **** 	wrPin_high; 
 951               		.loc 1 500 0
 952               	/* #NOAPP */
 953 025e 969A      		sbi 0x12,6
 501:setup.c       **** 	asm ("nop");
 954               		.loc 1 501 0
 955               	/* #APP */
 956               	 ;  501 "setup.c" 1
 957 0260 0000      		nop
 958               	 ;  0 "" 2
 502:setup.c       **** 	asm ("nop");
 959               		.loc 1 502 0
 960               	 ;  502 "setup.c" 1
 961 0262 0000      		nop
 962               	 ;  0 "" 2
 503:setup.c       **** 	
 504:setup.c       **** 	cs_mreqPin_high;
 963               		.loc 1 504 0
 964               	/* #NOAPP */
 965 0264 949A      		sbi 0x12,4
 966 0266 0895      		ret
 967               		.cfi_endproc
 968               	.LFE29:
 970               	.global	flash_write_bus_cycle
 972               	flash_write_bus_cycle:
 973               	.LFB30:
 505:setup.c       **** }
 506:setup.c       **** 
 507:setup.c       **** 
 508:setup.c       **** 
 509:setup.c       **** // ---------- FLASH ----------
 510:setup.c       **** 
 511:setup.c       **** // Set the address and data for the write byte cycle to the flash
 512:setup.c       **** void flash_write_bus_cycle(uint16_t address, uint8_t data) {
 974               		.loc 1 512 0
 975               		.cfi_startproc
 976               	.LVL60:
 977 0268 CF93      		push r28
 978               	.LCFI10:
 979               		.cfi_def_cfa_offset 3
 980               		.cfi_offset 28, -2
 981               	/* prologue: function */
 982               	/* frame size = 0 */
 983               	/* stack size = 1 */
 984               	.L__stack_usage = 1
 985 026a C62F      		mov r28,r22
 513:setup.c       **** 	GBA_DDR_RAM_DATA7_0 = 0xFF; // Set data pins as outputs
 986               		.loc 1 513 0
 987 026c 2FEF      		ldi r18,lo8(-1)
 988 026e 24BB      		out 0x14,r18
 514:setup.c       **** 	set_16bit_address(address);
 989               		.loc 1 514 0
 990 0270 00D0      		rcall set_16bit_address
 991               	.LVL61:
 515:setup.c       **** 	GBA_PORT_RAM_DATA7_0 = data;
 992               		.loc 1 515 0
 993 0272 C5BB      		out 0x15,r28
 516:setup.c       **** 	
 517:setup.c       **** 	wrPin_low;
 994               		.loc 1 517 0
 995 0274 9698      		cbi 0x12,6
 518:setup.c       **** 	cs2Pin_low;
 996               		.loc 1 518 0
 997 0276 3A98      		cbi 0x7,2
 519:setup.c       **** 	asm volatile("nop");
 998               		.loc 1 519 0
 999               	/* #APP */
 1000               	 ;  519 "setup.c" 1
 1001 0278 0000      		nop
 1002               	 ;  0 "" 2
 520:setup.c       **** 	wrPin_high;
 1003               		.loc 1 520 0
 1004               	/* #NOAPP */
 1005 027a 969A      		sbi 0x12,6
 521:setup.c       **** 	cs2Pin_high;
 1006               		.loc 1 521 0
 1007 027c 3A9A      		sbi 0x7,2
 1008               	/* epilogue start */
 522:setup.c       **** }
 1009               		.loc 1 522 0
 1010 027e CF91      		pop r28
 1011               	.LVL62:
 1012 0280 0895      		ret
 1013               		.cfi_endproc
 1014               	.LFE30:
 1016               	.global	flash_read_chip_id
 1018               	flash_read_chip_id:
 1019               	.LFB31:
 523:setup.c       **** 
 524:setup.c       **** // Read the flash manufacturer and device ID (Software ID)
 525:setup.c       **** void flash_read_chip_id(void) {
 1020               		.loc 1 525 0
 1021               		.cfi_startproc
 1022 0282 CF93      		push r28
 1023               	.LCFI11:
 1024               		.cfi_def_cfa_offset 3
 1025               		.cfi_offset 28, -2
 1026 0284 DF93      		push r29
 1027               	.LCFI12:
 1028               		.cfi_def_cfa_offset 4
 1029               		.cfi_offset 29, -3
 1030               	/* prologue: function */
 1031               	/* frame size = 0 */
 1032               	/* stack size = 2 */
 1033               	.L__stack_usage = 2
 526:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xAA);
 1034               		.loc 1 526 0
 1035 0286 6AEA      		ldi r22,lo8(-86)
 1036 0288 85E5      		ldi r24,lo8(85)
 1037 028a 95E5      		ldi r25,lo8(85)
 1038 028c 00D0      		rcall flash_write_bus_cycle
 1039               	.LVL63:
 527:setup.c       **** 	flash_write_bus_cycle(0x2AAA, 0x55);
 1040               		.loc 1 527 0
 1041 028e 65E5      		ldi r22,lo8(85)
 1042 0290 8AEA      		ldi r24,lo8(-86)
 1043 0292 9AE2      		ldi r25,lo8(42)
 1044 0294 00D0      		rcall flash_write_bus_cycle
 1045               	.LVL64:
 528:setup.c       **** 	flash_write_bus_cycle(0x5555, 0x90); // Software ID entry
 1046               		.loc 1 528 0
 1047 0296 60E9      		ldi r22,lo8(-112)
 1048 0298 85E5      		ldi r24,lo8(85)
 1049 029a 95E5      		ldi r25,lo8(85)
 1050 029c 00D0      		rcall flash_write_bus_cycle
 1051               	.LVL65:
 1052               	.LBB75:
 1053               	.LBB76:
 1054               		.file 2 "c:\\winavr-20100110\\avr\\include\\util\\delay.h"
   1:c:\winavr-20100110\avr\include\util\delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:c:\winavr-20100110\avr\include\util\delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:c:\winavr-20100110\avr\include\util\delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:c:\winavr-20100110\avr\include\util\delay.h ****    All rights reserved.
   5:c:\winavr-20100110\avr\include\util\delay.h **** 
   6:c:\winavr-20100110\avr\include\util\delay.h ****    Redistribution and use in source and binary forms, with or without
   7:c:\winavr-20100110\avr\include\util\delay.h ****    modification, are permitted provided that the following conditions are met:
   8:c:\winavr-20100110\avr\include\util\delay.h **** 
   9:c:\winavr-20100110\avr\include\util\delay.h ****    * Redistributions of source code must retain the above copyright
  10:c:\winavr-20100110\avr\include\util\delay.h ****      notice, this list of conditions and the following disclaimer.
  11:c:\winavr-20100110\avr\include\util\delay.h **** 
  12:c:\winavr-20100110\avr\include\util\delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:c:\winavr-20100110\avr\include\util\delay.h ****      notice, this list of conditions and the following disclaimer in
  14:c:\winavr-20100110\avr\include\util\delay.h ****      the documentation and/or other materials provided with the
  15:c:\winavr-20100110\avr\include\util\delay.h ****      distribution.
  16:c:\winavr-20100110\avr\include\util\delay.h **** 
  17:c:\winavr-20100110\avr\include\util\delay.h ****    * Neither the name of the copyright holders nor the names of
  18:c:\winavr-20100110\avr\include\util\delay.h ****      contributors may be used to endorse or promote products derived
  19:c:\winavr-20100110\avr\include\util\delay.h ****      from this software without specific prior written permission.
  20:c:\winavr-20100110\avr\include\util\delay.h **** 
  21:c:\winavr-20100110\avr\include\util\delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:c:\winavr-20100110\avr\include\util\delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:c:\winavr-20100110\avr\include\util\delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:c:\winavr-20100110\avr\include\util\delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:c:\winavr-20100110\avr\include\util\delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:c:\winavr-20100110\avr\include\util\delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:c:\winavr-20100110\avr\include\util\delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:c:\winavr-20100110\avr\include\util\delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:c:\winavr-20100110\avr\include\util\delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:c:\winavr-20100110\avr\include\util\delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:c:\winavr-20100110\avr\include\util\delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:c:\winavr-20100110\avr\include\util\delay.h **** 
  33:c:\winavr-20100110\avr\include\util\delay.h **** /* $Id$ */
  34:c:\winavr-20100110\avr\include\util\delay.h **** 
  35:c:\winavr-20100110\avr\include\util\delay.h **** #ifndef _UTIL_DELAY_H_
  36:c:\winavr-20100110\avr\include\util\delay.h **** #define _UTIL_DELAY_H_ 1
  37:c:\winavr-20100110\avr\include\util\delay.h **** 
  38:c:\winavr-20100110\avr\include\util\delay.h **** #ifndef __DOXYGEN__
  39:c:\winavr-20100110\avr\include\util\delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:c:\winavr-20100110\avr\include\util\delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:c:\winavr-20100110\avr\include\util\delay.h **** #  endif
  42:c:\winavr-20100110\avr\include\util\delay.h **** #endif  /* __DOXYGEN__ */
  43:c:\winavr-20100110\avr\include\util\delay.h **** 
  44:c:\winavr-20100110\avr\include\util\delay.h **** #include <inttypes.h>
  45:c:\winavr-20100110\avr\include\util\delay.h **** #include <util/delay_basic.h>
  46:c:\winavr-20100110\avr\include\util\delay.h **** #include <math.h>
  47:c:\winavr-20100110\avr\include\util\delay.h **** 
  48:c:\winavr-20100110\avr\include\util\delay.h **** /** \file */
  49:c:\winavr-20100110\avr\include\util\delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:c:\winavr-20100110\avr\include\util\delay.h ****     \code
  51:c:\winavr-20100110\avr\include\util\delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:c:\winavr-20100110\avr\include\util\delay.h ****     //#define F_CPU 14.7456E6
  53:c:\winavr-20100110\avr\include\util\delay.h ****     #include <util/delay.h>
  54:c:\winavr-20100110\avr\include\util\delay.h ****     \endcode
  55:c:\winavr-20100110\avr\include\util\delay.h **** 
  56:c:\winavr-20100110\avr\include\util\delay.h ****     \note As an alternative method, it is possible to pass the
  57:c:\winavr-20100110\avr\include\util\delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:c:\winavr-20100110\avr\include\util\delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:c:\winavr-20100110\avr\include\util\delay.h ****     used.
  60:c:\winavr-20100110\avr\include\util\delay.h **** 
  61:c:\winavr-20100110\avr\include\util\delay.h ****     The functions in this header file are wrappers around the basic
  62:c:\winavr-20100110\avr\include\util\delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:c:\winavr-20100110\avr\include\util\delay.h ****     convenience functions where actual time values can be specified
  64:c:\winavr-20100110\avr\include\util\delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:c:\winavr-20100110\avr\include\util\delay.h ****     that compile-time constant expressions will be eliminated by
  66:c:\winavr-20100110\avr\include\util\delay.h ****     compiler optimization so floating-point expressions can be used
  67:c:\winavr-20100110\avr\include\util\delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:c:\winavr-20100110\avr\include\util\delay.h ****     frequency passed by the macro F_CPU.
  69:c:\winavr-20100110\avr\include\util\delay.h **** 
  70:c:\winavr-20100110\avr\include\util\delay.h ****     \note In order for these functions to work as intended, compiler
  71:c:\winavr-20100110\avr\include\util\delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:c:\winavr-20100110\avr\include\util\delay.h ****     <em>must</em> be an expression that is a known constant at
  73:c:\winavr-20100110\avr\include\util\delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:c:\winavr-20100110\avr\include\util\delay.h ****     delay will be much longer (and basically unpredictable), and
  75:c:\winavr-20100110\avr\include\util\delay.h ****     applications that otherwise do not use floating-point calculations
  76:c:\winavr-20100110\avr\include\util\delay.h ****     will experience severe code bloat by the floating-point library
  77:c:\winavr-20100110\avr\include\util\delay.h ****     routines linked into the application.
  78:c:\winavr-20100110\avr\include\util\delay.h **** 
  79:c:\winavr-20100110\avr\include\util\delay.h ****     The functions available allow the specification of microsecond, and
  80:c:\winavr-20100110\avr\include\util\delay.h ****     millisecond delays directly, using the application-supplied macro
  81:c:\winavr-20100110\avr\include\util\delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:c:\winavr-20100110\avr\include\util\delay.h **** 
  83:c:\winavr-20100110\avr\include\util\delay.h **** */
  84:c:\winavr-20100110\avr\include\util\delay.h **** 
  85:c:\winavr-20100110\avr\include\util\delay.h **** #if !defined(__DOXYGEN__)
  86:c:\winavr-20100110\avr\include\util\delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:c:\winavr-20100110\avr\include\util\delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:c:\winavr-20100110\avr\include\util\delay.h **** #endif
  89:c:\winavr-20100110\avr\include\util\delay.h **** 
  90:c:\winavr-20100110\avr\include\util\delay.h **** #ifndef F_CPU
  91:c:\winavr-20100110\avr\include\util\delay.h **** /* prevent compiler error by supplying a default */
  92:c:\winavr-20100110\avr\include\util\delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:c:\winavr-20100110\avr\include\util\delay.h **** /** \ingroup util_delay
  94:c:\winavr-20100110\avr\include\util\delay.h ****     \def F_CPU
  95:c:\winavr-20100110\avr\include\util\delay.h ****     \brief CPU frequency in Hz
  96:c:\winavr-20100110\avr\include\util\delay.h **** 
  97:c:\winavr-20100110\avr\include\util\delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:c:\winavr-20100110\avr\include\util\delay.h ****     the delay macros.  This macro is normally supplied by the
  99:c:\winavr-20100110\avr\include\util\delay.h ****     environment (e.g. from within a project header, or the project's
 100:c:\winavr-20100110\avr\include\util\delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:c:\winavr-20100110\avr\include\util\delay.h ****     fallback if no such user-provided definition could be found.
 102:c:\winavr-20100110\avr\include\util\delay.h **** 
 103:c:\winavr-20100110\avr\include\util\delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:c:\winavr-20100110\avr\include\util\delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:c:\winavr-20100110\avr\include\util\delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:c:\winavr-20100110\avr\include\util\delay.h ****     integer value.
 107:c:\winavr-20100110\avr\include\util\delay.h ****  */
 108:c:\winavr-20100110\avr\include\util\delay.h **** # define F_CPU 1000000UL
 109:c:\winavr-20100110\avr\include\util\delay.h **** #endif
 110:c:\winavr-20100110\avr\include\util\delay.h **** 
 111:c:\winavr-20100110\avr\include\util\delay.h **** #ifndef __OPTIMIZE__
 112:c:\winavr-20100110\avr\include\util\delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:c:\winavr-20100110\avr\include\util\delay.h **** #endif
 114:c:\winavr-20100110\avr\include\util\delay.h **** 
 115:c:\winavr-20100110\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:c:\winavr-20100110\avr\include\util\delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:c:\winavr-20100110\avr\include\util\delay.h ****   __STDC_HOSTED__
 118:c:\winavr-20100110\avr\include\util\delay.h **** #  include <math.h>
 119:c:\winavr-20100110\avr\include\util\delay.h **** #endif
 120:c:\winavr-20100110\avr\include\util\delay.h **** 
 121:c:\winavr-20100110\avr\include\util\delay.h **** /**
 122:c:\winavr-20100110\avr\include\util\delay.h ****    \ingroup util_delay
 123:c:\winavr-20100110\avr\include\util\delay.h **** 
 124:c:\winavr-20100110\avr\include\util\delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:c:\winavr-20100110\avr\include\util\delay.h **** 
 126:c:\winavr-20100110\avr\include\util\delay.h ****    The macro F_CPU is supposed to be defined to a
 127:c:\winavr-20100110\avr\include\util\delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:c:\winavr-20100110\avr\include\util\delay.h **** 
 129:c:\winavr-20100110\avr\include\util\delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:c:\winavr-20100110\avr\include\util\delay.h **** 
 131:c:\winavr-20100110\avr\include\util\delay.h ****    When the user request delay which exceed the maximum possible one,
 132:c:\winavr-20100110\avr\include\util\delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:c:\winavr-20100110\avr\include\util\delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:c:\winavr-20100110\avr\include\util\delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:c:\winavr-20100110\avr\include\util\delay.h ****    user will not be informed about decreased resolution.
 136:c:\winavr-20100110\avr\include\util\delay.h **** 
 137:c:\winavr-20100110\avr\include\util\delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:c:\winavr-20100110\avr\include\util\delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:c:\winavr-20100110\avr\include\util\delay.h ****    values greater than the maximal possible delay, overflows results in
 140:c:\winavr-20100110\avr\include\util\delay.h ****    no delay i.e., 0ms.
 141:c:\winavr-20100110\avr\include\util\delay.h **** 
 142:c:\winavr-20100110\avr\include\util\delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:c:\winavr-20100110\avr\include\util\delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:c:\winavr-20100110\avr\include\util\delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:c:\winavr-20100110\avr\include\util\delay.h ****    microseconds of delay.
 146:c:\winavr-20100110\avr\include\util\delay.h **** 
 147:c:\winavr-20100110\avr\include\util\delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:c:\winavr-20100110\avr\include\util\delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:c:\winavr-20100110\avr\include\util\delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:c:\winavr-20100110\avr\include\util\delay.h ****    respectively.
 151:c:\winavr-20100110\avr\include\util\delay.h **** 
 152:c:\winavr-20100110\avr\include\util\delay.h ****    \note
 153:c:\winavr-20100110\avr\include\util\delay.h **** 
 154:c:\winavr-20100110\avr\include\util\delay.h ****    The implementation of _delay_ms() based on
 155:c:\winavr-20100110\avr\include\util\delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:c:\winavr-20100110\avr\include\util\delay.h ****    implementations.  In order to get functionality backward compatible
 157:c:\winavr-20100110\avr\include\util\delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:c:\winavr-20100110\avr\include\util\delay.h ****    must be defined before including this header file. Also, the
 159:c:\winavr-20100110\avr\include\util\delay.h ****    backward compatible algorithm will be chosen if the code is
 160:c:\winavr-20100110\avr\include\util\delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:c:\winavr-20100110\avr\include\util\delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:c:\winavr-20100110\avr\include\util\delay.h ****    not available to the compiler then.
 163:c:\winavr-20100110\avr\include\util\delay.h **** 
 164:c:\winavr-20100110\avr\include\util\delay.h ****  */
 165:c:\winavr-20100110\avr\include\util\delay.h **** void
 166:c:\winavr-20100110\avr\include\util\delay.h **** _delay_ms(double __ms)
 167:c:\winavr-20100110\avr\include\util\delay.h **** {
 168:c:\winavr-20100110\avr\include\util\delay.h **** 	double __tmp ;
 169:c:\winavr-20100110\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:c:\winavr-20100110\avr\include\util\delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:c:\winavr-20100110\avr\include\util\delay.h ****   __STDC_HOSTED__
 172:c:\winavr-20100110\avr\include\util\delay.h **** 	uint32_t __ticks_dc;
 173:c:\winavr-20100110\avr\include\util\delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 174:c:\winavr-20100110\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 175:c:\winavr-20100110\avr\include\util\delay.h **** 
 176:c:\winavr-20100110\avr\include\util\delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:c:\winavr-20100110\avr\include\util\delay.h **** 
 179:c:\winavr-20100110\avr\include\util\delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:c:\winavr-20100110\avr\include\util\delay.h **** 
 182:c:\winavr-20100110\avr\include\util\delay.h **** 	#else
 183:c:\winavr-20100110\avr\include\util\delay.h **** 		//round up by default
 184:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 185:c:\winavr-20100110\avr\include\util\delay.h **** 	#endif
 186:c:\winavr-20100110\avr\include\util\delay.h **** 
 187:c:\winavr-20100110\avr\include\util\delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 1055               		.loc 2 187 0
 1056 029e 8FE3      		ldi r24,lo8(-25537)
 1057 02a0 9CE9      		ldi r25,hi8(-25537)
 1058 02a2 0197      	1:	sbiw r24,1
 1059 02a4 01F4      		brne 1b
 1060 02a6 00C0      		rjmp .
 1061 02a8 0000      		nop
 1062               	.LVL66:
 1063               	.LBE76:
 1064               	.LBE75:
 529:setup.c       **** 	_delay_ms(20); // Wait a little (for Atmel chip)
 530:setup.c       **** 	
 531:setup.c       **** 	// Set data as inputs
 532:setup.c       **** 	GBA_PORT_RAM_DATA7_0 = 0;
 1065               		.loc 1 532 0
 1066 02aa 15BA      		out 0x15,__zero_reg__
 533:setup.c       **** 	GBA_DDR_RAM_DATA7_0 = 0;
 1067               		.loc 1 533 0
 1068 02ac 14BA      		out 0x14,__zero_reg__
 534:setup.c       **** 	
 535:setup.c       **** 	// Read and transmit the 2 bytes
 536:setup.c       **** 	flashChipIdBuffer[0] = gba_read_ram_8bit_data(0x0000);
 1069               		.loc 1 536 0
 1070 02ae 80E0      		ldi r24,0
 1071 02b0 90E0      		ldi r25,0
 1072 02b2 00D0      		rcall gba_read_ram_8bit_data
 1073               	.LVL67:
 1074 02b4 C0E0      		ldi r28,lo8(flashChipIdBuffer)
 1075 02b6 D0E0      		ldi r29,hi8(flashChipIdBuffer)
 1076 02b8 8883      		st Y,r24
 537:setup.c       **** 	flashChipIdBuffer[1] = gba_read_ram_8bit_data(0x0001);
 1077               		.loc 1 537 0
 1078 02ba 81E0      		ldi r24,lo8(1)
 1079 02bc 90E0      		ldi r25,0
 1080 02be 00D0      		rcall gba_read_ram_8bit_data
 1081               	.LVL68:
 1082 02c0 8983      		std Y+1,r24
 538:setup.c       **** 	
 539:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xAA);
 1083               		.loc 1 539 0
 1084 02c2 6AEA      		ldi r22,lo8(-86)
 1085 02c4 85E5      		ldi r24,lo8(85)
 1086 02c6 95E5      		ldi r25,lo8(85)
 1087 02c8 00D0      		rcall flash_write_bus_cycle
 1088               	.LVL69:
 540:setup.c       **** 	flash_write_bus_cycle(0x2AAA, 0x55);
 1089               		.loc 1 540 0
 1090 02ca 65E5      		ldi r22,lo8(85)
 1091 02cc 8AEA      		ldi r24,lo8(-86)
 1092 02ce 9AE2      		ldi r25,lo8(42)
 1093 02d0 00D0      		rcall flash_write_bus_cycle
 1094               	.LVL70:
 541:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xF0); // Software ID exit
 1095               		.loc 1 541 0
 1096 02d2 60EF      		ldi r22,lo8(-16)
 1097 02d4 85E5      		ldi r24,lo8(85)
 1098 02d6 95E5      		ldi r25,lo8(85)
 1099 02d8 00D0      		rcall flash_write_bus_cycle
 1100               	.LVL71:
 1101               	.LBB77:
 1102               	.LBB78:
 1103               		.loc 2 187 0
 1104 02da 8FE3      		ldi r24,lo8(-25537)
 1105 02dc 9CE9      		ldi r25,hi8(-25537)
 1106 02de 0197      	1:	sbiw r24,1
 1107 02e0 01F4      		brne 1b
 1108 02e2 00C0      		rjmp .
 1109 02e4 0000      		nop
 1110               	.LVL72:
 1111               	/* epilogue start */
 1112               	.LBE78:
 1113               	.LBE77:
 542:setup.c       **** 	_delay_ms(20); // Wait a little (for Atmel chip)
 543:setup.c       **** }
 1114               		.loc 1 543 0
 1115 02e6 DF91      		pop r29
 1116 02e8 CF91      		pop r28
 1117 02ea 0895      		ret
 1118               		.cfi_endproc
 1119               	.LFE31:
 1121               	.global	flash_switch_bank
 1123               	flash_switch_bank:
 1124               	.LFB32:
 544:setup.c       **** 
 545:setup.c       **** // Switch banks on the Flash
 546:setup.c       **** void flash_switch_bank(uint8_t bank) {
 1125               		.loc 1 546 0
 1126               		.cfi_startproc
 1127               	.LVL73:
 1128 02ec CF93      		push r28
 1129               	.LCFI13:
 1130               		.cfi_def_cfa_offset 3
 1131               		.cfi_offset 28, -2
 1132               	/* prologue: function */
 1133               	/* frame size = 0 */
 1134               	/* stack size = 1 */
 1135               	.L__stack_usage = 1
 1136 02ee C82F      		mov r28,r24
 547:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xAA);
 1137               		.loc 1 547 0
 1138 02f0 6AEA      		ldi r22,lo8(-86)
 1139 02f2 85E5      		ldi r24,lo8(85)
 1140 02f4 95E5      		ldi r25,lo8(85)
 1141               	.LVL74:
 1142 02f6 00D0      		rcall flash_write_bus_cycle
 1143               	.LVL75:
 548:setup.c       **** 	flash_write_bus_cycle(0x2AAA, 0x55);
 1144               		.loc 1 548 0
 1145 02f8 65E5      		ldi r22,lo8(85)
 1146 02fa 8AEA      		ldi r24,lo8(-86)
 1147 02fc 9AE2      		ldi r25,lo8(42)
 1148 02fe 00D0      		rcall flash_write_bus_cycle
 1149               	.LVL76:
 549:setup.c       **** 	
 550:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xB0);
 1150               		.loc 1 550 0
 1151 0300 60EB      		ldi r22,lo8(-80)
 1152 0302 85E5      		ldi r24,lo8(85)
 1153 0304 95E5      		ldi r25,lo8(85)
 1154 0306 00D0      		rcall flash_write_bus_cycle
 1155               	.LVL77:
 551:setup.c       **** 	flash_write_bus_cycle(0x0000, bank);
 1156               		.loc 1 551 0
 1157 0308 6C2F      		mov r22,r28
 1158 030a 80E0      		ldi r24,0
 1159 030c 90E0      		ldi r25,0
 1160               	/* epilogue start */
 552:setup.c       **** }
 1161               		.loc 1 552 0
 1162 030e CF91      		pop r28
 1163               	.LVL78:
 551:setup.c       **** 	flash_write_bus_cycle(0x0000, bank);
 1164               		.loc 1 551 0
 1165 0310 00C0      		rjmp flash_write_bus_cycle
 1166               	.LVL79:
 1167               		.cfi_endproc
 1168               	.LFE32:
 1170               	.global	flash_erase_4k_sector
 1172               	flash_erase_4k_sector:
 1173               	.LFB33:
 553:setup.c       **** 
 554:setup.c       **** // Erase 4K sector on Flash, expects first sector to start at 0, left shifts by 12 (A15-A12 to sele
 555:setup.c       **** // Takes 25ms after last command to erase sector
 556:setup.c       **** void flash_erase_4k_sector(uint8_t sector) {
 1174               		.loc 1 556 0
 1175               		.cfi_startproc
 1176               	.LVL80:
 1177 0312 CF93      		push r28
 1178               	.LCFI14:
 1179               		.cfi_def_cfa_offset 3
 1180               		.cfi_offset 28, -2
 1181               	/* prologue: function */
 1182               	/* frame size = 0 */
 1183               	/* stack size = 1 */
 1184               	.L__stack_usage = 1
 1185 0314 C82F      		mov r28,r24
 557:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xAA);
 1186               		.loc 1 557 0
 1187 0316 6AEA      		ldi r22,lo8(-86)
 1188 0318 85E5      		ldi r24,lo8(85)
 1189 031a 95E5      		ldi r25,lo8(85)
 1190               	.LVL81:
 1191 031c 00D0      		rcall flash_write_bus_cycle
 1192               	.LVL82:
 558:setup.c       **** 	flash_write_bus_cycle(0x2AAA, 0x55);
 1193               		.loc 1 558 0
 1194 031e 65E5      		ldi r22,lo8(85)
 1195 0320 8AEA      		ldi r24,lo8(-86)
 1196 0322 9AE2      		ldi r25,lo8(42)
 1197 0324 00D0      		rcall flash_write_bus_cycle
 1198               	.LVL83:
 559:setup.c       **** 	flash_write_bus_cycle(0x5555, 0x80);
 1199               		.loc 1 559 0
 1200 0326 60E8      		ldi r22,lo8(-128)
 1201 0328 85E5      		ldi r24,lo8(85)
 1202 032a 95E5      		ldi r25,lo8(85)
 1203 032c 00D0      		rcall flash_write_bus_cycle
 1204               	.LVL84:
 560:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xAA);
 1205               		.loc 1 560 0
 1206 032e 6AEA      		ldi r22,lo8(-86)
 1207 0330 85E5      		ldi r24,lo8(85)
 1208 0332 95E5      		ldi r25,lo8(85)
 1209 0334 00D0      		rcall flash_write_bus_cycle
 1210               	.LVL85:
 561:setup.c       **** 	flash_write_bus_cycle(0x2AAA, 0x55);
 1211               		.loc 1 561 0
 1212 0336 65E5      		ldi r22,lo8(85)
 1213 0338 8AEA      		ldi r24,lo8(-86)
 1214 033a 9AE2      		ldi r25,lo8(42)
 1215 033c 00D0      		rcall flash_write_bus_cycle
 1216               	.LVL86:
 562:setup.c       **** 	
 563:setup.c       **** 	flash_write_bus_cycle((uint16_t) sector << 12, 0x30);
 1217               		.loc 1 563 0
 1218 033e 60E3      		ldi r22,lo8(48)
 1219 0340 80E0      		ldi r24,0
 1220 0342 9C2F      		mov r25,r28
 1221 0344 9295      		swap r25
 1222 0346 907F      		andi r25,lo8(-16)
 1223 0348 00D0      		rcall flash_write_bus_cycle
 1224               	.LVL87:
 1225               	.LBB79:
 1226               	.LBB80:
 1227               		.loc 2 187 0
 1228 034a 8FE4      		ldi r24,lo8(-15537)
 1229 034c 93EC      		ldi r25,hi8(-15537)
 1230 034e 0197      	1:	sbiw r24,1
 1231 0350 01F4      		brne 1b
 1232 0352 00C0      		rjmp .
 1233 0354 0000      		nop
 1234               	.LVL88:
 1235               	/* epilogue start */
 1236               	.LBE80:
 1237               	.LBE79:
 564:setup.c       **** 	_delay_ms(25); // Wait 25ms for sector erase
 565:setup.c       **** }
 1238               		.loc 1 565 0
 1239 0356 CF91      		pop r28
 1240               	.LVL89:
 1241 0358 0895      		ret
 1242               		.cfi_endproc
 1243               	.LFE33:
 1245               	.global	flash_write_byte
 1247               	flash_write_byte:
 1248               	.LFB34:
 566:setup.c       **** 
 567:setup.c       **** // Write a single byte to the Flash address
 568:setup.c       **** // Takes 20us to program Flash
 569:setup.c       **** void flash_write_byte(uint16_t address, uint8_t data) {
 1249               		.loc 1 569 0
 1250               		.cfi_startproc
 1251               	.LVL90:
 1252 035a 1F93      		push r17
 1253               	.LCFI15:
 1254               		.cfi_def_cfa_offset 3
 1255               		.cfi_offset 17, -2
 1256 035c CF93      		push r28
 1257               	.LCFI16:
 1258               		.cfi_def_cfa_offset 4
 1259               		.cfi_offset 28, -3
 1260 035e DF93      		push r29
 1261               	.LCFI17:
 1262               		.cfi_def_cfa_offset 5
 1263               		.cfi_offset 29, -4
 1264               	/* prologue: function */
 1265               	/* frame size = 0 */
 1266               	/* stack size = 3 */
 1267               	.L__stack_usage = 3
 1268 0360 EC01      		movw r28,r24
 1269 0362 162F      		mov r17,r22
 570:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xAA);
 1270               		.loc 1 570 0
 1271 0364 6AEA      		ldi r22,lo8(-86)
 1272               	.LVL91:
 1273 0366 85E5      		ldi r24,lo8(85)
 1274 0368 95E5      		ldi r25,lo8(85)
 1275               	.LVL92:
 1276 036a 00D0      		rcall flash_write_bus_cycle
 1277               	.LVL93:
 571:setup.c       **** 	flash_write_bus_cycle(0x2AAA, 0x55);
 1278               		.loc 1 571 0
 1279 036c 65E5      		ldi r22,lo8(85)
 1280 036e 8AEA      		ldi r24,lo8(-86)
 1281 0370 9AE2      		ldi r25,lo8(42)
 1282 0372 00D0      		rcall flash_write_bus_cycle
 1283               	.LVL94:
 572:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xA0);
 1284               		.loc 1 572 0
 1285 0374 60EA      		ldi r22,lo8(-96)
 1286 0376 85E5      		ldi r24,lo8(85)
 1287 0378 95E5      		ldi r25,lo8(85)
 1288 037a 00D0      		rcall flash_write_bus_cycle
 1289               	.LVL95:
 573:setup.c       **** 	
 574:setup.c       **** 	flash_write_bus_cycle(address, data);
 1290               		.loc 1 574 0
 1291 037c 612F      		mov r22,r17
 1292 037e CE01      		movw r24,r28
 1293 0380 00D0      		rcall flash_write_bus_cycle
 1294               	.LVL96:
 1295               	.LBB81:
 1296               	.LBB82:
 188:c:\winavr-20100110\avr\include\util\delay.h **** 
 189:c:\winavr-20100110\avr\include\util\delay.h **** #else
 190:c:\winavr-20100110\avr\include\util\delay.h **** 	uint16_t __ticks;
 191:c:\winavr-20100110\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 4e3) * __ms;
 192:c:\winavr-20100110\avr\include\util\delay.h **** 	if (__tmp < 1.0)
 193:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks = 1;
 194:c:\winavr-20100110\avr\include\util\delay.h **** 	else if (__tmp > 65535)
 195:c:\winavr-20100110\avr\include\util\delay.h **** 	{
 196:c:\winavr-20100110\avr\include\util\delay.h **** 		//	__ticks = requested delay in 1/10 ms
 197:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 198:c:\winavr-20100110\avr\include\util\delay.h **** 		while(__ticks)
 199:c:\winavr-20100110\avr\include\util\delay.h **** 		{
 200:c:\winavr-20100110\avr\include\util\delay.h **** 			// wait 1/10 ms
 201:c:\winavr-20100110\avr\include\util\delay.h **** 			_delay_loop_2(((F_CPU) / 4e3) / 10);
 202:c:\winavr-20100110\avr\include\util\delay.h **** 			__ticks --;
 203:c:\winavr-20100110\avr\include\util\delay.h **** 		}
 204:c:\winavr-20100110\avr\include\util\delay.h **** 		return;
 205:c:\winavr-20100110\avr\include\util\delay.h **** 	}
 206:c:\winavr-20100110\avr\include\util\delay.h **** 	else
 207:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks = (uint16_t)__tmp;
 208:c:\winavr-20100110\avr\include\util\delay.h **** 	_delay_loop_2(__ticks);
 209:c:\winavr-20100110\avr\include\util\delay.h **** #endif
 210:c:\winavr-20100110\avr\include\util\delay.h **** }
 211:c:\winavr-20100110\avr\include\util\delay.h **** 
 212:c:\winavr-20100110\avr\include\util\delay.h **** /**
 213:c:\winavr-20100110\avr\include\util\delay.h ****    \ingroup util_delay
 214:c:\winavr-20100110\avr\include\util\delay.h **** 
 215:c:\winavr-20100110\avr\include\util\delay.h ****    Perform a delay of \c __us microseconds, using _delay_loop_1().
 216:c:\winavr-20100110\avr\include\util\delay.h **** 
 217:c:\winavr-20100110\avr\include\util\delay.h ****    The macro F_CPU is supposed to be defined to a
 218:c:\winavr-20100110\avr\include\util\delay.h ****    constant defining the CPU clock frequency (in Hertz).
 219:c:\winavr-20100110\avr\include\util\delay.h **** 
 220:c:\winavr-20100110\avr\include\util\delay.h ****    The maximal possible delay is 768 us / F_CPU in MHz.
 221:c:\winavr-20100110\avr\include\util\delay.h **** 
 222:c:\winavr-20100110\avr\include\util\delay.h ****    If the user requests a delay greater than the maximal possible one,
 223:c:\winavr-20100110\avr\include\util\delay.h ****    _delay_us() will automatically call _delay_ms() instead.  The user
 224:c:\winavr-20100110\avr\include\util\delay.h ****    will not be informed about this case.
 225:c:\winavr-20100110\avr\include\util\delay.h **** 
 226:c:\winavr-20100110\avr\include\util\delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 227:c:\winavr-20100110\avr\include\util\delay.h ****    support, maximal possible delay is 4294967.295 us/ F_CPU in MHz. For
 228:c:\winavr-20100110\avr\include\util\delay.h ****    values greater than the maximal possible delay, overflow results in
 229:c:\winavr-20100110\avr\include\util\delay.h ****    no delay i.e., 0us.
 230:c:\winavr-20100110\avr\include\util\delay.h **** 
 231:c:\winavr-20100110\avr\include\util\delay.h ****    Conversion of \c __us into clock cycles may not always result in
 232:c:\winavr-20100110\avr\include\util\delay.h ****    integer.  By default, the clock cycles rounded up to next
 233:c:\winavr-20100110\avr\include\util\delay.h ****    integer. This ensures that the user gets at least \c __us
 234:c:\winavr-20100110\avr\include\util\delay.h ****    microseconds of delay.
 235:c:\winavr-20100110\avr\include\util\delay.h **** 
 236:c:\winavr-20100110\avr\include\util\delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 237:c:\winavr-20100110\avr\include\util\delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 238:c:\winavr-20100110\avr\include\util\delay.h ****    algorithm can be made to round down, or round to closest integer,
 239:c:\winavr-20100110\avr\include\util\delay.h ****    respectively.
 240:c:\winavr-20100110\avr\include\util\delay.h **** 
 241:c:\winavr-20100110\avr\include\util\delay.h ****    \note
 242:c:\winavr-20100110\avr\include\util\delay.h **** 
 243:c:\winavr-20100110\avr\include\util\delay.h ****    The implementation of _delay_ms() based on
 244:c:\winavr-20100110\avr\include\util\delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 245:c:\winavr-20100110\avr\include\util\delay.h ****    implementations.  In order to get functionality backward compatible
 246:c:\winavr-20100110\avr\include\util\delay.h ****    with previous versions, the macro \c __DELAY_BACKWARD_COMPATIBLE__
 247:c:\winavr-20100110\avr\include\util\delay.h ****    must be defined before including this header file. Also, the
 248:c:\winavr-20100110\avr\include\util\delay.h ****    backward compatible algorithm will be chosen if the code is
 249:c:\winavr-20100110\avr\include\util\delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 250:c:\winavr-20100110\avr\include\util\delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 251:c:\winavr-20100110\avr\include\util\delay.h ****    not available to the compiler then.
 252:c:\winavr-20100110\avr\include\util\delay.h **** 
 253:c:\winavr-20100110\avr\include\util\delay.h ****  */
 254:c:\winavr-20100110\avr\include\util\delay.h **** void
 255:c:\winavr-20100110\avr\include\util\delay.h **** _delay_us(double __us)
 256:c:\winavr-20100110\avr\include\util\delay.h **** {
 257:c:\winavr-20100110\avr\include\util\delay.h **** 	double __tmp ;
 258:c:\winavr-20100110\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 259:c:\winavr-20100110\avr\include\util\delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 260:c:\winavr-20100110\avr\include\util\delay.h ****   __STDC_HOSTED__
 261:c:\winavr-20100110\avr\include\util\delay.h **** 	uint32_t __ticks_dc;
 262:c:\winavr-20100110\avr\include\util\delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 263:c:\winavr-20100110\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 264:c:\winavr-20100110\avr\include\util\delay.h **** 
 265:c:\winavr-20100110\avr\include\util\delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 266:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 267:c:\winavr-20100110\avr\include\util\delay.h **** 
 268:c:\winavr-20100110\avr\include\util\delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 269:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 270:c:\winavr-20100110\avr\include\util\delay.h **** 
 271:c:\winavr-20100110\avr\include\util\delay.h **** 	#else
 272:c:\winavr-20100110\avr\include\util\delay.h **** 		//round up by default
 273:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 274:c:\winavr-20100110\avr\include\util\delay.h **** 	#endif
 275:c:\winavr-20100110\avr\include\util\delay.h **** 
 276:c:\winavr-20100110\avr\include\util\delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 1297               		.loc 2 276 0
 1298 0382 85E3      		ldi r24,lo8(53)
 1299 0384 8A95      	1:	dec r24
 1300 0386 01F4      		brne 1b
 1301 0388 0000      		nop
 1302               	.LVL97:
 1303               	/* epilogue start */
 1304               	.LBE82:
 1305               	.LBE81:
 575:setup.c       **** 	_delay_us(20); // Wait byte program time
 576:setup.c       **** }
 1306               		.loc 1 576 0
 1307 038a DF91      		pop r29
 1308 038c CF91      		pop r28
 1309               	.LVL98:
 1310 038e 1F91      		pop r17
 1311               	.LVL99:
 1312 0390 0895      		ret
 1313               		.cfi_endproc
 1314               	.LFE34:
 1316               	.global	flash_write_sector
 1318               	flash_write_sector:
 1319               	.LFB35:
 577:setup.c       **** 
 578:setup.c       **** // Write a sector (128 bytes) to the Atmel flash
 579:setup.c       **** // Takes 20ms for write cycle
 580:setup.c       **** void flash_write_sector(uint16_t sector) {
 1320               		.loc 1 580 0
 1321               		.cfi_startproc
 1322               	.LVL100:
 1323 0392 EF92      		push r14
 1324               	.LCFI18:
 1325               		.cfi_def_cfa_offset 3
 1326               		.cfi_offset 14, -2
 1327 0394 FF92      		push r15
 1328               	.LCFI19:
 1329               		.cfi_def_cfa_offset 4
 1330               		.cfi_offset 15, -3
 1331 0396 0F93      		push r16
 1332               	.LCFI20:
 1333               		.cfi_def_cfa_offset 5
 1334               		.cfi_offset 16, -4
 1335 0398 1F93      		push r17
 1336               	.LCFI21:
 1337               		.cfi_def_cfa_offset 6
 1338               		.cfi_offset 17, -5
 1339 039a CF93      		push r28
 1340               	.LCFI22:
 1341               		.cfi_def_cfa_offset 7
 1342               		.cfi_offset 28, -6
 1343 039c DF93      		push r29
 1344               	.LCFI23:
 1345               		.cfi_def_cfa_offset 8
 1346               		.cfi_offset 29, -7
 1347               	/* prologue: function */
 1348               	/* frame size = 0 */
 1349               	/* stack size = 6 */
 1350               	.L__stack_usage = 6
 1351 039e 8C01      		movw r16,r24
 581:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xAA);
 1352               		.loc 1 581 0
 1353 03a0 6AEA      		ldi r22,lo8(-86)
 1354 03a2 85E5      		ldi r24,lo8(85)
 1355 03a4 95E5      		ldi r25,lo8(85)
 1356               	.LVL101:
 1357 03a6 00D0      		rcall flash_write_bus_cycle
 1358               	.LVL102:
 582:setup.c       **** 	flash_write_bus_cycle(0x2AAA, 0x55);
 1359               		.loc 1 582 0
 1360 03a8 65E5      		ldi r22,lo8(85)
 1361 03aa 8AEA      		ldi r24,lo8(-86)
 1362 03ac 9AE2      		ldi r25,lo8(42)
 1363 03ae 00D0      		rcall flash_write_bus_cycle
 1364               	.LVL103:
 583:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xA0);
 1365               		.loc 1 583 0
 1366 03b0 60EA      		ldi r22,lo8(-96)
 1367 03b2 85E5      		ldi r24,lo8(85)
 1368 03b4 95E5      		ldi r25,lo8(85)
 1369 03b6 00D0      		rcall flash_write_bus_cycle
 1370               	.LVL104:
 1371               	.LBB83:
 584:setup.c       **** 	
 585:setup.c       **** 	// Write the bytes (A0-A6 byte address, A7-A15 sector address)
 586:setup.c       **** 	for (uint8_t x = 0; x < 128; x++) {
 587:setup.c       **** 		flash_write_bus_cycle((uint16_t) (sector << 7) | (uint16_t) x, receivedBuffer[x]);
 1372               		.loc 1 587 0
 1373 03b8 1695      		lsr r17
 1374 03ba 102F      		mov r17,r16
 1375 03bc 0027      		clr r16
 1376 03be 1795      		ror r17
 1377 03c0 0795      		ror r16
 1378               	.LVL105:
 1379 03c2 90E0      		ldi r25,lo8(receivedBuffer)
 1380 03c4 E92E      		mov r14,r25
 1381 03c6 90E0      		ldi r25,hi8(receivedBuffer)
 1382 03c8 F92E      		mov r15,r25
 1383 03ca C0E0      		ldi r28,0
 1384 03cc D0E0      		ldi r29,0
 1385               	.LVL106:
 1386               	.L66:
 1387               		.loc 1 587 0 is_stmt 0 discriminator 3
 1388 03ce F701      		movw r30,r14
 1389 03d0 6191      		ld r22,Z+
 1390 03d2 7F01      		movw r14,r30
 1391 03d4 CE01      		movw r24,r28
 1392 03d6 802B      		or r24,r16
 1393 03d8 912B      		or r25,r17
 1394 03da 00D0      		rcall flash_write_bus_cycle
 1395               	.LVL107:
 1396 03dc 2196      		adiw r28,1
 1397               	.LVL108:
 586:setup.c       **** 		flash_write_bus_cycle((uint16_t) (sector << 7) | (uint16_t) x, receivedBuffer[x]);
 1398               		.loc 1 586 0 is_stmt 1 discriminator 3
 1399 03de C038      		cpi r28,-128
 1400 03e0 D105      		cpc r29,__zero_reg__
 1401 03e2 01F4      		brne .L66
 1402               	.LVL109:
 1403               	.LBE83:
 1404               	.LBB84:
 1405               	.LBB85:
 187:c:\winavr-20100110\avr\include\util\delay.h **** 
 1406               		.loc 2 187 0
 1407 03e4 8FE3      		ldi r24,lo8(-25537)
 1408 03e6 9CE9      		ldi r25,hi8(-25537)
 1409 03e8 0197      	1:	sbiw r24,1
 1410 03ea 01F4      		brne 1b
 1411 03ec 00C0      		rjmp .
 1412 03ee 0000      		nop
 1413               	.LVL110:
 1414               	/* epilogue start */
 1415               	.LBE85:
 1416               	.LBE84:
 588:setup.c       **** 	}
 589:setup.c       **** 	_delay_ms(20); // Wait sector program time
 590:setup.c       **** }
 1417               		.loc 1 590 0
 1418 03f0 DF91      		pop r29
 1419 03f2 CF91      		pop r28
 1420               	.LVL111:
 1421 03f4 1F91      		pop r17
 1422 03f6 0F91      		pop r16
 1423 03f8 FF90      		pop r15
 1424 03fa EF90      		pop r14
 1425 03fc 0895      		ret
 1426               		.cfi_endproc
 1427               	.LFE35:
 1429               	.global	gb_flash_read_byte
 1431               	gb_flash_read_byte:
 1432               	.LFB36:
 591:setup.c       **** 
 592:setup.c       **** 
 593:setup.c       **** 
 594:setup.c       **** // ---------- GB FLASH CARTS ----------
 595:setup.c       **** 
 596:setup.c       **** // Read a byte from the flash (No CS pin pulse)
 597:setup.c       **** uint8_t gb_flash_read_byte(uint16_t address) {
 1433               		.loc 1 597 0
 1434               		.cfi_startproc
 1435               	.LVL112:
 1436               	/* prologue: function */
 1437               	/* frame size = 0 */
 1438               	/* stack size = 0 */
 1439               	.L__stack_usage = 0
 598:setup.c       **** 	PORT_DATA7_0 = 0;
 1440               		.loc 1 598 0
 1441 03fe 15BA      		out 0x15,__zero_reg__
 599:setup.c       **** 	DDR_DATA7_0 = 0;
 1442               		.loc 1 599 0
 1443 0400 14BA      		out 0x14,__zero_reg__
 600:setup.c       **** 	
 601:setup.c       **** 	set_16bit_address(address);
 1444               		.loc 1 601 0
 1445 0402 00D0      		rcall set_16bit_address
 1446               	.LVL113:
 602:setup.c       **** 	
 603:setup.c       **** 	rdPin_low;
 1447               		.loc 1 603 0
 1448 0404 9598      		cbi 0x12,5
 604:setup.c       **** 	asm volatile("nop"); // Delay a little
 1449               		.loc 1 604 0
 1450               	/* #APP */
 1451               	 ;  604 "setup.c" 1
 1452 0406 0000      		nop
 1453               	 ;  0 "" 2
 605:setup.c       **** 	asm volatile("nop");
 1454               		.loc 1 605 0
 1455               	 ;  605 "setup.c" 1
 1456 0408 0000      		nop
 1457               	 ;  0 "" 2
 606:setup.c       **** 	uint8_t data = PIN_DATA7_0; // Read data
 1458               		.loc 1 606 0
 1459               	/* #NOAPP */
 1460 040a 83B3      		in r24,0x13
 1461               	.LVL114:
 607:setup.c       **** 	rdPin_high;
 1462               		.loc 1 607 0
 1463 040c 959A      		sbi 0x12,5
 608:setup.c       **** 	
 609:setup.c       **** 	return data;
 610:setup.c       **** }
 1464               		.loc 1 610 0
 1465 040e 0895      		ret
 1466               		.cfi_endproc
 1467               	.LFE36:
 1469               	.global	audio_flash_write_bus_cycle
 1471               	audio_flash_write_bus_cycle:
 1472               	.LFB37:
 611:setup.c       **** 
 612:setup.c       **** 
 613:setup.c       **** // 32K Audio WE - Set the address and data for the write byte cycle to the flash (pulsing audio pin
 614:setup.c       **** void audio_flash_write_bus_cycle(uint16_t address, uint8_t data) {
 1473               		.loc 1 614 0
 1474               		.cfi_startproc
 1475               	.LVL115:
 1476 0410 CF93      		push r28
 1477               	.LCFI24:
 1478               		.cfi_def_cfa_offset 3
 1479               		.cfi_offset 28, -2
 1480               	/* prologue: function */
 1481               	/* frame size = 0 */
 1482               	/* stack size = 1 */
 1483               	.L__stack_usage = 1
 1484 0412 C62F      		mov r28,r22
 615:setup.c       **** 	DDR_DATA7_0 = 0xFF; // Set data pins as outputs
 1485               		.loc 1 615 0
 1486 0414 2FEF      		ldi r18,lo8(-1)
 1487 0416 24BB      		out 0x14,r18
 616:setup.c       **** 	set_16bit_address(address);
 1488               		.loc 1 616 0
 1489 0418 00D0      		rcall set_16bit_address
 1490               	.LVL116:
 617:setup.c       **** 	PORT_DATA7_0 = data;
 1491               		.loc 1 617 0
 1492 041a C5BB      		out 0x15,r28
 618:setup.c       **** 	
 619:setup.c       **** 	audioPin_low; // WE low
 1493               		.loc 1 619 0
 1494 041c 3998      		cbi 0x7,1
 620:setup.c       **** 	asm volatile("nop");
 1495               		.loc 1 620 0
 1496               	/* #APP */
 1497               	 ;  620 "setup.c" 1
 1498 041e 0000      		nop
 1499               	 ;  0 "" 2
 621:setup.c       **** 	asm volatile("nop");
 1500               		.loc 1 621 0
 1501               	 ;  621 "setup.c" 1
 1502 0420 0000      		nop
 1503               	 ;  0 "" 2
 622:setup.c       **** 	asm volatile("nop");
 1504               		.loc 1 622 0
 1505               	 ;  622 "setup.c" 1
 1506 0422 0000      		nop
 1507               	 ;  0 "" 2
 623:setup.c       **** 	audioPin_high; // WE high
 1508               		.loc 1 623 0
 1509               	/* #NOAPP */
 1510 0424 399A      		sbi 0x7,1
 1511               	/* epilogue start */
 624:setup.c       **** }
 1512               		.loc 1 624 0
 1513 0426 CF91      		pop r28
 1514               	.LVL117:
 1515 0428 0895      		ret
 1516               		.cfi_endproc
 1517               	.LFE37:
 1519               	.global	audio_flash_write_byte
 1521               	audio_flash_write_byte:
 1522               	.LFB38:
 625:setup.c       **** 
 626:setup.c       **** // 32K Audio WE - Write a single byte to the Flash address. Takes 20us to program Flash.
 627:setup.c       **** void audio_flash_write_byte(uint16_t address, uint8_t data) {
 1523               		.loc 1 627 0
 1524               		.cfi_startproc
 1525               	.LVL118:
 1526 042a 1F93      		push r17
 1527               	.LCFI25:
 1528               		.cfi_def_cfa_offset 3
 1529               		.cfi_offset 17, -2
 1530 042c CF93      		push r28
 1531               	.LCFI26:
 1532               		.cfi_def_cfa_offset 4
 1533               		.cfi_offset 28, -3
 1534 042e DF93      		push r29
 1535               	.LCFI27:
 1536               		.cfi_def_cfa_offset 5
 1537               		.cfi_offset 29, -4
 1538               	/* prologue: function */
 1539               	/* frame size = 0 */
 1540               	/* stack size = 3 */
 1541               	.L__stack_usage = 3
 1542 0430 EC01      		movw r28,r24
 1543 0432 162F      		mov r17,r22
 628:setup.c       **** 	audio_flash_write_bus_cycle(0x555, 0xAA);
 1544               		.loc 1 628 0
 1545 0434 6AEA      		ldi r22,lo8(-86)
 1546               	.LVL119:
 1547 0436 85E5      		ldi r24,lo8(85)
 1548 0438 95E0      		ldi r25,lo8(5)
 1549               	.LVL120:
 1550 043a 00D0      		rcall audio_flash_write_bus_cycle
 1551               	.LVL121:
 629:setup.c       **** 	audio_flash_write_bus_cycle(0x2AA, 0x55);
 1552               		.loc 1 629 0
 1553 043c 65E5      		ldi r22,lo8(85)
 1554 043e 8AEA      		ldi r24,lo8(-86)
 1555 0440 92E0      		ldi r25,lo8(2)
 1556 0442 00D0      		rcall audio_flash_write_bus_cycle
 1557               	.LVL122:
 630:setup.c       **** 	audio_flash_write_bus_cycle(0x555, 0xA0);
 1558               		.loc 1 630 0
 1559 0444 60EA      		ldi r22,lo8(-96)
 1560 0446 85E5      		ldi r24,lo8(85)
 1561 0448 95E0      		ldi r25,lo8(5)
 1562 044a 00D0      		rcall audio_flash_write_bus_cycle
 1563               	.LVL123:
 631:setup.c       **** 	audio_flash_write_bus_cycle(address, data);
 1564               		.loc 1 631 0
 1565 044c 612F      		mov r22,r17
 1566 044e CE01      		movw r24,r28
 1567 0450 00D0      		rcall audio_flash_write_bus_cycle
 1568               	.LVL124:
 1569               	.LBB86:
 1570               	.LBB87:
 1571               		.loc 2 276 0
 1572 0452 85E3      		ldi r24,lo8(53)
 1573 0454 8A95      	1:	dec r24
 1574 0456 01F4      		brne 1b
 1575 0458 0000      		nop
 1576               	.LVL125:
 1577               	.LBE87:
 1578               	.LBE86:
 632:setup.c       **** 	_delay_us(20); // Wait byte program time
 633:setup.c       **** 	
 634:setup.c       **** 	// Set data pins inputs
 635:setup.c       **** 	PORT_DATA7_0 = 0;
 1579               		.loc 1 635 0
 1580 045a 15BA      		out 0x15,__zero_reg__
 636:setup.c       **** 	DDR_DATA7_0 = 0;
 1581               		.loc 1 636 0
 1582 045c 14BA      		out 0x14,__zero_reg__
 637:setup.c       **** 	
 638:setup.c       **** 	// Verify data
 639:setup.c       **** 	uint8_t dataVerify = gb_flash_read_byte(address);
 1583               		.loc 1 639 0
 1584 045e CE01      		movw r24,r28
 1585 0460 00D0      		rcall gb_flash_read_byte
 1586               	.LVL126:
 1587               	.L71:
 640:setup.c       **** 	while (data != dataVerify) {
 1588               		.loc 1 640 0
 1589 0462 8117      		cp r24,r17
 1590 0464 01F0      		breq .L73
 641:setup.c       **** 		dataVerify = gb_flash_read_byte(address);
 1591               		.loc 1 641 0
 1592 0466 CE01      		movw r24,r28
 1593               	.LVL127:
 1594 0468 00D0      		rcall gb_flash_read_byte
 1595               	.LVL128:
 1596               	.LBB88:
 1597               	.LBB89:
 1598               		.loc 2 276 0
 1599 046a 95E3      		ldi r25,lo8(53)
 1600 046c 9A95      	1:	dec r25
 1601 046e 01F4      		brne 1b
 1602 0470 0000      		nop
 1603 0472 00C0      		rjmp .L71
 1604               	.LVL129:
 1605               	.L73:
 1606               	/* epilogue start */
 1607               	.LBE89:
 1608               	.LBE88:
 642:setup.c       **** 		_delay_us(20);
 643:setup.c       **** 	}
 644:setup.c       **** }
 1609               		.loc 1 644 0
 1610 0474 DF91      		pop r29
 1611 0476 CF91      		pop r28
 1612               	.LVL130:
 1613 0478 1F91      		pop r17
 1614               	.LVL131:
 1615 047a 0895      		ret
 1616               		.cfi_endproc
 1617               	.LFE38:
 1619               	.global	bv5_flash_write_bus_cycle
 1621               	bv5_flash_write_bus_cycle:
 1622               	.LFB41:
 645:setup.c       **** 
 646:setup.c       **** 
 647:setup.c       **** // Regular WR - Set the address and data for the write byte cycle to the flash (pulsing WR pin, no 
 648:setup.c       **** void gb_wr_flash_write_bus_cycle(uint16_t address, uint8_t data) {
 649:setup.c       **** 	DDR_DATA7_0 = 0xFF; // Set data pins as outputs
 650:setup.c       **** 	set_16bit_address(address);
 651:setup.c       **** 	PORT_DATA7_0 = data;
 652:setup.c       **** 	
 653:setup.c       **** 	wrPin_low; // WE low
 654:setup.c       **** 	asm volatile("nop");
 655:setup.c       **** 	asm volatile("nop");
 656:setup.c       **** 	asm volatile("nop");
 657:setup.c       **** 	wrPin_high; // WE high
 658:setup.c       **** }
 659:setup.c       **** 
 660:setup.c       **** // Regular WR - Write a single byte to the Flash address. Takes 20us to program Flash. (No CS pin p
 661:setup.c       **** void gb_wr_flash_write_byte(uint16_t address, uint8_t data) {
 662:setup.c       **** 	gb_wr_flash_write_bus_cycle(0x555, 0xAA);
 663:setup.c       **** 	gb_wr_flash_write_bus_cycle(0x2AA, 0x55);
 664:setup.c       **** 	gb_wr_flash_write_bus_cycle(0x555, 0xA0);
 665:setup.c       **** 	gb_wr_flash_write_bus_cycle(address, data);
 666:setup.c       **** 	_delay_us(20); // Wait byte program time
 667:setup.c       **** 	
 668:setup.c       **** 	// Set data pins inputs
 669:setup.c       **** 	PORT_DATA7_0 = 0;
 670:setup.c       **** 	DDR_DATA7_0 = 0;
 671:setup.c       **** 	
 672:setup.c       **** 	// Verify data
 673:setup.c       **** 	uint8_t dataVerify = gb_flash_read_byte(address);
 674:setup.c       **** 	while (data != dataVerify) {
 675:setup.c       **** 		dataVerify = gb_flash_read_byte(address);
 676:setup.c       **** 		_delay_us(20);
 677:setup.c       **** 	}
 678:setup.c       **** }
 679:setup.c       **** 
 680:setup.c       **** 
 681:setup.c       **** // BV5 - Set the address and data for the write byte cycle to the flash (pulsing WR pin)
 682:setup.c       **** void bv5_flash_write_bus_cycle(uint16_t address, uint8_t data) {
 1623               		.loc 1 682 0
 1624               		.cfi_startproc
 1625               	.LVL132:
 1626 047c CF93      		push r28
 1627               	.LCFI28:
 1628               		.cfi_def_cfa_offset 3
 1629               		.cfi_offset 28, -2
 1630               	/* prologue: function */
 1631               	/* frame size = 0 */
 1632               	/* stack size = 1 */
 1633               	.L__stack_usage = 1
 1634 047e C62F      		mov r28,r22
 683:setup.c       **** 	DDR_DATA7_0 = 0xFF; // Set data pins as outputs
 1635               		.loc 1 683 0
 1636 0480 2FEF      		ldi r18,lo8(-1)
 1637 0482 24BB      		out 0x14,r18
 684:setup.c       **** 	set_16bit_address(address);
 1638               		.loc 1 684 0
 1639 0484 00D0      		rcall set_16bit_address
 1640               	.LVL133:
 685:setup.c       **** 	PORT_DATA7_0 = data;
 1641               		.loc 1 685 0
 1642 0486 C5BB      		out 0x15,r28
 686:setup.c       **** 	
 687:setup.c       **** 	wrPin_low;
 1643               		.loc 1 687 0
 1644 0488 9698      		cbi 0x12,6
 688:setup.c       **** 	asm volatile("nop");
 1645               		.loc 1 688 0
 1646               	/* #APP */
 1647               	 ;  688 "setup.c" 1
 1648 048a 0000      		nop
 1649               	 ;  0 "" 2
 689:setup.c       **** 	asm volatile("nop");
 1650               		.loc 1 689 0
 1651               	 ;  689 "setup.c" 1
 1652 048c 0000      		nop
 1653               	 ;  0 "" 2
 690:setup.c       **** 	asm volatile("nop");
 1654               		.loc 1 690 0
 1655               	 ;  690 "setup.c" 1
 1656 048e 0000      		nop
 1657               	 ;  0 "" 2
 691:setup.c       **** 	wrPin_high;
 1658               		.loc 1 691 0
 1659               	/* #NOAPP */
 1660 0490 969A      		sbi 0x12,6
 1661               	/* epilogue start */
 692:setup.c       **** }
 1662               		.loc 1 692 0
 1663 0492 CF91      		pop r28
 1664               	.LVL134:
 1665 0494 0895      		ret
 1666               		.cfi_endproc
 1667               	.LFE41:
 1669               	.global	gb_wr_flash_write_byte
 1671               	gb_wr_flash_write_byte:
 1672               	.LFB40:
 661:setup.c       **** 	gb_wr_flash_write_bus_cycle(0x555, 0xAA);
 1673               		.loc 1 661 0
 1674               		.cfi_startproc
 1675               	.LVL135:
 1676 0496 1F93      		push r17
 1677               	.LCFI29:
 1678               		.cfi_def_cfa_offset 3
 1679               		.cfi_offset 17, -2
 1680 0498 CF93      		push r28
 1681               	.LCFI30:
 1682               		.cfi_def_cfa_offset 4
 1683               		.cfi_offset 28, -3
 1684 049a DF93      		push r29
 1685               	.LCFI31:
 1686               		.cfi_def_cfa_offset 5
 1687               		.cfi_offset 29, -4
 1688               	/* prologue: function */
 1689               	/* frame size = 0 */
 1690               	/* stack size = 3 */
 1691               	.L__stack_usage = 3
 1692 049c EC01      		movw r28,r24
 1693 049e 162F      		mov r17,r22
 662:setup.c       **** 	gb_wr_flash_write_bus_cycle(0x2AA, 0x55);
 1694               		.loc 1 662 0
 1695 04a0 6AEA      		ldi r22,lo8(-86)
 1696               	.LVL136:
 1697 04a2 85E5      		ldi r24,lo8(85)
 1698 04a4 95E0      		ldi r25,lo8(5)
 1699               	.LVL137:
 1700 04a6 00D0      		rcall bv5_flash_write_bus_cycle
 1701               	.LVL138:
 663:setup.c       **** 	gb_wr_flash_write_bus_cycle(0x555, 0xA0);
 1702               		.loc 1 663 0
 1703 04a8 65E5      		ldi r22,lo8(85)
 1704 04aa 8AEA      		ldi r24,lo8(-86)
 1705 04ac 92E0      		ldi r25,lo8(2)
 1706 04ae 00D0      		rcall bv5_flash_write_bus_cycle
 1707               	.LVL139:
 664:setup.c       **** 	gb_wr_flash_write_bus_cycle(address, data);
 1708               		.loc 1 664 0
 1709 04b0 60EA      		ldi r22,lo8(-96)
 1710 04b2 85E5      		ldi r24,lo8(85)
 1711 04b4 95E0      		ldi r25,lo8(5)
 1712 04b6 00D0      		rcall bv5_flash_write_bus_cycle
 1713               	.LVL140:
 665:setup.c       **** 	_delay_us(20); // Wait byte program time
 1714               		.loc 1 665 0
 1715 04b8 612F      		mov r22,r17
 1716 04ba CE01      		movw r24,r28
 1717 04bc 00D0      		rcall bv5_flash_write_bus_cycle
 1718               	.LVL141:
 1719               	.LBB90:
 1720               	.LBB91:
 1721               		.loc 2 276 0
 1722 04be 85E3      		ldi r24,lo8(53)
 1723 04c0 8A95      	1:	dec r24
 1724 04c2 01F4      		brne 1b
 1725 04c4 0000      		nop
 1726               	.LVL142:
 1727               	.LBE91:
 1728               	.LBE90:
 669:setup.c       **** 	DDR_DATA7_0 = 0;
 1729               		.loc 1 669 0
 1730 04c6 15BA      		out 0x15,__zero_reg__
 670:setup.c       **** 	
 1731               		.loc 1 670 0
 1732 04c8 14BA      		out 0x14,__zero_reg__
 673:setup.c       **** 	while (data != dataVerify) {
 1733               		.loc 1 673 0
 1734 04ca CE01      		movw r24,r28
 1735 04cc 00D0      		rcall gb_flash_read_byte
 1736               	.LVL143:
 1737               	.L76:
 674:setup.c       **** 		dataVerify = gb_flash_read_byte(address);
 1738               		.loc 1 674 0
 1739 04ce 8117      		cp r24,r17
 1740 04d0 01F0      		breq .L78
 675:setup.c       **** 		_delay_us(20);
 1741               		.loc 1 675 0
 1742 04d2 CE01      		movw r24,r28
 1743               	.LVL144:
 1744 04d4 00D0      		rcall gb_flash_read_byte
 1745               	.LVL145:
 1746               	.LBB92:
 1747               	.LBB93:
 1748               		.loc 2 276 0
 1749 04d6 95E3      		ldi r25,lo8(53)
 1750 04d8 9A95      	1:	dec r25
 1751 04da 01F4      		brne 1b
 1752 04dc 0000      		nop
 1753 04de 00C0      		rjmp .L76
 1754               	.LVL146:
 1755               	.L78:
 1756               	/* epilogue start */
 1757               	.LBE93:
 1758               	.LBE92:
 678:setup.c       **** 
 1759               		.loc 1 678 0
 1760 04e0 DF91      		pop r29
 1761 04e2 CF91      		pop r28
 1762               	.LVL147:
 1763 04e4 1F91      		pop r17
 1764               	.LVL148:
 1765 04e6 0895      		ret
 1766               		.cfi_endproc
 1767               	.LFE40:
 1769               	.global	gb_wr_flash_write_bus_cycle
 1771               	gb_wr_flash_write_bus_cycle:
 1772               	.LFB49:
 1773               		.cfi_startproc
 1774               	/* prologue: function */
 1775               	/* frame size = 0 */
 1776               	/* stack size = 0 */
 1777               	.L__stack_usage = 0
 1778 04e8 00C0      		rjmp bv5_flash_write_bus_cycle
 1779               		.cfi_endproc
 1780               	.LFE49:
 1782               	.global	bv5_flash_write_byte
 1784               	bv5_flash_write_byte:
 1785               	.LFB42:
 693:setup.c       **** 
 694:setup.c       **** // BV5 - Write a single byte to the Flash address. Time to wait depends on Flash.
 695:setup.c       **** // Data byte's bit 0 & 1 are swapped for chip commands as D0 & D1 lines are swapped
 696:setup.c       **** void bv5_flash_write_byte(uint16_t address, uint8_t data) {
 1786               		.loc 1 696 0
 1787               		.cfi_startproc
 1788               	.LVL149:
 1789               		.loc 1 696 0
 1790 04ea 1F93      		push r17
 1791               	.LCFI32:
 1792               		.cfi_def_cfa_offset 3
 1793               		.cfi_offset 17, -2
 1794 04ec CF93      		push r28
 1795               	.LCFI33:
 1796               		.cfi_def_cfa_offset 4
 1797               		.cfi_offset 28, -3
 1798 04ee DF93      		push r29
 1799               	.LCFI34:
 1800               		.cfi_def_cfa_offset 5
 1801               		.cfi_offset 29, -4
 1802               	/* prologue: function */
 1803               	/* frame size = 0 */
 1804               	/* stack size = 3 */
 1805               	.L__stack_usage = 3
 1806 04f0 EC01      		movw r28,r24
 1807 04f2 162F      		mov r17,r22
 697:setup.c       **** 	bv5_flash_write_bus_cycle(0xAAA, 0xA9);
 1808               		.loc 1 697 0
 1809 04f4 69EA      		ldi r22,lo8(-87)
 1810               	.LVL150:
 1811 04f6 8AEA      		ldi r24,lo8(-86)
 1812 04f8 9AE0      		ldi r25,lo8(10)
 1813               	.LVL151:
 1814 04fa 00D0      		rcall bv5_flash_write_bus_cycle
 1815               	.LVL152:
 698:setup.c       **** 	bv5_flash_write_bus_cycle(0x555, 0x56);
 1816               		.loc 1 698 0
 1817 04fc 66E5      		ldi r22,lo8(86)
 1818 04fe 85E5      		ldi r24,lo8(85)
 1819 0500 95E0      		ldi r25,lo8(5)
 1820 0502 00D0      		rcall bv5_flash_write_bus_cycle
 1821               	.LVL153:
 699:setup.c       **** 	bv5_flash_write_bus_cycle(0xAAA, 0xA0);
 1822               		.loc 1 699 0
 1823 0504 60EA      		ldi r22,lo8(-96)
 1824 0506 8AEA      		ldi r24,lo8(-86)
 1825 0508 9AE0      		ldi r25,lo8(10)
 1826 050a 00D0      		rcall bv5_flash_write_bus_cycle
 1827               	.LVL154:
 700:setup.c       **** 	bv5_flash_write_bus_cycle(address, data);
 1828               		.loc 1 700 0
 1829 050c 612F      		mov r22,r17
 1830 050e CE01      		movw r24,r28
 1831 0510 00D0      		rcall bv5_flash_write_bus_cycle
 1832               	.LVL155:
 1833               	.LBB94:
 1834               	.LBB95:
 1835               		.loc 2 276 0
 1836 0512 85E3      		ldi r24,lo8(53)
 1837 0514 8A95      	1:	dec r24
 1838 0516 01F4      		brne 1b
 1839 0518 0000      		nop
 1840               	.LVL156:
 1841               	.LBE95:
 1842               	.LBE94:
 701:setup.c       **** 	_delay_us(20); // Wait byte program time
 702:setup.c       **** 	
 703:setup.c       **** 	// Verify data
 704:setup.c       **** 	uint8_t dataVerify = gb_flash_read_byte(address);
 1843               		.loc 1 704 0
 1844 051a CE01      		movw r24,r28
 1845 051c 00D0      		rcall gb_flash_read_byte
 1846               	.LVL157:
 1847               	.L81:
 705:setup.c       **** 	while (data != dataVerify) {
 1848               		.loc 1 705 0
 1849 051e 8117      		cp r24,r17
 1850 0520 01F0      		breq .L83
 706:setup.c       **** 		dataVerify = gb_flash_read_byte(address);
 1851               		.loc 1 706 0
 1852 0522 CE01      		movw r24,r28
 1853               	.LVL158:
 1854 0524 00D0      		rcall gb_flash_read_byte
 1855               	.LVL159:
 1856               	.LBB96:
 1857               	.LBB97:
 1858               		.loc 2 276 0
 1859 0526 95E3      		ldi r25,lo8(53)
 1860 0528 9A95      	1:	dec r25
 1861 052a 01F4      		brne 1b
 1862 052c 0000      		nop
 1863 052e 00C0      		rjmp .L81
 1864               	.LVL160:
 1865               	.L83:
 1866               	/* epilogue start */
 1867               	.LBE97:
 1868               	.LBE96:
 707:setup.c       **** 		_delay_us(20);
 708:setup.c       **** 	}
 709:setup.c       **** }
 1869               		.loc 1 709 0
 1870 0530 DF91      		pop r29
 1871 0532 CF91      		pop r28
 1872               	.LVL161:
 1873 0534 1F91      		pop r17
 1874               	.LVL162:
 1875 0536 0895      		ret
 1876               		.cfi_endproc
 1877               	.LFE42:
 1879               	.global	gb_word_flash_write_byte
 1881               	gb_word_flash_write_byte:
 1882               	.LFB43:
 710:setup.c       **** 
 711:setup.c       **** 
 712:setup.c       **** // GB (Word)- Write a single byte to the Flash address. Time to wait depends on Flash.
 713:setup.c       **** // Data byte's bit 0 & 1 are swapped for chip commands as D0 & D1 lines are swapped
 714:setup.c       **** void gb_word_flash_write_byte(uint16_t address, uint8_t data) {
 1883               		.loc 1 714 0
 1884               		.cfi_startproc
 1885               	.LVL163:
 1886 0538 1F93      		push r17
 1887               	.LCFI35:
 1888               		.cfi_def_cfa_offset 3
 1889               		.cfi_offset 17, -2
 1890 053a CF93      		push r28
 1891               	.LCFI36:
 1892               		.cfi_def_cfa_offset 4
 1893               		.cfi_offset 28, -3
 1894 053c DF93      		push r29
 1895               	.LCFI37:
 1896               		.cfi_def_cfa_offset 5
 1897               		.cfi_offset 29, -4
 1898               	/* prologue: function */
 1899               	/* frame size = 0 */
 1900               	/* stack size = 3 */
 1901               	.L__stack_usage = 3
 1902 053e EC01      		movw r28,r24
 1903 0540 162F      		mov r17,r22
 715:setup.c       **** 	bv5_flash_write_bus_cycle(0x555, 0xA9);
 1904               		.loc 1 715 0
 1905 0542 69EA      		ldi r22,lo8(-87)
 1906               	.LVL164:
 1907 0544 85E5      		ldi r24,lo8(85)
 1908 0546 95E0      		ldi r25,lo8(5)
 1909               	.LVL165:
 1910 0548 00D0      		rcall bv5_flash_write_bus_cycle
 1911               	.LVL166:
 716:setup.c       **** 	bv5_flash_write_bus_cycle(0x2AA, 0x56);
 1912               		.loc 1 716 0
 1913 054a 66E5      		ldi r22,lo8(86)
 1914 054c 8AEA      		ldi r24,lo8(-86)
 1915 054e 92E0      		ldi r25,lo8(2)
 1916 0550 00D0      		rcall bv5_flash_write_bus_cycle
 1917               	.LVL167:
 717:setup.c       **** 	bv5_flash_write_bus_cycle(0x555, 0xA0);
 1918               		.loc 1 717 0
 1919 0552 60EA      		ldi r22,lo8(-96)
 1920 0554 85E5      		ldi r24,lo8(85)
 1921 0556 95E0      		ldi r25,lo8(5)
 1922 0558 00D0      		rcall bv5_flash_write_bus_cycle
 1923               	.LVL168:
 718:setup.c       **** 	bv5_flash_write_bus_cycle(address, data);
 1924               		.loc 1 718 0
 1925 055a 612F      		mov r22,r17
 1926 055c CE01      		movw r24,r28
 1927 055e 00D0      		rcall bv5_flash_write_bus_cycle
 1928               	.LVL169:
 1929               	.LBB98:
 1930               	.LBB99:
 1931               		.loc 2 276 0
 1932 0560 85E3      		ldi r24,lo8(53)
 1933 0562 8A95      	1:	dec r24
 1934 0564 01F4      		brne 1b
 1935 0566 0000      		nop
 1936               	.LVL170:
 1937               	.LBE99:
 1938               	.LBE98:
 719:setup.c       **** 	_delay_us(20); // Wait byte program time
 720:setup.c       **** 	
 721:setup.c       **** 	// Verify data
 722:setup.c       **** 	uint8_t dataVerify = gb_flash_read_byte(address);
 1939               		.loc 1 722 0
 1940 0568 CE01      		movw r24,r28
 1941 056a 00D0      		rcall gb_flash_read_byte
 1942               	.LVL171:
 1943               	.L85:
 723:setup.c       **** 	while (data != dataVerify) {
 1944               		.loc 1 723 0
 1945 056c 8117      		cp r24,r17
 1946 056e 01F0      		breq .L87
 724:setup.c       **** 		dataVerify = gb_flash_read_byte(address);
 1947               		.loc 1 724 0
 1948 0570 CE01      		movw r24,r28
 1949               	.LVL172:
 1950 0572 00D0      		rcall gb_flash_read_byte
 1951               	.LVL173:
 1952               	.LBB100:
 1953               	.LBB101:
 1954               		.loc 2 276 0
 1955 0574 95E3      		ldi r25,lo8(53)
 1956 0576 9A95      	1:	dec r25
 1957 0578 01F4      		brne 1b
 1958 057a 0000      		nop
 1959 057c 00C0      		rjmp .L85
 1960               	.LVL174:
 1961               	.L87:
 1962               	/* epilogue start */
 1963               	.LBE101:
 1964               	.LBE100:
 725:setup.c       **** 		_delay_us(20);
 726:setup.c       **** 	}
 727:setup.c       **** }
 1965               		.loc 1 727 0
 1966 057e DF91      		pop r29
 1967 0580 CF91      		pop r28
 1968               	.LVL175:
 1969 0582 1F91      		pop r17
 1970               	.LVL176:
 1971 0584 0895      		ret
 1972               		.cfi_endproc
 1973               	.LFE43:
 1975               	.global	gba_flash_write_bus_cycle
 1977               	gba_flash_write_bus_cycle:
 1978               	.LFB44:
 728:setup.c       **** 
 729:setup.c       **** 
 730:setup.c       **** // ---------- GBA FLASH CARTS ----------
 731:setup.c       **** 
 732:setup.c       **** // Set the 24 bit address and 16 bit data for the write byte cycle to the flash (pulse WR pin)
 733:setup.c       **** void gba_flash_write_bus_cycle(uint32_t address, uint16_t data) {
 1979               		.loc 1 733 0
 1980               		.cfi_startproc
 1981               	.LVL177:
 1982 0586 CF93      		push r28
 1983               	.LCFI38:
 1984               		.cfi_def_cfa_offset 3
 1985               		.cfi_offset 28, -2
 1986 0588 DF93      		push r29
 1987               	.LCFI39:
 1988               		.cfi_def_cfa_offset 4
 1989               		.cfi_offset 29, -3
 1990               	/* prologue: function */
 1991               	/* frame size = 0 */
 1992               	/* stack size = 2 */
 1993               	.L__stack_usage = 2
 1994 058a EA01      		movw r28,r20
 734:setup.c       **** 	gba_set_24bit_address(address);
 1995               		.loc 1 734 0
 1996 058c 00D0      		rcall gba_set_24bit_address
 1997               	.LVL178:
 735:setup.c       **** 	
 736:setup.c       **** 	cs_mreqPin_low;
 1998               		.loc 1 736 0
 1999 058e 9498      		cbi 0x12,4
 737:setup.c       **** 	
 738:setup.c       **** 	GBA_DDR_ROM_ADDR15_8 = 0xFF; // Set data pins as outputs
 2000               		.loc 1 738 0
 2001 0590 8FEF      		ldi r24,lo8(-1)
 2002 0592 8ABB      		out 0x1a,r24
 739:setup.c       **** 	GBA_DDR_ROM_ADDR7_0 = 0xFF;
 2003               		.loc 1 739 0
 2004 0594 87BB      		out 0x17,r24
 740:setup.c       **** 	GBA_PORT_ROM_DATA15_8 = data >> 8; // Set data
 2005               		.loc 1 740 0
 2006 0596 DBBB      		out 0x1b,r29
 741:setup.c       **** 	GBA_PORT_ROM_DATA7_0 = data & 0xFF;
 2007               		.loc 1 741 0
 2008 0598 C8BB      		out 0x18,r28
 742:setup.c       **** 	
 743:setup.c       **** 	wrPin_low;
 2009               		.loc 1 743 0
 2010 059a 9698      		cbi 0x12,6
 744:setup.c       **** 	asm volatile("nop");
 2011               		.loc 1 744 0
 2012               	/* #APP */
 2013               	 ;  744 "setup.c" 1
 2014 059c 0000      		nop
 2015               	 ;  0 "" 2
 745:setup.c       **** 	asm volatile("nop");
 2016               		.loc 1 745 0
 2017               	 ;  745 "setup.c" 1
 2018 059e 0000      		nop
 2019               	 ;  0 "" 2
 746:setup.c       **** 	asm volatile("nop");
 2020               		.loc 1 746 0
 2021               	 ;  746 "setup.c" 1
 2022 05a0 0000      		nop
 2023               	 ;  0 "" 2
 747:setup.c       **** 	wrPin_high;
 2024               		.loc 1 747 0
 2025               	/* #NOAPP */
 2026 05a2 969A      		sbi 0x12,6
 748:setup.c       **** 	cs_mreqPin_high;
 2027               		.loc 1 748 0
 2028 05a4 949A      		sbi 0x12,4
 2029               	/* epilogue start */
 749:setup.c       **** }
 2030               		.loc 1 749 0
 2031 05a6 DF91      		pop r29
 2032 05a8 CF91      		pop r28
 2033               	.LVL179:
 2034 05aa 0895      		ret
 2035               		.cfi_endproc
 2036               	.LFE44:
 2038               	.global	gba_flash_write_byte_swapped
 2040               	gba_flash_write_byte_swapped:
 2041               	.LFB45:
 750:setup.c       **** 
 751:setup.c       **** // Write 2 bytes to the Flash address. Time to wait depends on Flash, we will query it to verify th
 752:setup.c       **** // Address is divided by 2 as we are in GBA mode. 
 753:setup.c       **** // Data byte's bit 0 & 1 are swapped for chip commands as D0 & D1 lines are swapped
 754:setup.c       **** void gba_flash_write_byte_swapped(uint32_t address, uint16_t data) {
 2042               		.loc 1 754 0
 2043               		.cfi_startproc
 2044               	.LVL180:
 2045 05ac CF92      		push r12
 2046               	.LCFI40:
 2047               		.cfi_def_cfa_offset 3
 2048               		.cfi_offset 12, -2
 2049 05ae DF92      		push r13
 2050               	.LCFI41:
 2051               		.cfi_def_cfa_offset 4
 2052               		.cfi_offset 13, -3
 2053 05b0 EF92      		push r14
 2054               	.LCFI42:
 2055               		.cfi_def_cfa_offset 5
 2056               		.cfi_offset 14, -4
 2057 05b2 FF92      		push r15
 2058               	.LCFI43:
 2059               		.cfi_def_cfa_offset 6
 2060               		.cfi_offset 15, -5
 2061 05b4 CF93      		push r28
 2062               	.LCFI44:
 2063               		.cfi_def_cfa_offset 7
 2064               		.cfi_offset 28, -6
 2065 05b6 DF93      		push r29
 2066               	.LCFI45:
 2067               		.cfi_def_cfa_offset 8
 2068               		.cfi_offset 29, -7
 2069               	/* prologue: function */
 2070               	/* frame size = 0 */
 2071               	/* stack size = 6 */
 2072               	.L__stack_usage = 6
 2073 05b8 6B01      		movw r12,r22
 2074 05ba 7C01      		movw r14,r24
 2075 05bc EA01      		movw r28,r20
 755:setup.c       **** 	gba_flash_write_bus_cycle(0xAAA / 2, 0xA9);
 2076               		.loc 1 755 0
 2077 05be 49EA      		ldi r20,lo8(-87)
 2078 05c0 50E0      		ldi r21,0
 2079               	.LVL181:
 2080 05c2 65E5      		ldi r22,lo8(85)
 2081 05c4 75E0      		ldi r23,lo8(5)
 2082 05c6 80E0      		ldi r24,0
 2083 05c8 90E0      		ldi r25,0
 2084               	.LVL182:
 2085 05ca 00D0      		rcall gba_flash_write_bus_cycle
 2086               	.LVL183:
 756:setup.c       **** 	gba_flash_write_bus_cycle(0x555 / 2, 0x56);
 2087               		.loc 1 756 0
 2088 05cc 46E5      		ldi r20,lo8(86)
 2089 05ce 50E0      		ldi r21,0
 2090 05d0 6AEA      		ldi r22,lo8(-86)
 2091 05d2 72E0      		ldi r23,lo8(2)
 2092 05d4 80E0      		ldi r24,0
 2093 05d6 90E0      		ldi r25,0
 2094 05d8 00D0      		rcall gba_flash_write_bus_cycle
 2095               	.LVL184:
 757:setup.c       **** 	gba_flash_write_bus_cycle(0xAAA / 2, 0xA0);
 2096               		.loc 1 757 0
 2097 05da 40EA      		ldi r20,lo8(-96)
 2098 05dc 50E0      		ldi r21,0
 2099 05de 65E5      		ldi r22,lo8(85)
 2100 05e0 75E0      		ldi r23,lo8(5)
 2101 05e2 80E0      		ldi r24,0
 2102 05e4 90E0      		ldi r25,0
 2103 05e6 00D0      		rcall gba_flash_write_bus_cycle
 2104               	.LVL185:
 758:setup.c       **** 	gba_flash_write_bus_cycle(address, data);
 2105               		.loc 1 758 0
 2106 05e8 AE01      		movw r20,r28
 2107 05ea C701      		movw r24,r14
 2108 05ec B601      		movw r22,r12
 2109 05ee 00D0      		rcall gba_flash_write_bus_cycle
 2110               	.LVL186:
 2111               	.LBB102:
 2112               	.LBB103:
 2113               		.loc 2 276 0
 2114 05f0 25E3      		ldi r18,lo8(53)
 2115 05f2 2A95      	1:	dec r18
 2116 05f4 01F4      		brne 1b
 2117 05f6 0000      		nop
 2118               	.LVL187:
 2119               	.LBE103:
 2120               	.LBE102:
 759:setup.c       **** 	_delay_us(20); // Wait byte program time
 760:setup.c       **** 	
 761:setup.c       **** 	// Verify data
 762:setup.c       **** 	uint16_t dataVerify = gba_read_16bit_data(address);
 2121               		.loc 1 762 0
 2122 05f8 C701      		movw r24,r14
 2123 05fa B601      		movw r22,r12
 2124 05fc 00D0      		rcall gba_read_16bit_data
 2125               	.LVL188:
 2126               	.L90:
 763:setup.c       **** 	while (data != dataVerify) {
 2127               		.loc 1 763 0
 2128 05fe 8C17      		cp r24,r28
 2129 0600 9D07      		cpc r25,r29
 2130 0602 01F0      		breq .L92
 764:setup.c       **** 		dataVerify = gba_read_16bit_data(address);
 2131               		.loc 1 764 0
 2132 0604 C701      		movw r24,r14
 2133 0606 B601      		movw r22,r12
 2134 0608 00D0      		rcall gba_read_16bit_data
 2135               	.LVL189:
 2136               	.LBB104:
 2137               	.LBB105:
 2138               		.loc 2 276 0
 2139 060a 25E3      		ldi r18,lo8(53)
 2140 060c 2A95      	1:	dec r18
 2141 060e 01F4      		brne 1b
 2142 0610 0000      		nop
 2143 0612 00C0      		rjmp .L90
 2144               	.LVL190:
 2145               	.L92:
 2146               	/* epilogue start */
 2147               	.LBE105:
 2148               	.LBE104:
 765:setup.c       **** 		_delay_us(20);
 766:setup.c       **** 	}
 767:setup.c       **** }
 2149               		.loc 1 767 0
 2150 0614 DF91      		pop r29
 2151 0616 CF91      		pop r28
 2152               	.LVL191:
 2153 0618 FF90      		pop r15
 2154 061a EF90      		pop r14
 2155 061c DF90      		pop r13
 2156 061e CF90      		pop r12
 2157               	.LVL192:
 2158 0620 0895      		ret
 2159               		.cfi_endproc
 2160               	.LFE45:
 2162               	.global	setup
 2164               	setup:
 2165               	.LFB46:
 768:setup.c       **** 
 769:setup.c       **** 
 770:setup.c       **** // Setup
 771:setup.c       **** void setup(void) {
 2166               		.loc 1 771 0
 2167               		.cfi_startproc
 2168               	/* prologue: function */
 2169               	/* frame size = 0 */
 2170               	/* stack size = 0 */
 2171               	.L__stack_usage = 0
 772:setup.c       **** 	// Turn off watchdog
 773:setup.c       **** 	MCUCSR &= ~(1<<WDRF);
 2172               		.loc 1 773 0
 2173 0622 84B7      		in r24,0x34
 2174 0624 877F      		andi r24,lo8(-9)
 2175 0626 84BF      		out 0x34,r24
 774:setup.c       **** 	WDTCR = (1<<WDCE) | (1<<WDE);
 2176               		.loc 1 774 0
 2177 0628 88E1      		ldi r24,lo8(24)
 2178 062a 81BD      		out 0x21,r24
 775:setup.c       **** 	WDTCR = 0;
 2179               		.loc 1 775 0
 2180 062c 11BC      		out 0x21,__zero_reg__
 776:setup.c       **** 	
 777:setup.c       **** 	// Reset common lines
 778:setup.c       **** 	rd_wr_csmreq_cs2_reset();
 2181               		.loc 1 778 0
 2182 062e 00D0      		rcall rd_wr_csmreq_cs2_reset
 2183               	.LVL193:
 779:setup.c       **** 	
 780:setup.c       **** 	// Set outputs
 781:setup.c       **** 	DDRD |= (1<<ACTIVITY_LED) | (1<<WR_PIN) | (1<<RD_PIN) | (1<<CS_MREQ_PIN) | (1<<LED_5V);
 2184               		.loc 1 781 0
 2185 0630 81B3      		in r24,0x11
 2186 0632 886F      		ori r24,lo8(-8)
 2187 0634 81BB      		out 0x11,r24
 782:setup.c       **** 	DDRE |= (1<<CS2_PIN) | (1<<LED_3V);
 2188               		.loc 1 782 0
 2189 0636 86B1      		in r24,0x6
 2190 0638 8560      		ori r24,lo8(5)
 2191 063a 86B9      		out 0x6,r24
 783:setup.c       **** 	
 784:setup.c       **** 	// Set all pins as inputs
 785:setup.c       **** 	PORT_DATA7_0 = 0;
 2192               		.loc 1 785 0
 2193 063c 15BA      		out 0x15,__zero_reg__
 786:setup.c       **** 	DDR_DATA7_0 = 0;
 2194               		.loc 1 786 0
 2195 063e 14BA      		out 0x14,__zero_reg__
 787:setup.c       **** 	PORT_ADDR7_0 = 0;
 2196               		.loc 1 787 0
 2197 0640 18BA      		out 0x18,__zero_reg__
 788:setup.c       **** 	DDR_ADDR7_0 = 0;
 2198               		.loc 1 788 0
 2199 0642 17BA      		out 0x17,__zero_reg__
 789:setup.c       **** 	PORT_ADDR15_8 = 0;
 2200               		.loc 1 789 0
 2201 0644 1BBA      		out 0x1b,__zero_reg__
 790:setup.c       **** 	DDR_ADDR15_8 = 0;
 2202               		.loc 1 790 0
 2203 0646 1ABA      		out 0x1a,__zero_reg__
 791:setup.c       **** 	
 792:setup.c       **** 	// Light up 3.3V or 5V
 793:setup.c       **** 	if (PIND & (1<<SWITCH_DETECT)) {
 2204               		.loc 1 793 0
 2205 0648 829B      		sbis 0x10,2
 2206 064a 00C0      		rjmp .L94
 794:setup.c       **** 		PORTD |= (1<<LED_5V);
 2207               		.loc 1 794 0
 2208 064c 979A      		sbi 0x12,7
 795:setup.c       **** 		PORTE &= ~(1<<LED_3V);
 2209               		.loc 1 795 0
 2210 064e 3898      		cbi 0x7,0
 2211 0650 00C0      		rjmp .L95
 2212               	.L94:
 796:setup.c       **** 	}
 797:setup.c       **** 	else {
 798:setup.c       **** 		PORTE |= (1<<LED_3V);
 2213               		.loc 1 798 0
 2214 0652 389A      		sbi 0x7,0
 799:setup.c       **** 		PORTD &= ~(1<<LED_5V);
 2215               		.loc 1 799 0
 2216 0654 9798      		cbi 0x12,7
 2217               	.L95:
 800:setup.c       **** 	}
 801:setup.c       **** 	
 802:setup.c       **** 	// Light LED
 803:setup.c       **** 	PORTD |= (1<<ACTIVITY_LED);
 2218               		.loc 1 803 0
 2219 0656 939A      		sbi 0x12,3
 2220               	.LVL194:
 2221               	.LBB106:
 2222               	.LBB107:
 187:c:\winavr-20100110\avr\include\util\delay.h **** 
 2223               		.loc 2 187 0
 2224 0658 2FEF      		ldi r18,lo8(799999)
 2225 065a 84E3      		ldi r24,hi8(799999)
 2226 065c 9CE0      		ldi r25,hlo8(799999)
 2227 065e 2150      	1:	subi r18,1
 2228 0660 8040      		sbci r24,0
 2229 0662 9040      		sbci r25,0
 2230 0664 01F4      		brne 1b
 2231 0666 00C0      		rjmp .
 2232 0668 0000      		nop
 2233               	.LVL195:
 2234               	.LBE107:
 2235               	.LBE106:
 804:setup.c       **** 	_delay_ms(500);
 805:setup.c       **** 	PORTD &= ~(1<<ACTIVITY_LED);
 2236               		.loc 1 805 0
 2237 066a 9398      		cbi 0x12,3
 806:setup.c       **** 	
 807:setup.c       **** 	// Setup USART
 808:setup.c       **** 	UBRRL = 0; // 1Mbps Baud rate
 2238               		.loc 1 808 0
 2239 066c 19B8      		out 0x9,__zero_reg__
 809:setup.c       **** 	sbi(UCSRA, U2X); // Double rate
 2240               		.loc 1 809 0
 2241 066e 599A      		sbi 0xb,1
 810:setup.c       **** 	sbi(UCSRB, TXEN); // Transmitter enable
 2242               		.loc 1 810 0
 2243 0670 539A      		sbi 0xa,3
 811:setup.c       **** 	sbi(UCSRB, RXEN); // Receiver enable
 2244               		.loc 1 811 0
 2245 0672 549A      		sbi 0xa,4
 812:setup.c       **** 	
 813:setup.c       **** 	// Turn on interrupts
 814:setup.c       **** 	sei();
 2246               		.loc 1 814 0
 2247               	/* #APP */
 2248               	 ;  814 "setup.c" 1
 2249 0674 7894      		sei
 2250               	 ;  0 "" 2
 2251               	/* #NOAPP */
 2252 0676 0895      		ret
 2253               		.cfi_endproc
 2254               	.LFE46:
 2256               		.section	.text.startup,"ax",@progbits
 2257               	.global	main
 2259               	main:
 2260               	.LFB47:
 2261               		.file 3 "main.c"
   1:main.c        **** /*
   2:main.c        ****  GBxCart RW
   3:main.c        ****  PCB version: 1.1 or 1.2
   4:main.c        ****  Firmware version: R7
   5:main.c        ****  Author: Alex from insideGadgets (www.insidegadgets.com)
   6:main.c        ****  Created: 7/11/2016
   7:main.c        ****  Last Modified: 17/01/2018
   8:main.c        ****  
   9:main.c        ****  GBxCart RW allows you to dump your Gameboy/Gameboy Colour/Gameboy Advance games ROM, save the RAM 
  10:main.c        ****  
  11:main.c        ****  The ATmega8515L talks to the cartridge and interfaces with the CH340G serial to USB converter with
  12:main.c        ****  
  13:main.c        ****  
  14:main.c        ****  Set fuse bits: External 8MHz crystal, divide clock by 8 is off, boot loader is on (512 bytes), BOD
  15:main.c        ****  avrdude -p atmega8515 -c usbasp -U lfuse:w:0xaf:m -U hfuse:w:0xda:m
  16:main.c        ****  
  17:main.c        ****  Program the TinySafeBoot boot loader (modified ASM code, watchdog reset will act as a hardware res
  18:main.c        ****  avrdude -p atmega8515 -c usbasp -U flash:w:GBxCart_RW_v1.1_Rx\tsb\tsb_m8515_d0d1_resetwdt.hex
  19:main.c        ****  
  20:main.c        ****  Program GBxCart RW through TinySafeBoot
  21:main.c        ****  tsb com16:57600 fw GBxCart_RW_v1.1_Rx\main.hex
  22:main.c        ****  
  23:main.c        ****  Set TinySafeBoot delay time to 25 (T 25), gives ~0.5s in bootloader
  24:main.c        ****  tsb com16:9600 T 25
  25:main.c        ****  
  26:main.c        ****  
  27:main.c        ****  Programming shortcuts (if added in Programmers Notepad):
  28:main.c        ****  Alt + W - Program fuse
  29:main.c        ****  Alt + B - Burn bootloader
  30:main.c        ****  
  31:main.c        ****  Plug in USB then
  32:main.c        ****  Alt + T - Program
  33:main.c        ****  Alt + N - Program delay settings
  34:main.c        ****  
  35:main.c        ****  
  36:main.c        ****  */
  37:main.c        **** 
  38:main.c        **** // ATmega8515L Pin Map
  39:main.c        **** //
  40:main.c        **** // VCC (5)			GND (6)			XTAL (7 ,8)		Activity LED PD3 (9)				Switch sense PD2 (8)
  41:main.c        **** // SCK PB7 (3)		MOSI PB5 (1)	MISO PB6 (2)	RST (4)		RXD PD0 (5)			TXD PD1 (7)
  42:main.c        **** // 
  43:main.c        **** // Gameboy / Gameboy Colour
  44:main.c        **** // A0-A7 PB0-7 (40-44, 1-3) 		A8-A15 PA0-7 (37-30)			D0-D7 PC0-7 (18-25)		Audio PE1 (27)
  45:main.c        **** // 
  46:main.c        **** // Gameboy Advance
  47:main.c        **** // AD0-AD7 PB0-7 (40-44, 1-3) 	AD8-AD15 PA0-7 (37-30)		A16-23 / D0-D7 PC0-7 (19-26)
  48:main.c        **** // *WR PD6 (13)						*RD PD5 (14)					*MREQ/CS PD4 (15)			CS2/RST PE2 (16)
  49:main.c        **** 
  50:main.c        **** #define F_CPU 8000000 // 8 MHz
  51:main.c        **** #define PCB_VERSION 2
  52:main.c        **** #define FIRMWARE_VERSION 7
  53:main.c        **** 
  54:main.c        **** #include <avr/io.h>
  55:main.c        **** #include <avr/wdt.h>
  56:main.c        **** #include <avr/eeprom.h>
  57:main.c        **** #include <avr/interrupt.h>
  58:main.c        **** #include <avr/sleep.h>
  59:main.c        **** #include <util/delay.h>
  60:main.c        **** #include <stdlib.h>
  61:main.c        **** #include <string.h>
  62:main.c        **** #include "setup.c" // See defines, variables, constants, functions here
  63:main.c        **** 
  64:main.c        **** 
  65:main.c        **** int main(void) {
 2262               		.loc 3 65 0
 2263               		.cfi_startproc
 2264               	/* prologue: function */
 2265               	/* frame size = 0 */
 2266               	/* stack size = 0 */
 2267               	.L__stack_usage = 0
  66:main.c        **** 	setup();
 2268               		.loc 3 66 0
 2269 0000 00D0      		rcall setup
 2270               	.LVL196:
  67:main.c        **** 	
  68:main.c        **** 	uint32_t address = 0;
  69:main.c        **** 	uint8_t eepromSize = EEPROM_4KBIT;
  70:main.c        **** 	uint8_t cartMode = GB_MODE;
  71:main.c        **** 	uint8_t resetCommonLines = 1;
 2271               		.loc 3 71 0
 2272 0002 8824      		clr r8
 2273 0004 8394      		inc r8
  69:main.c        **** 	uint8_t cartMode = GB_MODE;
 2274               		.loc 3 69 0
 2275 0006 9924      		clr r9
 2276 0008 9394      		inc r9
  68:main.c        **** 	uint8_t eepromSize = EEPROM_4KBIT;
 2277               		.loc 3 68 0
 2278 000a C12C      		mov r12,__zero_reg__
 2279 000c D12C      		mov r13,__zero_reg__
 2280 000e 7601      		movw r14,r12
 2281 0010 20E0      		ldi r18,lo8(receivedBuffer+64)
 2282 0012 622E      		mov r6,r18
 2283 0014 20E0      		ldi r18,hi8(receivedBuffer+64)
 2284 0016 722E      		mov r7,r18
 2285 0018 30E0      		ldi r19,lo8(eepromBuffer+8)
 2286 001a A32E      		mov r10,r19
 2287 001c 30E0      		ldi r19,hi8(eepromBuffer+8)
 2288 001e B32E      		mov r11,r19
 2289               	.LVL197:
 2290               	.L97:
  72:main.c        **** 	
  73:main.c        **** 	while(1) {
  74:main.c        **** 		if (resetCommonLines == 1) {
 2291               		.loc 3 74 0
 2292 0020 21E0      		ldi r18,lo8(1)
 2293 0022 8212      		cpse r8,r18
 2294 0024 00C0      		rjmp .L98
 2295               	.LVL198:
 2296               	.L197:
  75:main.c        **** 			rd_wr_csmreq_cs2_reset();
 2297               		.loc 3 75 0
 2298 0026 00D0      		rcall rd_wr_csmreq_cs2_reset
 2299               	.LVL199:
 2300               	.L98:
  76:main.c        **** 		}
  77:main.c        **** 		receivedChar = USART_Receive(); // Wait for 1 byte of data
 2301               		.loc 3 77 0
 2302 0028 00D0      		rcall USART_Receive
 2303               	.LVL200:
 2304 002a 8093 0000 		sts receivedChar,r24
  78:main.c        **** 		
  79:main.c        **** 		// Read the pin to find out which mode we are in, if it reads high, we are powered by 5V
  80:main.c        **** 		if (PIND & (1<<SWITCH_DETECT)) {
 2305               		.loc 3 80 0
 2306 002e 829B      		sbis 0x10,2
 2307 0030 00C0      		rjmp .L99
 2308               	.LVL201:
  81:main.c        **** 			cartMode = GB_MODE;
  82:main.c        **** 			PORTD |= (1<<LED_5V);
 2309               		.loc 3 82 0
 2310 0032 979A      		sbi 0x12,7
  83:main.c        **** 			PORTE &= ~(1<<LED_3V);
 2311               		.loc 3 83 0
 2312 0034 3898      		cbi 0x7,0
  81:main.c        **** 			cartMode = GB_MODE;
 2313               		.loc 3 81 0
 2314 0036 81E0      		ldi r24,lo8(1)
 2315 0038 00C0      		rjmp .L100
 2316               	.LVL202:
 2317               	.L99:
  84:main.c        **** 		}
  85:main.c        **** 		else {
  86:main.c        **** 			cartMode = GBA_MODE;
  87:main.c        **** 			PORTE |= (1<<LED_3V);
 2318               		.loc 3 87 0
 2319 003a 389A      		sbi 0x7,0
  88:main.c        **** 			PORTD &= ~(1<<LED_5V);
 2320               		.loc 3 88 0
 2321 003c 9798      		cbi 0x12,7
  86:main.c        **** 			PORTE |= (1<<LED_3V);
 2322               		.loc 3 86 0
 2323 003e 82E0      		ldi r24,lo8(2)
 2324               	.LVL203:
 2325               	.L100:
  89:main.c        **** 		}
  90:main.c        **** 		
  91:main.c        **** 		// Return the cart mode in use
  92:main.c        **** 		if (receivedChar == CART_MODE) {
 2326               		.loc 3 92 0
 2327 0040 9091 0000 		lds r25,receivedChar
 2328 0044 9334      		cpi r25,lo8(67)
 2329 0046 01F4      		brne .+2
 2330 0048 00C0      		rjmp .L198
  93:main.c        **** 			USART_Transmit(cartMode);
  94:main.c        **** 		}
  95:main.c        **** 		
  96:main.c        **** 		// Change to GB mode or GBA mode if requested
  97:main.c        **** 		else if (receivedChar == GB_CART_MODE) {
 2331               		.loc 3 97 0
 2332 004a 9734      		cpi r25,lo8(71)
 2333 004c 01F4      		brne .L103
  98:main.c        **** 			gb_mode();
 2334               		.loc 3 98 0
 2335 004e 00D0      		rcall gb_mode
 2336               	.LVL204:
 2337 0050 00C0      		rjmp .L97
 2338               	.LVL205:
 2339               	.L103:
  99:main.c        **** 		}
 100:main.c        **** 		else if (receivedChar == GBA_CART_MODE) {
 2340               		.loc 3 100 0
 2341 0052 9736      		cpi r25,lo8(103)
 2342 0054 01F4      		brne .+2
 2343 0056 00C0      		rjmp .L200
 101:main.c        **** 			gba_mode();
 102:main.c        **** 		}
 103:main.c        **** 		
 104:main.c        **** 		// Set address
 105:main.c        **** 		else if (receivedChar == SET_START_ADDRESS) {
 2344               		.loc 3 105 0
 2345 0058 9134      		cpi r25,lo8(65)
 2346 005a 01F4      		brne .L105
 106:main.c        **** 			usart_read_chars(); // Read start address
 2347               		.loc 3 106 0
 2348 005c 00D0      		rcall usart_read_chars
 2349               	.LVL206:
 107:main.c        **** 			address = strtol(receivedBuffer, NULL, 16); // Convert address string in hex to dec
 2350               		.loc 3 107 0
 2351 005e 40E1      		ldi r20,lo8(16)
 2352 0060 50E0      		ldi r21,0
 2353 0062 60E0      		ldi r22,0
 2354 0064 70E0      		ldi r23,0
 2355 0066 80E0      		ldi r24,lo8(receivedBuffer)
 2356 0068 90E0      		ldi r25,hi8(receivedBuffer)
 2357 006a 00D0      		rcall strtol
 2358               	.LVL207:
 2359 006c 6B01      		movw r12,r22
 2360 006e 7C01      		movw r14,r24
 2361               	.LVL208:
 2362 0070 00C0      		rjmp .L97
 2363               	.LVL209:
 2364               	.L105:
 108:main.c        **** 		}
 109:main.c        **** 		
 110:main.c        **** 		
 111:main.c        **** 		// ****** Gameboy / Gameboy Colour ******
 112:main.c        **** 		
 113:main.c        **** 		// Read 64 bytes of ROM/RAM from address (and increment) until anything but 1 is received
 114:main.c        **** 		else if (receivedChar == READ_ROM_RAM) {
 2365               		.loc 3 114 0
 2366 0072 9235      		cpi r25,lo8(82)
 2367 0074 01F4      		brne .L106
 115:main.c        **** 			gb_mode();
 2368               		.loc 3 115 0
 2369 0076 00D0      		rcall gb_mode
 2370               	.LVL210:
 116:main.c        **** 			receivedChar = '1';
 2371               		.loc 3 116 0
 2372 0078 81E3      		ldi r24,lo8(49)
 2373               	.LVL211:
 2374               	.L203:
 117:main.c        **** 			while (receivedChar == '1') {
 118:main.c        **** 				PORTD |= (1<<ACTIVITY_LED);
 119:main.c        **** 				for (uint8_t x = 0; x < 64; x++) {
 120:main.c        **** 					USART_Transmit(read_8bit_data(address));
 121:main.c        **** 					address++;
 122:main.c        **** 				}
 123:main.c        **** 				
 124:main.c        **** 				PORTD &= ~(1<<ACTIVITY_LED);
 125:main.c        **** 				receivedChar = USART_Receive();
 2375               		.loc 3 125 0
 2376 007a 8093 0000 		sts receivedChar,r24
 2377               	.LVL212:
 117:main.c        **** 			while (receivedChar == '1') {
 2378               		.loc 3 117 0
 2379 007e 8091 0000 		lds r24,receivedChar
 2380 0082 8133      		cpi r24,lo8(49)
 2381 0084 01F4      		brne .L97
 118:main.c        **** 				for (uint8_t x = 0; x < 64; x++) {
 2382               		.loc 3 118 0
 2383 0086 939A      		sbi 0x12,3
 2384               	.LVL213:
 2385 0088 C0E0      		ldi r28,0
 2386 008a D0E0      		ldi r29,0
 2387               	.LVL214:
 2388               	.L108:
 2389               	.LBB108:
 120:main.c        **** 					address++;
 2390               		.loc 3 120 0 discriminator 3
 2391 008c CE01      		movw r24,r28
 2392 008e 8C0D      		add r24,r12
 2393 0090 9D1D      		adc r25,r13
 2394 0092 00D0      		rcall read_8bit_data
 2395               	.LVL215:
 2396 0094 00D0      		rcall USART_Transmit
 2397               	.LVL216:
 2398 0096 2196      		adiw r28,1
 2399               	.LVL217:
 119:main.c        **** 					USART_Transmit(read_8bit_data(address));
 2400               		.loc 3 119 0 discriminator 3
 2401 0098 C034      		cpi r28,64
 2402 009a D105      		cpc r29,__zero_reg__
 2403 009c 01F4      		brne .L108
 2404 009e 80E4      		ldi r24,64
 2405 00a0 C80E      		add r12,r24
 2406 00a2 D11C      		adc r13,__zero_reg__
 2407 00a4 E11C      		adc r14,__zero_reg__
 2408 00a6 F11C      		adc r15,__zero_reg__
 2409               	.LBE108:
 124:main.c        **** 				receivedChar = USART_Receive();
 2410               		.loc 3 124 0
 2411 00a8 9398      		cbi 0x12,3
 2412               		.loc 3 125 0
 2413 00aa 00D0      		rcall USART_Receive
 2414               	.LVL218:
 2415 00ac 00C0      		rjmp .L203
 2416               	.LVL219:
 2417               	.L106:
 126:main.c        **** 			}
 127:main.c        **** 		}
 128:main.c        **** 		
 129:main.c        **** 		// Write 64 bytes to RAM on address (and increment)
 130:main.c        **** 		else if (receivedChar == WRITE_RAM) {
 2418               		.loc 3 130 0
 2419 00ae 9735      		cpi r25,lo8(87)
 2420 00b0 01F4      		brne .L110
 131:main.c        **** 			gb_mode();
 2421               		.loc 3 131 0
 2422 00b2 00D0      		rcall gb_mode
 2423               	.LVL220:
 132:main.c        **** 			
 133:main.c        **** 			// Read 64 bytes first as CH340G sends them all at once
 134:main.c        **** 			usart_read_bytes(64);
 2424               		.loc 3 134 0
 2425 00b4 80E4      		ldi r24,lo8(64)
 2426 00b6 00D0      		rcall usart_read_bytes
 2427               	.LVL221:
 135:main.c        **** 			
 136:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 2428               		.loc 3 136 0
 2429 00b8 939A      		sbi 0x12,3
 2430               	.LVL222:
 2431 00ba C0E0      		ldi r28,lo8(receivedBuffer)
 2432 00bc D0E0      		ldi r29,hi8(receivedBuffer)
 2433 00be 00E0      		ldi r16,0
 2434 00c0 10E0      		ldi r17,0
 2435               	.LVL223:
 2436               	.L111:
 2437               	.LBB109:
 137:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 138:main.c        **** 				write_8bit_data(address, receivedBuffer[x], MEMORY_WRITE);
 2438               		.loc 3 138 0 discriminator 3
 2439 00c2 6991      		ld r22,Y+
 2440 00c4 C801      		movw r24,r16
 2441 00c6 8C0D      		add r24,r12
 2442 00c8 9D1D      		adc r25,r13
 2443 00ca 41E0      		ldi r20,lo8(1)
 2444 00cc 00D0      		rcall write_8bit_data
 2445               	.LVL224:
 2446 00ce 0F5F      		subi r16,-1
 2447 00d0 1F4F      		sbci r17,-1
 2448               	.LVL225:
 137:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 2449               		.loc 3 137 0 discriminator 3
 2450 00d2 0034      		cpi r16,64
 2451 00d4 1105      		cpc r17,__zero_reg__
 2452 00d6 01F4      		brne .L111
 2453 00d8 90E4      		ldi r25,64
 2454 00da C90E      		add r12,r25
 2455 00dc D11C      		adc r13,__zero_reg__
 2456 00de E11C      		adc r14,__zero_reg__
 2457 00e0 F11C      		adc r15,__zero_reg__
 2458 00e2 00C0      		rjmp .L221
 2459               	.LVL226:
 2460               	.L110:
 2461               	.LBE109:
 139:main.c        **** 				address++;
 140:main.c        **** 			}
 141:main.c        **** 			
 142:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 143:main.c        **** 			USART_Transmit('1'); // Send back acknowledgement
 144:main.c        **** 		}
 145:main.c        **** 		
 146:main.c        **** 		// Set bank address and write a byte
 147:main.c        **** 		else if (receivedChar == SET_BANK) {
 2462               		.loc 3 147 0
 2463 00e4 9234      		cpi r25,lo8(66)
 2464 00e6 01F4      		brne .L112
 2465               	.LBB110:
 148:main.c        **** 			gb_mode();
 2466               		.loc 3 148 0
 2467 00e8 00D0      		rcall gb_mode
 2468               	.LVL227:
 149:main.c        **** 			
 150:main.c        **** 			usart_read_chars(); // Read start address
 2469               		.loc 3 150 0
 2470 00ea 00D0      		rcall usart_read_chars
 2471               	.LVL228:
 151:main.c        **** 			uint16_t bankaddress = strtol(receivedBuffer, NULL, 16); // Convert address string in hex to dec
 2472               		.loc 3 151 0
 2473 00ec 40E1      		ldi r20,lo8(16)
 2474 00ee 50E0      		ldi r21,0
 2475 00f0 60E0      		ldi r22,0
 2476 00f2 70E0      		ldi r23,0
 2477 00f4 80E0      		ldi r24,lo8(receivedBuffer)
 2478 00f6 90E0      		ldi r25,hi8(receivedBuffer)
 2479 00f8 00D0      		rcall strtol
 2480               	.LVL229:
 2481 00fa 1B01      		movw r2,r22
 2482 00fc 2C01      		movw r4,r24
 2483               	.LVL230:
 152:main.c        **** 			
 153:main.c        **** 			receivedChar = USART_Receive(); // Wait for bank number
 2484               		.loc 3 153 0
 2485 00fe 00D0      		rcall USART_Receive
 2486               	.LVL231:
 2487 0100 8093 0000 		sts receivedChar,r24
 154:main.c        **** 			if (receivedChar == 'B') {
 2488               		.loc 3 154 0
 2489 0104 8234      		cpi r24,lo8(66)
 2490 0106 01F0      		breq .+2
 2491 0108 00C0      		rjmp .L97
 2492               	.LBB111:
 155:main.c        **** 				usart_read_chars(); // Read data
 2493               		.loc 3 155 0
 2494 010a 00D0      		rcall usart_read_chars
 2495               	.LVL232:
 156:main.c        **** 				uint8_t data = atoi(receivedBuffer); // Convert data string to dec
 2496               		.loc 3 156 0
 2497 010c 80E0      		ldi r24,lo8(receivedBuffer)
 2498 010e 90E0      		ldi r25,hi8(receivedBuffer)
 2499 0110 00D0      		rcall atoi
 2500               	.LVL233:
 157:main.c        **** 				
 158:main.c        **** 				write_8bit_data(bankaddress, data, BANK_WRITE);
 2501               		.loc 3 158 0
 2502 0112 40E0      		ldi r20,0
 2503 0114 682F      		mov r22,r24
 2504 0116 C101      		movw r24,r2
 2505               	.LVL234:
 2506 0118 00D0      		rcall write_8bit_data
 2507               	.LVL235:
 2508 011a 00C0      		rjmp .L97
 2509               	.LVL236:
 2510               	.L112:
 2511               	.LBE111:
 2512               	.LBE110:
 159:main.c        **** 			}
 160:main.c        **** 		}
 161:main.c        **** 		
 162:main.c        **** 		
 163:main.c        **** 		// ****** Gameboy Advance ******
 164:main.c        **** 		
 165:main.c        **** 		// ---------- ROM ----------
 166:main.c        **** 		// Read one 16bit byte from ROM using address (and increment) until anything but 1 is received
 167:main.c        **** 		else if (receivedChar == GBA_READ_ROM) {
 2513               		.loc 3 167 0
 2514 011c 9237      		cpi r25,lo8(114)
 2515 011e 01F4      		brne .L113
 168:main.c        **** 			gba_mode(); 
 2516               		.loc 3 168 0
 2517 0120 00D0      		rcall gba_mode
 2518               	.LVL237:
 169:main.c        **** 			
 170:main.c        **** 			receivedChar = '1';
 2519               		.loc 3 170 0
 2520 0122 81E3      		ldi r24,lo8(49)
 2521               	.LVL238:
 2522               	.L204:
 171:main.c        **** 			while (receivedChar == '1') {
 172:main.c        **** 				PORTD |= (1<<ACTIVITY_LED);
 173:main.c        **** 				for (uint8_t x = 0; x < 32; x++) {
 174:main.c        **** 					uint16_t dataRead = gba_read_16bit_data(address);
 175:main.c        **** 					
 176:main.c        **** 					// Low byte & High byte
 177:main.c        **** 					USART_Transmit(dataRead & 0xFF);
 178:main.c        **** 					USART_Transmit(dataRead >> 8);
 179:main.c        **** 					
 180:main.c        **** 					address++;
 181:main.c        **** 				}
 182:main.c        **** 				
 183:main.c        **** 				PORTD &= ~(1<<ACTIVITY_LED);
 184:main.c        **** 				receivedChar = USART_Receive();
 2523               		.loc 3 184 0
 2524 0124 8093 0000 		sts receivedChar,r24
 2525               	.LVL239:
 171:main.c        **** 			while (receivedChar == '1') {
 2526               		.loc 3 171 0
 2527 0128 8091 0000 		lds r24,receivedChar
 2528 012c 8133      		cpi r24,lo8(49)
 2529 012e 01F0      		breq .+2
 2530 0130 00C0      		rjmp .L97
 172:main.c        **** 				for (uint8_t x = 0; x < 32; x++) {
 2531               		.loc 3 172 0
 2532 0132 939A      		sbi 0x12,3
 2533               	.LVL240:
 2534 0134 1601      		movw r2,r12
 2535 0136 2701      		movw r4,r14
 2536               	.LBB112:
 173:main.c        **** 					uint16_t dataRead = gba_read_16bit_data(address);
 2537               		.loc 3 173 0
 2538 0138 C0E0      		ldi r28,0
 2539               	.LVL241:
 2540               	.L115:
 2541               	.LBB113:
 174:main.c        **** 					
 2542               		.loc 3 174 0 discriminator 3
 2543 013a C201      		movw r24,r4
 2544 013c B101      		movw r22,r2
 2545 013e 00D0      		rcall gba_read_16bit_data
 2546               	.LVL242:
 2547 0140 D92F      		mov r29,r25
 2548               	.LVL243:
 177:main.c        **** 					USART_Transmit(dataRead >> 8);
 2549               		.loc 3 177 0 discriminator 3
 2550 0142 00D0      		rcall USART_Transmit
 2551               	.LVL244:
 178:main.c        **** 					
 2552               		.loc 3 178 0 discriminator 3
 2553 0144 8D2F      		mov r24,r29
 2554 0146 00D0      		rcall USART_Transmit
 2555               	.LVL245:
 180:main.c        **** 				}
 2556               		.loc 3 180 0 discriminator 3
 2557 0148 EFEF      		ldi r30,-1
 2558 014a 2E1A      		sub r2,r30
 2559 014c 3E0A      		sbc r3,r30
 2560 014e 4E0A      		sbc r4,r30
 2561 0150 5E0A      		sbc r5,r30
 2562               	.LVL246:
 2563               	.LBE113:
 173:main.c        **** 					uint16_t dataRead = gba_read_16bit_data(address);
 2564               		.loc 3 173 0 discriminator 3
 2565 0152 CF5F      		subi r28,lo8(-(1))
 2566               	.LVL247:
 2567 0154 C032      		cpi r28,lo8(32)
 2568 0156 01F4      		brne .L115
 2569 0158 F0E2      		ldi r31,32
 2570 015a CF0E      		add r12,r31
 2571 015c D11C      		adc r13,__zero_reg__
 2572 015e E11C      		adc r14,__zero_reg__
 2573 0160 F11C      		adc r15,__zero_reg__
 2574               	.LBE112:
 183:main.c        **** 				receivedChar = USART_Receive();
 2575               		.loc 3 183 0
 2576 0162 9398      		cbi 0x12,3
 2577               		.loc 3 184 0
 2578 0164 00D0      		rcall USART_Receive
 2579               	.LVL248:
 2580 0166 00C0      		rjmp .L204
 2581               	.LVL249:
 2582               	.L113:
 185:main.c        **** 			}
 186:main.c        **** 		}
 187:main.c        **** 		
 188:main.c        **** 		
 189:main.c        **** 		// ---------- SRAM ----------
 190:main.c        **** 		// Read RAM from address (and increment) until anything but 1 is received
 191:main.c        **** 		else if (receivedChar == GBA_READ_SRAM) {
 2583               		.loc 3 191 0
 2584 0168 9D36      		cpi r25,lo8(109)
 2585 016a 01F4      		brne .L117
 192:main.c        **** 			gb_mode(); // Set GB mode as it uses 16 bit address with 8 bit data
 2586               		.loc 3 192 0
 2587 016c 00D0      		rcall gb_mode
 2588               	.LVL250:
 193:main.c        **** 			
 194:main.c        **** 			receivedChar = '1';
 2589               		.loc 3 194 0
 2590 016e 81E3      		ldi r24,lo8(49)
 2591               	.LVL251:
 2592               	.L205:
 195:main.c        **** 			while (receivedChar == '1') {
 196:main.c        **** 				PORTD |= (1<<ACTIVITY_LED);
 197:main.c        **** 				for (uint8_t x = 0; x < 64; x++) {
 198:main.c        **** 					USART_Transmit(gba_read_ram_8bit_data(address));
 199:main.c        **** 					address++;
 200:main.c        **** 				}
 201:main.c        **** 				
 202:main.c        **** 				PORTD &= ~(1<<ACTIVITY_LED);
 203:main.c        **** 				receivedChar = USART_Receive();
 2593               		.loc 3 203 0
 2594 0170 8093 0000 		sts receivedChar,r24
 2595               	.LVL252:
 195:main.c        **** 			while (receivedChar == '1') {
 2596               		.loc 3 195 0
 2597 0174 8091 0000 		lds r24,receivedChar
 2598 0178 8133      		cpi r24,lo8(49)
 2599 017a 01F4      		brne .L200
 196:main.c        **** 				for (uint8_t x = 0; x < 64; x++) {
 2600               		.loc 3 196 0
 2601 017c 939A      		sbi 0x12,3
 2602               	.LVL253:
 2603 017e C0E0      		ldi r28,0
 2604 0180 D0E0      		ldi r29,0
 2605               	.LVL254:
 2606               	.L119:
 2607               	.LBB114:
 198:main.c        **** 					address++;
 2608               		.loc 3 198 0 discriminator 3
 2609 0182 CE01      		movw r24,r28
 2610 0184 8C0D      		add r24,r12
 2611 0186 9D1D      		adc r25,r13
 2612 0188 00D0      		rcall gba_read_ram_8bit_data
 2613               	.LVL255:
 2614 018a 00D0      		rcall USART_Transmit
 2615               	.LVL256:
 2616 018c 2196      		adiw r28,1
 2617               	.LVL257:
 197:main.c        **** 					USART_Transmit(gba_read_ram_8bit_data(address));
 2618               		.loc 3 197 0 discriminator 3
 2619 018e C034      		cpi r28,64
 2620 0190 D105      		cpc r29,__zero_reg__
 2621 0192 01F4      		brne .L119
 2622 0194 20E4      		ldi r18,64
 2623 0196 C20E      		add r12,r18
 2624 0198 D11C      		adc r13,__zero_reg__
 2625 019a E11C      		adc r14,__zero_reg__
 2626 019c F11C      		adc r15,__zero_reg__
 2627               	.LBE114:
 202:main.c        **** 				receivedChar = USART_Receive();
 2628               		.loc 3 202 0
 2629 019e 9398      		cbi 0x12,3
 2630               		.loc 3 203 0
 2631 01a0 00D0      		rcall USART_Receive
 2632               	.LVL258:
 2633 01a2 00C0      		rjmp .L205
 2634               	.LVL259:
 2635               	.L117:
 204:main.c        **** 			}
 205:main.c        **** 			
 206:main.c        **** 			gba_mode(); // Set back
 207:main.c        **** 		}
 208:main.c        **** 		
 209:main.c        **** 		// Write to RAM on address (and increment) with 64 bytes of data
 210:main.c        **** 		else if (receivedChar == GBA_WRITE_SRAM) {
 2636               		.loc 3 210 0
 2637 01a4 9737      		cpi r25,lo8(119)
 2638 01a6 01F4      		brne .L121
 211:main.c        **** 			gb_mode();
 2639               		.loc 3 211 0
 2640 01a8 00D0      		rcall gb_mode
 2641               	.LVL260:
 212:main.c        **** 			
 213:main.c        **** 			usart_read_bytes(64);
 2642               		.loc 3 213 0
 2643 01aa 80E4      		ldi r24,lo8(64)
 2644 01ac 00D0      		rcall usart_read_bytes
 2645               	.LVL261:
 214:main.c        **** 			
 215:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 2646               		.loc 3 215 0
 2647 01ae 939A      		sbi 0x12,3
 2648               	.LVL262:
 2649 01b0 C0E0      		ldi r28,lo8(receivedBuffer)
 2650 01b2 D0E0      		ldi r29,hi8(receivedBuffer)
 2651 01b4 00E0      		ldi r16,0
 2652 01b6 10E0      		ldi r17,0
 2653               	.LVL263:
 2654               	.L122:
 2655               	.LBB115:
 216:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 217:main.c        **** 				gba_write_ram_8bit_data(address, receivedBuffer[x]);
 2656               		.loc 3 217 0 discriminator 3
 2657 01b8 6991      		ld r22,Y+
 2658 01ba C801      		movw r24,r16
 2659 01bc 8C0D      		add r24,r12
 2660 01be 9D1D      		adc r25,r13
 2661 01c0 00D0      		rcall gba_write_ram_8bit_data
 2662               	.LVL264:
 2663 01c2 0F5F      		subi r16,-1
 2664 01c4 1F4F      		sbci r17,-1
 2665               	.LVL265:
 216:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 2666               		.loc 3 216 0 discriminator 3
 2667 01c6 0034      		cpi r16,64
 2668 01c8 1105      		cpc r17,__zero_reg__
 2669 01ca 01F4      		brne .L122
 2670 01cc 80E4      		ldi r24,64
 2671 01ce C80E      		add r12,r24
 2672 01d0 D11C      		adc r13,__zero_reg__
 2673 01d2 E11C      		adc r14,__zero_reg__
 2674 01d4 F11C      		adc r15,__zero_reg__
 2675               	.LVL266:
 2676               	.L202:
 2677               	.LBE115:
 218:main.c        **** 				address++;
 219:main.c        **** 			}
 220:main.c        **** 			USART_Transmit('1'); // Send back acknowledgement
 2678               		.loc 3 220 0
 2679 01d6 81E3      		ldi r24,lo8(49)
 2680 01d8 00D0      		rcall USART_Transmit
 2681               	.LVL267:
 221:main.c        **** 			
 222:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 2682               		.loc 3 222 0
 2683 01da 9398      		cbi 0x12,3
 2684               	.L200:
 223:main.c        **** 			gba_mode(); // Set back
 2685               		.loc 3 223 0
 2686 01dc 00D0      		rcall gba_mode
 2687               	.LVL268:
 2688 01de 00C0      		rjmp .L97
 2689               	.LVL269:
 2690               	.L121:
 224:main.c        **** 		}
 225:main.c        **** 		
 226:main.c        **** 		// Write 1 byte to SRAM address
 227:main.c        **** 		else if (receivedChar == GBA_WRITE_ONE_BYTE_SRAM) {
 2691               		.loc 3 227 0
 2692 01e0 9F36      		cpi r25,lo8(111)
 2693 01e2 01F4      		brne .L123
 2694               	.LBB116:
 228:main.c        **** 			gb_mode();
 2695               		.loc 3 228 0
 2696 01e4 00D0      		rcall gb_mode
 2697               	.LVL270:
 229:main.c        **** 			
 230:main.c        **** 			uint8_t data = USART_Receive();
 2698               		.loc 3 230 0
 2699 01e6 00D0      		rcall USART_Receive
 2700               	.LVL271:
 231:main.c        **** 			gba_write_ram_8bit_data(address, data);
 2701               		.loc 3 231 0
 2702 01e8 682F      		mov r22,r24
 2703 01ea C601      		movw r24,r12
 2704               	.LVL272:
 2705 01ec 00D0      		rcall gba_write_ram_8bit_data
 2706               	.LVL273:
 2707 01ee 00C0      		rjmp .L207
 2708               	.LVL274:
 2709               	.L123:
 2710               	.LBE116:
 232:main.c        **** 			USART_Transmit('1'); // Send back acknowledgement
 233:main.c        **** 			
 234:main.c        **** 			gba_mode(); // Set back
 235:main.c        **** 		}
 236:main.c        **** 		
 237:main.c        **** 		
 238:main.c        **** 		// ---------- FLASH ----------
 239:main.c        **** 		// Read the Flash Manufacturer and Device ID
 240:main.c        **** 		else if (receivedChar == GBA_FLASH_READ_ID) {
 2711               		.loc 3 240 0
 2712 01f0 9936      		cpi r25,lo8(105)
 2713 01f2 01F4      		brne .L124
 241:main.c        **** 			gb_mode();
 2714               		.loc 3 241 0
 2715 01f4 00D0      		rcall gb_mode
 2716               	.LVL275:
 242:main.c        **** 			
 243:main.c        **** 			flash_read_chip_id();
 2717               		.loc 3 243 0
 2718 01f6 00D0      		rcall flash_read_chip_id
 2719               	.LVL276:
 244:main.c        **** 			USART_Transmit(flashChipIdBuffer[0]);
 2720               		.loc 3 244 0
 2721 01f8 8091 0000 		lds r24,flashChipIdBuffer
 2722 01fc 00D0      		rcall USART_Transmit
 2723               	.LVL277:
 245:main.c        **** 			USART_Transmit(flashChipIdBuffer[1]);
 2724               		.loc 3 245 0
 2725 01fe 8091 0000 		lds r24,flashChipIdBuffer+1
 2726               	.L206:
 2727 0202 00D0      		rcall USART_Transmit
 2728               	.LVL278:
 2729 0204 00C0      		rjmp .L200
 2730               	.LVL279:
 2731               	.L124:
 246:main.c        **** 			
 247:main.c        **** 			gba_mode(); // Set back
 248:main.c        **** 		}
 249:main.c        **** 		
 250:main.c        **** 		// Change bank
 251:main.c        **** 		else if (receivedChar == GBA_FLASH_SET_BANK) {
 2732               		.loc 3 251 0
 2733 0206 9B36      		cpi r25,lo8(107)
 2734 0208 01F4      		brne .L125
 2735               	.LBB117:
 252:main.c        **** 			usart_read_chars(); // Read data
 2736               		.loc 3 252 0
 2737 020a 00D0      		rcall usart_read_chars
 2738               	.LVL280:
 253:main.c        **** 			uint8_t bank = atoi(receivedBuffer); // Convert data string to dec
 2739               		.loc 3 253 0
 2740 020c 80E0      		ldi r24,lo8(receivedBuffer)
 2741 020e 90E0      		ldi r25,hi8(receivedBuffer)
 2742 0210 00D0      		rcall atoi
 2743               	.LVL281:
 2744 0212 C82F      		mov r28,r24
 2745               	.LVL282:
 254:main.c        **** 			
 255:main.c        **** 			gb_mode();
 2746               		.loc 3 255 0
 2747 0214 00D0      		rcall gb_mode
 2748               	.LVL283:
 256:main.c        **** 			flash_switch_bank(bank);
 2749               		.loc 3 256 0
 2750 0216 8C2F      		mov r24,r28
 2751 0218 00D0      		rcall flash_switch_bank
 2752               	.LVL284:
 2753 021a 00C0      		rjmp .L200
 2754               	.LVL285:
 2755               	.L125:
 2756               	.LBE117:
 257:main.c        **** 			
 258:main.c        **** 			gba_mode(); // Set back
 259:main.c        **** 		}
 260:main.c        **** 		
 261:main.c        **** 		// Erase 4K sector on Flash (sector 0 to 15 for 512Kbit)
 262:main.c        **** 		else if (receivedChar == GBA_FLASH_4K_SECTOR_ERASE) {
 2757               		.loc 3 262 0
 2758 021c 9337      		cpi r25,lo8(115)
 2759 021e 01F4      		brne .L126
 2760               	.LBB118:
 263:main.c        **** 			gb_mode();
 2761               		.loc 3 263 0
 2762 0220 00D0      		rcall gb_mode
 2763               	.LVL286:
 264:main.c        **** 			
 265:main.c        **** 			usart_read_chars(); // Read sector
 2764               		.loc 3 265 0
 2765 0222 00D0      		rcall usart_read_chars
 2766               	.LVL287:
 266:main.c        **** 			uint8_t sectorAddress = strtol(receivedBuffer, NULL, 16); // Convert address string in hex to de
 2767               		.loc 3 266 0
 2768 0224 40E1      		ldi r20,lo8(16)
 2769 0226 50E0      		ldi r21,0
 2770 0228 60E0      		ldi r22,0
 2771 022a 70E0      		ldi r23,0
 2772 022c 80E0      		ldi r24,lo8(receivedBuffer)
 2773 022e 90E0      		ldi r25,hi8(receivedBuffer)
 2774 0230 00D0      		rcall strtol
 2775               	.LVL288:
 2776 0232 862F      		mov r24,r22
 2777               	.LVL289:
 267:main.c        **** 			
 268:main.c        **** 			flash_erase_4k_sector(sectorAddress);
 2778               		.loc 3 268 0
 2779 0234 00D0      		rcall flash_erase_4k_sector
 2780               	.LVL290:
 2781               	.L207:
 269:main.c        **** 			USART_Transmit('1'); // Send back acknowledgement
 2782               		.loc 3 269 0
 2783 0236 81E3      		ldi r24,lo8(49)
 2784 0238 00C0      		rjmp .L206
 2785               	.LVL291:
 2786               	.L126:
 2787               	.LBE118:
 270:main.c        **** 			
 271:main.c        **** 			gba_mode(); // Set back
 272:main.c        **** 		}
 273:main.c        **** 		
 274:main.c        **** 		// Write 64 bytes to Flash address one byte write at a time (and increment)
 275:main.c        **** 		else if (receivedChar == GBA_FLASH_WRITE_BYTE) {
 2788               		.loc 3 275 0
 2789 023a 9236      		cpi r25,lo8(98)
 2790 023c 01F4      		brne .L127
 276:main.c        **** 			gb_mode();
 2791               		.loc 3 276 0
 2792 023e 00D0      		rcall gb_mode
 2793               	.LVL292:
 277:main.c        **** 			
 278:main.c        **** 			usart_read_bytes(64);
 2794               		.loc 3 278 0
 2795 0240 80E4      		ldi r24,lo8(64)
 2796 0242 00D0      		rcall usart_read_bytes
 2797               	.LVL293:
 279:main.c        **** 			
 280:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 2798               		.loc 3 280 0
 2799 0244 939A      		sbi 0x12,3
 2800               	.LVL294:
 2801 0246 00E0      		ldi r16,lo8(receivedBuffer)
 2802 0248 10E0      		ldi r17,hi8(receivedBuffer)
 2803 024a C0E0      		ldi r28,0
 2804 024c D0E0      		ldi r29,0
 2805               	.LVL295:
 2806               	.L128:
 2807               	.LBB119:
 281:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 282:main.c        **** 				flash_write_byte(address, receivedBuffer[x]);
 2808               		.loc 3 282 0 discriminator 3
 2809 024e F801      		movw r30,r16
 2810 0250 6191      		ld r22,Z+
 2811 0252 8F01      		movw r16,r30
 2812 0254 CE01      		movw r24,r28
 2813 0256 8C0D      		add r24,r12
 2814 0258 9D1D      		adc r25,r13
 2815 025a 00D0      		rcall flash_write_byte
 2816               	.LVL296:
 2817 025c 2196      		adiw r28,1
 2818               	.LVL297:
 281:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 2819               		.loc 3 281 0 discriminator 3
 2820 025e C034      		cpi r28,64
 2821 0260 D105      		cpc r29,__zero_reg__
 2822 0262 01F4      		brne .L128
 2823 0264 F0E4      		ldi r31,64
 2824 0266 CF0E      		add r12,r31
 2825 0268 D11C      		adc r13,__zero_reg__
 2826 026a E11C      		adc r14,__zero_reg__
 2827 026c F11C      		adc r15,__zero_reg__
 2828 026e 00C0      		rjmp .L202
 2829               	.LVL298:
 2830               	.L127:
 2831               	.LBE119:
 283:main.c        **** 				address++;
 284:main.c        **** 			}
 285:main.c        **** 			USART_Transmit('1'); // Send back acknowledgement
 286:main.c        **** 			
 287:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 288:main.c        **** 			gba_mode(); // Set back
 289:main.c        **** 		}
 290:main.c        **** 		
 291:main.c        **** 		// Write 128 bytes to flash sector for Atmel flash (and increment)
 292:main.c        **** 		else if (receivedChar == GBA_FLASH_WRITE_ATMEL) {
 2832               		.loc 3 292 0
 2833 0270 9136      		cpi r25,lo8(97)
 2834 0272 01F4      		brne .L129
 293:main.c        **** 			gb_mode();
 2835               		.loc 3 293 0
 2836 0274 00D0      		rcall gb_mode
 2837               	.LVL299:
 294:main.c        **** 			
 295:main.c        **** 			usart_read_bytes(128);
 2838               		.loc 3 295 0
 2839 0276 80E8      		ldi r24,lo8(-128)
 2840 0278 00D0      		rcall usart_read_bytes
 2841               	.LVL300:
 296:main.c        **** 			
 297:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 2842               		.loc 3 297 0
 2843 027a 939A      		sbi 0x12,3
 298:main.c        **** 			flash_write_sector(address); // Address used as sector number
 2844               		.loc 3 298 0
 2845 027c C601      		movw r24,r12
 2846 027e 00D0      		rcall flash_write_sector
 2847               	.LVL301:
 299:main.c        **** 			address++;
 2848               		.loc 3 299 0
 2849 0280 2FEF      		ldi r18,-1
 2850 0282 C21A      		sub r12,r18
 2851 0284 D20A      		sbc r13,r18
 2852 0286 E20A      		sbc r14,r18
 2853 0288 F20A      		sbc r15,r18
 2854               	.LVL302:
 2855 028a 00C0      		rjmp .L202
 2856               	.LVL303:
 2857               	.L129:
 300:main.c        **** 			USART_Transmit('1'); // Send back acknowledgement
 301:main.c        **** 			
 302:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 303:main.c        **** 			gba_mode(); // Set back
 304:main.c        **** 		}
 305:main.c        **** 		
 306:main.c        **** 		
 307:main.c        **** 		// ---------- EEPROM ----------
 308:main.c        **** 		// Set EEPROM size
 309:main.c        **** 		else if (receivedChar == GBA_SET_EEPROM_SIZE) {
 2858               		.loc 3 309 0
 2859 028c 9335      		cpi r25,lo8(83)
 2860 028e 01F4      		brne .L130
 310:main.c        **** 			usart_read_chars(); // Read size
 2861               		.loc 3 310 0
 2862 0290 00D0      		rcall usart_read_chars
 2863               	.LVL304:
 311:main.c        **** 			eepromSize = strtol(receivedBuffer, NULL, 16); // Convert size to dec
 2864               		.loc 3 311 0
 2865 0292 40E1      		ldi r20,lo8(16)
 2866 0294 50E0      		ldi r21,0
 2867 0296 60E0      		ldi r22,0
 2868 0298 70E0      		ldi r23,0
 2869 029a 80E0      		ldi r24,lo8(receivedBuffer)
 2870 029c 90E0      		ldi r25,hi8(receivedBuffer)
 2871 029e 00D0      		rcall strtol
 2872               	.LVL305:
 2873 02a0 962E      		mov r9,r22
 2874               	.LVL306:
 2875 02a2 00C0      		rjmp .L97
 2876               	.LVL307:
 2877               	.L130:
 312:main.c        **** 		}
 313:main.c        **** 		
 314:main.c        **** 		// Read the EEPROM on address (and increment) until anything but 1 is received
 315:main.c        **** 		else if (receivedChar == GBA_READ_EEPROM) {
 2878               		.loc 3 315 0
 2879 02a4 9536      		cpi r25,lo8(101)
 2880 02a6 01F4      		brne .L131
 316:main.c        **** 			gba_eeprom_mode();
 2881               		.loc 3 316 0
 2882 02a8 00D0      		rcall gba_eeprom_mode
 2883               	.LVL308:
 317:main.c        **** 			
 318:main.c        **** 			receivedChar = '1';
 2884               		.loc 3 318 0
 2885 02aa 81E3      		ldi r24,lo8(49)
 2886               	.L208:
 319:main.c        **** 			while (receivedChar == '1') {
 320:main.c        **** 				PORTD |= (1<<ACTIVITY_LED);
 321:main.c        **** 				gba_eeprom_read(address, eepromSize);
 322:main.c        **** 				
 323:main.c        **** 				// Send back the 8 bytes of data
 324:main.c        **** 				for (uint8_t c = 0; c < 8; c++) {
 325:main.c        **** 					USART_Transmit(eepromBuffer[c]);
 326:main.c        **** 				}
 327:main.c        **** 				address++; // Increment to next 8 bytes
 328:main.c        **** 				
 329:main.c        **** 				PORTD &= ~(1<<ACTIVITY_LED);
 330:main.c        **** 				receivedChar = USART_Receive();
 2887               		.loc 3 330 0
 2888 02ac 8093 0000 		sts receivedChar,r24
 319:main.c        **** 			while (receivedChar == '1') {
 2889               		.loc 3 319 0
 2890 02b0 8091 0000 		lds r24,receivedChar
 2891 02b4 8133      		cpi r24,lo8(49)
 2892 02b6 01F0      		breq .+2
 2893 02b8 00C0      		rjmp .L200
 320:main.c        **** 				gba_eeprom_read(address, eepromSize);
 2894               		.loc 3 320 0
 2895 02ba 939A      		sbi 0x12,3
 321:main.c        **** 				
 2896               		.loc 3 321 0
 2897 02bc 692D      		mov r22,r9
 2898 02be C601      		movw r24,r12
 2899 02c0 00D0      		rcall gba_eeprom_read
 2900               	.LVL309:
 2901 02c2 C0E0      		ldi r28,lo8(eepromBuffer)
 2902 02c4 D0E0      		ldi r29,hi8(eepromBuffer)
 2903               	.LVL310:
 2904               	.L133:
 2905               	.LBB120:
 325:main.c        **** 				}
 2906               		.loc 3 325 0 discriminator 3
 2907 02c6 8991      		ld r24,Y+
 2908               	.LVL311:
 2909 02c8 00D0      		rcall USART_Transmit
 2910               	.LVL312:
 324:main.c        **** 					USART_Transmit(eepromBuffer[c]);
 2911               		.loc 3 324 0 discriminator 3
 2912 02ca AC16      		cp r10,r28
 2913 02cc BD06      		cpc r11,r29
 2914 02ce 01F4      		brne .L133
 2915               	.LBE120:
 327:main.c        **** 				
 2916               		.loc 3 327 0
 2917 02d0 8FEF      		ldi r24,-1
 2918 02d2 C81A      		sub r12,r24
 2919 02d4 D80A      		sbc r13,r24
 2920 02d6 E80A      		sbc r14,r24
 2921 02d8 F80A      		sbc r15,r24
 2922               	.LVL313:
 329:main.c        **** 				receivedChar = USART_Receive();
 2923               		.loc 3 329 0
 2924 02da 9398      		cbi 0x12,3
 2925               		.loc 3 330 0
 2926 02dc 00D0      		rcall USART_Receive
 2927               	.LVL314:
 2928 02de 00C0      		rjmp .L208
 2929               	.LVL315:
 2930               	.L131:
 331:main.c        **** 			}
 332:main.c        **** 			
 333:main.c        **** 			gba_mode(); // Set back
 334:main.c        **** 		}
 335:main.c        **** 		
 336:main.c        **** 		// Write 8 bytes to the EEPROM address (and increment)
 337:main.c        **** 		else if (receivedChar == GBA_WRITE_EEPROM) {
 2931               		.loc 3 337 0
 2932 02e0 9037      		cpi r25,lo8(112)
 2933 02e2 01F4      		brne .L135
 338:main.c        **** 			gba_eeprom_mode();
 2934               		.loc 3 338 0
 2935 02e4 00D0      		rcall gba_eeprom_mode
 2936               	.LVL316:
 2937 02e6 C0E0      		ldi r28,lo8(eepromBuffer)
 2938 02e8 D0E0      		ldi r29,hi8(eepromBuffer)
 2939               	.LVL317:
 2940               	.L136:
 2941               	.LBB121:
 339:main.c        **** 			
 340:main.c        **** 			// Read 8 bytes from USART and place in buffer
 341:main.c        **** 			for (uint8_t x = 0; x < 8; x++) {
 342:main.c        **** 				eepromBuffer[x] = USART_Receive();
 2942               		.loc 3 342 0 discriminator 3
 2943 02ea 00D0      		rcall USART_Receive
 2944               	.LVL318:
 2945 02ec 8993      		st Y+,r24
 2946               	.LVL319:
 341:main.c        **** 				eepromBuffer[x] = USART_Receive();
 2947               		.loc 3 341 0 discriminator 3
 2948 02ee AC16      		cp r10,r28
 2949 02f0 BD06      		cpc r11,r29
 2950 02f2 01F4      		brne .L136
 2951               	.LBE121:
 343:main.c        **** 			}
 344:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 2952               		.loc 3 344 0
 2953 02f4 939A      		sbi 0x12,3
 345:main.c        **** 			
 346:main.c        **** 			gba_eeprom_write(address, eepromSize);
 2954               		.loc 3 346 0
 2955 02f6 692D      		mov r22,r9
 2956 02f8 C601      		movw r24,r12
 2957 02fa 00D0      		rcall gba_eeprom_write
 2958               	.LVL320:
 347:main.c        **** 			address++;
 2959               		.loc 3 347 0
 2960 02fc 9FEF      		ldi r25,-1
 2961 02fe C91A      		sub r12,r25
 2962 0300 D90A      		sbc r13,r25
 2963 0302 E90A      		sbc r14,r25
 2964 0304 F90A      		sbc r15,r25
 2965               	.LVL321:
 2966               	.LBB122:
 2967               	.LBB123:
 187:c:\winavr-20100110\avr\include\util\delay.h **** 
 2968               		.loc 2 187 0
 2969 0306 EFE7      		ldi r30,lo8(15999)
 2970 0308 FEE3      		ldi r31,hi8(15999)
 2971 030a 3197      	1:	sbiw r30,1
 2972 030c 01F4      		brne 1b
 2973 030e 00C0      		rjmp .
 2974 0310 0000      		nop
 2975               	.LVL322:
 2976 0312 00C0      		rjmp .L202
 2977               	.LVL323:
 2978               	.L135:
 2979               	.LBE123:
 2980               	.LBE122:
 348:main.c        **** 			
 349:main.c        **** 			_delay_ms(8); // Wait for EEPROM to write data (8ms)
 350:main.c        **** 			USART_Transmit('1'); // Send back acknowledgement
 351:main.c        **** 			
 352:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 353:main.c        **** 			gba_mode(); // Set back
 354:main.c        **** 		}
 355:main.c        **** 		
 356:main.c        **** 		
 357:main.c        **** 		// ---------- GB FLASH CARTS ----------
 358:main.c        **** 		// Write address, one byte and pulse a pin
 359:main.c        **** 		else if (receivedChar == GB_FLASH_WRITE_BYTE) {
 2981               		.loc 3 359 0
 2982 0314 9634      		cpi r25,lo8(70)
 2983 0316 01F4      		brne .L137
 2984               	.LBB124:
 360:main.c        **** 			usart_read_chars(); // Read address
 2985               		.loc 3 360 0
 2986 0318 00D0      		rcall usart_read_chars
 2987               	.LVL324:
 361:main.c        **** 			uint16_t flashAddress = strtol(receivedBuffer, NULL, 16); // Convert address string in hex to de
 2988               		.loc 3 361 0
 2989 031a 40E1      		ldi r20,lo8(16)
 2990 031c 50E0      		ldi r21,0
 2991 031e 60E0      		ldi r22,0
 2992 0320 70E0      		ldi r23,0
 2993 0322 80E0      		ldi r24,lo8(receivedBuffer)
 2994 0324 90E0      		ldi r25,hi8(receivedBuffer)
 2995 0326 00D0      		rcall strtol
 2996               	.LVL325:
 2997 0328 1B01      		movw r2,r22
 2998 032a 2C01      		movw r4,r24
 2999               	.LVL326:
 362:main.c        **** 			
 363:main.c        **** 			receivedChar = USART_Receive(); // Wait for byte to say which flash cart write method
 3000               		.loc 3 363 0
 3001 032c 00D0      		rcall USART_Receive
 3002               	.LVL327:
 3003 032e 8093 0000 		sts receivedChar,r24
 364:main.c        **** 			usart_read_chars(); // Read data
 3004               		.loc 3 364 0
 3005 0332 00D0      		rcall usart_read_chars
 3006               	.LVL328:
 365:main.c        **** 			uint8_t flashByte = strtol(receivedBuffer, NULL, 16); // Convert data byte in hex to dec
 3007               		.loc 3 365 0
 3008 0334 40E1      		ldi r20,lo8(16)
 3009 0336 50E0      		ldi r21,0
 3010 0338 60E0      		ldi r22,0
 3011 033a 70E0      		ldi r23,0
 3012 033c 80E0      		ldi r24,lo8(receivedBuffer)
 3013 033e 90E0      		ldi r25,hi8(receivedBuffer)
 3014 0340 00D0      		rcall strtol
 3015               	.LVL329:
 366:main.c        **** 			
 367:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 3016               		.loc 3 367 0
 3017 0342 939A      		sbi 0x12,3
 368:main.c        **** 			if (receivedChar == GB_AUDIO_FLASH_WRITE) { // Pulse audio pin
 3018               		.loc 3 368 0
 3019 0344 8091 0000 		lds r24,receivedChar
 3020 0348 8535      		cpi r24,lo8(85)
 3021 034a 01F4      		brne .L138
 369:main.c        **** 				audio_flash_write_bus_cycle(flashAddress, flashByte);
 3022               		.loc 3 369 0
 3023 034c C101      		movw r24,r2
 3024 034e 00D0      		rcall audio_flash_write_bus_cycle
 3025               	.LVL330:
 3026 0350 00C0      		rjmp .L221
 3027               	.LVL331:
 3028               	.L138:
 370:main.c        **** 			}
 371:main.c        **** 			else if (receivedChar == GB_WR_FLASH_WRITE) { // Pulse WR pin
 3029               		.loc 3 371 0
 3030 0352 8534      		cpi r24,lo8(69)
 3031 0354 01F0      		breq .L209
 372:main.c        **** 				gb_wr_flash_write_bus_cycle(flashAddress, flashByte);
 373:main.c        **** 			}
 374:main.c        **** 			else if (receivedChar == GB_BV5_FLASH_WRITE) { // Pulse WR pin
 3032               		.loc 3 374 0
 3033 0356 8533      		cpi r24,lo8(53)
 3034 0358 01F0      		breq .+2
 3035 035a 00C0      		rjmp .L221
 3036               	.L209:
 375:main.c        **** 				bv5_flash_write_bus_cycle(flashAddress, flashByte);
 3037               		.loc 3 375 0
 3038 035c C101      		movw r24,r2
 3039 035e 00D0      		rcall bv5_flash_write_bus_cycle
 3040               	.LVL332:
 3041 0360 00C0      		rjmp .L221
 3042               	.LVL333:
 3043               	.L137:
 3044               	.LBE124:
 376:main.c        **** 			}
 377:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 378:main.c        **** 			
 379:main.c        **** 			USART_Transmit('1'); // Send back acknowledgement
 380:main.c        **** 		}
 381:main.c        **** 		
 382:main.c        **** 		// Write 64 bytes to Flash address one byte write at a time (and increment), pulse a pin
 383:main.c        **** 		else if (receivedChar == GB_FLASH_WRITE_64BYTE) {
 3045               		.loc 3 383 0
 3046 0362 9435      		cpi r25,lo8(84)
 3047 0364 01F4      		brne .L141
 384:main.c        **** 			receivedChar = USART_Receive(); // Wait for byte
 3048               		.loc 3 384 0
 3049 0366 00D0      		rcall USART_Receive
 3050               	.LVL334:
 3051 0368 8093 0000 		sts receivedChar,r24
 385:main.c        **** 			usart_read_bytes(64);
 3052               		.loc 3 385 0
 3053 036c 80E4      		ldi r24,lo8(64)
 3054 036e 00D0      		rcall usart_read_bytes
 3055               	.LVL335:
 386:main.c        **** 			
 387:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 3056               		.loc 3 387 0
 3057 0370 939A      		sbi 0x12,3
 3058               	.LVL336:
 3059 0372 00E0      		ldi r16,lo8(receivedBuffer)
 3060 0374 10E0      		ldi r17,hi8(receivedBuffer)
 3061 0376 E601      		movw r28,r12
 3062 0378 90E4      		ldi r25,lo8(64)
 3063 037a 592E      		mov r5,r25
 3064               	.LVL337:
 3065               	.L146:
 3066               	.LBB125:
 388:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 389:main.c        **** 				if (receivedChar == GB_AUDIO_FLASH_WRITE) { // Pulse audio pin
 3067               		.loc 3 389 0
 3068 037c 8091 0000 		lds r24,receivedChar
 3069 0380 8535      		cpi r24,lo8(85)
 3070 0382 01F4      		brne .L142
 390:main.c        **** 					audio_flash_write_byte(address, receivedBuffer[x]);
 3071               		.loc 3 390 0
 3072 0384 F801      		movw r30,r16
 3073 0386 6081      		ld r22,Z
 3074 0388 CE01      		movw r24,r28
 3075 038a 00D0      		rcall audio_flash_write_byte
 3076               	.LVL338:
 3077 038c 00C0      		rjmp .L143
 3078               	.L142:
 391:main.c        **** 				}
 392:main.c        **** 				else if (receivedChar == GB_WR_FLASH_WRITE) { // Pulse WR pin
 3079               		.loc 3 392 0
 3080 038e 8534      		cpi r24,lo8(69)
 3081 0390 01F4      		brne .L144
 393:main.c        **** 					gb_wr_flash_write_byte(address, receivedBuffer[x]);
 3082               		.loc 3 393 0
 3083 0392 F801      		movw r30,r16
 3084 0394 6081      		ld r22,Z
 3085 0396 CE01      		movw r24,r28
 3086 0398 00D0      		rcall gb_wr_flash_write_byte
 3087               	.LVL339:
 3088 039a 00C0      		rjmp .L143
 3089               	.L144:
 394:main.c        **** 				}
 395:main.c        **** 				else if (receivedChar == GB_WORD_FLASH_WRITE) { // Pulse WR pin
 3090               		.loc 3 395 0
 3091 039c 8935      		cpi r24,lo8(89)
 3092 039e 01F4      		brne .L145
 396:main.c        **** 					gb_word_flash_write_byte(address, receivedBuffer[x]);
 3093               		.loc 3 396 0
 3094 03a0 F801      		movw r30,r16
 3095 03a2 6081      		ld r22,Z
 3096 03a4 CE01      		movw r24,r28
 3097 03a6 00D0      		rcall gb_word_flash_write_byte
 3098               	.LVL340:
 3099 03a8 00C0      		rjmp .L143
 3100               	.L145:
 397:main.c        **** 				}
 398:main.c        **** 				else if (receivedChar == GB_BV5_FLASH_WRITE) { // Pulse WR pin
 3101               		.loc 3 398 0
 3102 03aa 8533      		cpi r24,lo8(53)
 3103 03ac 01F4      		brne .L143
 399:main.c        **** 					bv5_flash_write_byte(address, receivedBuffer[x]);
 3104               		.loc 3 399 0
 3105 03ae F801      		movw r30,r16
 3106 03b0 6081      		ld r22,Z
 3107 03b2 CE01      		movw r24,r28
 3108 03b4 00D0      		rcall bv5_flash_write_byte
 3109               	.LVL341:
 3110               	.L143:
 3111 03b6 5A94      		dec r5
 3112 03b8 0F5F      		subi r16,-1
 3113 03ba 1F4F      		sbci r17,-1
 3114               	.LVL342:
 3115 03bc 2196      		adiw r28,1
 388:main.c        **** 				if (receivedChar == GB_AUDIO_FLASH_WRITE) { // Pulse audio pin
 3116               		.loc 3 388 0 discriminator 2
 3117 03be 5110      		cpse r5,__zero_reg__
 3118 03c0 00C0      		rjmp .L146
 3119 03c2 F0E4      		ldi r31,64
 3120 03c4 CF0E      		add r12,r31
 3121 03c6 D11C      		adc r13,__zero_reg__
 3122 03c8 E11C      		adc r14,__zero_reg__
 3123 03ca F11C      		adc r15,__zero_reg__
 3124 03cc 00C0      		rjmp .L210
 3125               	.LVL343:
 3126               	.L141:
 3127               	.LBE125:
 400:main.c        **** 				}
 401:main.c        **** 				
 402:main.c        **** 				address++;
 403:main.c        **** 			}
 404:main.c        **** 			USART_Transmit('1'); // Send back acknowledgement
 405:main.c        **** 			
 406:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 407:main.c        **** 		}
 408:main.c        **** 		
 409:main.c        **** 		
 410:main.c        **** 		// ---------- GBA FLASH CARTS ----------
 411:main.c        **** 		// Write 24 bit address, 16 bit data and pulse a pin
 412:main.c        **** 		else if (receivedChar == GBA_FLASH_CART_WRITE_BYTE) {
 3128               		.loc 3 412 0
 3129 03ce 9E36      		cpi r25,lo8(110)
 3130 03d0 01F4      		brne .L147
 3131               	.LBB126:
 413:main.c        **** 			usart_read_chars(); // Read address
 3132               		.loc 3 413 0
 3133 03d2 00D0      		rcall usart_read_chars
 3134               	.LVL344:
 414:main.c        **** 			uint32_t flashAddress = strtol(receivedBuffer, NULL, 16); // Convert address string in hex to de
 3135               		.loc 3 414 0
 3136 03d4 40E1      		ldi r20,lo8(16)
 3137 03d6 50E0      		ldi r21,0
 3138 03d8 60E0      		ldi r22,0
 3139 03da 70E0      		ldi r23,0
 3140 03dc 80E0      		ldi r24,lo8(receivedBuffer)
 3141 03de 90E0      		ldi r25,hi8(receivedBuffer)
 3142 03e0 00D0      		rcall strtol
 3143               	.LVL345:
 3144 03e2 1B01      		movw r2,r22
 3145 03e4 2C01      		movw r4,r24
 3146               	.LVL346:
 415:main.c        **** 			
 416:main.c        **** 			receivedChar = USART_Receive(); // Wait for byte
 3147               		.loc 3 416 0
 3148 03e6 00D0      		rcall USART_Receive
 3149               	.LVL347:
 3150 03e8 8093 0000 		sts receivedChar,r24
 417:main.c        **** 			if (receivedChar == GBA_FLASH_CART_WRITE_BYTE) {
 3151               		.loc 3 417 0
 3152 03ec 8E36      		cpi r24,lo8(110)
 3153 03ee 01F0      		breq .+2
 3154 03f0 00C0      		rjmp .L97
 3155               	.LBB127:
 418:main.c        **** 				usart_read_chars(); // Read data
 3156               		.loc 3 418 0
 3157 03f2 00D0      		rcall usart_read_chars
 3158               	.LVL348:
 419:main.c        **** 				uint16_t flashByte = strtol(receivedBuffer, NULL, 16); // Convert data byte in hex to dec
 3159               		.loc 3 419 0
 3160 03f4 40E1      		ldi r20,lo8(16)
 3161 03f6 50E0      		ldi r21,0
 3162 03f8 60E0      		ldi r22,0
 3163 03fa 70E0      		ldi r23,0
 3164 03fc 80E0      		ldi r24,lo8(receivedBuffer)
 3165 03fe 90E0      		ldi r25,hi8(receivedBuffer)
 3166 0400 00D0      		rcall strtol
 3167               	.LVL349:
 420:main.c        **** 				
 421:main.c        **** 				PORTD |= (1<<ACTIVITY_LED);
 3168               		.loc 3 421 0
 3169 0402 939A      		sbi 0x12,3
 422:main.c        **** 				gba_flash_write_bus_cycle(flashAddress, flashByte);
 3170               		.loc 3 422 0
 3171 0404 AB01      		movw r20,r22
 3172 0406 C201      		movw r24,r4
 3173 0408 B101      		movw r22,r2
 3174               	.LVL350:
 3175 040a 00D0      		rcall gba_flash_write_bus_cycle
 3176               	.LVL351:
 3177               	.L221:
 423:main.c        **** 				PORTD &= ~(1<<ACTIVITY_LED);
 3178               		.loc 3 423 0
 3179 040c 9398      		cbi 0x12,3
 424:main.c        **** 				
 425:main.c        **** 				USART_Transmit('1'); // Send back acknowledgement
 3180               		.loc 3 425 0
 3181 040e 81E3      		ldi r24,lo8(49)
 3182 0410 00C0      		rjmp .L198
 3183               	.LVL352:
 3184               	.L147:
 3185               	.LBE127:
 3186               	.LBE126:
 426:main.c        **** 			}
 427:main.c        **** 		}
 428:main.c        **** 		
 429:main.c        **** 		// Write 64 bytes to Flash address, combine 2 bytes and write at a time (and increment address by
 430:main.c        **** 		else if (receivedChar == GBA_FLASH_WRITE_64BYTE) {
 3187               		.loc 3 430 0
 3188 0412 9137      		cpi r25,lo8(113)
 3189 0414 01F4      		brne .L148
 431:main.c        **** 			usart_read_bytes(64);
 3190               		.loc 3 431 0
 3191 0416 80E4      		ldi r24,lo8(64)
 3192               	.LVL353:
 3193 0418 00D0      		rcall usart_read_bytes
 3194               	.LVL354:
 432:main.c        **** 			
 433:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 3195               		.loc 3 433 0
 3196 041a 939A      		sbi 0x12,3
 3197               	.LVL355:
 3198 041c C0E0      		ldi r28,lo8(receivedBuffer)
 3199 041e D0E0      		ldi r29,hi8(receivedBuffer)
 3200 0420 1601      		movw r2,r12
 3201 0422 2701      		movw r4,r14
 3202               	.LVL356:
 3203               	.L149:
 3204               	.LBB128:
 3205               	.LBB129:
 434:main.c        **** 			for (uint8_t x = 0; x < 64; x += 2) {
 435:main.c        **** 				uint16_t combinedBytes = (uint16_t) receivedBuffer[x+1] << 8 | (uint16_t) receivedBuffer[x];
 436:main.c        **** 				gba_flash_write_byte_swapped(address, combinedBytes);
 3206               		.loc 3 436 0 discriminator 3
 3207 0424 4981      		ldd r20,Y+1
 3208 0426 50E0      		ldi r21,0
 3209 0428 542F      		mov r21,r20
 3210 042a 4427      		clr r20
 3211 042c 8881      		ld r24,Y
 3212 042e 482B      		or r20,r24
 3213 0430 C201      		movw r24,r4
 3214 0432 B101      		movw r22,r2
 3215 0434 00D0      		rcall gba_flash_write_byte_swapped
 3216               	.LVL357:
 437:main.c        **** 				address++;
 3217               		.loc 3 437 0 discriminator 3
 3218 0436 2FEF      		ldi r18,-1
 3219 0438 221A      		sub r2,r18
 3220 043a 320A      		sbc r3,r18
 3221 043c 420A      		sbc r4,r18
 3222 043e 520A      		sbc r5,r18
 3223               	.LVL358:
 3224 0440 2296      		adiw r28,2
 3225               	.LVL359:
 3226               	.LBE129:
 434:main.c        **** 			for (uint8_t x = 0; x < 64; x += 2) {
 3227               		.loc 3 434 0 discriminator 3
 3228 0442 6C16      		cp r6,r28
 3229 0444 7D06      		cpc r7,r29
 3230 0446 01F4      		brne .L149
 3231 0448 80E2      		ldi r24,32
 3232 044a C80E      		add r12,r24
 3233 044c D11C      		adc r13,__zero_reg__
 3234 044e E11C      		adc r14,__zero_reg__
 3235 0450 F11C      		adc r15,__zero_reg__
 3236               	.LVL360:
 3237               	.L210:
 3238               	.LBE128:
 438:main.c        **** 			}
 439:main.c        **** 			USART_Transmit('1'); // Send back acknowledgement
 3239               		.loc 3 439 0
 3240 0452 81E3      		ldi r24,lo8(49)
 3241 0454 00C0      		rjmp .L201
 3242               	.LVL361:
 3243               	.L148:
 440:main.c        **** 			
 441:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 442:main.c        **** 		}
 443:main.c        **** 		
 444:main.c        **** 		
 445:main.c        **** 		// ---------- General commands ----------
 446:main.c        **** 		// Set any pin as input/output
 447:main.c        **** 		// Reads the DDR/PORT (e.g. DDRB/PORTB is 'B') and the hex value that represents pins to set to a
 448:main.c        **** 		else if (receivedChar == SET_INPUT || receivedChar == SET_OUTPUT) {
 3244               		.loc 3 448 0
 3245 0456 9934      		cpi r25,lo8(73)
 3246 0458 01F0      		breq .L150
 3247               		.loc 3 448 0 is_stmt 0 discriminator 1
 3248 045a 9F34      		cpi r25,lo8(79)
 3249 045c 01F0      		breq .+2
 3250 045e 00C0      		rjmp .L151
 3251               	.L150:
 3252               	.LBB130:
 449:main.c        **** 			char portChar = USART_Receive();
 3253               		.loc 3 449 0 is_stmt 1
 3254 0460 00D0      		rcall USART_Receive
 3255               	.LVL362:
 3256 0462 C82F      		mov r28,r24
 3257               	.LVL363:
 450:main.c        **** 			usart_read_chars();
 3258               		.loc 3 450 0
 3259 0464 00D0      		rcall usart_read_chars
 3260               	.LVL364:
 451:main.c        **** 			uint8_t setValue = strtol(receivedBuffer, NULL, 16);
 3261               		.loc 3 451 0
 3262 0466 40E1      		ldi r20,lo8(16)
 3263 0468 50E0      		ldi r21,0
 3264 046a 60E0      		ldi r22,0
 3265 046c 70E0      		ldi r23,0
 3266 046e 80E0      		ldi r24,lo8(receivedBuffer)
 3267 0470 90E0      		ldi r25,hi8(receivedBuffer)
 3268 0472 00D0      		rcall strtol
 3269               	.LVL365:
 452:main.c        **** 			
 453:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 3270               		.loc 3 453 0
 3271 0474 939A      		sbi 0x12,3
 454:main.c        **** 			if (receivedChar == SET_INPUT) {
 3272               		.loc 3 454 0
 3273 0476 8091 0000 		lds r24,receivedChar
 3274 047a 8934      		cpi r24,lo8(73)
 3275 047c 01F4      		brne .L152
 455:main.c        **** 				if (portChar == 'A') {
 3276               		.loc 3 455 0
 3277 047e C134      		cpi r28,lo8(65)
 3278 0480 01F4      		brne .L153
 456:main.c        **** 					DDRA &= ~(setValue);
 3279               		.loc 3 456 0
 3280 0482 8AB3      		in r24,0x1a
 3281 0484 6095      		com r22
 3282               	.LVL366:
 3283 0486 6823      		and r22,r24
 3284               	.LVL367:
 3285 0488 00C0      		rjmp .L212
 3286               	.LVL368:
 3287               	.L153:
 457:main.c        **** 				}
 458:main.c        **** 				else if (portChar == 'B') {
 3288               		.loc 3 458 0
 3289 048a C234      		cpi r28,lo8(66)
 3290 048c 01F4      		brne .L155
 459:main.c        **** 					DDRB &= ~(setValue);
 3291               		.loc 3 459 0
 3292 048e 87B3      		in r24,0x17
 3293 0490 6095      		com r22
 3294               	.LVL369:
 3295 0492 6823      		and r22,r24
 3296               	.LVL370:
 3297 0494 00C0      		rjmp .L213
 3298               	.LVL371:
 3299               	.L155:
 460:main.c        **** 				}
 461:main.c        **** 				else if (portChar == 'C') {
 3300               		.loc 3 461 0
 3301 0496 C334      		cpi r28,lo8(67)
 3302 0498 01F4      		brne .L156
 462:main.c        **** 					DDRC &= ~(setValue);
 3303               		.loc 3 462 0
 3304 049a 84B3      		in r24,0x14
 3305 049c 6095      		com r22
 3306               	.LVL372:
 3307 049e 6823      		and r22,r24
 3308               	.LVL373:
 3309 04a0 00C0      		rjmp .L218
 3310               	.LVL374:
 3311               	.L156:
 463:main.c        **** 				}
 464:main.c        **** 				else if (portChar == 'D') {
 3312               		.loc 3 464 0
 3313 04a2 C434      		cpi r28,lo8(68)
 3314 04a4 01F4      		brne .L157
 465:main.c        **** 					DDRD &= ~(setValue);
 3315               		.loc 3 465 0
 3316 04a6 81B3      		in r24,0x11
 3317 04a8 6095      		com r22
 3318               	.LVL375:
 3319 04aa 6823      		and r22,r24
 3320               	.LVL376:
 3321 04ac 00C0      		rjmp .L219
 3322               	.LVL377:
 3323               	.L157:
 466:main.c        **** 				}
 467:main.c        **** 				else if (portChar == 'E') {
 3324               		.loc 3 467 0
 3325 04ae C534      		cpi r28,lo8(69)
 3326 04b0 01F0      		breq .+2
 3327 04b2 00C0      		rjmp .L176
 468:main.c        **** 					DDRE &= ~(setValue);
 3328               		.loc 3 468 0
 3329 04b4 86B1      		in r24,0x6
 3330 04b6 6095      		com r22
 3331               	.LVL378:
 3332 04b8 6823      		and r22,r24
 3333               	.LVL379:
 3334 04ba 00C0      		rjmp .L220
 3335               	.LVL380:
 3336               	.L152:
 469:main.c        **** 				}
 470:main.c        **** 			}
 471:main.c        **** 			else if (receivedChar == SET_OUTPUT) {
 3337               		.loc 3 471 0
 3338 04bc 8F34      		cpi r24,lo8(79)
 3339 04be 01F0      		breq .+2
 3340 04c0 00C0      		rjmp .L176
 472:main.c        **** 				if (portChar == 'A') {
 3341               		.loc 3 472 0
 3342 04c2 C134      		cpi r28,lo8(65)
 3343 04c4 01F4      		brne .L158
 473:main.c        **** 					DDRA |= (setValue);
 3344               		.loc 3 473 0
 3345 04c6 8AB3      		in r24,0x1a
 3346 04c8 682B      		or r22,r24
 3347               	.LVL381:
 3348               	.L212:
 3349 04ca 6ABB      		out 0x1a,r22
 3350 04cc 00C0      		rjmp .L176
 3351               	.LVL382:
 3352               	.L158:
 474:main.c        **** 				}
 475:main.c        **** 				else if (portChar == 'B') {
 3353               		.loc 3 475 0
 3354 04ce C234      		cpi r28,lo8(66)
 3355 04d0 01F4      		brne .L159
 476:main.c        **** 					DDRB |= (setValue);
 3356               		.loc 3 476 0
 3357 04d2 87B3      		in r24,0x17
 3358 04d4 682B      		or r22,r24
 3359               	.LVL383:
 3360               	.L213:
 3361 04d6 67BB      		out 0x17,r22
 3362 04d8 00C0      		rjmp .L176
 3363               	.LVL384:
 3364               	.L159:
 477:main.c        **** 				}
 478:main.c        **** 				else if (portChar == 'C') {
 3365               		.loc 3 478 0
 3366 04da C334      		cpi r28,lo8(67)
 3367 04dc 01F4      		brne .L160
 479:main.c        **** 					DDRC |= (setValue);
 3368               		.loc 3 479 0
 3369 04de 84B3      		in r24,0x14
 3370 04e0 682B      		or r22,r24
 3371               	.LVL385:
 3372               	.L218:
 3373 04e2 64BB      		out 0x14,r22
 3374 04e4 00C0      		rjmp .L176
 3375               	.LVL386:
 3376               	.L160:
 480:main.c        **** 				}
 481:main.c        **** 				else if (portChar == 'D') {
 3377               		.loc 3 481 0
 3378 04e6 C434      		cpi r28,lo8(68)
 3379 04e8 01F4      		brne .L161
 482:main.c        **** 					DDRD |= (setValue);
 3380               		.loc 3 482 0
 3381 04ea 81B3      		in r24,0x11
 3382 04ec 682B      		or r22,r24
 3383               	.LVL387:
 3384               	.L219:
 3385 04ee 61BB      		out 0x11,r22
 3386 04f0 00C0      		rjmp .L176
 3387               	.LVL388:
 3388               	.L161:
 483:main.c        **** 				}
 484:main.c        **** 				else if (portChar == 'E') {
 3389               		.loc 3 484 0
 3390 04f2 C534      		cpi r28,lo8(69)
 3391 04f4 01F0      		breq .+2
 3392 04f6 00C0      		rjmp .L176
 485:main.c        **** 					DDRE |= (setValue);
 3393               		.loc 3 485 0
 3394 04f8 86B1      		in r24,0x6
 3395 04fa 682B      		or r22,r24
 3396               	.LVL389:
 3397               	.L220:
 3398 04fc 66B9      		out 0x6,r22
 3399 04fe 00C0      		rjmp .L176
 3400               	.LVL390:
 3401               	.L151:
 3402               	.LBE130:
 486:main.c        **** 				}
 487:main.c        **** 			}
 488:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 489:main.c        **** 		}
 490:main.c        **** 		
 491:main.c        **** 		// Set pin output as low
 492:main.c        **** 		else if (receivedChar == SET_OUTPUT_LOW) {
 3403               		.loc 3 492 0
 3404 0500 9C34      		cpi r25,lo8(76)
 3405 0502 01F4      		brne .L162
 3406               	.LBB131:
 493:main.c        **** 			char portChar = USART_Receive();			
 3407               		.loc 3 493 0
 3408 0504 00D0      		rcall USART_Receive
 3409               	.LVL391:
 3410 0506 C82F      		mov r28,r24
 3411               	.LVL392:
 494:main.c        **** 			usart_read_chars();
 3412               		.loc 3 494 0
 3413 0508 00D0      		rcall usart_read_chars
 3414               	.LVL393:
 495:main.c        **** 			uint8_t setValue = strtol(receivedBuffer, NULL, 16);
 3415               		.loc 3 495 0
 3416 050a 40E1      		ldi r20,lo8(16)
 3417 050c 50E0      		ldi r21,0
 3418 050e 60E0      		ldi r22,0
 3419 0510 70E0      		ldi r23,0
 3420 0512 80E0      		ldi r24,lo8(receivedBuffer)
 3421 0514 90E0      		ldi r25,hi8(receivedBuffer)
 3422 0516 00D0      		rcall strtol
 3423               	.LVL394:
 496:main.c        **** 			
 497:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 3424               		.loc 3 497 0
 3425 0518 939A      		sbi 0x12,3
 498:main.c        **** 			if (portChar == 'A') {
 3426               		.loc 3 498 0
 3427 051a C134      		cpi r28,lo8(65)
 3428 051c 01F4      		brne .L163
 499:main.c        **** 				PORTA &= ~(setValue);
 3429               		.loc 3 499 0
 3430 051e 8BB3      		in r24,0x1b
 3431 0520 6095      		com r22
 3432               	.LVL395:
 3433 0522 6823      		and r22,r24
 3434               	.LVL396:
 3435 0524 00C0      		rjmp .L217
 3436               	.LVL397:
 3437               	.L163:
 500:main.c        **** 			}
 501:main.c        **** 			else if (portChar == 'B') {
 3438               		.loc 3 501 0
 3439 0526 C234      		cpi r28,lo8(66)
 3440 0528 01F4      		brne .L165
 502:main.c        **** 				PORTB &= ~(setValue);
 3441               		.loc 3 502 0
 3442 052a 88B3      		in r24,0x18
 3443 052c 6095      		com r22
 3444               	.LVL398:
 3445 052e 6823      		and r22,r24
 3446               	.LVL399:
 3447 0530 00C0      		rjmp .L216
 3448               	.LVL400:
 3449               	.L165:
 503:main.c        **** 			}
 504:main.c        **** 			else if (portChar == 'C') {
 3450               		.loc 3 504 0
 3451 0532 C334      		cpi r28,lo8(67)
 3452 0534 01F4      		brne .L166
 505:main.c        **** 				PORTC &= ~(setValue);
 3453               		.loc 3 505 0
 3454 0536 85B3      		in r24,0x15
 3455 0538 6095      		com r22
 3456               	.LVL401:
 3457 053a 6823      		and r22,r24
 3458               	.LVL402:
 3459 053c 00C0      		rjmp .L215
 3460               	.LVL403:
 3461               	.L166:
 506:main.c        **** 			}
 507:main.c        **** 			else if (portChar == 'D') {
 3462               		.loc 3 507 0
 3463 053e C434      		cpi r28,lo8(68)
 3464 0540 01F4      		brne .L167
 508:main.c        **** 				PORTD &= ~(setValue);
 3465               		.loc 3 508 0
 3466 0542 82B3      		in r24,0x12
 3467 0544 6095      		com r22
 3468               	.LVL404:
 3469 0546 6823      		and r22,r24
 3470               	.LVL405:
 3471 0548 00C0      		rjmp .L214
 3472               	.LVL406:
 3473               	.L167:
 509:main.c        **** 			}
 510:main.c        **** 			else if (portChar == 'E') {
 3474               		.loc 3 510 0
 3475 054a C534      		cpi r28,lo8(69)
 3476 054c 01F0      		breq .+2
 3477 054e 00C0      		rjmp .L176
 511:main.c        **** 				PORTE &= ~(setValue);
 3478               		.loc 3 511 0
 3479 0550 87B1      		in r24,0x7
 3480 0552 6095      		com r22
 3481               	.LVL407:
 3482 0554 6823      		and r22,r24
 3483               	.LVL408:
 3484 0556 00C0      		rjmp .L211
 3485               	.LVL409:
 3486               	.L162:
 3487               	.LBE131:
 512:main.c        **** 			}
 513:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 514:main.c        **** 		}
 515:main.c        **** 		
 516:main.c        **** 		// Set pin output as high
 517:main.c        **** 		else if (receivedChar == SET_OUTPUT_HIGH) {
 3488               		.loc 3 517 0
 3489 0558 9834      		cpi r25,lo8(72)
 3490 055a 01F4      		brne .L168
 3491               	.LBB132:
 518:main.c        **** 			char portChar = USART_Receive();			
 3492               		.loc 3 518 0
 3493 055c 00D0      		rcall USART_Receive
 3494               	.LVL410:
 3495 055e C82F      		mov r28,r24
 3496               	.LVL411:
 519:main.c        **** 			usart_read_chars();
 3497               		.loc 3 519 0
 3498 0560 00D0      		rcall usart_read_chars
 3499               	.LVL412:
 520:main.c        **** 			uint8_t setValue = strtol(receivedBuffer, NULL, 16);
 3500               		.loc 3 520 0
 3501 0562 40E1      		ldi r20,lo8(16)
 3502 0564 50E0      		ldi r21,0
 3503 0566 60E0      		ldi r22,0
 3504 0568 70E0      		ldi r23,0
 3505 056a 80E0      		ldi r24,lo8(receivedBuffer)
 3506 056c 90E0      		ldi r25,hi8(receivedBuffer)
 3507 056e 00D0      		rcall strtol
 3508               	.LVL413:
 521:main.c        **** 			
 522:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 3509               		.loc 3 522 0
 3510 0570 939A      		sbi 0x12,3
 523:main.c        **** 			if (portChar == 'A') {
 3511               		.loc 3 523 0
 3512 0572 C134      		cpi r28,lo8(65)
 3513 0574 01F4      		brne .L169
 524:main.c        **** 				PORTA |= (setValue);
 3514               		.loc 3 524 0
 3515 0576 8BB3      		in r24,0x1b
 3516 0578 682B      		or r22,r24
 3517               	.LVL414:
 3518               	.L217:
 3519 057a 6BBB      		out 0x1b,r22
 3520 057c 00C0      		rjmp .L176
 3521               	.LVL415:
 3522               	.L169:
 525:main.c        **** 			}
 526:main.c        **** 			else if (portChar == 'B') {
 3523               		.loc 3 526 0
 3524 057e C234      		cpi r28,lo8(66)
 3525 0580 01F4      		brne .L171
 527:main.c        **** 				PORTB |= (setValue);
 3526               		.loc 3 527 0
 3527 0582 88B3      		in r24,0x18
 3528 0584 682B      		or r22,r24
 3529               	.LVL416:
 3530               	.L216:
 3531 0586 68BB      		out 0x18,r22
 3532 0588 00C0      		rjmp .L176
 3533               	.LVL417:
 3534               	.L171:
 528:main.c        **** 			}
 529:main.c        **** 			else if (portChar == 'C') {
 3535               		.loc 3 529 0
 3536 058a C334      		cpi r28,lo8(67)
 3537 058c 01F4      		brne .L172
 530:main.c        **** 				PORTC |= (setValue);
 3538               		.loc 3 530 0
 3539 058e 85B3      		in r24,0x15
 3540 0590 682B      		or r22,r24
 3541               	.LVL418:
 3542               	.L215:
 3543 0592 65BB      		out 0x15,r22
 3544 0594 00C0      		rjmp .L176
 3545               	.LVL419:
 3546               	.L172:
 531:main.c        **** 			}
 532:main.c        **** 			else if (portChar == 'D') {
 3547               		.loc 3 532 0
 3548 0596 C434      		cpi r28,lo8(68)
 3549 0598 01F4      		brne .L173
 533:main.c        **** 				PORTD |= (setValue);
 3550               		.loc 3 533 0
 3551 059a 82B3      		in r24,0x12
 3552 059c 682B      		or r22,r24
 3553               	.LVL420:
 3554               	.L214:
 3555 059e 62BB      		out 0x12,r22
 3556 05a0 00C0      		rjmp .L176
 3557               	.LVL421:
 3558               	.L173:
 534:main.c        **** 			}
 535:main.c        **** 			else if (portChar == 'E') {
 3559               		.loc 3 535 0
 3560 05a2 C534      		cpi r28,lo8(69)
 3561 05a4 01F4      		brne .L176
 536:main.c        **** 				PORTE |= (setValue);
 3562               		.loc 3 536 0
 3563 05a6 87B1      		in r24,0x7
 3564 05a8 682B      		or r22,r24
 3565               	.LVL422:
 3566               	.L211:
 3567 05aa 67B9      		out 0x7,r22
 3568 05ac 00C0      		rjmp .L176
 3569               	.LVL423:
 3570               	.L168:
 3571               	.LBE132:
 537:main.c        **** 			}
 538:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 539:main.c        **** 		}
 540:main.c        **** 		
 541:main.c        **** 		// Read all pins of a PORT and return the value
 542:main.c        **** 		else if (receivedChar == READ_INPUT) {
 3572               		.loc 3 542 0
 3573 05ae 9434      		cpi r25,lo8(68)
 3574 05b0 01F4      		brne .L174
 3575               	.LBB133:
 543:main.c        **** 			char portChar = USART_Receive();			
 3576               		.loc 3 543 0
 3577 05b2 00D0      		rcall USART_Receive
 3578               	.LVL424:
 544:main.c        **** 			
 545:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 3579               		.loc 3 545 0
 3580 05b4 939A      		sbi 0x12,3
 546:main.c        **** 			if (portChar == 'A') {
 3581               		.loc 3 546 0
 3582 05b6 8134      		cpi r24,lo8(65)
 3583 05b8 01F4      		brne .L175
 547:main.c        **** 				USART_Transmit(PINA);
 3584               		.loc 3 547 0
 3585 05ba 89B3      		in r24,0x19
 3586               	.LVL425:
 3587 05bc 00C0      		rjmp .L201
 3588               	.LVL426:
 3589               	.L175:
 548:main.c        **** 			}
 549:main.c        **** 			else if (portChar == 'B') {
 3590               		.loc 3 549 0
 3591 05be 8234      		cpi r24,lo8(66)
 3592 05c0 01F4      		brne .L177
 550:main.c        **** 				USART_Transmit(PINB);
 3593               		.loc 3 550 0
 3594 05c2 86B3      		in r24,0x16
 3595               	.LVL427:
 3596 05c4 00C0      		rjmp .L201
 3597               	.LVL428:
 3598               	.L177:
 551:main.c        **** 			}
 552:main.c        **** 			else if (portChar == 'C') {
 3599               		.loc 3 552 0
 3600 05c6 8334      		cpi r24,lo8(67)
 3601 05c8 01F4      		brne .L178
 553:main.c        **** 				USART_Transmit(PINC);
 3602               		.loc 3 553 0
 3603 05ca 83B3      		in r24,0x13
 3604               	.LVL429:
 3605 05cc 00C0      		rjmp .L201
 3606               	.LVL430:
 3607               	.L178:
 554:main.c        **** 			}
 555:main.c        **** 			else if (portChar == 'D') {
 3608               		.loc 3 555 0
 3609 05ce 8434      		cpi r24,lo8(68)
 3610 05d0 01F4      		brne .L179
 556:main.c        **** 				USART_Transmit(PIND);
 3611               		.loc 3 556 0
 3612 05d2 80B3      		in r24,0x10
 3613               	.LVL431:
 3614 05d4 00C0      		rjmp .L201
 3615               	.LVL432:
 3616               	.L179:
 557:main.c        **** 			}
 558:main.c        **** 			else if (portChar == 'E') {
 3617               		.loc 3 558 0
 3618 05d6 8534      		cpi r24,lo8(69)
 3619 05d8 01F4      		brne .L176
 559:main.c        **** 				USART_Transmit(PINE);
 3620               		.loc 3 559 0
 3621 05da 85B1      		in r24,0x5
 3622               	.LVL433:
 3623               	.L201:
 3624 05dc 00D0      		rcall USART_Transmit
 3625               	.LVL434:
 3626               	.L176:
 560:main.c        **** 			}
 561:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 3627               		.loc 3 561 0
 3628 05de 9398      		cbi 0x12,3
 3629               	.LBE133:
 3630 05e0 00C0      		rjmp .L97
 3631               	.LVL435:
 3632               	.L174:
 562:main.c        **** 		}
 563:main.c        **** 		
 564:main.c        **** 		// Set the reset common lines variable on or off, useful if you are controlling all the pins dire
 565:main.c        **** 		else if (receivedChar == RESET_COMMON_LINES) {
 3633               		.loc 3 565 0
 3634 05e2 9D34      		cpi r25,lo8(77)
 3635 05e4 01F4      		brne .L180
 3636               	.LBB134:
 566:main.c        **** 			char commonChar = USART_Receive();
 3637               		.loc 3 566 0
 3638 05e6 00D0      		rcall USART_Receive
 3639               	.LVL436:
 567:main.c        **** 			if (commonChar == '1') {
 3640               		.loc 3 567 0
 3641 05e8 8133      		cpi r24,lo8(49)
 3642 05ea 01F4      		brne .L222
 568:main.c        **** 				resetCommonLines = 1;
 3643               		.loc 3 568 0
 3644 05ec 8824      		clr r8
 3645 05ee 8394      		inc r8
 3646 05f0 00C0      		rjmp .L197
 3647               	.L222:
 569:main.c        **** 			}
 570:main.c        **** 			else if (commonChar == '0') {
 3648               		.loc 3 570 0
 3649 05f2 8033      		cpi r24,lo8(48)
 3650 05f4 01F0      		breq .+2
 3651 05f6 00C0      		rjmp .L97
 571:main.c        **** 				resetCommonLines = 0;
 3652               		.loc 3 571 0
 3653 05f8 812C      		mov r8,__zero_reg__
 3654 05fa 00C0      		rjmp .L98
 3655               	.LVL437:
 3656               	.L180:
 3657               	.LBE134:
 572:main.c        **** 			}
 573:main.c        **** 		}
 574:main.c        **** 		
 575:main.c        **** 		// Send back the PCB version number
 576:main.c        **** 		else if (receivedChar == READ_PCB_VERSION) {
 3658               		.loc 3 576 0
 3659 05fc 9836      		cpi r25,lo8(104)
 3660 05fe 01F4      		brne .L181
 577:main.c        **** 			USART_Transmit(PCB_VERSION);
 3661               		.loc 3 577 0
 3662 0600 82E0      		ldi r24,lo8(2)
 3663               	.LVL438:
 3664 0602 00C0      		rjmp .L198
 3665               	.LVL439:
 3666               	.L181:
 578:main.c        **** 		}
 579:main.c        **** 		
 580:main.c        **** 		// Send back the firmware version number
 581:main.c        **** 		else if (receivedChar == READ_FIRMWARE_VERSION) {
 3667               		.loc 3 581 0
 3668 0604 9635      		cpi r25,lo8(86)
 3669 0606 01F4      		brne .L182
 582:main.c        **** 			USART_Transmit(FIRMWARE_VERSION);
 3670               		.loc 3 582 0
 3671 0608 87E0      		ldi r24,lo8(7)
 3672               	.LVL440:
 3673               	.L198:
 3674 060a 00D0      		rcall USART_Transmit
 3675               	.LVL441:
 3676 060c 00C0      		rjmp .L97
 3677               	.LVL442:
 3678               	.L182:
 583:main.c        **** 		}
 584:main.c        **** 		
 585:main.c        **** 		// Reset the AVR if it matches the number
 586:main.c        **** 		else if (receivedChar == RESET_AVR) {
 3679               		.loc 3 586 0
 3680 060e 9A32      		cpi r25,lo8(42)
 3681 0610 01F0      		breq .+2
 3682 0612 00C0      		rjmp .L97
 3683               	.LBB135:
 587:main.c        **** 			usart_read_chars();
 3684               		.loc 3 587 0
 3685 0614 00D0      		rcall usart_read_chars
 3686               	.LVL443:
 588:main.c        **** 			uint32_t resetValue = strtol(receivedBuffer, NULL, 16);
 3687               		.loc 3 588 0
 3688 0616 40E1      		ldi r20,lo8(16)
 3689 0618 50E0      		ldi r21,0
 3690 061a 60E0      		ldi r22,0
 3691 061c 70E0      		ldi r23,0
 3692 061e 80E0      		ldi r24,lo8(receivedBuffer)
 3693 0620 90E0      		ldi r25,hi8(receivedBuffer)
 3694 0622 00D0      		rcall strtol
 3695               	.LVL444:
 589:main.c        **** 			if (resetValue == RESET_VALUE) {
 3696               		.loc 3 589 0
 3697 0624 613E      		cpi r22,-31
 3698 0626 754E      		sbci r23,-27
 3699 0628 8740      		sbci r24,7
 3700 062a 9105      		cpc r25,__zero_reg__
 3701 062c 01F0      		breq .+2
 3702 062e 00C0      		rjmp .L97
 590:main.c        **** 				// Clear watchdog flag
 591:main.c        **** 				MCUCSR &= ~(1<<WDRF);
 3703               		.loc 3 591 0
 3704 0630 84B7      		in r24,0x34
 3705 0632 877F      		andi r24,lo8(-9)
 3706 0634 84BF      		out 0x34,r24
 592:main.c        **** 				
 593:main.c        **** 				// Start timed sequence
 594:main.c        **** 				WDTCR = (1<<WDCE) | (1<<WDE);
 3707               		.loc 3 594 0
 3708 0636 F8E1      		ldi r31,lo8(24)
 3709 0638 F1BD      		out 0x21,r31
 595:main.c        **** 				
 596:main.c        **** 				// Reset in 250 ms
 597:main.c        **** 				WDTCR = (1<<WDP2) | (1<<WDE);
 3710               		.loc 3 597 0
 3711 063a 2CE0      		ldi r18,lo8(12)
 3712 063c 21BD      		out 0x21,r18
 3713               	.LVL445:
 3714               	.LBB136:
 3715               	.LBB137:
 3716               		.file 4 "c:\\winavr-20100110\\avr\\include\\util\\delay_basic.h"
   1:c:\winavr-20100110\avr\include\util\delay_basic.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:c:\winavr-20100110\avr\include\util\delay_basic.h ****    Copyright (c) 2007 Joerg Wunsch
   3:c:\winavr-20100110\avr\include\util\delay_basic.h ****    All rights reserved.
   4:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
   5:c:\winavr-20100110\avr\include\util\delay_basic.h ****    Redistribution and use in source and binary forms, with or without
   6:c:\winavr-20100110\avr\include\util\delay_basic.h ****    modification, are permitted provided that the following conditions are met:
   7:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
   8:c:\winavr-20100110\avr\include\util\delay_basic.h ****    * Redistributions of source code must retain the above copyright
   9:c:\winavr-20100110\avr\include\util\delay_basic.h ****      notice, this list of conditions and the following disclaimer.
  10:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  11:c:\winavr-20100110\avr\include\util\delay_basic.h ****    * Redistributions in binary form must reproduce the above copyright
  12:c:\winavr-20100110\avr\include\util\delay_basic.h ****      notice, this list of conditions and the following disclaimer in
  13:c:\winavr-20100110\avr\include\util\delay_basic.h ****      the documentation and/or other materials provided with the
  14:c:\winavr-20100110\avr\include\util\delay_basic.h ****      distribution.
  15:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  16:c:\winavr-20100110\avr\include\util\delay_basic.h ****    * Neither the name of the copyright holders nor the names of
  17:c:\winavr-20100110\avr\include\util\delay_basic.h ****      contributors may be used to endorse or promote products derived
  18:c:\winavr-20100110\avr\include\util\delay_basic.h ****      from this software without specific prior written permission.
  19:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  20:c:\winavr-20100110\avr\include\util\delay_basic.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  21:c:\winavr-20100110\avr\include\util\delay_basic.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  22:c:\winavr-20100110\avr\include\util\delay_basic.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  23:c:\winavr-20100110\avr\include\util\delay_basic.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  24:c:\winavr-20100110\avr\include\util\delay_basic.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  25:c:\winavr-20100110\avr\include\util\delay_basic.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  26:c:\winavr-20100110\avr\include\util\delay_basic.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  27:c:\winavr-20100110\avr\include\util\delay_basic.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  28:c:\winavr-20100110\avr\include\util\delay_basic.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  29:c:\winavr-20100110\avr\include\util\delay_basic.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  30:c:\winavr-20100110\avr\include\util\delay_basic.h ****   POSSIBILITY OF SUCH DAMAGE. */
  31:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  32:c:\winavr-20100110\avr\include\util\delay_basic.h **** /* $Id$ */
  33:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  34:c:\winavr-20100110\avr\include\util\delay_basic.h **** #ifndef _UTIL_DELAY_BASIC_H_
  35:c:\winavr-20100110\avr\include\util\delay_basic.h **** #define _UTIL_DELAY_BASIC_H_ 1
  36:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  37:c:\winavr-20100110\avr\include\util\delay_basic.h **** #include <inttypes.h>
  38:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  39:c:\winavr-20100110\avr\include\util\delay_basic.h **** #if !defined(__DOXYGEN__)
  40:c:\winavr-20100110\avr\include\util\delay_basic.h **** static __inline__ void _delay_loop_1(uint8_t __count) __attribute__((__always_inline__));
  41:c:\winavr-20100110\avr\include\util\delay_basic.h **** static __inline__ void _delay_loop_2(uint16_t __count) __attribute__((__always_inline__));
  42:c:\winavr-20100110\avr\include\util\delay_basic.h **** #endif
  43:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  44:c:\winavr-20100110\avr\include\util\delay_basic.h **** /** \file */
  45:c:\winavr-20100110\avr\include\util\delay_basic.h **** /** \defgroup util_delay_basic <util/delay_basic.h>: Basic busy-wait delay loops
  46:c:\winavr-20100110\avr\include\util\delay_basic.h ****     \code
  47:c:\winavr-20100110\avr\include\util\delay_basic.h ****     #include <util/delay_basic.h>
  48:c:\winavr-20100110\avr\include\util\delay_basic.h ****     \endcode
  49:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  50:c:\winavr-20100110\avr\include\util\delay_basic.h ****     The functions in this header file implement simple delay loops
  51:c:\winavr-20100110\avr\include\util\delay_basic.h ****     that perform a busy-waiting.  They are typically used to
  52:c:\winavr-20100110\avr\include\util\delay_basic.h ****     facilitate short delays in the program execution.  They are
  53:c:\winavr-20100110\avr\include\util\delay_basic.h ****     implemented as count-down loops with a well-known CPU cycle
  54:c:\winavr-20100110\avr\include\util\delay_basic.h ****     count per loop iteration.  As such, no other processing can
  55:c:\winavr-20100110\avr\include\util\delay_basic.h ****     occur simultaneously.  It should be kept in mind that the
  56:c:\winavr-20100110\avr\include\util\delay_basic.h ****     functions described here do not disable interrupts.
  57:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  58:c:\winavr-20100110\avr\include\util\delay_basic.h ****     In general, for long delays, the use of hardware timers is
  59:c:\winavr-20100110\avr\include\util\delay_basic.h ****     much preferrable, as they free the CPU, and allow for
  60:c:\winavr-20100110\avr\include\util\delay_basic.h ****     concurrent processing of other events while the timer is
  61:c:\winavr-20100110\avr\include\util\delay_basic.h ****     running.  However, in particular for very short delays, the
  62:c:\winavr-20100110\avr\include\util\delay_basic.h ****     overhead of setting up a hardware timer is too much compared
  63:c:\winavr-20100110\avr\include\util\delay_basic.h ****     to the overall delay time.
  64:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  65:c:\winavr-20100110\avr\include\util\delay_basic.h ****     Two inline functions are provided for the actual delay algorithms.
  66:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  67:c:\winavr-20100110\avr\include\util\delay_basic.h **** */
  68:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  69:c:\winavr-20100110\avr\include\util\delay_basic.h **** /** \ingroup util_delay_basic
  70:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  71:c:\winavr-20100110\avr\include\util\delay_basic.h ****     Delay loop using an 8-bit counter \c __count, so up to 256
  72:c:\winavr-20100110\avr\include\util\delay_basic.h ****     iterations are possible.  (The value 256 would have to be passed
  73:c:\winavr-20100110\avr\include\util\delay_basic.h ****     as 0.)  The loop executes three CPU cycles per iteration, not
  74:c:\winavr-20100110\avr\include\util\delay_basic.h ****     including the overhead the compiler needs to setup the counter
  75:c:\winavr-20100110\avr\include\util\delay_basic.h ****     register.
  76:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  77:c:\winavr-20100110\avr\include\util\delay_basic.h ****     Thus, at a CPU speed of 1 MHz, delays of up to 768 microseconds
  78:c:\winavr-20100110\avr\include\util\delay_basic.h ****     can be achieved.
  79:c:\winavr-20100110\avr\include\util\delay_basic.h **** */
  80:c:\winavr-20100110\avr\include\util\delay_basic.h **** void
  81:c:\winavr-20100110\avr\include\util\delay_basic.h **** _delay_loop_1(uint8_t __count)
  82:c:\winavr-20100110\avr\include\util\delay_basic.h **** {
  83:c:\winavr-20100110\avr\include\util\delay_basic.h **** 	__asm__ volatile (
  84:c:\winavr-20100110\avr\include\util\delay_basic.h **** 		"1: dec %0" "\n\t"
  85:c:\winavr-20100110\avr\include\util\delay_basic.h **** 		"brne 1b"
  86:c:\winavr-20100110\avr\include\util\delay_basic.h **** 		: "=r" (__count)
  87:c:\winavr-20100110\avr\include\util\delay_basic.h **** 		: "0" (__count)
  88:c:\winavr-20100110\avr\include\util\delay_basic.h **** 	);
  89:c:\winavr-20100110\avr\include\util\delay_basic.h **** }
  90:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  91:c:\winavr-20100110\avr\include\util\delay_basic.h **** /** \ingroup util_delay_basic
  92:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  93:c:\winavr-20100110\avr\include\util\delay_basic.h ****     Delay loop using a 16-bit counter \c __count, so up to 65536
  94:c:\winavr-20100110\avr\include\util\delay_basic.h ****     iterations are possible.  (The value 65536 would have to be
  95:c:\winavr-20100110\avr\include\util\delay_basic.h ****     passed as 0.)  The loop executes four CPU cycles per iteration,
  96:c:\winavr-20100110\avr\include\util\delay_basic.h ****     not including the overhead the compiler requires to setup the
  97:c:\winavr-20100110\avr\include\util\delay_basic.h ****     counter register pair.
  98:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  99:c:\winavr-20100110\avr\include\util\delay_basic.h ****     Thus, at a CPU speed of 1 MHz, delays of up to about 262.1
 100:c:\winavr-20100110\avr\include\util\delay_basic.h ****     milliseconds can be achieved.
 101:c:\winavr-20100110\avr\include\util\delay_basic.h ****  */
 102:c:\winavr-20100110\avr\include\util\delay_basic.h **** void
 103:c:\winavr-20100110\avr\include\util\delay_basic.h **** _delay_loop_2(uint16_t __count)
 104:c:\winavr-20100110\avr\include\util\delay_basic.h **** {
 105:c:\winavr-20100110\avr\include\util\delay_basic.h **** 	__asm__ volatile (
 3717               		.loc 4 105 0
 3718 063e 8FEF      		ldi r24,lo8(-1)
 3719 0640 9FEF      		ldi r25,lo8(-1)
 3720               	/* #APP */
 3721               	 ;  105 "c:\winavr-20100110\avr\include\util\delay_basic.h" 1
 3722 0642 0197      		1: sbiw r24,1
 3723 0644 01F4      		brne 1b
 3724               	 ;  0 "" 2
 3725               	.LVL446:
 3726               	/* #NOAPP */
 3727 0646 00C0      		rjmp .L97
 3728               	.LBE137:
 3729               	.LBE136:
 3730               	.LBE135:
 3731               		.cfi_endproc
 3732               	.LFE47:
 3734               		.comm	flashChipIdBuffer,2,1
 3735               		.comm	eepromBuffer,8,1
 3736               		.comm	receivedChar,1,1
 3737               		.comm	receivedBuffer,129,1
 3738               		.text
 3739               	.Letext0:
 3740               		.file 5 "c:\\winavr-20100110\\avr\\include\\stdint.h"
 3741               		.file 6 "c:\\winavr-20100110\\avr\\include\\stdlib.h"
DEFINED SYMBOLS
                            *ABS*:00000000 main.c
C:\Users\Alex\AppData\Local\Temp\ccsoCHMU.s:2      *ABS*:0000003e __SP_H__
C:\Users\Alex\AppData\Local\Temp\ccsoCHMU.s:3      *ABS*:0000003d __SP_L__
C:\Users\Alex\AppData\Local\Temp\ccsoCHMU.s:4      *ABS*:0000003f __SREG__
C:\Users\Alex\AppData\Local\Temp\ccsoCHMU.s:5      *ABS*:00000000 __tmp_reg__
C:\Users\Alex\AppData\Local\Temp\ccsoCHMU.s:6      *ABS*:00000001 __zero_reg__
C:\Users\Alex\AppData\Local\Temp\ccsoCHMU.s:12     .text:00000000 USART_Receive
C:\Users\Alex\AppData\Local\Temp\ccsoCHMU.s:34     .text:00000008 USART_Transmit
C:\Users\Alex\AppData\Local\Temp\ccsoCHMU.s:55     .text:00000010 usart_read_bytes
                            *COM*:00000081 receivedBuffer
C:\Users\Alex\AppData\Local\Temp\ccsoCHMU.s:118    .text:0000003a usart_read_chars
C:\Users\Alex\AppData\Local\Temp\ccsoCHMU.s:162    .text:00000056 rd_wr_csmreq_cs2_reset
C:\Users\Alex\AppData\Local\Temp\ccsoCHMU.s:184    .text:00000060 gb_mode
C:\Users\Alex\AppData\Local\Temp\ccsoCHMU.s:211    .text:00000070 set_16bit_address
C:\Users\Alex\AppData\Local\Temp\ccsoCHMU.s:230    .text:00000076 read_8bit_data
C:\Users\Alex\AppData\Local\Temp\ccsoCHMU.s:270    .text:00000088 write_8bit_data
C:\Users\Alex\AppData\Local\Temp\ccsoCHMU.s:335    .text:000000b4 gba_mode
C:\Users\Alex\AppData\Local\Temp\ccsoCHMU.s:362    .text:000000c4 gba_set_24bit_address
C:\Users\Alex\AppData\Local\Temp\ccsoCHMU.s:415    .text:000000f0 gba_read_16bit_data
C:\Users\Alex\AppData\Local\Temp\ccsoCHMU.s:463    .text:0000010e gba_read_ram_8bit_data
C:\Users\Alex\AppData\Local\Temp\ccsoCHMU.s:503    .text:00000120 gba_write_ram_8bit_data
C:\Users\Alex\AppData\Local\Temp\ccsoCHMU.s:557    .text:00000140 gba_eeprom_mode
C:\Users\Alex\AppData\Local\Temp\ccsoCHMU.s:585    .text:00000152 gba_eeprom_set_address
C:\Users\Alex\AppData\Local\Temp\ccsoCHMU.s:724    .text:000001ba gba_eeprom_read
                            *COM*:00000008 eepromBuffer
C:\Users\Alex\AppData\Local\Temp\ccsoCHMU.s:856    .text:00000214 gba_eeprom_write
C:\Users\Alex\AppData\Local\Temp\ccsoCHMU.s:972    .text:00000268 flash_write_bus_cycle
C:\Users\Alex\AppData\Local\Temp\ccsoCHMU.s:1018   .text:00000282 flash_read_chip_id
                            *COM*:00000002 flashChipIdBuffer
C:\Users\Alex\AppData\Local\Temp\ccsoCHMU.s:1123   .text:000002ec flash_switch_bank
C:\Users\Alex\AppData\Local\Temp\ccsoCHMU.s:1172   .text:00000312 flash_erase_4k_sector
C:\Users\Alex\AppData\Local\Temp\ccsoCHMU.s:1247   .text:0000035a flash_write_byte
C:\Users\Alex\AppData\Local\Temp\ccsoCHMU.s:1318   .text:00000392 flash_write_sector
C:\Users\Alex\AppData\Local\Temp\ccsoCHMU.s:1431   .text:000003fe gb_flash_read_byte
C:\Users\Alex\AppData\Local\Temp\ccsoCHMU.s:1471   .text:00000410 audio_flash_write_bus_cycle
C:\Users\Alex\AppData\Local\Temp\ccsoCHMU.s:1521   .text:0000042a audio_flash_write_byte
C:\Users\Alex\AppData\Local\Temp\ccsoCHMU.s:1621   .text:0000047c bv5_flash_write_bus_cycle
C:\Users\Alex\AppData\Local\Temp\ccsoCHMU.s:1671   .text:00000496 gb_wr_flash_write_byte
C:\Users\Alex\AppData\Local\Temp\ccsoCHMU.s:1771   .text:000004e8 gb_wr_flash_write_bus_cycle
C:\Users\Alex\AppData\Local\Temp\ccsoCHMU.s:1784   .text:000004ea bv5_flash_write_byte
C:\Users\Alex\AppData\Local\Temp\ccsoCHMU.s:1881   .text:00000538 gb_word_flash_write_byte
C:\Users\Alex\AppData\Local\Temp\ccsoCHMU.s:1977   .text:00000586 gba_flash_write_bus_cycle
C:\Users\Alex\AppData\Local\Temp\ccsoCHMU.s:2040   .text:000005ac gba_flash_write_byte_swapped
C:\Users\Alex\AppData\Local\Temp\ccsoCHMU.s:2164   .text:00000622 setup
C:\Users\Alex\AppData\Local\Temp\ccsoCHMU.s:2259   .text.startup:00000000 main
                            *COM*:00000001 receivedChar

UNDEFINED SYMBOLS
strtol
atoi
__do_clear_bss
