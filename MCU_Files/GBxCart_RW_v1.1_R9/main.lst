   1               		.file	"main.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               	.global	USART_Receive
  12               	USART_Receive:
  13               	.LFB12:
  14               		.file 1 "setup.c"
   1:setup.c       **** /*
   2:setup.c       ****  GBxCart RW
   3:setup.c       ****  PCB version: 1.1 or 1.2
   4:setup.c       ****  Firmware version: R9
   5:setup.c       ****  Author: Alex from insideGadgets (www.insidegadgets.com)
   6:setup.c       ****  Created: 7/11/2016
   7:setup.c       ****  Last Modified: 19/03/2018
   8:setup.c       ****  
   9:setup.c       ****  */
  10:setup.c       ****  
  11:setup.c       **** #ifndef cbi
  12:setup.c       **** #define cbi(sfr, bit) (_SFR_BYTE(sfr) &= ~_BV(bit))
  13:setup.c       **** #endif
  14:setup.c       **** #ifndef sbi
  15:setup.c       **** #define sbi(sfr, bit) (_SFR_BYTE(sfr) |= _BV(bit))
  16:setup.c       **** #endif
  17:setup.c       **** 
  18:setup.c       **** #ifndef NULL
  19:setup.c       **** #define NULL ((void *)0)
  20:setup.c       **** #endif
  21:setup.c       **** 
  22:setup.c       **** #define LOW 0
  23:setup.c       **** #define HIGH 1
  24:setup.c       **** #define false 0
  25:setup.c       **** #define true 1
  26:setup.c       **** 
  27:setup.c       **** #define SWITCH_DETECT PD2
  28:setup.c       **** #define ACTIVITY_LED PD3
  29:setup.c       **** #define LED_5V PD7
  30:setup.c       **** #define LED_3V PE0
  31:setup.c       **** 
  32:setup.c       **** #define WR_PIN PD6
  33:setup.c       **** #define RD_PIN PD5
  34:setup.c       **** #define CS_MREQ_PIN PD4
  35:setup.c       **** #define CS2_PIN PE2
  36:setup.c       **** #define AUDIO_PIN PE1
  37:setup.c       **** 
  38:setup.c       **** #define wrPin_high	PORTD |= (1<<WR_PIN);
  39:setup.c       **** #define wrPin_low		PORTD &= ~(1<<WR_PIN);
  40:setup.c       **** #define rdPin_high	PORTD |= (1<<RD_PIN);
  41:setup.c       **** #define rdPin_low		PORTD &= ~(1<<RD_PIN);
  42:setup.c       **** #define cs_mreqPin_high		PORTD |= (1<<CS_MREQ_PIN);
  43:setup.c       **** #define cs_mreqPin_low		PORTD &= ~(1<<CS_MREQ_PIN);
  44:setup.c       **** #define cs2Pin_high		PORTE |= (1<<CS2_PIN);
  45:setup.c       **** #define cs2Pin_low		PORTE &= ~(1<<CS2_PIN);
  46:setup.c       **** #define audioPin_high	PORTE |= (1<<AUDIO_PIN);
  47:setup.c       **** #define audioPin_low		PORTE &= ~(1<<AUDIO_PIN);
  48:setup.c       **** 
  49:setup.c       **** #define GB_MODE 1
  50:setup.c       **** #define GBA_MODE 2
  51:setup.c       **** 
  52:setup.c       **** // GB/GBC
  53:setup.c       **** #define PORT_ADDR7_0 PORTB
  54:setup.c       **** #define PORT_ADDR15_8 PORTA
  55:setup.c       **** #define PORT_DATA7_0 PORTC
  56:setup.c       **** 
  57:setup.c       **** #define DDR_ADDR7_0 DDRB
  58:setup.c       **** #define DDR_ADDR15_8 DDRA
  59:setup.c       **** #define DDR_DATA7_0 DDRC
  60:setup.c       **** 
  61:setup.c       **** #define PIN_ADDR7_0 PINB
  62:setup.c       **** #define PIN_ADDR15_8 PINA
  63:setup.c       **** #define PIN_DATA7_0 PINC
  64:setup.c       **** 
  65:setup.c       **** #define BANK_WRITE 0
  66:setup.c       **** #define MEMORY_WRITE 1
  67:setup.c       **** 
  68:setup.c       **** // GBA
  69:setup.c       **** #define EEPROM_WRITE 1
  70:setup.c       **** #define EEPROM_READ 0
  71:setup.c       **** 
  72:setup.c       **** #define EEPROM_NONE 0
  73:setup.c       **** #define EEPROM_4KBIT 1
  74:setup.c       **** #define EEPROM_64KBIT 2
  75:setup.c       **** 
  76:setup.c       **** #define AD0 PB0
  77:setup.c       **** #define ad0Pin_high		PORTB |= (1<<AD0);
  78:setup.c       **** #define ad0Pin_low		PORTB &= ~(1<<AD0);
  79:setup.c       **** 
  80:setup.c       **** #define A23 PC7
  81:setup.c       **** #define a23Pin_high		PORTC |= (1<<A23);
  82:setup.c       **** #define a23Pin_low		PORTC &= ~(1<<A23);
  83:setup.c       **** 
  84:setup.c       **** #define GBA_DDR_ROM_ADDR7_0 DDRB
  85:setup.c       **** #define GBA_DDR_ROM_ADDR15_8 DDRA
  86:setup.c       **** #define GBA_DDR_ROM_ADDR23_16 DDRC
  87:setup.c       **** #define GBA_DDR_ROM_DATA7_0 DDRB
  88:setup.c       **** #define GBA_DDR_ROM_DATA15_8 DDRA
  89:setup.c       **** #define GBA_DDR_RAM_DATA7_0 DDRC
  90:setup.c       **** #define GBA_DDR_EEPROM_DATA7_0 DDRB
  91:setup.c       **** 
  92:setup.c       **** #define GBA_PORT_ROM_ADDR7_0 PORTB
  93:setup.c       **** #define GBA_PORT_ROM_ADDR15_8 PORTA
  94:setup.c       **** #define GBA_PORT_ROM_ADDR23_16 PORTC
  95:setup.c       **** #define GBA_PORT_ROM_DATA7_0 PORTB
  96:setup.c       **** #define GBA_PORT_ROM_DATA15_8 PORTA
  97:setup.c       **** #define GBA_PORT_RAM_DATA7_0 PORTC
  98:setup.c       **** #define GBA_PORT_EEPROM_DATA7_0 PORTB
  99:setup.c       **** 
 100:setup.c       **** #define GBA_PIN_ROM_DATA7_0 PINB
 101:setup.c       **** #define GBA_PIN_ROM_DATA15_8 PINA
 102:setup.c       **** #define GBA_PIN_RAM_DATA7_0 PINC
 103:setup.c       **** #define GBA_PIN_EEPROM_DATA7_0 PINB
 104:setup.c       **** 
 105:setup.c       **** // GB/GBC commands
 106:setup.c       **** #define SET_START_ADDRESS 'A'
 107:setup.c       **** #define READ_ROM_RAM 'R'
 108:setup.c       **** #define WRITE_RAM 'W'
 109:setup.c       **** #define SET_BANK 'B'
 110:setup.c       **** #define GB_CART_MODE 'G'
 111:setup.c       **** 
 112:setup.c       **** // GBA commands
 113:setup.c       **** #define GBA_READ_ROM 'r'
 114:setup.c       **** #define GBA_READ_SRAM 'm'
 115:setup.c       **** #define GBA_WRITE_SRAM 'w'
 116:setup.c       **** #define GBA_WRITE_ONE_BYTE_SRAM 'o'
 117:setup.c       **** #define GBA_CART_MODE 'g'
 118:setup.c       **** 
 119:setup.c       **** #define GBA_FLASH_READ_ID 'i'
 120:setup.c       **** #define GBA_FLASH_SET_BANK 'k'
 121:setup.c       **** #define GBA_FLASH_4K_SECTOR_ERASE 's'
 122:setup.c       **** #define GBA_FLASH_WRITE_BYTE 'b'
 123:setup.c       **** #define GBA_FLASH_WRITE_ATMEL 'a'
 124:setup.c       **** 
 125:setup.c       **** #define GBA_SET_EEPROM_SIZE 'S'
 126:setup.c       **** #define GBA_READ_EEPROM 'e'
 127:setup.c       **** #define GBA_WRITE_EEPROM 'p'
 128:setup.c       **** 
 129:setup.c       **** // Flash Cart commands
 130:setup.c       **** #define GB_FLASH_WE_PIN 'P'
 131:setup.c       **** 	#define WE_AS_AUDIO_PIN 'A'
 132:setup.c       **** 	#define WE_AS_WR_PIN 'W'
 133:setup.c       **** 
 134:setup.c       **** #define GB_FLASH_PROGRAM_METHOD 'E'
 135:setup.c       **** 	#define GB_FLASH_PROGRAM_555 0
 136:setup.c       **** 	#define GB_FLASH_PROGRAM_AAA 1
 137:setup.c       **** 	#define GB_FLASH_PROGRAM_555_BIT01_SWAPPED 2
 138:setup.c       **** 	#define GB_FLASH_PROGRAM_AAA_BIT01_SWAPPED 3
 139:setup.c       **** 	#define GB_FLASH_PROGRAM_5555 4
 140:setup.c       **** 
 141:setup.c       **** #define GB_FLASH_WRITE_BYTE 'F'
 142:setup.c       **** #define GB_FLASH_WRITE_64BYTE 'T'
 143:setup.c       **** 
 144:setup.c       **** #define GBA_FLASH_CART_WRITE_BYTE 'n'
 145:setup.c       **** #define GBA_FLASH_WRITE_64BYTE 'q'
 146:setup.c       **** 
 147:setup.c       **** // General commands
 148:setup.c       **** #define SEND_ACK '1'
 149:setup.c       **** #define CART_MODE 'C'
 150:setup.c       **** #define SET_INPUT 'I'
 151:setup.c       **** #define SET_OUTPUT 'O'
 152:setup.c       **** #define SET_OUTPUT_LOW 'L'
 153:setup.c       **** #define SET_OUTPUT_HIGH 'H'
 154:setup.c       **** #define READ_INPUT 'D'
 155:setup.c       **** #define RESET_COMMON_LINES 'M'
 156:setup.c       **** #define READ_FIRMWARE_VERSION 'V'
 157:setup.c       **** #define READ_PCB_VERSION 'h'
 158:setup.c       **** 
 159:setup.c       **** #define RESET_AVR '*'
 160:setup.c       **** #define RESET_VALUE 0x7E5E1
 161:setup.c       **** 
 162:setup.c       **** 
 163:setup.c       **** char receivedBuffer[129];
 164:setup.c       **** char receivedChar;
 165:setup.c       **** uint8_t eepromBuffer[8];
 166:setup.c       **** uint8_t flashChipIdBuffer[2];
 167:setup.c       **** 
 168:setup.c       **** char flashWriteWePin;
 169:setup.c       **** uint16_t flashWriteCycle[3][2];
 170:setup.c       **** 
 171:setup.c       **** 
 172:setup.c       **** // Receive USART data
 173:setup.c       **** uint8_t USART_Receive(void) {
  15               		.loc 1 173 0
  16               		.cfi_startproc
  17               	/* prologue: function */
  18               	/* frame size = 0 */
  19               	/* stack size = 0 */
  20               	.L__stack_usage = 0
  21               	.L2:
 174:setup.c       **** 	while ( !(UCSRA & (1<<RXC)) ); // Wait for data to be received
  22               		.loc 1 174 0 discriminator 1
  23 0000 5F9B      		sbis 0xb,7
  24 0002 00C0      		rjmp .L2
 175:setup.c       **** 	return UDR; // Get and return received data from buffer
  25               		.loc 1 175 0
  26 0004 8CB1      		in r24,0xc
 176:setup.c       **** }
  27               		.loc 1 176 0
  28 0006 0895      		ret
  29               		.cfi_endproc
  30               	.LFE12:
  32               	.global	USART_Transmit
  34               	USART_Transmit:
  35               	.LFB13:
 177:setup.c       **** 
 178:setup.c       **** // Transmit USART data
 179:setup.c       **** void USART_Transmit(unsigned char data) {
  36               		.loc 1 179 0
  37               		.cfi_startproc
  38               	/* prologue: function */
  39               	/* frame size = 0 */
  40               	/* stack size = 0 */
  41               	.L__stack_usage = 0
  42               	.LVL0:
  43               	.L6:
 180:setup.c       **** 	while ( !( UCSRA & (1<<UDRE)) ); // Wait for empty transmit buffer
  44               		.loc 1 180 0 discriminator 1
  45 0008 5D9B      		sbis 0xb,5
  46 000a 00C0      		rjmp .L6
 181:setup.c       **** 	UDR = data;
  47               		.loc 1 181 0
  48 000c 8CB9      		out 0xc,r24
  49 000e 0895      		ret
  50               		.cfi_endproc
  51               	.LFE13:
  53               	.global	usart_read_bytes
  55               	usart_read_bytes:
  56               	.LFB14:
 182:setup.c       **** }
 183:setup.c       **** 
 184:setup.c       **** // Read 1-128 bytes from the USART 
 185:setup.c       **** void usart_read_bytes(uint8_t count) {
  57               		.loc 1 185 0
  58               		.cfi_startproc
  59               	.LVL1:
  60 0010 0F93      		push r16
  61               	.LCFI0:
  62               		.cfi_def_cfa_offset 3
  63               		.cfi_offset 16, -2
  64 0012 1F93      		push r17
  65               	.LCFI1:
  66               		.cfi_def_cfa_offset 4
  67               		.cfi_offset 17, -3
  68 0014 CF93      		push r28
  69               	.LCFI2:
  70               		.cfi_def_cfa_offset 5
  71               		.cfi_offset 28, -4
  72 0016 DF93      		push r29
  73               	.LCFI3:
  74               		.cfi_def_cfa_offset 6
  75               		.cfi_offset 29, -5
  76               	/* prologue: function */
  77               	/* frame size = 0 */
  78               	/* stack size = 4 */
  79               	.L__stack_usage = 4
  80 0018 D82F      		mov r29,r24
  81               	.LVL2:
  82 001a 00E0      		ldi r16,lo8(receivedBuffer)
  83 001c 10E0      		ldi r17,hi8(receivedBuffer)
  84               	.LBB54:
 186:setup.c       **** 	for (uint8_t x = 0; x < count; x++) {
  85               		.loc 1 186 0
  86 001e C0E0      		ldi r28,0
  87               	.LVL3:
  88               	.L10:
  89               		.loc 1 186 0 is_stmt 0 discriminator 1
  90 0020 CD17      		cp r28,r29
  91 0022 01F0      		breq .L12
 187:setup.c       **** 		receivedBuffer[x] = USART_Receive();
  92               		.loc 1 187 0 is_stmt 1 discriminator 3
  93 0024 00D0      		rcall USART_Receive
  94               	.LVL4:
  95 0026 F801      		movw r30,r16
  96 0028 8193      		st Z+,r24
  97 002a 8F01      		movw r16,r30
 186:setup.c       **** 	for (uint8_t x = 0; x < count; x++) {
  98               		.loc 1 186 0 discriminator 3
  99 002c CF5F      		subi r28,lo8(-(1))
 100               	.LVL5:
 101 002e 00C0      		rjmp .L10
 102               	.L12:
 103               	/* epilogue start */
 104               	.LBE54:
 188:setup.c       **** 	}
 189:setup.c       **** }
 105               		.loc 1 189 0
 106 0030 DF91      		pop r29
 107               	.LVL6:
 108 0032 CF91      		pop r28
 109               	.LVL7:
 110 0034 1F91      		pop r17
 111 0036 0F91      		pop r16
 112 0038 0895      		ret
 113               		.cfi_endproc
 114               	.LFE14:
 116               	.global	usart_read_chars
 118               	usart_read_chars:
 119               	.LFB15:
 190:setup.c       **** 
 191:setup.c       **** // Read the USART until a 0 (string terminator byte) is received
 192:setup.c       **** void usart_read_chars(void) {
 120               		.loc 1 192 0
 121               		.cfi_startproc
 122 003a CF93      		push r28
 123               	.LCFI4:
 124               		.cfi_def_cfa_offset 3
 125               		.cfi_offset 28, -2
 126               	/* prologue: function */
 127               	/* frame size = 0 */
 128               	/* stack size = 1 */
 129               	.L__stack_usage = 1
 130               	.LVL8:
 193:setup.c       **** 	uint8_t x = 0;
 131               		.loc 1 193 0
 132 003c C0E0      		ldi r28,0
 133               	.LVL9:
 134               	.L15:
 194:setup.c       **** 	while (1) {
 195:setup.c       **** 		receivedBuffer[x] = USART_Receive();
 135               		.loc 1 195 0
 136 003e 00D0      		rcall USART_Receive
 137               	.LVL10:
 138 0040 EC2F      		mov r30,r28
 139 0042 F0E0      		ldi r31,0
 140 0044 E050      		subi r30,lo8(-(receivedBuffer))
 141 0046 F040      		sbci r31,hi8(-(receivedBuffer))
 142 0048 8083      		st Z,r24
 196:setup.c       **** 		if (receivedBuffer[x] == 0) {
 143               		.loc 1 196 0
 144 004a 8823      		tst r24
 145 004c 01F0      		breq .L13
 197:setup.c       **** 			break;
 198:setup.c       **** 		}
 199:setup.c       **** 		x++;
 146               		.loc 1 199 0
 147 004e CF5F      		subi r28,lo8(-(1))
 148               	.LVL11:
 200:setup.c       **** 	}
 149               		.loc 1 200 0
 150 0050 00C0      		rjmp .L15
 151               	.L13:
 152               	/* epilogue start */
 201:setup.c       **** }
 153               		.loc 1 201 0
 154 0052 CF91      		pop r28
 155               	.LVL12:
 156 0054 0895      		ret
 157               		.cfi_endproc
 158               	.LFE15:
 160               	.global	rd_wr_csmreq_cs2_reset
 162               	rd_wr_csmreq_cs2_reset:
 163               	.LFB16:
 202:setup.c       **** 
 203:setup.c       **** // Turn RD, WR, CS/MREQ and CS2 to high so they are deselected (reset state)
 204:setup.c       **** void rd_wr_csmreq_cs2_reset(void) {
 164               		.loc 1 204 0
 165               		.cfi_startproc
 166               	/* prologue: function */
 167               	/* frame size = 0 */
 168               	/* stack size = 0 */
 169               	.L__stack_usage = 0
 205:setup.c       **** 	cs2Pin_high; // CS2 off
 170               		.loc 1 205 0
 171 0056 3A9A      		sbi 0x7,2
 206:setup.c       **** 	cs_mreqPin_high; // CS/MREQ off
 172               		.loc 1 206 0
 173 0058 949A      		sbi 0x12,4
 207:setup.c       **** 	rdPin_high; // RD off
 174               		.loc 1 207 0
 175 005a 959A      		sbi 0x12,5
 208:setup.c       **** 	wrPin_high; // WR off
 176               		.loc 1 208 0
 177 005c 969A      		sbi 0x12,6
 178 005e 0895      		ret
 179               		.cfi_endproc
 180               	.LFE16:
 182               	.global	gb_mode
 184               	gb_mode:
 185               	.LFB17:
 209:setup.c       **** }
 210:setup.c       **** 
 211:setup.c       **** 
 212:setup.c       **** 
 213:setup.c       **** // ****** Gameboy / Gameboy Colour functions ******
 214:setup.c       **** 
 215:setup.c       **** // Set Gameboy mode
 216:setup.c       **** void gb_mode(void) {
 186               		.loc 1 216 0
 187               		.cfi_startproc
 188               	/* prologue: function */
 189               	/* frame size = 0 */
 190               	/* stack size = 0 */
 191               	.L__stack_usage = 0
 217:setup.c       **** 	// Set inputs
 218:setup.c       **** 	PORT_DATA7_0 = 0;
 192               		.loc 1 218 0
 193 0060 15BA      		out 0x15,__zero_reg__
 219:setup.c       **** 	DDR_DATA7_0 = 0;
 194               		.loc 1 219 0
 195 0062 14BA      		out 0x14,__zero_reg__
 220:setup.c       **** 	
 221:setup.c       **** 	// Set outputs
 222:setup.c       **** 	PORT_ADDR7_0 = 0;
 196               		.loc 1 222 0
 197 0064 18BA      		out 0x18,__zero_reg__
 223:setup.c       **** 	PORT_ADDR15_8 = 0;
 198               		.loc 1 223 0
 199 0066 1BBA      		out 0x1b,__zero_reg__
 224:setup.c       **** 	DDR_ADDR7_0 = 0xFF;
 200               		.loc 1 224 0
 201 0068 8FEF      		ldi r24,lo8(-1)
 202 006a 87BB      		out 0x17,r24
 225:setup.c       **** 	DDR_ADDR15_8 = 0xFF;
 203               		.loc 1 225 0
 204 006c 8ABB      		out 0x1a,r24
 205 006e 0895      		ret
 206               		.cfi_endproc
 207               	.LFE17:
 209               	.global	set_16bit_address
 211               	set_16bit_address:
 212               	.LFB18:
 226:setup.c       **** }
 227:setup.c       **** 
 228:setup.c       **** // Set the 16 bit address on A15-0
 229:setup.c       **** void set_16bit_address(uint16_t address) {
 213               		.loc 1 229 0
 214               		.cfi_startproc
 215               	.LVL13:
 216               	/* prologue: function */
 217               	/* frame size = 0 */
 218               	/* stack size = 0 */
 219               	.L__stack_usage = 0
 230:setup.c       **** 	PORT_ADDR15_8 = (address >> 8);
 220               		.loc 1 230 0
 221 0070 9BBB      		out 0x1b,r25
 231:setup.c       **** 	PORT_ADDR7_0 = (address & 0xFF);
 222               		.loc 1 231 0
 223 0072 88BB      		out 0x18,r24
 224 0074 0895      		ret
 225               		.cfi_endproc
 226               	.LFE18:
 228               	.global	read_8bit_data
 230               	read_8bit_data:
 231               	.LFB19:
 232:setup.c       **** }
 233:setup.c       **** 
 234:setup.c       **** // Set the address and read a byte from the 8 bit data line
 235:setup.c       **** uint8_t read_8bit_data(uint16_t address) {
 232               		.loc 1 235 0
 233               		.cfi_startproc
 234               	.LVL14:
 235               	/* prologue: function */
 236               	/* frame size = 0 */
 237               	/* stack size = 0 */
 238               	.L__stack_usage = 0
 236:setup.c       **** 	set_16bit_address(address);
 239               		.loc 1 236 0
 240 0076 00D0      		rcall set_16bit_address
 241               	.LVL15:
 237:setup.c       **** 	
 238:setup.c       **** 	cs_mreqPin_low;
 242               		.loc 1 238 0
 243 0078 9498      		cbi 0x12,4
 239:setup.c       **** 	rdPin_low;
 244               		.loc 1 239 0
 245 007a 9598      		cbi 0x12,5
 240:setup.c       **** 	
 241:setup.c       **** 	asm volatile("nop"); // Delay a little (minimum needed is 1 nops, 2 nops for GB camera)
 246               		.loc 1 241 0
 247               	/* #APP */
 248               	 ;  241 "setup.c" 1
 249 007c 0000      		nop
 250               	 ;  0 "" 2
 242:setup.c       **** 	asm volatile("nop");
 251               		.loc 1 242 0
 252               	 ;  242 "setup.c" 1
 253 007e 0000      		nop
 254               	 ;  0 "" 2
 243:setup.c       **** 	uint8_t data = PIN_DATA7_0; // Read data
 255               		.loc 1 243 0
 256               	/* #NOAPP */
 257 0080 83B3      		in r24,0x13
 258               	.LVL16:
 244:setup.c       **** 	
 245:setup.c       **** 	rdPin_high;
 259               		.loc 1 245 0
 260 0082 959A      		sbi 0x12,5
 246:setup.c       **** 	cs_mreqPin_high;
 261               		.loc 1 246 0
 262 0084 949A      		sbi 0x12,4
 247:setup.c       **** 	
 248:setup.c       **** 	return data;
 249:setup.c       **** }
 263               		.loc 1 249 0
 264 0086 0895      		ret
 265               		.cfi_endproc
 266               	.LFE19:
 268               	.global	write_8bit_data
 270               	write_8bit_data:
 271               	.LFB20:
 250:setup.c       **** 
 251:setup.c       **** // Set the address and write a byte to the 8 bit data line and pulse cs/mREQ if writing to RAM
 252:setup.c       **** void write_8bit_data(uint16_t address, uint8_t data, uint8_t type) {
 272               		.loc 1 252 0
 273               		.cfi_startproc
 274               	.LVL17:
 275 0088 CF93      		push r28
 276               	.LCFI5:
 277               		.cfi_def_cfa_offset 3
 278               		.cfi_offset 28, -2
 279 008a DF93      		push r29
 280               	.LCFI6:
 281               		.cfi_def_cfa_offset 4
 282               		.cfi_offset 29, -3
 283               	/* prologue: function */
 284               	/* frame size = 0 */
 285               	/* stack size = 2 */
 286               	.L__stack_usage = 2
 287 008c D62F      		mov r29,r22
 288 008e C42F      		mov r28,r20
 253:setup.c       **** 	set_16bit_address(address);
 289               		.loc 1 253 0
 290 0090 00D0      		rcall set_16bit_address
 291               	.LVL18:
 254:setup.c       **** 	
 255:setup.c       **** 	DDR_DATA7_0 = 0xFF; // Set data pins as outputs
 292               		.loc 1 255 0
 293 0092 8FEF      		ldi r24,lo8(-1)
 294 0094 84BB      		out 0x14,r24
 256:setup.c       **** 	PORT_DATA7_0 = data; // Set data
 295               		.loc 1 256 0
 296 0096 D5BB      		out 0x15,r29
 257:setup.c       **** 	
 258:setup.c       **** 	// Pulse WR and mREQ if the type matches
 259:setup.c       **** 	wrPin_low;
 297               		.loc 1 259 0
 298 0098 9698      		cbi 0x12,6
 260:setup.c       **** 	if (type == MEMORY_WRITE) {
 299               		.loc 1 260 0
 300 009a C130      		cpi r28,lo8(1)
 301 009c 01F4      		brne .L21
 261:setup.c       **** 		cs_mreqPin_low;
 302               		.loc 1 261 0
 303 009e 9498      		cbi 0x12,4
 304               	.L21:
 262:setup.c       **** 	}
 263:setup.c       **** 	
 264:setup.c       **** 	asm volatile("nop");
 305               		.loc 1 264 0
 306               	/* #APP */
 307               	 ;  264 "setup.c" 1
 308 00a0 0000      		nop
 309               	 ;  0 "" 2
 265:setup.c       **** 	
 266:setup.c       **** 	if (type == MEMORY_WRITE) {
 310               		.loc 1 266 0
 311               	/* #NOAPP */
 312 00a2 C130      		cpi r28,lo8(1)
 313 00a4 01F4      		brne .L22
 267:setup.c       **** 		cs_mreqPin_high;
 314               		.loc 1 267 0
 315 00a6 949A      		sbi 0x12,4
 316               	.L22:
 268:setup.c       **** 	}
 269:setup.c       **** 	wrPin_high;
 317               		.loc 1 269 0
 318 00a8 969A      		sbi 0x12,6
 270:setup.c       **** 	
 271:setup.c       **** 	// Clear data outputs and set data pins as inputs
 272:setup.c       **** 	PORT_DATA7_0 = 0;
 319               		.loc 1 272 0
 320 00aa 15BA      		out 0x15,__zero_reg__
 273:setup.c       **** 	DDR_DATA7_0 = 0;
 321               		.loc 1 273 0
 322 00ac 14BA      		out 0x14,__zero_reg__
 323               	/* epilogue start */
 274:setup.c       **** }
 324               		.loc 1 274 0
 325 00ae DF91      		pop r29
 326               	.LVL19:
 327 00b0 CF91      		pop r28
 328               	.LVL20:
 329 00b2 0895      		ret
 330               		.cfi_endproc
 331               	.LFE20:
 333               	.global	gba_mode
 335               	gba_mode:
 336               	.LFB21:
 275:setup.c       **** 
 276:setup.c       **** 
 277:setup.c       **** 
 278:setup.c       **** // ****** Gameboy Advance functions ****** 
 279:setup.c       **** 
 280:setup.c       **** // Set GBA mode
 281:setup.c       **** void gba_mode(void) {
 337               		.loc 1 281 0
 338               		.cfi_startproc
 339               	/* prologue: function */
 340               	/* frame size = 0 */
 341               	/* stack size = 0 */
 342               	.L__stack_usage = 0
 282:setup.c       **** 	// Set outputs for reading ROM addresses as default
 283:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = 0;
 343               		.loc 1 283 0
 344 00b4 18BA      		out 0x18,__zero_reg__
 284:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = 0;
 345               		.loc 1 284 0
 346 00b6 1BBA      		out 0x1b,__zero_reg__
 285:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = 0;
 347               		.loc 1 285 0
 348 00b8 15BA      		out 0x15,__zero_reg__
 286:setup.c       **** 	GBA_DDR_ROM_ADDR7_0 = 0xFF;
 349               		.loc 1 286 0
 350 00ba 8FEF      		ldi r24,lo8(-1)
 351 00bc 87BB      		out 0x17,r24
 287:setup.c       **** 	GBA_DDR_ROM_ADDR15_8 = 0xFF;
 352               		.loc 1 287 0
 353 00be 8ABB      		out 0x1a,r24
 288:setup.c       **** 	GBA_DDR_ROM_ADDR23_16 = 0xFF;
 354               		.loc 1 288 0
 355 00c0 84BB      		out 0x14,r24
 356 00c2 0895      		ret
 357               		.cfi_endproc
 358               	.LFE21:
 360               	.global	gba_set_24bit_address
 362               	gba_set_24bit_address:
 363               	.LFB22:
 289:setup.c       **** }
 290:setup.c       **** 
 291:setup.c       **** // Set the 24 bit address on A23-0
 292:setup.c       **** void gba_set_24bit_address(uint32_t address) {	
 364               		.loc 1 292 0
 365               		.cfi_startproc
 366               	.LVL21:
 367 00c4 0F93      		push r16
 368               	.LCFI7:
 369               		.cfi_def_cfa_offset 3
 370               		.cfi_offset 16, -2
 371 00c6 1F93      		push r17
 372               	.LCFI8:
 373               		.cfi_def_cfa_offset 4
 374               		.cfi_offset 17, -3
 375               	/* prologue: function */
 376               	/* frame size = 0 */
 377               	/* stack size = 2 */
 378               	.L__stack_usage = 2
 293:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = 0; // Set 0-23 address lines low and set as outputs
 379               		.loc 1 293 0
 380 00c8 15BA      		out 0x15,__zero_reg__
 294:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = 0;
 381               		.loc 1 294 0
 382 00ca 1BBA      		out 0x1b,__zero_reg__
 295:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = 0;
 383               		.loc 1 295 0
 384 00cc 18BA      		out 0x18,__zero_reg__
 296:setup.c       **** 	GBA_DDR_ROM_ADDR23_16 = 0xFF;
 385               		.loc 1 296 0
 386 00ce 2FEF      		ldi r18,lo8(-1)
 387 00d0 24BB      		out 0x14,r18
 297:setup.c       **** 	GBA_DDR_ROM_ADDR15_8 = 0xFF;
 388               		.loc 1 297 0
 389 00d2 2ABB      		out 0x1a,r18
 298:setup.c       **** 	GBA_DDR_ROM_ADDR7_0 = 0xFF;
 390               		.loc 1 298 0
 391 00d4 27BB      		out 0x17,r18
 299:setup.c       **** 	
 300:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = (address >> 16);
 392               		.loc 1 300 0
 393 00d6 8C01      		movw r16,r24
 394 00d8 2227      		clr r18
 395 00da 3327      		clr r19
 396 00dc 05BB      		out 0x15,r16
 301:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = (address >> 8);
 397               		.loc 1 301 0
 398 00de 072F      		mov r16,r23
 399 00e0 182F      		mov r17,r24
 400 00e2 292F      		mov r18,r25
 401 00e4 3327      		clr r19
 402 00e6 0BBB      		out 0x1b,r16
 302:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = (address & 0xFF);
 403               		.loc 1 302 0
 404 00e8 68BB      		out 0x18,r22
 405               	/* epilogue start */
 303:setup.c       **** }
 406               		.loc 1 303 0
 407 00ea 1F91      		pop r17
 408 00ec 0F91      		pop r16
 409 00ee 0895      		ret
 410               		.cfi_endproc
 411               	.LFE22:
 413               	.global	gba_read_16bit_data
 415               	gba_read_16bit_data:
 416               	.LFB23:
 304:setup.c       **** 
 305:setup.c       **** 
 306:setup.c       **** 
 307:setup.c       **** // ---------- ROM/SRAM ----------
 308:setup.c       **** 
 309:setup.c       **** // Read a byte from the 16 bit data line non-sequentially
 310:setup.c       **** uint16_t gba_read_16bit_data(uint32_t address) {
 417               		.loc 1 310 0
 418               		.cfi_startproc
 419               	.LVL22:
 420               	/* prologue: function */
 421               	/* frame size = 0 */
 422               	/* stack size = 0 */
 423               	.L__stack_usage = 0
 311:setup.c       **** 	gba_set_24bit_address(address);
 424               		.loc 1 311 0
 425 00f0 00D0      		rcall gba_set_24bit_address
 426               	.LVL23:
 312:setup.c       **** 	
 313:setup.c       **** 	cs_mreqPin_low;
 427               		.loc 1 313 0
 428 00f2 9498      		cbi 0x12,4
 314:setup.c       **** 	
 315:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = 0; // Set address lines low and set as inputs
 429               		.loc 1 315 0
 430 00f4 1BBA      		out 0x1b,__zero_reg__
 316:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = 0;
 431               		.loc 1 316 0
 432 00f6 18BA      		out 0x18,__zero_reg__
 317:setup.c       **** 	GBA_DDR_ROM_ADDR15_8 = 0;
 433               		.loc 1 317 0
 434 00f8 1ABA      		out 0x1a,__zero_reg__
 318:setup.c       **** 	GBA_DDR_ROM_ADDR7_0 = 0;
 435               		.loc 1 318 0
 436 00fa 17BA      		out 0x17,__zero_reg__
 319:setup.c       **** 	
 320:setup.c       **** 	rdPin_low;
 437               		.loc 1 320 0
 438 00fc 9598      		cbi 0x12,5
 321:setup.c       **** 	asm volatile("nop");
 439               		.loc 1 321 0
 440               	/* #APP */
 441               	 ;  321 "setup.c" 1
 442 00fe 0000      		nop
 443               	 ;  0 "" 2
 322:setup.c       **** 	
 323:setup.c       **** 	uint16_t data = (GBA_PIN_ROM_DATA15_8 << 8) | GBA_PIN_ROM_DATA7_0; // Read data
 444               		.loc 1 323 0
 445               	/* #NOAPP */
 446 0100 29B3      		in r18,0x19
 447 0102 86B3      		in r24,0x16
 448               	.LVL24:
 324:setup.c       **** 	
 325:setup.c       **** 	rdPin_high;
 449               		.loc 1 325 0
 450 0104 959A      		sbi 0x12,5
 326:setup.c       **** 	cs_mreqPin_high;
 451               		.loc 1 326 0
 452 0106 949A      		sbi 0x12,4
 327:setup.c       **** 	
 328:setup.c       **** 	return data;
 453               		.loc 1 328 0
 454 0108 90E0      		ldi r25,0
 329:setup.c       **** }
 455               		.loc 1 329 0
 456 010a 922B      		or r25,r18
 457 010c 0895      		ret
 458               		.cfi_endproc
 459               	.LFE23:
 461               	.global	gba_read_ram_8bit_data
 463               	gba_read_ram_8bit_data:
 464               	.LFB24:
 330:setup.c       **** 
 331:setup.c       **** // Set the address and read a byte from the 8 bit data line
 332:setup.c       **** uint8_t gba_read_ram_8bit_data(uint16_t address) {
 465               		.loc 1 332 0
 466               		.cfi_startproc
 467               	.LVL25:
 468               	/* prologue: function */
 469               	/* frame size = 0 */
 470               	/* stack size = 0 */
 471               	.L__stack_usage = 0
 333:setup.c       **** 	set_16bit_address(address);
 472               		.loc 1 333 0
 473 010e 00D0      		rcall set_16bit_address
 474               	.LVL26:
 334:setup.c       **** 	
 335:setup.c       **** 	rdPin_low;
 475               		.loc 1 335 0
 476 0110 9598      		cbi 0x12,5
 336:setup.c       **** 	cs2Pin_low; // CS2 pin low for SRAM/Flash select
 477               		.loc 1 336 0
 478 0112 3A98      		cbi 0x7,2
 337:setup.c       **** 	
 338:setup.c       **** 	asm volatile("nop"); // Delay a little (minimum needed is 2)
 479               		.loc 1 338 0
 480               	/* #APP */
 481               	 ;  338 "setup.c" 1
 482 0114 0000      		nop
 483               	 ;  0 "" 2
 339:setup.c       **** 	asm volatile("nop");
 484               		.loc 1 339 0
 485               	 ;  339 "setup.c" 1
 486 0116 0000      		nop
 487               	 ;  0 "" 2
 340:setup.c       **** 	
 341:setup.c       **** 	uint8_t data = GBA_PIN_RAM_DATA7_0; // Read data
 488               		.loc 1 341 0
 489               	/* #NOAPP */
 490 0118 83B3      		in r24,0x13
 491               	.LVL27:
 342:setup.c       **** 	
 343:setup.c       **** 	cs2Pin_high;
 492               		.loc 1 343 0
 493 011a 3A9A      		sbi 0x7,2
 344:setup.c       **** 	rdPin_high;
 494               		.loc 1 344 0
 495 011c 959A      		sbi 0x12,5
 345:setup.c       **** 	
 346:setup.c       **** 	return data;
 347:setup.c       **** }
 496               		.loc 1 347 0
 497 011e 0895      		ret
 498               		.cfi_endproc
 499               	.LFE24:
 501               	.global	gba_write_ram_8bit_data
 503               	gba_write_ram_8bit_data:
 504               	.LFB25:
 348:setup.c       **** 
 349:setup.c       **** // Set the address and write a byte to the 8 bit data line 
 350:setup.c       **** void gba_write_ram_8bit_data(uint16_t address, uint8_t data) {
 505               		.loc 1 350 0
 506               		.cfi_startproc
 507               	.LVL28:
 508 0120 CF93      		push r28
 509               	.LCFI9:
 510               		.cfi_def_cfa_offset 3
 511               		.cfi_offset 28, -2
 512               	/* prologue: function */
 513               	/* frame size = 0 */
 514               	/* stack size = 1 */
 515               	.L__stack_usage = 1
 516 0122 C62F      		mov r28,r22
 351:setup.c       **** 	set_16bit_address(address);
 517               		.loc 1 351 0
 518 0124 00D0      		rcall set_16bit_address
 519               	.LVL29:
 352:setup.c       **** 	
 353:setup.c       **** 	GBA_DDR_RAM_DATA7_0 = 0xFF; // Set data pins as outputs
 520               		.loc 1 353 0
 521 0126 8FEF      		ldi r24,lo8(-1)
 522 0128 84BB      		out 0x14,r24
 354:setup.c       **** 	GBA_PORT_RAM_DATA7_0 = data; // Set data
 523               		.loc 1 354 0
 524 012a C5BB      		out 0x15,r28
 355:setup.c       **** 	
 356:setup.c       **** 	// Pulse WR
 357:setup.c       **** 	wrPin_low;
 525               		.loc 1 357 0
 526 012c 9698      		cbi 0x12,6
 358:setup.c       **** 	cs2Pin_low; // CS2 pin low for SRAM/Flash select
 527               		.loc 1 358 0
 528 012e 3A98      		cbi 0x7,2
 359:setup.c       **** 	
 360:setup.c       **** 	asm volatile("nop");
 529               		.loc 1 360 0
 530               	/* #APP */
 531               	 ;  360 "setup.c" 1
 532 0130 0000      		nop
 533               	 ;  0 "" 2
 361:setup.c       **** 	asm volatile("nop");
 534               		.loc 1 361 0
 535               	 ;  361 "setup.c" 1
 536 0132 0000      		nop
 537               	 ;  0 "" 2
 362:setup.c       **** 	
 363:setup.c       **** 	cs2Pin_high;
 538               		.loc 1 363 0
 539               	/* #NOAPP */
 540 0134 3A9A      		sbi 0x7,2
 364:setup.c       **** 	wrPin_high;
 541               		.loc 1 364 0
 542 0136 969A      		sbi 0x12,6
 365:setup.c       **** 	
 366:setup.c       **** 	// Clear data outputs and set data pins as inputs
 367:setup.c       **** 	GBA_PORT_RAM_DATA7_0 = 0;
 543               		.loc 1 367 0
 544 0138 15BA      		out 0x15,__zero_reg__
 368:setup.c       **** 	GBA_DDR_RAM_DATA7_0 = 0;
 545               		.loc 1 368 0
 546 013a 14BA      		out 0x14,__zero_reg__
 547               	/* epilogue start */
 369:setup.c       **** }
 548               		.loc 1 369 0
 549 013c CF91      		pop r28
 550               	.LVL30:
 551 013e 0895      		ret
 552               		.cfi_endproc
 553               	.LFE25:
 555               	.global	gba_eeprom_mode
 557               	gba_eeprom_mode:
 558               	.LFB26:
 370:setup.c       **** 
 371:setup.c       **** 
 372:setup.c       **** 
 373:setup.c       **** // ---------- EEPROM ----------
 374:setup.c       **** 
 375:setup.c       **** // Set address/data all high (includes AD0/A23)
 376:setup.c       **** void gba_eeprom_mode (void) {
 559               		.loc 1 376 0
 560               		.cfi_startproc
 561               	/* prologue: function */
 562               	/* frame size = 0 */
 563               	/* stack size = 0 */
 564               	.L__stack_usage = 0
 377:setup.c       **** 	GBA_DDR_ROM_ADDR7_0 = 0xFF;
 565               		.loc 1 377 0
 566 0140 8FEF      		ldi r24,lo8(-1)
 567 0142 87BB      		out 0x17,r24
 378:setup.c       **** 	GBA_DDR_ROM_ADDR15_8 = 0xFF;
 568               		.loc 1 378 0
 569 0144 8ABB      		out 0x1a,r24
 379:setup.c       **** 	GBA_DDR_ROM_ADDR23_16 = 0xFF;
 570               		.loc 1 379 0
 571 0146 84BB      		out 0x14,r24
 380:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = 0x80;
 572               		.loc 1 380 0
 573 0148 90E8      		ldi r25,lo8(-128)
 574 014a 98BB      		out 0x18,r25
 381:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = 0xFF;
 575               		.loc 1 381 0
 576 014c 8BBB      		out 0x1b,r24
 382:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = 0xFF;
 577               		.loc 1 382 0
 578 014e 85BB      		out 0x15,r24
 579 0150 0895      		ret
 580               		.cfi_endproc
 581               	.LFE26:
 583               	.global	gba_eeprom_set_address
 585               	gba_eeprom_set_address:
 586               	.LFB27:
 383:setup.c       **** }
 384:setup.c       **** 
 385:setup.c       **** // Send out EEPROM address serially (WR clock, AD0 data out)
 386:setup.c       **** void gba_eeprom_set_address(uint16_t address, uint8_t eepromSize, uint8_t command) {
 587               		.loc 1 386 0
 588               		.cfi_startproc
 589               	.LVL31:
 590               	/* prologue: function */
 591               	/* frame size = 0 */
 592               	/* stack size = 0 */
 593               	.L__stack_usage = 0
 387:setup.c       **** 	cs_mreqPin_low;
 594               		.loc 1 387 0
 595 0152 9498      		cbi 0x12,4
 596               	.LVL32:
 388:setup.c       **** 	
 389:setup.c       **** 	int8_t x = 0;
 390:setup.c       **** 	if (eepromSize == EEPROM_64KBIT) {
 597               		.loc 1 390 0
 598 0154 6230      		cpi r22,lo8(2)
 599 0156 01F4      		brne .L30
 391:setup.c       **** 		if (command == EEPROM_READ) {
 600               		.loc 1 391 0
 601 0158 4111      		cpse r20,__zero_reg__
 602 015a 00C0      		rjmp .L31
 392:setup.c       **** 			address |= (1<<15) | (1<<14); // Set upper 2 bits high for read request
 603               		.loc 1 392 0
 604 015c 906C      		ori r25,192
 605               	.LVL33:
 606               	.L40:
 393:setup.c       **** 		}
 394:setup.c       **** 		else {
 395:setup.c       **** 			address |= (1<<15); // Set upper 1 bit high for write request
 396:setup.c       **** 		}
 397:setup.c       **** 		x = 15;
 607               		.loc 1 397 0
 608 015e 2FE0      		ldi r18,lo8(15)
 609               	.L33:
 610               	.LVL34:
 398:setup.c       **** 	}
 399:setup.c       **** 	else {
 400:setup.c       **** 		if (command == EEPROM_READ) {
 401:setup.c       **** 			address |= (1<<7) | (1<<6);
 402:setup.c       **** 		}
 403:setup.c       **** 		else {
 404:setup.c       **** 			address |= (1<<7);
 405:setup.c       **** 		}
 406:setup.c       **** 		x = 7;
 407:setup.c       **** 	}
 408:setup.c       **** 	
 409:setup.c       **** 	// Loop through address, 8 or 16 bits depending on EEPROM (includes the 2 bits for request type)
 410:setup.c       **** 	while (x >= 0) {
 411:setup.c       **** 		if (address & (1<<x)) {
 611               		.loc 1 411 0
 612 0160 E1E0      		ldi r30,lo8(1)
 613 0162 F0E0      		ldi r31,0
 614 0164 00C0      		rjmp .L32
 615               	.LVL35:
 616               	.L31:
 395:setup.c       **** 		}
 617               		.loc 1 395 0
 618 0166 9068      		ori r25,128
 619               	.LVL36:
 620 0168 00C0      		rjmp .L40
 621               	.L30:
 400:setup.c       **** 			address |= (1<<7) | (1<<6);
 622               		.loc 1 400 0
 623 016a 4111      		cpse r20,__zero_reg__
 624 016c 00C0      		rjmp .L34
 401:setup.c       **** 		}
 625               		.loc 1 401 0
 626 016e 806C      		ori r24,192
 627               	.LVL37:
 628 0170 00C0      		rjmp .L39
 629               	.L34:
 404:setup.c       **** 		}
 630               		.loc 1 404 0
 631 0172 8068      		ori r24,128
 632               	.LVL38:
 633               	.L39:
 406:setup.c       **** 	}
 634               		.loc 1 406 0
 635 0174 27E0      		ldi r18,lo8(7)
 636 0176 00C0      		rjmp .L33
 637               	.LVL39:
 638               	.L35:
 412:setup.c       **** 			ad0Pin_high;
 413:setup.c       **** 		}
 414:setup.c       **** 		else {
 415:setup.c       **** 			ad0Pin_low;
 639               		.loc 1 415 0
 640 0178 C098      		cbi 0x18,0
 641               	.L36:
 416:setup.c       **** 		}
 417:setup.c       **** 		
 418:setup.c       **** 		wrPin_low; // CLK
 642               		.loc 1 418 0
 643 017a 9698      		cbi 0x12,6
 419:setup.c       **** 		asm ("nop");
 644               		.loc 1 419 0
 645               	/* #APP */
 646               	 ;  419 "setup.c" 1
 647 017c 0000      		nop
 648               	 ;  0 "" 2
 420:setup.c       **** 		asm ("nop");
 649               		.loc 1 420 0
 650               	 ;  420 "setup.c" 1
 651 017e 0000      		nop
 652               	 ;  0 "" 2
 421:setup.c       **** 		wrPin_high; 
 653               		.loc 1 421 0
 654               	/* #NOAPP */
 655 0180 969A      		sbi 0x12,6
 422:setup.c       **** 		asm ("nop");
 656               		.loc 1 422 0
 657               	/* #APP */
 658               	 ;  422 "setup.c" 1
 659 0182 0000      		nop
 660               	 ;  0 "" 2
 423:setup.c       **** 		asm ("nop");
 661               		.loc 1 423 0
 662               	 ;  423 "setup.c" 1
 663 0184 0000      		nop
 664               	 ;  0 "" 2
 665               	/* #NOAPP */
 666 0186 2150      		subi r18,lo8(-(-1))
 667               	.LVL40:
 410:setup.c       **** 		if (address & (1<<x)) {
 668               		.loc 1 410 0
 669 0188 27FD      		sbrc r18,7
 670 018a 00C0      		rjmp .L41
 671               	.L32:
 411:setup.c       **** 			ad0Pin_high;
 672               		.loc 1 411 0
 673 018c BF01      		movw r22,r30
 674 018e 022E      		mov r0,r18
 675 0190 00C0      		rjmp 2f
 676               		1:
 677 0192 660F      		lsl r22
 678 0194 771F      		rol r23
 679               		2:
 680 0196 0A94      		dec r0
 681 0198 02F4      		brpl 1b
 682 019a 6823      		and r22,r24
 683 019c 7923      		and r23,r25
 684 019e 672B      		or r22,r23
 685 01a0 01F0      		breq .L35
 412:setup.c       **** 		}
 686               		.loc 1 412 0
 687 01a2 C09A      		sbi 0x18,0
 688 01a4 00C0      		rjmp .L36
 689               	.L41:
 424:setup.c       **** 		
 425:setup.c       **** 		x--;
 426:setup.c       **** 	}
 427:setup.c       **** 	
 428:setup.c       **** 	// Only send stop bit (0) and WR/CS high if reading, as writing is done in 1 continuous chunk
 429:setup.c       **** 	if (command == EEPROM_READ) {  
 690               		.loc 1 429 0
 691 01a6 4111      		cpse r20,__zero_reg__
 692 01a8 00C0      		rjmp .L29
 430:setup.c       **** 		ad0Pin_low;
 693               		.loc 1 430 0
 694 01aa C098      		cbi 0x18,0
 431:setup.c       **** 		asm ("nop");
 695               		.loc 1 431 0
 696               	/* #APP */
 697               	 ;  431 "setup.c" 1
 698 01ac 0000      		nop
 699               	 ;  0 "" 2
 432:setup.c       **** 		wrPin_low;
 700               		.loc 1 432 0
 701               	/* #NOAPP */
 702 01ae 9698      		cbi 0x12,6
 433:setup.c       **** 		asm ("nop");
 703               		.loc 1 433 0
 704               	/* #APP */
 705               	 ;  433 "setup.c" 1
 706 01b0 0000      		nop
 707               	 ;  0 "" 2
 434:setup.c       **** 		asm ("nop");
 708               		.loc 1 434 0
 709               	 ;  434 "setup.c" 1
 710 01b2 0000      		nop
 711               	 ;  0 "" 2
 435:setup.c       **** 		
 436:setup.c       **** 		wrPin_high;
 712               		.loc 1 436 0
 713               	/* #NOAPP */
 714 01b4 969A      		sbi 0x12,6
 437:setup.c       **** 		cs_mreqPin_high;
 715               		.loc 1 437 0
 716 01b6 949A      		sbi 0x12,4
 717               	.L29:
 718 01b8 0895      		ret
 719               		.cfi_endproc
 720               	.LFE27:
 722               	.global	gba_eeprom_read
 724               	gba_eeprom_read:
 725               	.LFB28:
 438:setup.c       **** 	}
 439:setup.c       **** }
 440:setup.c       **** 
 441:setup.c       **** // Read 8 bytes from the EEPROM address, data is valid on rising edge
 442:setup.c       **** void gba_eeprom_read(uint16_t address, uint8_t eepromSize) {
 726               		.loc 1 442 0
 727               		.cfi_startproc
 728               	.LVL41:
 729               	/* prologue: function */
 730               	/* frame size = 0 */
 731               	/* stack size = 0 */
 732               	.L__stack_usage = 0
 443:setup.c       **** 	gba_eeprom_set_address(address, eepromSize, EEPROM_READ);
 733               		.loc 1 443 0
 734 01ba 40E0      		ldi r20,0
 735 01bc 00D0      		rcall gba_eeprom_set_address
 736               	.LVL42:
 444:setup.c       **** 	
 445:setup.c       **** 	// Set AD0 pin as input
 446:setup.c       **** 	GBA_PORT_EEPROM_DATA7_0 &= ~(1<<AD0);
 737               		.loc 1 446 0
 738 01be C098      		cbi 0x18,0
 447:setup.c       **** 	GBA_DDR_EEPROM_DATA7_0 &= ~(1<<AD0);
 739               		.loc 1 447 0
 740 01c0 B898      		cbi 0x17,0
 448:setup.c       **** 	
 449:setup.c       **** 	cs_mreqPin_low;
 741               		.loc 1 449 0
 742 01c2 9498      		cbi 0x12,4
 743               	.LVL43:
 744 01c4 84E0      		ldi r24,lo8(4)
 745               	.LVL44:
 746               	.L43:
 747               	.LBB55:
 450:setup.c       **** 	
 451:setup.c       **** 	// Ignore first 4 bits
 452:setup.c       **** 	for (int8_t x = 0; x < 4; x++) {
 453:setup.c       **** 		rdPin_low; // CLK
 748               		.loc 1 453 0 discriminator 3
 749 01c6 9598      		cbi 0x12,5
 454:setup.c       **** 		asm ("nop");
 750               		.loc 1 454 0 discriminator 3
 751               	/* #APP */
 752               	 ;  454 "setup.c" 1
 753 01c8 0000      		nop
 754               	 ;  0 "" 2
 455:setup.c       **** 		asm ("nop");
 755               		.loc 1 455 0 discriminator 3
 756               	 ;  455 "setup.c" 1
 757 01ca 0000      		nop
 758               	 ;  0 "" 2
 456:setup.c       **** 		rdPin_high; 
 759               		.loc 1 456 0 discriminator 3
 760               	/* #NOAPP */
 761 01cc 959A      		sbi 0x12,5
 457:setup.c       **** 		asm ("nop");
 762               		.loc 1 457 0 discriminator 3
 763               	/* #APP */
 764               	 ;  457 "setup.c" 1
 765 01ce 0000      		nop
 766               	 ;  0 "" 2
 458:setup.c       **** 		asm ("nop");
 767               		.loc 1 458 0 discriminator 3
 768               	 ;  458 "setup.c" 1
 769 01d0 0000      		nop
 770               	 ;  0 "" 2
 771               	.LVL45:
 772               	/* #NOAPP */
 773 01d2 8150      		subi r24,lo8(-(-1))
 774               	.LVL46:
 452:setup.c       **** 		rdPin_low; // CLK
 775               		.loc 1 452 0 discriminator 3
 776 01d4 01F4      		brne .L43
 777 01d6 E0E0      		ldi r30,lo8(eepromBuffer)
 778 01d8 F0E0      		ldi r31,hi8(eepromBuffer)
 779               	.LBE55:
 780               	.LBB56:
 781               	.LBB57:
 782               	.LBB58:
 459:setup.c       **** 	}
 460:setup.c       **** 	
 461:setup.c       **** 	// Read out 64 bits
 462:setup.c       **** 	for (uint8_t c = 0; c < 8; c++) {
 463:setup.c       **** 		uint8_t data = 0;
 464:setup.c       **** 		for (int8_t x = 7; x >= 0; x--) {
 465:setup.c       **** 			rdPin_low; // CLK
 466:setup.c       **** 			asm ("nop");
 467:setup.c       **** 			asm ("nop");
 468:setup.c       **** 			rdPin_high;
 469:setup.c       **** 			
 470:setup.c       **** 			if (GBA_PIN_EEPROM_DATA7_0 & (1<<AD0)) {
 471:setup.c       **** 				data |= (1<<x);
 783               		.loc 1 471 0
 784 01da 41E0      		ldi r20,lo8(1)
 785 01dc 50E0      		ldi r21,0
 786               	.LVL47:
 787               	.L44:
 788               	.LBE58:
 789               	.LBE57:
 790               	.LBE56:
 449:setup.c       **** 	
 791               		.loc 1 449 0
 792 01de 87E0      		ldi r24,lo8(7)
 793 01e0 90E0      		ldi r25,0
 794 01e2 20E0      		ldi r18,0
 795               	.LVL48:
 796               	.L46:
 797               	.LBB61:
 798               	.LBB60:
 799               	.LBB59:
 465:setup.c       **** 			asm ("nop");
 800               		.loc 1 465 0
 801 01e4 9598      		cbi 0x12,5
 466:setup.c       **** 			asm ("nop");
 802               		.loc 1 466 0
 803               	/* #APP */
 804               	 ;  466 "setup.c" 1
 805 01e6 0000      		nop
 806               	 ;  0 "" 2
 467:setup.c       **** 			rdPin_high;
 807               		.loc 1 467 0
 808               	 ;  467 "setup.c" 1
 809 01e8 0000      		nop
 810               	 ;  0 "" 2
 468:setup.c       **** 			
 811               		.loc 1 468 0
 812               	/* #NOAPP */
 813 01ea 959A      		sbi 0x12,5
 470:setup.c       **** 				data |= (1<<x);
 814               		.loc 1 470 0
 815 01ec B09B      		sbis 0x16,0
 816 01ee 00C0      		rjmp .L45
 817               		.loc 1 471 0
 818 01f0 BA01      		movw r22,r20
 819 01f2 082E      		mov r0,r24
 820 01f4 00C0      		rjmp 2f
 821               		1:
 822 01f6 660F      		lsl r22
 823               		2:
 824 01f8 0A94      		dec r0
 825 01fa 02F4      		brpl 1b
 826 01fc 262B      		or r18,r22
 827               	.LVL49:
 828               	.L45:
 829               	.LVL50:
 830 01fe 0197      		sbiw r24,1
 831 0200 00F4      		brcc .L46
 832               	.LBE59:
 472:setup.c       **** 			}
 473:setup.c       **** 		}
 474:setup.c       **** 		eepromBuffer[c] = data;
 833               		.loc 1 474 0 discriminator 2
 834 0202 2193      		st Z+,r18
 835               	.LVL51:
 836               	.LBE60:
 462:setup.c       **** 		uint8_t data = 0;
 837               		.loc 1 462 0 discriminator 2
 838 0204 80E0      		ldi r24,hi8(eepromBuffer+8)
 839 0206 E030      		cpi r30,lo8(eepromBuffer+8)
 840 0208 F807      		cpc r31,r24
 841               	.LVL52:
 842 020a 01F4      		brne .L44
 843               	.LBE61:
 475:setup.c       **** 	}
 476:setup.c       **** 	
 477:setup.c       **** 	cs_mreqPin_high;
 844               		.loc 1 477 0
 845 020c 949A      		sbi 0x12,4
 478:setup.c       **** 	
 479:setup.c       **** 	// Set AD0 pin as output
 480:setup.c       **** 	GBA_PORT_EEPROM_DATA7_0 |= (1<<AD0);
 846               		.loc 1 480 0
 847 020e C09A      		sbi 0x18,0
 481:setup.c       **** 	GBA_DDR_EEPROM_DATA7_0 |= (1<<AD0);
 848               		.loc 1 481 0
 849 0210 B89A      		sbi 0x17,0
 850 0212 0895      		ret
 851               		.cfi_endproc
 852               	.LFE28:
 854               	.global	gba_eeprom_write
 856               	gba_eeprom_write:
 857               	.LFB29:
 482:setup.c       **** }
 483:setup.c       **** 
 484:setup.c       **** // Write 8 bytes to the EEPROM address
 485:setup.c       **** void gba_eeprom_write(uint16_t address, uint8_t eepromSize) {
 858               		.loc 1 485 0
 859               		.cfi_startproc
 860               	.LVL53:
 861               	/* prologue: function */
 862               	/* frame size = 0 */
 863               	/* stack size = 0 */
 864               	.L__stack_usage = 0
 486:setup.c       **** 	gba_eeprom_set_address(address, eepromSize, EEPROM_WRITE);
 865               		.loc 1 486 0
 866 0214 41E0      		ldi r20,lo8(1)
 867 0216 00D0      		rcall gba_eeprom_set_address
 868               	.LVL54:
 869 0218 E0E0      		ldi r30,lo8(eepromBuffer)
 870 021a F0E0      		ldi r31,hi8(eepromBuffer)
 871 021c 48E0      		ldi r20,lo8(8)
 872               	.LVL55:
 873               	.L54:
 485:setup.c       **** 	gba_eeprom_set_address(address, eepromSize, EEPROM_WRITE);
 874               		.loc 1 485 0
 875 021e 27E0      		ldi r18,lo8(7)
 876 0220 30E0      		ldi r19,0
 877               	.LVL56:
 878               	.L57:
 879               	.LBB62:
 880               	.LBB63:
 487:setup.c       **** 	
 488:setup.c       **** 	// Write 64 bits
 489:setup.c       **** 	for (uint8_t c = 0; c < 8; c++) {
 490:setup.c       **** 		for (int8_t x = 7; x >= 0; x--) {
 491:setup.c       **** 			if (eepromBuffer[c] & (1<<x)) {
 881               		.loc 1 491 0
 882 0222 8081      		ld r24,Z
 883 0224 90E0      		ldi r25,0
 884 0226 022E      		mov r0,r18
 885 0228 00C0      		rjmp 2f
 886               		1:
 887 022a 9595      		asr r25
 888 022c 8795      		ror r24
 889               		2:
 890 022e 0A94      		dec r0
 891 0230 02F4      		brpl 1b
 892 0232 80FF      		sbrs r24,0
 893 0234 00C0      		rjmp .L55
 492:setup.c       **** 				ad0Pin_high;
 894               		.loc 1 492 0
 895 0236 C09A      		sbi 0x18,0
 896 0238 00C0      		rjmp .L56
 897               	.L55:
 493:setup.c       **** 			}
 494:setup.c       **** 			else {
 495:setup.c       **** 				ad0Pin_low;
 898               		.loc 1 495 0
 899 023a C098      		cbi 0x18,0
 900               	.L56:
 496:setup.c       **** 			}
 497:setup.c       **** 			
 498:setup.c       **** 			wrPin_low; // CLK
 901               		.loc 1 498 0 discriminator 2
 902 023c 9698      		cbi 0x12,6
 499:setup.c       **** 			asm ("nop");
 903               		.loc 1 499 0 discriminator 2
 904               	/* #APP */
 905               	 ;  499 "setup.c" 1
 906 023e 0000      		nop
 907               	 ;  0 "" 2
 500:setup.c       **** 			asm ("nop");
 908               		.loc 1 500 0 discriminator 2
 909               	 ;  500 "setup.c" 1
 910 0240 0000      		nop
 911               	 ;  0 "" 2
 501:setup.c       **** 			wrPin_high; 
 912               		.loc 1 501 0 discriminator 2
 913               	/* #NOAPP */
 914 0242 969A      		sbi 0x12,6
 502:setup.c       **** 			asm ("nop");
 915               		.loc 1 502 0 discriminator 2
 916               	/* #APP */
 917               	 ;  502 "setup.c" 1
 918 0244 0000      		nop
 919               	 ;  0 "" 2
 503:setup.c       **** 			asm ("nop");
 920               		.loc 1 503 0 discriminator 2
 921               	 ;  503 "setup.c" 1
 922 0246 0000      		nop
 923               	 ;  0 "" 2
 924               	.LVL57:
 925               	/* #NOAPP */
 926               	.LVL58:
 927 0248 2150      		subi r18,1
 928 024a 3109      		sbc r19,__zero_reg__
 929 024c 00F4      		brcc .L57
 930 024e 4150      		subi r20,lo8(-(-1))
 931 0250 3196      		adiw r30,1
 932               	.LVL59:
 933               	.LBE63:
 489:setup.c       **** 		for (int8_t x = 7; x >= 0; x--) {
 934               		.loc 1 489 0 discriminator 2
 935 0252 4111      		cpse r20,__zero_reg__
 936 0254 00C0      		rjmp .L54
 937               	.LBE62:
 504:setup.c       **** 		}
 505:setup.c       **** 	}
 506:setup.c       **** 	
 507:setup.c       **** 	// Last bit low
 508:setup.c       **** 	ad0Pin_low;
 938               		.loc 1 508 0
 939 0256 C098      		cbi 0x18,0
 509:setup.c       **** 	wrPin_low; // CLK
 940               		.loc 1 509 0
 941 0258 9698      		cbi 0x12,6
 510:setup.c       **** 	asm ("nop");
 942               		.loc 1 510 0
 943               	/* #APP */
 944               	 ;  510 "setup.c" 1
 945 025a 0000      		nop
 946               	 ;  0 "" 2
 511:setup.c       **** 	asm ("nop");
 947               		.loc 1 511 0
 948               	 ;  511 "setup.c" 1
 949 025c 0000      		nop
 950               	 ;  0 "" 2
 512:setup.c       **** 	wrPin_high; 
 951               		.loc 1 512 0
 952               	/* #NOAPP */
 953 025e 969A      		sbi 0x12,6
 513:setup.c       **** 	asm ("nop");
 954               		.loc 1 513 0
 955               	/* #APP */
 956               	 ;  513 "setup.c" 1
 957 0260 0000      		nop
 958               	 ;  0 "" 2
 514:setup.c       **** 	asm ("nop");
 959               		.loc 1 514 0
 960               	 ;  514 "setup.c" 1
 961 0262 0000      		nop
 962               	 ;  0 "" 2
 515:setup.c       **** 	
 516:setup.c       **** 	cs_mreqPin_high;
 963               		.loc 1 516 0
 964               	/* #NOAPP */
 965 0264 949A      		sbi 0x12,4
 966 0266 0895      		ret
 967               		.cfi_endproc
 968               	.LFE29:
 970               	.global	flash_write_bus_cycle
 972               	flash_write_bus_cycle:
 973               	.LFB30:
 517:setup.c       **** }
 518:setup.c       **** 
 519:setup.c       **** 
 520:setup.c       **** 
 521:setup.c       **** // ---------- FLASH ----------
 522:setup.c       **** 
 523:setup.c       **** // Set the address and data for the write byte cycle to the flash
 524:setup.c       **** void flash_write_bus_cycle(uint16_t address, uint8_t data) {
 974               		.loc 1 524 0
 975               		.cfi_startproc
 976               	.LVL60:
 977 0268 CF93      		push r28
 978               	.LCFI10:
 979               		.cfi_def_cfa_offset 3
 980               		.cfi_offset 28, -2
 981               	/* prologue: function */
 982               	/* frame size = 0 */
 983               	/* stack size = 1 */
 984               	.L__stack_usage = 1
 985 026a C62F      		mov r28,r22
 525:setup.c       **** 	GBA_DDR_RAM_DATA7_0 = 0xFF; // Set data pins as outputs
 986               		.loc 1 525 0
 987 026c 2FEF      		ldi r18,lo8(-1)
 988 026e 24BB      		out 0x14,r18
 526:setup.c       **** 	set_16bit_address(address);
 989               		.loc 1 526 0
 990 0270 00D0      		rcall set_16bit_address
 991               	.LVL61:
 527:setup.c       **** 	GBA_PORT_RAM_DATA7_0 = data;
 992               		.loc 1 527 0
 993 0272 C5BB      		out 0x15,r28
 528:setup.c       **** 	
 529:setup.c       **** 	wrPin_low;
 994               		.loc 1 529 0
 995 0274 9698      		cbi 0x12,6
 530:setup.c       **** 	cs2Pin_low;
 996               		.loc 1 530 0
 997 0276 3A98      		cbi 0x7,2
 531:setup.c       **** 	asm volatile("nop");
 998               		.loc 1 531 0
 999               	/* #APP */
 1000               	 ;  531 "setup.c" 1
 1001 0278 0000      		nop
 1002               	 ;  0 "" 2
 532:setup.c       **** 	wrPin_high;
 1003               		.loc 1 532 0
 1004               	/* #NOAPP */
 1005 027a 969A      		sbi 0x12,6
 533:setup.c       **** 	cs2Pin_high;
 1006               		.loc 1 533 0
 1007 027c 3A9A      		sbi 0x7,2
 1008               	/* epilogue start */
 534:setup.c       **** }
 1009               		.loc 1 534 0
 1010 027e CF91      		pop r28
 1011               	.LVL62:
 1012 0280 0895      		ret
 1013               		.cfi_endproc
 1014               	.LFE30:
 1016               	.global	flash_read_chip_id
 1018               	flash_read_chip_id:
 1019               	.LFB31:
 535:setup.c       **** 
 536:setup.c       **** // Read the flash manufacturer and device ID (Software ID)
 537:setup.c       **** void flash_read_chip_id(void) {
 1020               		.loc 1 537 0
 1021               		.cfi_startproc
 1022 0282 CF93      		push r28
 1023               	.LCFI11:
 1024               		.cfi_def_cfa_offset 3
 1025               		.cfi_offset 28, -2
 1026 0284 DF93      		push r29
 1027               	.LCFI12:
 1028               		.cfi_def_cfa_offset 4
 1029               		.cfi_offset 29, -3
 1030               	/* prologue: function */
 1031               	/* frame size = 0 */
 1032               	/* stack size = 2 */
 1033               	.L__stack_usage = 2
 538:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xAA);
 1034               		.loc 1 538 0
 1035 0286 6AEA      		ldi r22,lo8(-86)
 1036 0288 85E5      		ldi r24,lo8(85)
 1037 028a 95E5      		ldi r25,lo8(85)
 1038 028c 00D0      		rcall flash_write_bus_cycle
 1039               	.LVL63:
 539:setup.c       **** 	flash_write_bus_cycle(0x2AAA, 0x55);
 1040               		.loc 1 539 0
 1041 028e 65E5      		ldi r22,lo8(85)
 1042 0290 8AEA      		ldi r24,lo8(-86)
 1043 0292 9AE2      		ldi r25,lo8(42)
 1044 0294 00D0      		rcall flash_write_bus_cycle
 1045               	.LVL64:
 540:setup.c       **** 	flash_write_bus_cycle(0x5555, 0x90); // Software ID entry
 1046               		.loc 1 540 0
 1047 0296 60E9      		ldi r22,lo8(-112)
 1048 0298 85E5      		ldi r24,lo8(85)
 1049 029a 95E5      		ldi r25,lo8(85)
 1050 029c 00D0      		rcall flash_write_bus_cycle
 1051               	.LVL65:
 1052               	.LBB64:
 1053               	.LBB65:
 1054               		.file 2 "c:\\winavr-20100110\\avr\\include\\util\\delay.h"
   1:c:\winavr-20100110\avr\include\util\delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:c:\winavr-20100110\avr\include\util\delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:c:\winavr-20100110\avr\include\util\delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:c:\winavr-20100110\avr\include\util\delay.h ****    All rights reserved.
   5:c:\winavr-20100110\avr\include\util\delay.h **** 
   6:c:\winavr-20100110\avr\include\util\delay.h ****    Redistribution and use in source and binary forms, with or without
   7:c:\winavr-20100110\avr\include\util\delay.h ****    modification, are permitted provided that the following conditions are met:
   8:c:\winavr-20100110\avr\include\util\delay.h **** 
   9:c:\winavr-20100110\avr\include\util\delay.h ****    * Redistributions of source code must retain the above copyright
  10:c:\winavr-20100110\avr\include\util\delay.h ****      notice, this list of conditions and the following disclaimer.
  11:c:\winavr-20100110\avr\include\util\delay.h **** 
  12:c:\winavr-20100110\avr\include\util\delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:c:\winavr-20100110\avr\include\util\delay.h ****      notice, this list of conditions and the following disclaimer in
  14:c:\winavr-20100110\avr\include\util\delay.h ****      the documentation and/or other materials provided with the
  15:c:\winavr-20100110\avr\include\util\delay.h ****      distribution.
  16:c:\winavr-20100110\avr\include\util\delay.h **** 
  17:c:\winavr-20100110\avr\include\util\delay.h ****    * Neither the name of the copyright holders nor the names of
  18:c:\winavr-20100110\avr\include\util\delay.h ****      contributors may be used to endorse or promote products derived
  19:c:\winavr-20100110\avr\include\util\delay.h ****      from this software without specific prior written permission.
  20:c:\winavr-20100110\avr\include\util\delay.h **** 
  21:c:\winavr-20100110\avr\include\util\delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:c:\winavr-20100110\avr\include\util\delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:c:\winavr-20100110\avr\include\util\delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:c:\winavr-20100110\avr\include\util\delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:c:\winavr-20100110\avr\include\util\delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:c:\winavr-20100110\avr\include\util\delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:c:\winavr-20100110\avr\include\util\delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:c:\winavr-20100110\avr\include\util\delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:c:\winavr-20100110\avr\include\util\delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:c:\winavr-20100110\avr\include\util\delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:c:\winavr-20100110\avr\include\util\delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:c:\winavr-20100110\avr\include\util\delay.h **** 
  33:c:\winavr-20100110\avr\include\util\delay.h **** /* $Id$ */
  34:c:\winavr-20100110\avr\include\util\delay.h **** 
  35:c:\winavr-20100110\avr\include\util\delay.h **** #ifndef _UTIL_DELAY_H_
  36:c:\winavr-20100110\avr\include\util\delay.h **** #define _UTIL_DELAY_H_ 1
  37:c:\winavr-20100110\avr\include\util\delay.h **** 
  38:c:\winavr-20100110\avr\include\util\delay.h **** #ifndef __DOXYGEN__
  39:c:\winavr-20100110\avr\include\util\delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:c:\winavr-20100110\avr\include\util\delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:c:\winavr-20100110\avr\include\util\delay.h **** #  endif
  42:c:\winavr-20100110\avr\include\util\delay.h **** #endif  /* __DOXYGEN__ */
  43:c:\winavr-20100110\avr\include\util\delay.h **** 
  44:c:\winavr-20100110\avr\include\util\delay.h **** #include <inttypes.h>
  45:c:\winavr-20100110\avr\include\util\delay.h **** #include <util/delay_basic.h>
  46:c:\winavr-20100110\avr\include\util\delay.h **** #include <math.h>
  47:c:\winavr-20100110\avr\include\util\delay.h **** 
  48:c:\winavr-20100110\avr\include\util\delay.h **** /** \file */
  49:c:\winavr-20100110\avr\include\util\delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:c:\winavr-20100110\avr\include\util\delay.h ****     \code
  51:c:\winavr-20100110\avr\include\util\delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:c:\winavr-20100110\avr\include\util\delay.h ****     //#define F_CPU 14.7456E6
  53:c:\winavr-20100110\avr\include\util\delay.h ****     #include <util/delay.h>
  54:c:\winavr-20100110\avr\include\util\delay.h ****     \endcode
  55:c:\winavr-20100110\avr\include\util\delay.h **** 
  56:c:\winavr-20100110\avr\include\util\delay.h ****     \note As an alternative method, it is possible to pass the
  57:c:\winavr-20100110\avr\include\util\delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:c:\winavr-20100110\avr\include\util\delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:c:\winavr-20100110\avr\include\util\delay.h ****     used.
  60:c:\winavr-20100110\avr\include\util\delay.h **** 
  61:c:\winavr-20100110\avr\include\util\delay.h ****     The functions in this header file are wrappers around the basic
  62:c:\winavr-20100110\avr\include\util\delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:c:\winavr-20100110\avr\include\util\delay.h ****     convenience functions where actual time values can be specified
  64:c:\winavr-20100110\avr\include\util\delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:c:\winavr-20100110\avr\include\util\delay.h ****     that compile-time constant expressions will be eliminated by
  66:c:\winavr-20100110\avr\include\util\delay.h ****     compiler optimization so floating-point expressions can be used
  67:c:\winavr-20100110\avr\include\util\delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:c:\winavr-20100110\avr\include\util\delay.h ****     frequency passed by the macro F_CPU.
  69:c:\winavr-20100110\avr\include\util\delay.h **** 
  70:c:\winavr-20100110\avr\include\util\delay.h ****     \note In order for these functions to work as intended, compiler
  71:c:\winavr-20100110\avr\include\util\delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:c:\winavr-20100110\avr\include\util\delay.h ****     <em>must</em> be an expression that is a known constant at
  73:c:\winavr-20100110\avr\include\util\delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:c:\winavr-20100110\avr\include\util\delay.h ****     delay will be much longer (and basically unpredictable), and
  75:c:\winavr-20100110\avr\include\util\delay.h ****     applications that otherwise do not use floating-point calculations
  76:c:\winavr-20100110\avr\include\util\delay.h ****     will experience severe code bloat by the floating-point library
  77:c:\winavr-20100110\avr\include\util\delay.h ****     routines linked into the application.
  78:c:\winavr-20100110\avr\include\util\delay.h **** 
  79:c:\winavr-20100110\avr\include\util\delay.h ****     The functions available allow the specification of microsecond, and
  80:c:\winavr-20100110\avr\include\util\delay.h ****     millisecond delays directly, using the application-supplied macro
  81:c:\winavr-20100110\avr\include\util\delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:c:\winavr-20100110\avr\include\util\delay.h **** 
  83:c:\winavr-20100110\avr\include\util\delay.h **** */
  84:c:\winavr-20100110\avr\include\util\delay.h **** 
  85:c:\winavr-20100110\avr\include\util\delay.h **** #if !defined(__DOXYGEN__)
  86:c:\winavr-20100110\avr\include\util\delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:c:\winavr-20100110\avr\include\util\delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:c:\winavr-20100110\avr\include\util\delay.h **** #endif
  89:c:\winavr-20100110\avr\include\util\delay.h **** 
  90:c:\winavr-20100110\avr\include\util\delay.h **** #ifndef F_CPU
  91:c:\winavr-20100110\avr\include\util\delay.h **** /* prevent compiler error by supplying a default */
  92:c:\winavr-20100110\avr\include\util\delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:c:\winavr-20100110\avr\include\util\delay.h **** /** \ingroup util_delay
  94:c:\winavr-20100110\avr\include\util\delay.h ****     \def F_CPU
  95:c:\winavr-20100110\avr\include\util\delay.h ****     \brief CPU frequency in Hz
  96:c:\winavr-20100110\avr\include\util\delay.h **** 
  97:c:\winavr-20100110\avr\include\util\delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:c:\winavr-20100110\avr\include\util\delay.h ****     the delay macros.  This macro is normally supplied by the
  99:c:\winavr-20100110\avr\include\util\delay.h ****     environment (e.g. from within a project header, or the project's
 100:c:\winavr-20100110\avr\include\util\delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:c:\winavr-20100110\avr\include\util\delay.h ****     fallback if no such user-provided definition could be found.
 102:c:\winavr-20100110\avr\include\util\delay.h **** 
 103:c:\winavr-20100110\avr\include\util\delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:c:\winavr-20100110\avr\include\util\delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:c:\winavr-20100110\avr\include\util\delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:c:\winavr-20100110\avr\include\util\delay.h ****     integer value.
 107:c:\winavr-20100110\avr\include\util\delay.h ****  */
 108:c:\winavr-20100110\avr\include\util\delay.h **** # define F_CPU 1000000UL
 109:c:\winavr-20100110\avr\include\util\delay.h **** #endif
 110:c:\winavr-20100110\avr\include\util\delay.h **** 
 111:c:\winavr-20100110\avr\include\util\delay.h **** #ifndef __OPTIMIZE__
 112:c:\winavr-20100110\avr\include\util\delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:c:\winavr-20100110\avr\include\util\delay.h **** #endif
 114:c:\winavr-20100110\avr\include\util\delay.h **** 
 115:c:\winavr-20100110\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:c:\winavr-20100110\avr\include\util\delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:c:\winavr-20100110\avr\include\util\delay.h ****   __STDC_HOSTED__
 118:c:\winavr-20100110\avr\include\util\delay.h **** #  include <math.h>
 119:c:\winavr-20100110\avr\include\util\delay.h **** #endif
 120:c:\winavr-20100110\avr\include\util\delay.h **** 
 121:c:\winavr-20100110\avr\include\util\delay.h **** /**
 122:c:\winavr-20100110\avr\include\util\delay.h ****    \ingroup util_delay
 123:c:\winavr-20100110\avr\include\util\delay.h **** 
 124:c:\winavr-20100110\avr\include\util\delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:c:\winavr-20100110\avr\include\util\delay.h **** 
 126:c:\winavr-20100110\avr\include\util\delay.h ****    The macro F_CPU is supposed to be defined to a
 127:c:\winavr-20100110\avr\include\util\delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:c:\winavr-20100110\avr\include\util\delay.h **** 
 129:c:\winavr-20100110\avr\include\util\delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:c:\winavr-20100110\avr\include\util\delay.h **** 
 131:c:\winavr-20100110\avr\include\util\delay.h ****    When the user request delay which exceed the maximum possible one,
 132:c:\winavr-20100110\avr\include\util\delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:c:\winavr-20100110\avr\include\util\delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:c:\winavr-20100110\avr\include\util\delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:c:\winavr-20100110\avr\include\util\delay.h ****    user will not be informed about decreased resolution.
 136:c:\winavr-20100110\avr\include\util\delay.h **** 
 137:c:\winavr-20100110\avr\include\util\delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:c:\winavr-20100110\avr\include\util\delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:c:\winavr-20100110\avr\include\util\delay.h ****    values greater than the maximal possible delay, overflows results in
 140:c:\winavr-20100110\avr\include\util\delay.h ****    no delay i.e., 0ms.
 141:c:\winavr-20100110\avr\include\util\delay.h **** 
 142:c:\winavr-20100110\avr\include\util\delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:c:\winavr-20100110\avr\include\util\delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:c:\winavr-20100110\avr\include\util\delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:c:\winavr-20100110\avr\include\util\delay.h ****    microseconds of delay.
 146:c:\winavr-20100110\avr\include\util\delay.h **** 
 147:c:\winavr-20100110\avr\include\util\delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:c:\winavr-20100110\avr\include\util\delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:c:\winavr-20100110\avr\include\util\delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:c:\winavr-20100110\avr\include\util\delay.h ****    respectively.
 151:c:\winavr-20100110\avr\include\util\delay.h **** 
 152:c:\winavr-20100110\avr\include\util\delay.h ****    \note
 153:c:\winavr-20100110\avr\include\util\delay.h **** 
 154:c:\winavr-20100110\avr\include\util\delay.h ****    The implementation of _delay_ms() based on
 155:c:\winavr-20100110\avr\include\util\delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:c:\winavr-20100110\avr\include\util\delay.h ****    implementations.  In order to get functionality backward compatible
 157:c:\winavr-20100110\avr\include\util\delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:c:\winavr-20100110\avr\include\util\delay.h ****    must be defined before including this header file. Also, the
 159:c:\winavr-20100110\avr\include\util\delay.h ****    backward compatible algorithm will be chosen if the code is
 160:c:\winavr-20100110\avr\include\util\delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:c:\winavr-20100110\avr\include\util\delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:c:\winavr-20100110\avr\include\util\delay.h ****    not available to the compiler then.
 163:c:\winavr-20100110\avr\include\util\delay.h **** 
 164:c:\winavr-20100110\avr\include\util\delay.h ****  */
 165:c:\winavr-20100110\avr\include\util\delay.h **** void
 166:c:\winavr-20100110\avr\include\util\delay.h **** _delay_ms(double __ms)
 167:c:\winavr-20100110\avr\include\util\delay.h **** {
 168:c:\winavr-20100110\avr\include\util\delay.h **** 	double __tmp ;
 169:c:\winavr-20100110\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:c:\winavr-20100110\avr\include\util\delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:c:\winavr-20100110\avr\include\util\delay.h ****   __STDC_HOSTED__
 172:c:\winavr-20100110\avr\include\util\delay.h **** 	uint32_t __ticks_dc;
 173:c:\winavr-20100110\avr\include\util\delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 174:c:\winavr-20100110\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 175:c:\winavr-20100110\avr\include\util\delay.h **** 
 176:c:\winavr-20100110\avr\include\util\delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:c:\winavr-20100110\avr\include\util\delay.h **** 
 179:c:\winavr-20100110\avr\include\util\delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:c:\winavr-20100110\avr\include\util\delay.h **** 
 182:c:\winavr-20100110\avr\include\util\delay.h **** 	#else
 183:c:\winavr-20100110\avr\include\util\delay.h **** 		//round up by default
 184:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 185:c:\winavr-20100110\avr\include\util\delay.h **** 	#endif
 186:c:\winavr-20100110\avr\include\util\delay.h **** 
 187:c:\winavr-20100110\avr\include\util\delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 1055               		.loc 2 187 0
 1056 029e 8FE3      		ldi r24,lo8(-25537)
 1057 02a0 9CE9      		ldi r25,hi8(-25537)
 1058 02a2 0197      	1:	sbiw r24,1
 1059 02a4 01F4      		brne 1b
 1060 02a6 00C0      		rjmp .
 1061 02a8 0000      		nop
 1062               	.LVL66:
 1063               	.LBE65:
 1064               	.LBE64:
 541:setup.c       **** 	_delay_ms(20); // Wait a little (for Atmel chip)
 542:setup.c       **** 	
 543:setup.c       **** 	// Set data as inputs
 544:setup.c       **** 	GBA_PORT_RAM_DATA7_0 = 0;
 1065               		.loc 1 544 0
 1066 02aa 15BA      		out 0x15,__zero_reg__
 545:setup.c       **** 	GBA_DDR_RAM_DATA7_0 = 0;
 1067               		.loc 1 545 0
 1068 02ac 14BA      		out 0x14,__zero_reg__
 546:setup.c       **** 	
 547:setup.c       **** 	// Read and transmit the 2 bytes
 548:setup.c       **** 	flashChipIdBuffer[0] = gba_read_ram_8bit_data(0x0000);
 1069               		.loc 1 548 0
 1070 02ae 80E0      		ldi r24,0
 1071 02b0 90E0      		ldi r25,0
 1072 02b2 00D0      		rcall gba_read_ram_8bit_data
 1073               	.LVL67:
 1074 02b4 C0E0      		ldi r28,lo8(flashChipIdBuffer)
 1075 02b6 D0E0      		ldi r29,hi8(flashChipIdBuffer)
 1076 02b8 8883      		st Y,r24
 549:setup.c       **** 	flashChipIdBuffer[1] = gba_read_ram_8bit_data(0x0001);
 1077               		.loc 1 549 0
 1078 02ba 81E0      		ldi r24,lo8(1)
 1079 02bc 90E0      		ldi r25,0
 1080 02be 00D0      		rcall gba_read_ram_8bit_data
 1081               	.LVL68:
 1082 02c0 8983      		std Y+1,r24
 550:setup.c       **** 	
 551:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xAA);
 1083               		.loc 1 551 0
 1084 02c2 6AEA      		ldi r22,lo8(-86)
 1085 02c4 85E5      		ldi r24,lo8(85)
 1086 02c6 95E5      		ldi r25,lo8(85)
 1087 02c8 00D0      		rcall flash_write_bus_cycle
 1088               	.LVL69:
 552:setup.c       **** 	flash_write_bus_cycle(0x2AAA, 0x55);
 1089               		.loc 1 552 0
 1090 02ca 65E5      		ldi r22,lo8(85)
 1091 02cc 8AEA      		ldi r24,lo8(-86)
 1092 02ce 9AE2      		ldi r25,lo8(42)
 1093 02d0 00D0      		rcall flash_write_bus_cycle
 1094               	.LVL70:
 553:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xF0); // Software ID exit
 1095               		.loc 1 553 0
 1096 02d2 60EF      		ldi r22,lo8(-16)
 1097 02d4 85E5      		ldi r24,lo8(85)
 1098 02d6 95E5      		ldi r25,lo8(85)
 1099 02d8 00D0      		rcall flash_write_bus_cycle
 1100               	.LVL71:
 1101               	.LBB66:
 1102               	.LBB67:
 1103               		.loc 2 187 0
 1104 02da 8FE3      		ldi r24,lo8(-25537)
 1105 02dc 9CE9      		ldi r25,hi8(-25537)
 1106 02de 0197      	1:	sbiw r24,1
 1107 02e0 01F4      		brne 1b
 1108 02e2 00C0      		rjmp .
 1109 02e4 0000      		nop
 1110               	.LVL72:
 1111               	/* epilogue start */
 1112               	.LBE67:
 1113               	.LBE66:
 554:setup.c       **** 	_delay_ms(20); // Wait a little (for Atmel chip)
 555:setup.c       **** }
 1114               		.loc 1 555 0
 1115 02e6 DF91      		pop r29
 1116 02e8 CF91      		pop r28
 1117 02ea 0895      		ret
 1118               		.cfi_endproc
 1119               	.LFE31:
 1121               	.global	flash_switch_bank
 1123               	flash_switch_bank:
 1124               	.LFB32:
 556:setup.c       **** 
 557:setup.c       **** // Switch banks on the Flash
 558:setup.c       **** void flash_switch_bank(uint8_t bank) {
 1125               		.loc 1 558 0
 1126               		.cfi_startproc
 1127               	.LVL73:
 1128 02ec CF93      		push r28
 1129               	.LCFI13:
 1130               		.cfi_def_cfa_offset 3
 1131               		.cfi_offset 28, -2
 1132               	/* prologue: function */
 1133               	/* frame size = 0 */
 1134               	/* stack size = 1 */
 1135               	.L__stack_usage = 1
 1136 02ee C82F      		mov r28,r24
 559:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xAA);
 1137               		.loc 1 559 0
 1138 02f0 6AEA      		ldi r22,lo8(-86)
 1139 02f2 85E5      		ldi r24,lo8(85)
 1140 02f4 95E5      		ldi r25,lo8(85)
 1141               	.LVL74:
 1142 02f6 00D0      		rcall flash_write_bus_cycle
 1143               	.LVL75:
 560:setup.c       **** 	flash_write_bus_cycle(0x2AAA, 0x55);
 1144               		.loc 1 560 0
 1145 02f8 65E5      		ldi r22,lo8(85)
 1146 02fa 8AEA      		ldi r24,lo8(-86)
 1147 02fc 9AE2      		ldi r25,lo8(42)
 1148 02fe 00D0      		rcall flash_write_bus_cycle
 1149               	.LVL76:
 561:setup.c       **** 	
 562:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xB0);
 1150               		.loc 1 562 0
 1151 0300 60EB      		ldi r22,lo8(-80)
 1152 0302 85E5      		ldi r24,lo8(85)
 1153 0304 95E5      		ldi r25,lo8(85)
 1154 0306 00D0      		rcall flash_write_bus_cycle
 1155               	.LVL77:
 563:setup.c       **** 	flash_write_bus_cycle(0x0000, bank);
 1156               		.loc 1 563 0
 1157 0308 6C2F      		mov r22,r28
 1158 030a 80E0      		ldi r24,0
 1159 030c 90E0      		ldi r25,0
 1160               	/* epilogue start */
 564:setup.c       **** }
 1161               		.loc 1 564 0
 1162 030e CF91      		pop r28
 1163               	.LVL78:
 563:setup.c       **** 	flash_write_bus_cycle(0x0000, bank);
 1164               		.loc 1 563 0
 1165 0310 00C0      		rjmp flash_write_bus_cycle
 1166               	.LVL79:
 1167               		.cfi_endproc
 1168               	.LFE32:
 1170               	.global	flash_erase_4k_sector
 1172               	flash_erase_4k_sector:
 1173               	.LFB33:
 565:setup.c       **** 
 566:setup.c       **** // Erase 4K sector on Flash, expects first sector to start at 0, left shifts by 12 (A15-A12 to sele
 567:setup.c       **** // Takes 25ms after last command to erase sector
 568:setup.c       **** void flash_erase_4k_sector(uint8_t sector) {
 1174               		.loc 1 568 0
 1175               		.cfi_startproc
 1176               	.LVL80:
 1177 0312 CF93      		push r28
 1178               	.LCFI14:
 1179               		.cfi_def_cfa_offset 3
 1180               		.cfi_offset 28, -2
 1181               	/* prologue: function */
 1182               	/* frame size = 0 */
 1183               	/* stack size = 1 */
 1184               	.L__stack_usage = 1
 1185 0314 C82F      		mov r28,r24
 569:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xAA);
 1186               		.loc 1 569 0
 1187 0316 6AEA      		ldi r22,lo8(-86)
 1188 0318 85E5      		ldi r24,lo8(85)
 1189 031a 95E5      		ldi r25,lo8(85)
 1190               	.LVL81:
 1191 031c 00D0      		rcall flash_write_bus_cycle
 1192               	.LVL82:
 570:setup.c       **** 	flash_write_bus_cycle(0x2AAA, 0x55);
 1193               		.loc 1 570 0
 1194 031e 65E5      		ldi r22,lo8(85)
 1195 0320 8AEA      		ldi r24,lo8(-86)
 1196 0322 9AE2      		ldi r25,lo8(42)
 1197 0324 00D0      		rcall flash_write_bus_cycle
 1198               	.LVL83:
 571:setup.c       **** 	flash_write_bus_cycle(0x5555, 0x80);
 1199               		.loc 1 571 0
 1200 0326 60E8      		ldi r22,lo8(-128)
 1201 0328 85E5      		ldi r24,lo8(85)
 1202 032a 95E5      		ldi r25,lo8(85)
 1203 032c 00D0      		rcall flash_write_bus_cycle
 1204               	.LVL84:
 572:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xAA);
 1205               		.loc 1 572 0
 1206 032e 6AEA      		ldi r22,lo8(-86)
 1207 0330 85E5      		ldi r24,lo8(85)
 1208 0332 95E5      		ldi r25,lo8(85)
 1209 0334 00D0      		rcall flash_write_bus_cycle
 1210               	.LVL85:
 573:setup.c       **** 	flash_write_bus_cycle(0x2AAA, 0x55);
 1211               		.loc 1 573 0
 1212 0336 65E5      		ldi r22,lo8(85)
 1213 0338 8AEA      		ldi r24,lo8(-86)
 1214 033a 9AE2      		ldi r25,lo8(42)
 1215 033c 00D0      		rcall flash_write_bus_cycle
 1216               	.LVL86:
 574:setup.c       **** 	
 575:setup.c       **** 	flash_write_bus_cycle((uint16_t) sector << 12, 0x30);
 1217               		.loc 1 575 0
 1218 033e 60E3      		ldi r22,lo8(48)
 1219 0340 80E0      		ldi r24,0
 1220 0342 9C2F      		mov r25,r28
 1221 0344 9295      		swap r25
 1222 0346 907F      		andi r25,lo8(-16)
 1223 0348 00D0      		rcall flash_write_bus_cycle
 1224               	.LVL87:
 1225               	.LBB68:
 1226               	.LBB69:
 1227               		.loc 2 187 0
 1228 034a 8FE4      		ldi r24,lo8(-15537)
 1229 034c 93EC      		ldi r25,hi8(-15537)
 1230 034e 0197      	1:	sbiw r24,1
 1231 0350 01F4      		brne 1b
 1232 0352 00C0      		rjmp .
 1233 0354 0000      		nop
 1234               	.LVL88:
 1235               	/* epilogue start */
 1236               	.LBE69:
 1237               	.LBE68:
 576:setup.c       **** 	_delay_ms(25); // Wait 25ms for sector erase
 577:setup.c       **** }
 1238               		.loc 1 577 0
 1239 0356 CF91      		pop r28
 1240               	.LVL89:
 1241 0358 0895      		ret
 1242               		.cfi_endproc
 1243               	.LFE33:
 1245               	.global	flash_write_byte
 1247               	flash_write_byte:
 1248               	.LFB34:
 578:setup.c       **** 
 579:setup.c       **** // Write a single byte to the Flash address
 580:setup.c       **** // Takes 20us to program Flash
 581:setup.c       **** void flash_write_byte(uint16_t address, uint8_t data) {
 1249               		.loc 1 581 0
 1250               		.cfi_startproc
 1251               	.LVL90:
 1252 035a 1F93      		push r17
 1253               	.LCFI15:
 1254               		.cfi_def_cfa_offset 3
 1255               		.cfi_offset 17, -2
 1256 035c CF93      		push r28
 1257               	.LCFI16:
 1258               		.cfi_def_cfa_offset 4
 1259               		.cfi_offset 28, -3
 1260 035e DF93      		push r29
 1261               	.LCFI17:
 1262               		.cfi_def_cfa_offset 5
 1263               		.cfi_offset 29, -4
 1264               	/* prologue: function */
 1265               	/* frame size = 0 */
 1266               	/* stack size = 3 */
 1267               	.L__stack_usage = 3
 1268 0360 EC01      		movw r28,r24
 1269 0362 162F      		mov r17,r22
 582:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xAA);
 1270               		.loc 1 582 0
 1271 0364 6AEA      		ldi r22,lo8(-86)
 1272               	.LVL91:
 1273 0366 85E5      		ldi r24,lo8(85)
 1274 0368 95E5      		ldi r25,lo8(85)
 1275               	.LVL92:
 1276 036a 00D0      		rcall flash_write_bus_cycle
 1277               	.LVL93:
 583:setup.c       **** 	flash_write_bus_cycle(0x2AAA, 0x55);
 1278               		.loc 1 583 0
 1279 036c 65E5      		ldi r22,lo8(85)
 1280 036e 8AEA      		ldi r24,lo8(-86)
 1281 0370 9AE2      		ldi r25,lo8(42)
 1282 0372 00D0      		rcall flash_write_bus_cycle
 1283               	.LVL94:
 584:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xA0);
 1284               		.loc 1 584 0
 1285 0374 60EA      		ldi r22,lo8(-96)
 1286 0376 85E5      		ldi r24,lo8(85)
 1287 0378 95E5      		ldi r25,lo8(85)
 1288 037a 00D0      		rcall flash_write_bus_cycle
 1289               	.LVL95:
 585:setup.c       **** 	
 586:setup.c       **** 	flash_write_bus_cycle(address, data);
 1290               		.loc 1 586 0
 1291 037c 612F      		mov r22,r17
 1292 037e CE01      		movw r24,r28
 1293 0380 00D0      		rcall flash_write_bus_cycle
 1294               	.LVL96:
 1295               	.LBB70:
 1296               	.LBB71:
 188:c:\winavr-20100110\avr\include\util\delay.h **** 
 189:c:\winavr-20100110\avr\include\util\delay.h **** #else
 190:c:\winavr-20100110\avr\include\util\delay.h **** 	uint16_t __ticks;
 191:c:\winavr-20100110\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 4e3) * __ms;
 192:c:\winavr-20100110\avr\include\util\delay.h **** 	if (__tmp < 1.0)
 193:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks = 1;
 194:c:\winavr-20100110\avr\include\util\delay.h **** 	else if (__tmp > 65535)
 195:c:\winavr-20100110\avr\include\util\delay.h **** 	{
 196:c:\winavr-20100110\avr\include\util\delay.h **** 		//	__ticks = requested delay in 1/10 ms
 197:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 198:c:\winavr-20100110\avr\include\util\delay.h **** 		while(__ticks)
 199:c:\winavr-20100110\avr\include\util\delay.h **** 		{
 200:c:\winavr-20100110\avr\include\util\delay.h **** 			// wait 1/10 ms
 201:c:\winavr-20100110\avr\include\util\delay.h **** 			_delay_loop_2(((F_CPU) / 4e3) / 10);
 202:c:\winavr-20100110\avr\include\util\delay.h **** 			__ticks --;
 203:c:\winavr-20100110\avr\include\util\delay.h **** 		}
 204:c:\winavr-20100110\avr\include\util\delay.h **** 		return;
 205:c:\winavr-20100110\avr\include\util\delay.h **** 	}
 206:c:\winavr-20100110\avr\include\util\delay.h **** 	else
 207:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks = (uint16_t)__tmp;
 208:c:\winavr-20100110\avr\include\util\delay.h **** 	_delay_loop_2(__ticks);
 209:c:\winavr-20100110\avr\include\util\delay.h **** #endif
 210:c:\winavr-20100110\avr\include\util\delay.h **** }
 211:c:\winavr-20100110\avr\include\util\delay.h **** 
 212:c:\winavr-20100110\avr\include\util\delay.h **** /**
 213:c:\winavr-20100110\avr\include\util\delay.h ****    \ingroup util_delay
 214:c:\winavr-20100110\avr\include\util\delay.h **** 
 215:c:\winavr-20100110\avr\include\util\delay.h ****    Perform a delay of \c __us microseconds, using _delay_loop_1().
 216:c:\winavr-20100110\avr\include\util\delay.h **** 
 217:c:\winavr-20100110\avr\include\util\delay.h ****    The macro F_CPU is supposed to be defined to a
 218:c:\winavr-20100110\avr\include\util\delay.h ****    constant defining the CPU clock frequency (in Hertz).
 219:c:\winavr-20100110\avr\include\util\delay.h **** 
 220:c:\winavr-20100110\avr\include\util\delay.h ****    The maximal possible delay is 768 us / F_CPU in MHz.
 221:c:\winavr-20100110\avr\include\util\delay.h **** 
 222:c:\winavr-20100110\avr\include\util\delay.h ****    If the user requests a delay greater than the maximal possible one,
 223:c:\winavr-20100110\avr\include\util\delay.h ****    _delay_us() will automatically call _delay_ms() instead.  The user
 224:c:\winavr-20100110\avr\include\util\delay.h ****    will not be informed about this case.
 225:c:\winavr-20100110\avr\include\util\delay.h **** 
 226:c:\winavr-20100110\avr\include\util\delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 227:c:\winavr-20100110\avr\include\util\delay.h ****    support, maximal possible delay is 4294967.295 us/ F_CPU in MHz. For
 228:c:\winavr-20100110\avr\include\util\delay.h ****    values greater than the maximal possible delay, overflow results in
 229:c:\winavr-20100110\avr\include\util\delay.h ****    no delay i.e., 0us.
 230:c:\winavr-20100110\avr\include\util\delay.h **** 
 231:c:\winavr-20100110\avr\include\util\delay.h ****    Conversion of \c __us into clock cycles may not always result in
 232:c:\winavr-20100110\avr\include\util\delay.h ****    integer.  By default, the clock cycles rounded up to next
 233:c:\winavr-20100110\avr\include\util\delay.h ****    integer. This ensures that the user gets at least \c __us
 234:c:\winavr-20100110\avr\include\util\delay.h ****    microseconds of delay.
 235:c:\winavr-20100110\avr\include\util\delay.h **** 
 236:c:\winavr-20100110\avr\include\util\delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 237:c:\winavr-20100110\avr\include\util\delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 238:c:\winavr-20100110\avr\include\util\delay.h ****    algorithm can be made to round down, or round to closest integer,
 239:c:\winavr-20100110\avr\include\util\delay.h ****    respectively.
 240:c:\winavr-20100110\avr\include\util\delay.h **** 
 241:c:\winavr-20100110\avr\include\util\delay.h ****    \note
 242:c:\winavr-20100110\avr\include\util\delay.h **** 
 243:c:\winavr-20100110\avr\include\util\delay.h ****    The implementation of _delay_ms() based on
 244:c:\winavr-20100110\avr\include\util\delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 245:c:\winavr-20100110\avr\include\util\delay.h ****    implementations.  In order to get functionality backward compatible
 246:c:\winavr-20100110\avr\include\util\delay.h ****    with previous versions, the macro \c __DELAY_BACKWARD_COMPATIBLE__
 247:c:\winavr-20100110\avr\include\util\delay.h ****    must be defined before including this header file. Also, the
 248:c:\winavr-20100110\avr\include\util\delay.h ****    backward compatible algorithm will be chosen if the code is
 249:c:\winavr-20100110\avr\include\util\delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 250:c:\winavr-20100110\avr\include\util\delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 251:c:\winavr-20100110\avr\include\util\delay.h ****    not available to the compiler then.
 252:c:\winavr-20100110\avr\include\util\delay.h **** 
 253:c:\winavr-20100110\avr\include\util\delay.h ****  */
 254:c:\winavr-20100110\avr\include\util\delay.h **** void
 255:c:\winavr-20100110\avr\include\util\delay.h **** _delay_us(double __us)
 256:c:\winavr-20100110\avr\include\util\delay.h **** {
 257:c:\winavr-20100110\avr\include\util\delay.h **** 	double __tmp ;
 258:c:\winavr-20100110\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 259:c:\winavr-20100110\avr\include\util\delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 260:c:\winavr-20100110\avr\include\util\delay.h ****   __STDC_HOSTED__
 261:c:\winavr-20100110\avr\include\util\delay.h **** 	uint32_t __ticks_dc;
 262:c:\winavr-20100110\avr\include\util\delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 263:c:\winavr-20100110\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 264:c:\winavr-20100110\avr\include\util\delay.h **** 
 265:c:\winavr-20100110\avr\include\util\delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 266:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 267:c:\winavr-20100110\avr\include\util\delay.h **** 
 268:c:\winavr-20100110\avr\include\util\delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 269:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 270:c:\winavr-20100110\avr\include\util\delay.h **** 
 271:c:\winavr-20100110\avr\include\util\delay.h **** 	#else
 272:c:\winavr-20100110\avr\include\util\delay.h **** 		//round up by default
 273:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 274:c:\winavr-20100110\avr\include\util\delay.h **** 	#endif
 275:c:\winavr-20100110\avr\include\util\delay.h **** 
 276:c:\winavr-20100110\avr\include\util\delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 1297               		.loc 2 276 0
 1298 0382 85E3      		ldi r24,lo8(53)
 1299 0384 8A95      	1:	dec r24
 1300 0386 01F4      		brne 1b
 1301 0388 0000      		nop
 1302               	.LVL97:
 1303               	/* epilogue start */
 1304               	.LBE71:
 1305               	.LBE70:
 587:setup.c       **** 	_delay_us(20); // Wait byte program time
 588:setup.c       **** }
 1306               		.loc 1 588 0
 1307 038a DF91      		pop r29
 1308 038c CF91      		pop r28
 1309               	.LVL98:
 1310 038e 1F91      		pop r17
 1311               	.LVL99:
 1312 0390 0895      		ret
 1313               		.cfi_endproc
 1314               	.LFE34:
 1316               	.global	flash_write_sector
 1318               	flash_write_sector:
 1319               	.LFB35:
 589:setup.c       **** 
 590:setup.c       **** // Write a sector (128 bytes) to the Atmel flash
 591:setup.c       **** // Takes 20ms for write cycle
 592:setup.c       **** void flash_write_sector(uint16_t sector) {
 1320               		.loc 1 592 0
 1321               		.cfi_startproc
 1322               	.LVL100:
 1323 0392 EF92      		push r14
 1324               	.LCFI18:
 1325               		.cfi_def_cfa_offset 3
 1326               		.cfi_offset 14, -2
 1327 0394 FF92      		push r15
 1328               	.LCFI19:
 1329               		.cfi_def_cfa_offset 4
 1330               		.cfi_offset 15, -3
 1331 0396 0F93      		push r16
 1332               	.LCFI20:
 1333               		.cfi_def_cfa_offset 5
 1334               		.cfi_offset 16, -4
 1335 0398 1F93      		push r17
 1336               	.LCFI21:
 1337               		.cfi_def_cfa_offset 6
 1338               		.cfi_offset 17, -5
 1339 039a CF93      		push r28
 1340               	.LCFI22:
 1341               		.cfi_def_cfa_offset 7
 1342               		.cfi_offset 28, -6
 1343 039c DF93      		push r29
 1344               	.LCFI23:
 1345               		.cfi_def_cfa_offset 8
 1346               		.cfi_offset 29, -7
 1347               	/* prologue: function */
 1348               	/* frame size = 0 */
 1349               	/* stack size = 6 */
 1350               	.L__stack_usage = 6
 1351 039e 8C01      		movw r16,r24
 593:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xAA);
 1352               		.loc 1 593 0
 1353 03a0 6AEA      		ldi r22,lo8(-86)
 1354 03a2 85E5      		ldi r24,lo8(85)
 1355 03a4 95E5      		ldi r25,lo8(85)
 1356               	.LVL101:
 1357 03a6 00D0      		rcall flash_write_bus_cycle
 1358               	.LVL102:
 594:setup.c       **** 	flash_write_bus_cycle(0x2AAA, 0x55);
 1359               		.loc 1 594 0
 1360 03a8 65E5      		ldi r22,lo8(85)
 1361 03aa 8AEA      		ldi r24,lo8(-86)
 1362 03ac 9AE2      		ldi r25,lo8(42)
 1363 03ae 00D0      		rcall flash_write_bus_cycle
 1364               	.LVL103:
 595:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xA0);
 1365               		.loc 1 595 0
 1366 03b0 60EA      		ldi r22,lo8(-96)
 1367 03b2 85E5      		ldi r24,lo8(85)
 1368 03b4 95E5      		ldi r25,lo8(85)
 1369 03b6 00D0      		rcall flash_write_bus_cycle
 1370               	.LVL104:
 1371               	.LBB72:
 596:setup.c       **** 	
 597:setup.c       **** 	// Write the bytes (A0-A6 byte address, A7-A15 sector address)
 598:setup.c       **** 	for (uint8_t x = 0; x < 128; x++) {
 599:setup.c       **** 		flash_write_bus_cycle((uint16_t) (sector << 7) | (uint16_t) x, receivedBuffer[x]);
 1372               		.loc 1 599 0
 1373 03b8 1695      		lsr r17
 1374 03ba 102F      		mov r17,r16
 1375 03bc 0027      		clr r16
 1376 03be 1795      		ror r17
 1377 03c0 0795      		ror r16
 1378               	.LVL105:
 1379 03c2 90E0      		ldi r25,lo8(receivedBuffer)
 1380 03c4 E92E      		mov r14,r25
 1381 03c6 90E0      		ldi r25,hi8(receivedBuffer)
 1382 03c8 F92E      		mov r15,r25
 1383 03ca C0E0      		ldi r28,0
 1384 03cc D0E0      		ldi r29,0
 1385               	.LVL106:
 1386               	.L66:
 1387               		.loc 1 599 0 is_stmt 0 discriminator 3
 1388 03ce F701      		movw r30,r14
 1389 03d0 6191      		ld r22,Z+
 1390 03d2 7F01      		movw r14,r30
 1391 03d4 CE01      		movw r24,r28
 1392 03d6 802B      		or r24,r16
 1393 03d8 912B      		or r25,r17
 1394 03da 00D0      		rcall flash_write_bus_cycle
 1395               	.LVL107:
 1396 03dc 2196      		adiw r28,1
 1397               	.LVL108:
 598:setup.c       **** 		flash_write_bus_cycle((uint16_t) (sector << 7) | (uint16_t) x, receivedBuffer[x]);
 1398               		.loc 1 598 0 is_stmt 1 discriminator 3
 1399 03de C038      		cpi r28,-128
 1400 03e0 D105      		cpc r29,__zero_reg__
 1401 03e2 01F4      		brne .L66
 1402               	.LVL109:
 1403               	.LBE72:
 1404               	.LBB73:
 1405               	.LBB74:
 187:c:\winavr-20100110\avr\include\util\delay.h **** 
 1406               		.loc 2 187 0
 1407 03e4 8FE3      		ldi r24,lo8(-25537)
 1408 03e6 9CE9      		ldi r25,hi8(-25537)
 1409 03e8 0197      	1:	sbiw r24,1
 1410 03ea 01F4      		brne 1b
 1411 03ec 00C0      		rjmp .
 1412 03ee 0000      		nop
 1413               	.LVL110:
 1414               	/* epilogue start */
 1415               	.LBE74:
 1416               	.LBE73:
 600:setup.c       **** 	}
 601:setup.c       **** 	_delay_ms(20); // Wait sector program time
 602:setup.c       **** }
 1417               		.loc 1 602 0
 1418 03f0 DF91      		pop r29
 1419 03f2 CF91      		pop r28
 1420               	.LVL111:
 1421 03f4 1F91      		pop r17
 1422 03f6 0F91      		pop r16
 1423 03f8 FF90      		pop r15
 1424 03fa EF90      		pop r14
 1425 03fc 0895      		ret
 1426               		.cfi_endproc
 1427               	.LFE35:
 1429               	.global	gb_flash_read_byte
 1431               	gb_flash_read_byte:
 1432               	.LFB36:
 603:setup.c       **** 
 604:setup.c       **** 
 605:setup.c       **** 
 606:setup.c       **** // ---------- GB FLASH CARTS ----------
 607:setup.c       **** 
 608:setup.c       **** // Read a byte from the flash (No CS pin pulse)
 609:setup.c       **** uint8_t gb_flash_read_byte(uint16_t address) {
 1433               		.loc 1 609 0
 1434               		.cfi_startproc
 1435               	.LVL112:
 1436               	/* prologue: function */
 1437               	/* frame size = 0 */
 1438               	/* stack size = 0 */
 1439               	.L__stack_usage = 0
 610:setup.c       **** 	PORT_DATA7_0 = 0;
 1440               		.loc 1 610 0
 1441 03fe 15BA      		out 0x15,__zero_reg__
 611:setup.c       **** 	DDR_DATA7_0 = 0;
 1442               		.loc 1 611 0
 1443 0400 14BA      		out 0x14,__zero_reg__
 612:setup.c       **** 	
 613:setup.c       **** 	set_16bit_address(address);
 1444               		.loc 1 613 0
 1445 0402 00D0      		rcall set_16bit_address
 1446               	.LVL113:
 614:setup.c       **** 	
 615:setup.c       **** 	rdPin_low;
 1447               		.loc 1 615 0
 1448 0404 9598      		cbi 0x12,5
 616:setup.c       **** 	asm volatile("nop"); // Delay a little
 1449               		.loc 1 616 0
 1450               	/* #APP */
 1451               	 ;  616 "setup.c" 1
 1452 0406 0000      		nop
 1453               	 ;  0 "" 2
 617:setup.c       **** 	asm volatile("nop");
 1454               		.loc 1 617 0
 1455               	 ;  617 "setup.c" 1
 1456 0408 0000      		nop
 1457               	 ;  0 "" 2
 618:setup.c       **** 	uint8_t data = PIN_DATA7_0; // Read data
 1458               		.loc 1 618 0
 1459               	/* #NOAPP */
 1460 040a 83B3      		in r24,0x13
 1461               	.LVL114:
 619:setup.c       **** 	rdPin_high;
 1462               		.loc 1 619 0
 1463 040c 959A      		sbi 0x12,5
 620:setup.c       **** 	
 621:setup.c       **** 	return data;
 622:setup.c       **** }
 1464               		.loc 1 622 0
 1465 040e 0895      		ret
 1466               		.cfi_endproc
 1467               	.LFE36:
 1469               	.global	gb_flash_write_bus_cycle
 1471               	gb_flash_write_bus_cycle:
 1472               	.LFB37:
 623:setup.c       **** 
 624:setup.c       **** // Set the address and data for the write byte cycle to the flash
 625:setup.c       **** void gb_flash_write_bus_cycle(uint16_t address, uint8_t data) {
 1473               		.loc 1 625 0
 1474               		.cfi_startproc
 1475               	.LVL115:
 1476 0410 CF93      		push r28
 1477               	.LCFI24:
 1478               		.cfi_def_cfa_offset 3
 1479               		.cfi_offset 28, -2
 1480               	/* prologue: function */
 1481               	/* frame size = 0 */
 1482               	/* stack size = 1 */
 1483               	.L__stack_usage = 1
 1484 0412 C62F      		mov r28,r22
 626:setup.c       **** 	DDR_DATA7_0 = 0xFF; // Set data pins as outputs
 1485               		.loc 1 626 0
 1486 0414 2FEF      		ldi r18,lo8(-1)
 1487 0416 24BB      		out 0x14,r18
 627:setup.c       **** 	set_16bit_address(address);
 1488               		.loc 1 627 0
 1489 0418 00D0      		rcall set_16bit_address
 1490               	.LVL116:
 628:setup.c       **** 	PORT_DATA7_0 = data;
 1491               		.loc 1 628 0
 1492 041a C5BB      		out 0x15,r28
 629:setup.c       **** 	
 630:setup.c       **** 	if (flashWriteWePin == WE_AS_AUDIO_PIN) { // Audio pin
 1493               		.loc 1 630 0
 1494 041c 8091 0000 		lds r24,flashWriteWePin
 1495 0420 8134      		cpi r24,lo8(65)
 1496 0422 01F4      		brne .L70
 1497               	.LVL117:
 1498               	.LBB77:
 1499               	.LBB78:
 631:setup.c       **** 		audioPin_low; // WE low
 1500               		.loc 1 631 0
 1501 0424 3998      		cbi 0x7,1
 632:setup.c       **** 		asm volatile("nop");
 1502               		.loc 1 632 0
 1503               	/* #APP */
 1504               	 ;  632 "setup.c" 1
 1505 0426 0000      		nop
 1506               	 ;  0 "" 2
 633:setup.c       **** 		asm volatile("nop");
 1507               		.loc 1 633 0
 1508               	 ;  633 "setup.c" 1
 1509 0428 0000      		nop
 1510               	 ;  0 "" 2
 634:setup.c       **** 		asm volatile("nop");
 1511               		.loc 1 634 0
 1512               	 ;  634 "setup.c" 1
 1513 042a 0000      		nop
 1514               	 ;  0 "" 2
 635:setup.c       **** 		audioPin_high; // WE high
 1515               		.loc 1 635 0
 1516               	/* #NOAPP */
 1517 042c 399A      		sbi 0x7,1
 1518 042e 00C0      		rjmp .L69
 1519               	.LVL118:
 1520               	.L70:
 1521               	.LBE78:
 1522               	.LBE77:
 636:setup.c       **** 	}
 637:setup.c       **** 	else { // WR pin
 638:setup.c       **** 		wrPin_low; // WE low
 1523               		.loc 1 638 0
 1524 0430 9698      		cbi 0x12,6
 639:setup.c       **** 		asm volatile("nop");
 1525               		.loc 1 639 0
 1526               	/* #APP */
 1527               	 ;  639 "setup.c" 1
 1528 0432 0000      		nop
 1529               	 ;  0 "" 2
 640:setup.c       **** 		asm volatile("nop");
 1530               		.loc 1 640 0
 1531               	 ;  640 "setup.c" 1
 1532 0434 0000      		nop
 1533               	 ;  0 "" 2
 641:setup.c       **** 		asm volatile("nop");
 1534               		.loc 1 641 0
 1535               	 ;  641 "setup.c" 1
 1536 0436 0000      		nop
 1537               	 ;  0 "" 2
 642:setup.c       **** 		wrPin_high; // WE high
 1538               		.loc 1 642 0
 1539               	/* #NOAPP */
 1540 0438 969A      		sbi 0x12,6
 1541               	.L69:
 1542               	/* epilogue start */
 643:setup.c       **** 	}
 644:setup.c       **** }
 1543               		.loc 1 644 0
 1544 043a CF91      		pop r28
 1545               	.LVL119:
 1546 043c 0895      		ret
 1547               		.cfi_endproc
 1548               	.LFE37:
 1550               	.global	gb_flash_write_byte
 1552               	gb_flash_write_byte:
 1553               	.LFB38:
 645:setup.c       **** 
 646:setup.c       **** // Write a single byte to the Flash address. Takes 20-50us to program each byte.
 647:setup.c       **** void gb_flash_write_byte(uint16_t address, uint8_t data) {
 1554               		.loc 1 647 0
 1555               		.cfi_startproc
 1556               	.LVL120:
 1557 043e 1F93      		push r17
 1558               	.LCFI25:
 1559               		.cfi_def_cfa_offset 3
 1560               		.cfi_offset 17, -2
 1561 0440 CF93      		push r28
 1562               	.LCFI26:
 1563               		.cfi_def_cfa_offset 4
 1564               		.cfi_offset 28, -3
 1565 0442 DF93      		push r29
 1566               	.LCFI27:
 1567               		.cfi_def_cfa_offset 5
 1568               		.cfi_offset 29, -4
 1569               	/* prologue: function */
 1570               	/* frame size = 0 */
 1571               	/* stack size = 3 */
 1572               	.L__stack_usage = 3
 1573 0444 EC01      		movw r28,r24
 1574 0446 162F      		mov r17,r22
 648:setup.c       **** 	gb_flash_write_bus_cycle(flashWriteCycle[0][0], flashWriteCycle[0][1]);
 1575               		.loc 1 648 0
 1576 0448 6091 0000 		lds r22,flashWriteCycle+2
 1577               	.LVL121:
 1578 044c 8091 0000 		lds r24,flashWriteCycle
 1579 0450 9091 0000 		lds r25,flashWriteCycle+1
 1580               	.LVL122:
 1581 0454 00D0      		rcall gb_flash_write_bus_cycle
 1582               	.LVL123:
 649:setup.c       **** 	gb_flash_write_bus_cycle(flashWriteCycle[1][0], flashWriteCycle[1][1]);
 1583               		.loc 1 649 0
 1584 0456 6091 0000 		lds r22,flashWriteCycle+6
 1585 045a 8091 0000 		lds r24,flashWriteCycle+4
 1586 045e 9091 0000 		lds r25,flashWriteCycle+4+1
 1587 0462 00D0      		rcall gb_flash_write_bus_cycle
 1588               	.LVL124:
 650:setup.c       **** 	gb_flash_write_bus_cycle(flashWriteCycle[2][0], flashWriteCycle[2][1]);
 1589               		.loc 1 650 0
 1590 0464 6091 0000 		lds r22,flashWriteCycle+10
 1591 0468 8091 0000 		lds r24,flashWriteCycle+8
 1592 046c 9091 0000 		lds r25,flashWriteCycle+8+1
 1593 0470 00D0      		rcall gb_flash_write_bus_cycle
 1594               	.LVL125:
 651:setup.c       **** 	gb_flash_write_bus_cycle(address, data);
 1595               		.loc 1 651 0
 1596 0472 612F      		mov r22,r17
 1597 0474 CE01      		movw r24,r28
 1598 0476 00D0      		rcall gb_flash_write_bus_cycle
 1599               	.LVL126:
 1600               	.LBB79:
 1601               	.LBB80:
 1602               		.loc 2 276 0
 1603 0478 85E3      		ldi r24,lo8(53)
 1604 047a 8A95      	1:	dec r24
 1605 047c 01F4      		brne 1b
 1606 047e 0000      		nop
 1607               	.LVL127:
 1608               	.LBE80:
 1609               	.LBE79:
 652:setup.c       **** 	_delay_us(20); // Wait byte program time
 653:setup.c       **** 	
 654:setup.c       **** 	// Set data pins inputs
 655:setup.c       **** 	PORT_DATA7_0 = 0;
 1610               		.loc 1 655 0
 1611 0480 15BA      		out 0x15,__zero_reg__
 656:setup.c       **** 	DDR_DATA7_0 = 0;
 1612               		.loc 1 656 0
 1613 0482 14BA      		out 0x14,__zero_reg__
 657:setup.c       **** 	
 658:setup.c       **** 	// Verify data
 659:setup.c       **** 	uint8_t dataVerify = gb_flash_read_byte(address);
 1614               		.loc 1 659 0
 1615 0484 CE01      		movw r24,r28
 1616 0486 00D0      		rcall gb_flash_read_byte
 1617               	.LVL128:
 1618               	.L73:
 660:setup.c       **** 	while (data != dataVerify) {
 1619               		.loc 1 660 0
 1620 0488 8117      		cp r24,r17
 1621 048a 01F0      		breq .L75
 661:setup.c       **** 		dataVerify = gb_flash_read_byte(address);
 1622               		.loc 1 661 0
 1623 048c CE01      		movw r24,r28
 1624               	.LVL129:
 1625 048e 00D0      		rcall gb_flash_read_byte
 1626               	.LVL130:
 1627               	.LBB81:
 1628               	.LBB82:
 1629               		.loc 2 276 0
 1630 0490 95E3      		ldi r25,lo8(53)
 1631 0492 9A95      	1:	dec r25
 1632 0494 01F4      		brne 1b
 1633 0496 0000      		nop
 1634 0498 00C0      		rjmp .L73
 1635               	.LVL131:
 1636               	.L75:
 1637               	/* epilogue start */
 1638               	.LBE82:
 1639               	.LBE81:
 662:setup.c       **** 		_delay_us(20);
 663:setup.c       **** 	}
 664:setup.c       **** }
 1640               		.loc 1 664 0
 1641 049a DF91      		pop r29
 1642 049c CF91      		pop r28
 1643               	.LVL132:
 1644 049e 1F91      		pop r17
 1645               	.LVL133:
 1646 04a0 0895      		ret
 1647               		.cfi_endproc
 1648               	.LFE38:
 1650               	.global	gba_flash_write_bus_cycle
 1652               	gba_flash_write_bus_cycle:
 1653               	.LFB39:
 665:setup.c       **** 
 666:setup.c       **** 
 667:setup.c       **** 
 668:setup.c       **** // ---------- GBA FLASH CARTS ----------
 669:setup.c       **** 
 670:setup.c       **** // Set the 24 bit address and 16 bit data for the write byte cycle to the flash (pulse WR pin)
 671:setup.c       **** void gba_flash_write_bus_cycle(uint32_t address, uint16_t data) {
 1654               		.loc 1 671 0
 1655               		.cfi_startproc
 1656               	.LVL134:
 1657 04a2 CF93      		push r28
 1658               	.LCFI28:
 1659               		.cfi_def_cfa_offset 3
 1660               		.cfi_offset 28, -2
 1661 04a4 DF93      		push r29
 1662               	.LCFI29:
 1663               		.cfi_def_cfa_offset 4
 1664               		.cfi_offset 29, -3
 1665               	/* prologue: function */
 1666               	/* frame size = 0 */
 1667               	/* stack size = 2 */
 1668               	.L__stack_usage = 2
 1669 04a6 EA01      		movw r28,r20
 672:setup.c       **** 	gba_set_24bit_address(address);
 1670               		.loc 1 672 0
 1671 04a8 00D0      		rcall gba_set_24bit_address
 1672               	.LVL135:
 673:setup.c       **** 	
 674:setup.c       **** 	cs_mreqPin_low;
 1673               		.loc 1 674 0
 1674 04aa 9498      		cbi 0x12,4
 675:setup.c       **** 	
 676:setup.c       **** 	GBA_DDR_ROM_ADDR15_8 = 0xFF; // Set data pins as outputs
 1675               		.loc 1 676 0
 1676 04ac 8FEF      		ldi r24,lo8(-1)
 1677 04ae 8ABB      		out 0x1a,r24
 677:setup.c       **** 	GBA_DDR_ROM_ADDR7_0 = 0xFF;
 1678               		.loc 1 677 0
 1679 04b0 87BB      		out 0x17,r24
 678:setup.c       **** 	GBA_PORT_ROM_DATA15_8 = data >> 8; // Set data
 1680               		.loc 1 678 0
 1681 04b2 DBBB      		out 0x1b,r29
 679:setup.c       **** 	GBA_PORT_ROM_DATA7_0 = data & 0xFF;
 1682               		.loc 1 679 0
 1683 04b4 C8BB      		out 0x18,r28
 680:setup.c       **** 	
 681:setup.c       **** 	wrPin_low;
 1684               		.loc 1 681 0
 1685 04b6 9698      		cbi 0x12,6
 682:setup.c       **** 	asm volatile("nop");
 1686               		.loc 1 682 0
 1687               	/* #APP */
 1688               	 ;  682 "setup.c" 1
 1689 04b8 0000      		nop
 1690               	 ;  0 "" 2
 683:setup.c       **** 	asm volatile("nop");
 1691               		.loc 1 683 0
 1692               	 ;  683 "setup.c" 1
 1693 04ba 0000      		nop
 1694               	 ;  0 "" 2
 684:setup.c       **** 	asm volatile("nop");
 1695               		.loc 1 684 0
 1696               	 ;  684 "setup.c" 1
 1697 04bc 0000      		nop
 1698               	 ;  0 "" 2
 685:setup.c       **** 	wrPin_high;
 1699               		.loc 1 685 0
 1700               	/* #NOAPP */
 1701 04be 969A      		sbi 0x12,6
 686:setup.c       **** 	cs_mreqPin_high;
 1702               		.loc 1 686 0
 1703 04c0 949A      		sbi 0x12,4
 1704               	/* epilogue start */
 687:setup.c       **** }
 1705               		.loc 1 687 0
 1706 04c2 DF91      		pop r29
 1707 04c4 CF91      		pop r28
 1708               	.LVL136:
 1709 04c6 0895      		ret
 1710               		.cfi_endproc
 1711               	.LFE39:
 1713               	.global	gba_flash_write_byte_swapped
 1715               	gba_flash_write_byte_swapped:
 1716               	.LFB40:
 688:setup.c       **** 
 689:setup.c       **** // Write 2 bytes to the Flash address. Time to wait depends on Flash, we will query it to verify th
 690:setup.c       **** // Address is divided by 2 as we are in GBA mode. 
 691:setup.c       **** // Data byte's bit 0 & 1 are swapped for chip commands as D0 & D1 lines are swapped
 692:setup.c       **** void gba_flash_write_byte_swapped(uint32_t address, uint16_t data) {
 1717               		.loc 1 692 0
 1718               		.cfi_startproc
 1719               	.LVL137:
 1720 04c8 CF92      		push r12
 1721               	.LCFI30:
 1722               		.cfi_def_cfa_offset 3
 1723               		.cfi_offset 12, -2
 1724 04ca DF92      		push r13
 1725               	.LCFI31:
 1726               		.cfi_def_cfa_offset 4
 1727               		.cfi_offset 13, -3
 1728 04cc EF92      		push r14
 1729               	.LCFI32:
 1730               		.cfi_def_cfa_offset 5
 1731               		.cfi_offset 14, -4
 1732 04ce FF92      		push r15
 1733               	.LCFI33:
 1734               		.cfi_def_cfa_offset 6
 1735               		.cfi_offset 15, -5
 1736 04d0 CF93      		push r28
 1737               	.LCFI34:
 1738               		.cfi_def_cfa_offset 7
 1739               		.cfi_offset 28, -6
 1740 04d2 DF93      		push r29
 1741               	.LCFI35:
 1742               		.cfi_def_cfa_offset 8
 1743               		.cfi_offset 29, -7
 1744               	/* prologue: function */
 1745               	/* frame size = 0 */
 1746               	/* stack size = 6 */
 1747               	.L__stack_usage = 6
 1748 04d4 6B01      		movw r12,r22
 1749 04d6 7C01      		movw r14,r24
 1750 04d8 EA01      		movw r28,r20
 693:setup.c       **** 	gba_flash_write_bus_cycle(0xAAA / 2, 0xA9);
 1751               		.loc 1 693 0
 1752 04da 49EA      		ldi r20,lo8(-87)
 1753 04dc 50E0      		ldi r21,0
 1754               	.LVL138:
 1755 04de 65E5      		ldi r22,lo8(85)
 1756 04e0 75E0      		ldi r23,lo8(5)
 1757 04e2 80E0      		ldi r24,0
 1758 04e4 90E0      		ldi r25,0
 1759               	.LVL139:
 1760 04e6 00D0      		rcall gba_flash_write_bus_cycle
 1761               	.LVL140:
 694:setup.c       **** 	gba_flash_write_bus_cycle(0x555 / 2, 0x56);
 1762               		.loc 1 694 0
 1763 04e8 46E5      		ldi r20,lo8(86)
 1764 04ea 50E0      		ldi r21,0
 1765 04ec 6AEA      		ldi r22,lo8(-86)
 1766 04ee 72E0      		ldi r23,lo8(2)
 1767 04f0 80E0      		ldi r24,0
 1768 04f2 90E0      		ldi r25,0
 1769 04f4 00D0      		rcall gba_flash_write_bus_cycle
 1770               	.LVL141:
 695:setup.c       **** 	gba_flash_write_bus_cycle(0xAAA / 2, 0xA0);
 1771               		.loc 1 695 0
 1772 04f6 40EA      		ldi r20,lo8(-96)
 1773 04f8 50E0      		ldi r21,0
 1774 04fa 65E5      		ldi r22,lo8(85)
 1775 04fc 75E0      		ldi r23,lo8(5)
 1776 04fe 80E0      		ldi r24,0
 1777 0500 90E0      		ldi r25,0
 1778 0502 00D0      		rcall gba_flash_write_bus_cycle
 1779               	.LVL142:
 696:setup.c       **** 	gba_flash_write_bus_cycle(address, data);
 1780               		.loc 1 696 0
 1781 0504 AE01      		movw r20,r28
 1782 0506 C701      		movw r24,r14
 1783 0508 B601      		movw r22,r12
 1784 050a 00D0      		rcall gba_flash_write_bus_cycle
 1785               	.LVL143:
 1786               	.LBB83:
 1787               	.LBB84:
 1788               		.loc 2 276 0
 1789 050c 25E3      		ldi r18,lo8(53)
 1790 050e 2A95      	1:	dec r18
 1791 0510 01F4      		brne 1b
 1792 0512 0000      		nop
 1793               	.LVL144:
 1794               	.LBE84:
 1795               	.LBE83:
 697:setup.c       **** 	_delay_us(20); // Wait byte program time
 698:setup.c       **** 	
 699:setup.c       **** 	// Verify data
 700:setup.c       **** 	uint16_t dataVerify = gba_read_16bit_data(address);
 1796               		.loc 1 700 0
 1797 0514 C701      		movw r24,r14
 1798 0516 B601      		movw r22,r12
 1799 0518 00D0      		rcall gba_read_16bit_data
 1800               	.LVL145:
 1801               	.L78:
 701:setup.c       **** 	while (data != dataVerify) {
 1802               		.loc 1 701 0
 1803 051a 8C17      		cp r24,r28
 1804 051c 9D07      		cpc r25,r29
 1805 051e 01F0      		breq .L80
 702:setup.c       **** 		dataVerify = gba_read_16bit_data(address);
 1806               		.loc 1 702 0
 1807 0520 C701      		movw r24,r14
 1808 0522 B601      		movw r22,r12
 1809 0524 00D0      		rcall gba_read_16bit_data
 1810               	.LVL146:
 1811               	.LBB85:
 1812               	.LBB86:
 1813               		.loc 2 276 0
 1814 0526 25E3      		ldi r18,lo8(53)
 1815 0528 2A95      	1:	dec r18
 1816 052a 01F4      		brne 1b
 1817 052c 0000      		nop
 1818 052e 00C0      		rjmp .L78
 1819               	.LVL147:
 1820               	.L80:
 1821               	/* epilogue start */
 1822               	.LBE86:
 1823               	.LBE85:
 703:setup.c       **** 		_delay_us(20);
 704:setup.c       **** 	}
 705:setup.c       **** }
 1824               		.loc 1 705 0
 1825 0530 DF91      		pop r29
 1826 0532 CF91      		pop r28
 1827               	.LVL148:
 1828 0534 FF90      		pop r15
 1829 0536 EF90      		pop r14
 1830 0538 DF90      		pop r13
 1831 053a CF90      		pop r12
 1832               	.LVL149:
 1833 053c 0895      		ret
 1834               		.cfi_endproc
 1835               	.LFE40:
 1837               	.global	setup
 1839               	setup:
 1840               	.LFB41:
 706:setup.c       **** 
 707:setup.c       **** 
 708:setup.c       **** // Setup
 709:setup.c       **** void setup(void) {
 1841               		.loc 1 709 0
 1842               		.cfi_startproc
 1843               	/* prologue: function */
 1844               	/* frame size = 0 */
 1845               	/* stack size = 0 */
 1846               	.L__stack_usage = 0
 710:setup.c       **** 	// Turn off watchdog
 711:setup.c       **** 	MCUCSR &= ~(1<<WDRF);
 1847               		.loc 1 711 0
 1848 053e 84B7      		in r24,0x34
 1849 0540 877F      		andi r24,lo8(-9)
 1850 0542 84BF      		out 0x34,r24
 712:setup.c       **** 	WDTCR = (1<<WDCE) | (1<<WDE);
 1851               		.loc 1 712 0
 1852 0544 88E1      		ldi r24,lo8(24)
 1853 0546 81BD      		out 0x21,r24
 713:setup.c       **** 	WDTCR = 0;
 1854               		.loc 1 713 0
 1855 0548 11BC      		out 0x21,__zero_reg__
 714:setup.c       **** 	
 715:setup.c       **** 	// Reset common lines
 716:setup.c       **** 	rd_wr_csmreq_cs2_reset();
 1856               		.loc 1 716 0
 1857 054a 00D0      		rcall rd_wr_csmreq_cs2_reset
 1858               	.LVL150:
 717:setup.c       **** 	
 718:setup.c       **** 	// Set outputs
 719:setup.c       **** 	DDRD |= (1<<ACTIVITY_LED) | (1<<WR_PIN) | (1<<RD_PIN) | (1<<CS_MREQ_PIN) | (1<<LED_5V);
 1859               		.loc 1 719 0
 1860 054c 81B3      		in r24,0x11
 1861 054e 886F      		ori r24,lo8(-8)
 1862 0550 81BB      		out 0x11,r24
 720:setup.c       **** 	DDRE |= (1<<CS2_PIN) | (1<<LED_3V);
 1863               		.loc 1 720 0
 1864 0552 86B1      		in r24,0x6
 1865 0554 8560      		ori r24,lo8(5)
 1866 0556 86B9      		out 0x6,r24
 721:setup.c       **** 	
 722:setup.c       **** 	// Set all pins as inputs
 723:setup.c       **** 	PORT_DATA7_0 = 0;
 1867               		.loc 1 723 0
 1868 0558 15BA      		out 0x15,__zero_reg__
 724:setup.c       **** 	DDR_DATA7_0 = 0;
 1869               		.loc 1 724 0
 1870 055a 14BA      		out 0x14,__zero_reg__
 725:setup.c       **** 	PORT_ADDR7_0 = 0;
 1871               		.loc 1 725 0
 1872 055c 18BA      		out 0x18,__zero_reg__
 726:setup.c       **** 	DDR_ADDR7_0 = 0;
 1873               		.loc 1 726 0
 1874 055e 17BA      		out 0x17,__zero_reg__
 727:setup.c       **** 	PORT_ADDR15_8 = 0;
 1875               		.loc 1 727 0
 1876 0560 1BBA      		out 0x1b,__zero_reg__
 728:setup.c       **** 	DDR_ADDR15_8 = 0;
 1877               		.loc 1 728 0
 1878 0562 1ABA      		out 0x1a,__zero_reg__
 729:setup.c       **** 	
 730:setup.c       **** 	// Light up 3.3V or 5V
 731:setup.c       **** 	if (PIND & (1<<SWITCH_DETECT)) {
 1879               		.loc 1 731 0
 1880 0564 829B      		sbis 0x10,2
 1881 0566 00C0      		rjmp .L82
 732:setup.c       **** 		PORTD |= (1<<LED_5V);
 1882               		.loc 1 732 0
 1883 0568 979A      		sbi 0x12,7
 733:setup.c       **** 		PORTE &= ~(1<<LED_3V);
 1884               		.loc 1 733 0
 1885 056a 3898      		cbi 0x7,0
 1886 056c 00C0      		rjmp .L83
 1887               	.L82:
 734:setup.c       **** 	}
 735:setup.c       **** 	else {
 736:setup.c       **** 		PORTE |= (1<<LED_3V);
 1888               		.loc 1 736 0
 1889 056e 389A      		sbi 0x7,0
 737:setup.c       **** 		PORTD &= ~(1<<LED_5V);
 1890               		.loc 1 737 0
 1891 0570 9798      		cbi 0x12,7
 1892               	.L83:
 738:setup.c       **** 	}
 739:setup.c       **** 	
 740:setup.c       **** 	// Light LED
 741:setup.c       **** 	PORTD |= (1<<ACTIVITY_LED);
 1893               		.loc 1 741 0
 1894 0572 939A      		sbi 0x12,3
 1895               	.LVL151:
 1896               	.LBB87:
 1897               	.LBB88:
 187:c:\winavr-20100110\avr\include\util\delay.h **** 
 1898               		.loc 2 187 0
 1899 0574 2FEF      		ldi r18,lo8(799999)
 1900 0576 84E3      		ldi r24,hi8(799999)
 1901 0578 9CE0      		ldi r25,hlo8(799999)
 1902 057a 2150      	1:	subi r18,1
 1903 057c 8040      		sbci r24,0
 1904 057e 9040      		sbci r25,0
 1905 0580 01F4      		brne 1b
 1906 0582 00C0      		rjmp .
 1907 0584 0000      		nop
 1908               	.LVL152:
 1909               	.LBE88:
 1910               	.LBE87:
 742:setup.c       **** 	_delay_ms(500);
 743:setup.c       **** 	PORTD &= ~(1<<ACTIVITY_LED);
 1911               		.loc 1 743 0
 1912 0586 9398      		cbi 0x12,3
 744:setup.c       **** 	
 745:setup.c       **** 	// Setup USART
 746:setup.c       **** 	UBRRL = 0; // 1Mbps Baud rate
 1913               		.loc 1 746 0
 1914 0588 19B8      		out 0x9,__zero_reg__
 747:setup.c       **** 	sbi(UCSRA, U2X); // Double rate
 1915               		.loc 1 747 0
 1916 058a 599A      		sbi 0xb,1
 748:setup.c       **** 	sbi(UCSRB, TXEN); // Transmitter enable
 1917               		.loc 1 748 0
 1918 058c 539A      		sbi 0xa,3
 749:setup.c       **** 	sbi(UCSRB, RXEN); // Receiver enable
 1919               		.loc 1 749 0
 1920 058e 549A      		sbi 0xa,4
 750:setup.c       **** 	
 751:setup.c       **** 	// Turn on interrupts
 752:setup.c       **** 	sei();
 1921               		.loc 1 752 0
 1922               	/* #APP */
 1923               	 ;  752 "setup.c" 1
 1924 0590 7894      		sei
 1925               	 ;  0 "" 2
 1926               	/* #NOAPP */
 1927 0592 0895      		ret
 1928               		.cfi_endproc
 1929               	.LFE41:
 1931               		.section	.text.startup,"ax",@progbits
 1932               	.global	main
 1934               	main:
 1935               	.LFB42:
 1936               		.file 3 "main.c"
   1:main.c        **** /*
   2:main.c        ****  GBxCart RW
   3:main.c        ****  PCB version: 1.1 or 1.2
   4:main.c        ****  Firmware version: R9
   5:main.c        ****  Author: Alex from insideGadgets (www.insidegadgets.com)
   6:main.c        ****  Created: 7/11/2016
   7:main.c        ****  Last Modified: 19/03/2018
   8:main.c        ****  
   9:main.c        ****  GBxCart RW allows you to dump your Gameboy/Gameboy Colour/Gameboy Advance games ROM, save the RAM 
  10:main.c        ****  
  11:main.c        ****  The ATmega8515L talks to the cartridge and interfaces with the CH340G serial to USB converter with
  12:main.c        ****  
  13:main.c        ****  
  14:main.c        ****  Set fuse bits: External 8MHz crystal, divide clock by 8 is off, boot loader is on (512 bytes), BOD
  15:main.c        ****  avrdude -p atmega8515 -c usbasp -U lfuse:w:0xaf:m -U hfuse:w:0xda:m
  16:main.c        ****  
  17:main.c        ****  Program the TinySafeBoot boot loader (modified ASM code, watchdog reset will act as a hardware res
  18:main.c        ****  avrdude -p atmega8515 -c usbasp -U flash:w:GBxCart_RW_v1.1_Rx\tsb\tsb_m8515_d0d1_resetwdt.hex
  19:main.c        ****  
  20:main.c        ****  Program GBxCart RW through TinySafeBoot
  21:main.c        ****  tsb com16:57600 fw GBxCart_RW_v1.1_Rx\main.hex
  22:main.c        ****  
  23:main.c        ****  Set TinySafeBoot delay time to 25 (T 25), gives ~0.5s in bootloader
  24:main.c        ****  tsb com16:9600 T 25
  25:main.c        ****  
  26:main.c        ****  
  27:main.c        ****  Programming shortcuts (if added in Programmers Notepad):
  28:main.c        ****  Alt + W - Program fuse
  29:main.c        ****  Alt + B - Burn bootloader
  30:main.c        ****  
  31:main.c        ****  Plug in USB then
  32:main.c        ****  Alt + T - Program
  33:main.c        ****  Alt + N - Program delay settings
  34:main.c        ****  
  35:main.c        ****  
  36:main.c        ****  */
  37:main.c        **** 
  38:main.c        **** // ATmega8515L Pin Map
  39:main.c        **** //
  40:main.c        **** // VCC (5)			GND (6)			XTAL (7 ,8)		Activity LED PD3 (9)				Switch sense PD2 (8)
  41:main.c        **** // SCK PB7 (3)		MOSI PB5 (1)	MISO PB6 (2)	RST (4)		RXD PD0 (5)			TXD PD1 (7)
  42:main.c        **** // 
  43:main.c        **** // Gameboy / Gameboy Colour
  44:main.c        **** // A0-A7 PB0-7 (40-44, 1-3) 		A8-A15 PA0-7 (37-30)			D0-D7 PC0-7 (18-25)		Audio PE1 (27)
  45:main.c        **** // 
  46:main.c        **** // Gameboy Advance
  47:main.c        **** // AD0-AD7 PB0-7 (40-44, 1-3) 	AD8-AD15 PA0-7 (37-30)		A16-23 / D0-D7 PC0-7 (19-26)
  48:main.c        **** // *WR PD6 (13)						*RD PD5 (14)					*MREQ/CS PD4 (15)			CS2/RST PE2 (16)
  49:main.c        **** 
  50:main.c        **** #define F_CPU 8000000 // 8 MHz
  51:main.c        **** #define PCB_VERSION 2
  52:main.c        **** #define FIRMWARE_VERSION 9
  53:main.c        **** 
  54:main.c        **** #include <avr/io.h>
  55:main.c        **** #include <avr/wdt.h>
  56:main.c        **** #include <avr/eeprom.h>
  57:main.c        **** #include <avr/interrupt.h>
  58:main.c        **** #include <avr/sleep.h>
  59:main.c        **** #include <util/delay.h>
  60:main.c        **** #include <stdlib.h>
  61:main.c        **** #include <string.h>
  62:main.c        **** #include "setup.c" // See defines, variables, constants, functions here
  63:main.c        **** 
  64:main.c        **** 
  65:main.c        **** int main(void) {
 1937               		.loc 3 65 0
 1938               		.cfi_startproc
 1939               	/* prologue: function */
 1940               	/* frame size = 0 */
 1941               	/* stack size = 0 */
 1942               	.L__stack_usage = 0
  66:main.c        **** 	setup();
 1943               		.loc 3 66 0
 1944 0000 00D0      		rcall setup
 1945               	.LVL153:
  67:main.c        **** 	
  68:main.c        **** 	uint32_t address = 0;
  69:main.c        **** 	uint8_t eepromSize = EEPROM_4KBIT;
  70:main.c        **** 	uint8_t cartMode = GB_MODE;
  71:main.c        **** 	uint8_t resetCommonLines = 1;
 1946               		.loc 3 71 0
 1947 0002 8824      		clr r8
 1948 0004 8394      		inc r8
  69:main.c        **** 	uint8_t cartMode = GB_MODE;
 1949               		.loc 3 69 0
 1950 0006 9924      		clr r9
 1951 0008 9394      		inc r9
  68:main.c        **** 	uint8_t eepromSize = EEPROM_4KBIT;
 1952               		.loc 3 68 0
 1953 000a C12C      		mov r12,__zero_reg__
 1954 000c D12C      		mov r13,__zero_reg__
 1955 000e 7601      		movw r14,r12
 1956 0010 30E0      		ldi r19,lo8(flashWriteCycle+12)
 1957 0012 632E      		mov r6,r19
 1958 0014 30E0      		ldi r19,hi8(flashWriteCycle+12)
 1959 0016 732E      		mov r7,r19
 1960 0018 00E0      		ldi r16,lo8(eepromBuffer+8)
 1961 001a 10E0      		ldi r17,hi8(eepromBuffer+8)
 1962               	.LVL154:
 1963               	.L85:
  72:main.c        **** 	
  73:main.c        **** 	while(1) {
  74:main.c        **** 		if (resetCommonLines == 1) {
 1964               		.loc 3 74 0
 1965 001c 21E0      		ldi r18,lo8(1)
 1966 001e 8212      		cpse r8,r18
 1967 0020 00C0      		rjmp .L86
 1968               	.LVL155:
 1969               	.L182:
  75:main.c        **** 			rd_wr_csmreq_cs2_reset();
 1970               		.loc 3 75 0
 1971 0022 00D0      		rcall rd_wr_csmreq_cs2_reset
 1972               	.LVL156:
 1973               	.L86:
  76:main.c        **** 		}
  77:main.c        **** 		receivedChar = USART_Receive(); // Wait for 1 byte of data
 1974               		.loc 3 77 0
 1975 0024 00D0      		rcall USART_Receive
 1976               	.LVL157:
 1977 0026 8093 0000 		sts receivedChar,r24
  78:main.c        **** 		
  79:main.c        **** 		// Read the pin to find out which mode we are in, if it reads high, we are powered by 5V
  80:main.c        **** 		if (PIND & (1<<SWITCH_DETECT)) {
 1978               		.loc 3 80 0
 1979 002a 829B      		sbis 0x10,2
 1980 002c 00C0      		rjmp .L87
 1981               	.LVL158:
  81:main.c        **** 			cartMode = GB_MODE;
  82:main.c        **** 			PORTD |= (1<<LED_5V);
 1982               		.loc 3 82 0
 1983 002e 979A      		sbi 0x12,7
  83:main.c        **** 			PORTE &= ~(1<<LED_3V);
 1984               		.loc 3 83 0
 1985 0030 3898      		cbi 0x7,0
  81:main.c        **** 			cartMode = GB_MODE;
 1986               		.loc 3 81 0
 1987 0032 81E0      		ldi r24,lo8(1)
 1988 0034 00C0      		rjmp .L88
 1989               	.LVL159:
 1990               	.L87:
  84:main.c        **** 		}
  85:main.c        **** 		else {
  86:main.c        **** 			cartMode = GBA_MODE;
  87:main.c        **** 			PORTE |= (1<<LED_3V);
 1991               		.loc 3 87 0
 1992 0036 389A      		sbi 0x7,0
  88:main.c        **** 			PORTD &= ~(1<<LED_5V);
 1993               		.loc 3 88 0
 1994 0038 9798      		cbi 0x12,7
  86:main.c        **** 			PORTE |= (1<<LED_3V);
 1995               		.loc 3 86 0
 1996 003a 82E0      		ldi r24,lo8(2)
 1997               	.LVL160:
 1998               	.L88:
  89:main.c        **** 		}
  90:main.c        **** 		
  91:main.c        **** 		// Return the cart mode in use
  92:main.c        **** 		if (receivedChar == CART_MODE) {
 1999               		.loc 3 92 0
 2000 003c 9091 0000 		lds r25,receivedChar
 2001 0040 9334      		cpi r25,lo8(67)
 2002 0042 01F4      		brne .+2
 2003 0044 00C0      		rjmp .L183
  93:main.c        **** 			USART_Transmit(cartMode);
  94:main.c        **** 		}
  95:main.c        **** 		
  96:main.c        **** 		// Change to GB mode or GBA mode if requested
  97:main.c        **** 		else if (receivedChar == GB_CART_MODE) {
 2004               		.loc 3 97 0
 2005 0046 9734      		cpi r25,lo8(71)
 2006 0048 01F4      		brne .L91
  98:main.c        **** 			gb_mode();
 2007               		.loc 3 98 0
 2008 004a 00D0      		rcall gb_mode
 2009               	.LVL161:
 2010 004c 00C0      		rjmp .L85
 2011               	.LVL162:
 2012               	.L91:
  99:main.c        **** 		}
 100:main.c        **** 		else if (receivedChar == GBA_CART_MODE) {
 2013               		.loc 3 100 0
 2014 004e 9736      		cpi r25,lo8(103)
 2015 0050 01F4      		brne .+2
 2016 0052 00C0      		rjmp .L185
 101:main.c        **** 			gba_mode();
 102:main.c        **** 		}
 103:main.c        **** 		
 104:main.c        **** 		// Set address
 105:main.c        **** 		else if (receivedChar == SET_START_ADDRESS) {
 2017               		.loc 3 105 0
 2018 0054 9134      		cpi r25,lo8(65)
 2019 0056 01F4      		brne .L93
 106:main.c        **** 			usart_read_chars(); // Read start address
 2020               		.loc 3 106 0
 2021 0058 00D0      		rcall usart_read_chars
 2022               	.LVL163:
 107:main.c        **** 			address = strtol(receivedBuffer, NULL, 16); // Convert address string in hex to dec
 2023               		.loc 3 107 0
 2024 005a 40E1      		ldi r20,lo8(16)
 2025 005c 50E0      		ldi r21,0
 2026 005e 60E0      		ldi r22,0
 2027 0060 70E0      		ldi r23,0
 2028 0062 80E0      		ldi r24,lo8(receivedBuffer)
 2029 0064 90E0      		ldi r25,hi8(receivedBuffer)
 2030 0066 00D0      		rcall strtol
 2031               	.LVL164:
 2032 0068 6B01      		movw r12,r22
 2033 006a 7C01      		movw r14,r24
 2034               	.LVL165:
 2035 006c 00C0      		rjmp .L85
 2036               	.LVL166:
 2037               	.L93:
 108:main.c        **** 		}
 109:main.c        **** 		
 110:main.c        **** 		
 111:main.c        **** 		// ****** Gameboy / Gameboy Colour ******
 112:main.c        **** 		
 113:main.c        **** 		// Read 64 bytes of ROM/RAM from address (and increment) until anything but 1 is received
 114:main.c        **** 		else if (receivedChar == READ_ROM_RAM) {
 2038               		.loc 3 114 0
 2039 006e 9235      		cpi r25,lo8(82)
 2040 0070 01F4      		brne .L94
 115:main.c        **** 			gb_mode();
 2041               		.loc 3 115 0
 2042 0072 00D0      		rcall gb_mode
 2043               	.LVL167:
 116:main.c        **** 			receivedChar = '1';
 2044               		.loc 3 116 0
 2045 0074 81E3      		ldi r24,lo8(49)
 2046               	.LVL168:
 2047               	.L188:
 117:main.c        **** 			while (receivedChar == '1') {
 118:main.c        **** 				PORTD |= (1<<ACTIVITY_LED);
 119:main.c        **** 				for (uint8_t x = 0; x < 64; x++) {
 120:main.c        **** 					USART_Transmit(read_8bit_data(address));
 121:main.c        **** 					address++;
 122:main.c        **** 				}
 123:main.c        **** 				
 124:main.c        **** 				PORTD &= ~(1<<ACTIVITY_LED);
 125:main.c        **** 				receivedChar = USART_Receive();
 2048               		.loc 3 125 0
 2049 0076 8093 0000 		sts receivedChar,r24
 2050               	.LVL169:
 117:main.c        **** 			while (receivedChar == '1') {
 2051               		.loc 3 117 0
 2052 007a 8091 0000 		lds r24,receivedChar
 2053 007e 8133      		cpi r24,lo8(49)
 2054 0080 01F4      		brne .L85
 118:main.c        **** 				for (uint8_t x = 0; x < 64; x++) {
 2055               		.loc 3 118 0
 2056 0082 939A      		sbi 0x12,3
 2057               	.LVL170:
 2058 0084 C0E0      		ldi r28,0
 2059 0086 D0E0      		ldi r29,0
 2060               	.LVL171:
 2061               	.L96:
 2062               	.LBB89:
 120:main.c        **** 					address++;
 2063               		.loc 3 120 0 discriminator 3
 2064 0088 CE01      		movw r24,r28
 2065 008a 8C0D      		add r24,r12
 2066 008c 9D1D      		adc r25,r13
 2067 008e 00D0      		rcall read_8bit_data
 2068               	.LVL172:
 2069 0090 00D0      		rcall USART_Transmit
 2070               	.LVL173:
 2071 0092 2196      		adiw r28,1
 2072               	.LVL174:
 119:main.c        **** 					USART_Transmit(read_8bit_data(address));
 2073               		.loc 3 119 0 discriminator 3
 2074 0094 C034      		cpi r28,64
 2075 0096 D105      		cpc r29,__zero_reg__
 2076 0098 01F4      		brne .L96
 2077 009a 80E4      		ldi r24,64
 2078 009c C80E      		add r12,r24
 2079 009e D11C      		adc r13,__zero_reg__
 2080 00a0 E11C      		adc r14,__zero_reg__
 2081 00a2 F11C      		adc r15,__zero_reg__
 2082               	.LBE89:
 124:main.c        **** 				receivedChar = USART_Receive();
 2083               		.loc 3 124 0
 2084 00a4 9398      		cbi 0x12,3
 2085               		.loc 3 125 0
 2086 00a6 00D0      		rcall USART_Receive
 2087               	.LVL175:
 2088 00a8 00C0      		rjmp .L188
 2089               	.LVL176:
 2090               	.L94:
 126:main.c        **** 			}
 127:main.c        **** 		}
 128:main.c        **** 		
 129:main.c        **** 		// Write 64 bytes to RAM on address (and increment)
 130:main.c        **** 		else if (receivedChar == WRITE_RAM) {
 2091               		.loc 3 130 0
 2092 00aa 9735      		cpi r25,lo8(87)
 2093 00ac 01F4      		brne .L98
 131:main.c        **** 			gb_mode();
 2094               		.loc 3 131 0
 2095 00ae 00D0      		rcall gb_mode
 2096               	.LVL177:
 132:main.c        **** 			
 133:main.c        **** 			// Read 64 bytes first as CH340G sends them all at once
 134:main.c        **** 			usart_read_bytes(64);
 2097               		.loc 3 134 0
 2098 00b0 80E4      		ldi r24,lo8(64)
 2099 00b2 00D0      		rcall usart_read_bytes
 2100               	.LVL178:
 135:main.c        **** 			
 136:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 2101               		.loc 3 136 0
 2102 00b4 939A      		sbi 0x12,3
 2103               	.LVL179:
 2104 00b6 C0E0      		ldi r28,lo8(receivedBuffer)
 2105 00b8 D0E0      		ldi r29,hi8(receivedBuffer)
 2106 00ba A12C      		mov r10,__zero_reg__
 2107 00bc B12C      		mov r11,__zero_reg__
 2108               	.LVL180:
 2109               	.L99:
 2110               	.LBB90:
 137:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 138:main.c        **** 				write_8bit_data(address, receivedBuffer[x], MEMORY_WRITE);
 2111               		.loc 3 138 0 discriminator 3
 2112 00be 6991      		ld r22,Y+
 2113 00c0 C501      		movw r24,r10
 2114 00c2 8C0D      		add r24,r12
 2115 00c4 9D1D      		adc r25,r13
 2116 00c6 41E0      		ldi r20,lo8(1)
 2117 00c8 00D0      		rcall write_8bit_data
 2118               	.LVL181:
 2119 00ca 9FEF      		ldi r25,-1
 2120 00cc A91A      		sub r10,r25
 2121 00ce B90A      		sbc r11,r25
 2122               	.LVL182:
 137:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 2123               		.loc 3 137 0 discriminator 3
 2124 00d0 E0E4      		ldi r30,64
 2125 00d2 AE16      		cp r10,r30
 2126 00d4 B104      		cpc r11,__zero_reg__
 2127 00d6 01F4      		brne .L99
 2128 00d8 F0E4      		ldi r31,64
 2129 00da CF0E      		add r12,r31
 2130 00dc D11C      		adc r13,__zero_reg__
 2131 00de E11C      		adc r14,__zero_reg__
 2132 00e0 F11C      		adc r15,__zero_reg__
 2133 00e2 00C0      		rjmp .L205
 2134               	.LVL183:
 2135               	.L98:
 2136               	.LBE90:
 139:main.c        **** 				address++;
 140:main.c        **** 			}
 141:main.c        **** 			
 142:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 143:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 144:main.c        **** 		}
 145:main.c        **** 		
 146:main.c        **** 		// Set bank address and write a byte
 147:main.c        **** 		else if (receivedChar == SET_BANK) {
 2137               		.loc 3 147 0
 2138 00e4 9234      		cpi r25,lo8(66)
 2139 00e6 01F4      		brne .L100
 2140               	.LBB91:
 148:main.c        **** 			gb_mode();
 2141               		.loc 3 148 0
 2142 00e8 00D0      		rcall gb_mode
 2143               	.LVL184:
 149:main.c        **** 			
 150:main.c        **** 			usart_read_chars(); // Read start address
 2144               		.loc 3 150 0
 2145 00ea 00D0      		rcall usart_read_chars
 2146               	.LVL185:
 151:main.c        **** 			uint16_t bankaddress = strtol(receivedBuffer, NULL, 16); // Convert address string in hex to dec
 2147               		.loc 3 151 0
 2148 00ec 40E1      		ldi r20,lo8(16)
 2149 00ee 50E0      		ldi r21,0
 2150 00f0 60E0      		ldi r22,0
 2151 00f2 70E0      		ldi r23,0
 2152 00f4 80E0      		ldi r24,lo8(receivedBuffer)
 2153 00f6 90E0      		ldi r25,hi8(receivedBuffer)
 2154 00f8 00D0      		rcall strtol
 2155               	.LVL186:
 2156 00fa 1B01      		movw r2,r22
 2157 00fc 2C01      		movw r4,r24
 2158               	.LVL187:
 152:main.c        **** 			
 153:main.c        **** 			receivedChar = USART_Receive(); // Wait for bank number
 2159               		.loc 3 153 0
 2160 00fe 00D0      		rcall USART_Receive
 2161               	.LVL188:
 2162 0100 8093 0000 		sts receivedChar,r24
 154:main.c        **** 			if (receivedChar == 'B') {
 2163               		.loc 3 154 0
 2164 0104 8234      		cpi r24,lo8(66)
 2165 0106 01F0      		breq .+2
 2166 0108 00C0      		rjmp .L85
 2167               	.LBB92:
 155:main.c        **** 				usart_read_chars(); // Read data
 2168               		.loc 3 155 0
 2169 010a 00D0      		rcall usart_read_chars
 2170               	.LVL189:
 156:main.c        **** 				uint8_t data = atoi(receivedBuffer); // Convert data string to dec
 2171               		.loc 3 156 0
 2172 010c 80E0      		ldi r24,lo8(receivedBuffer)
 2173 010e 90E0      		ldi r25,hi8(receivedBuffer)
 2174 0110 00D0      		rcall atoi
 2175               	.LVL190:
 157:main.c        **** 				
 158:main.c        **** 				write_8bit_data(bankaddress, data, BANK_WRITE);
 2176               		.loc 3 158 0
 2177 0112 40E0      		ldi r20,0
 2178 0114 682F      		mov r22,r24
 2179 0116 C101      		movw r24,r2
 2180               	.LVL191:
 2181 0118 00D0      		rcall write_8bit_data
 2182               	.LVL192:
 2183 011a 00C0      		rjmp .L85
 2184               	.LVL193:
 2185               	.L100:
 2186               	.LBE92:
 2187               	.LBE91:
 159:main.c        **** 			}
 160:main.c        **** 		}
 161:main.c        **** 		
 162:main.c        **** 		
 163:main.c        **** 		// ****** Gameboy Advance ******
 164:main.c        **** 		
 165:main.c        **** 		// ---------- ROM ----------
 166:main.c        **** 		// Read one 16bit byte from ROM using address (and increment) until anything but 1 is received
 167:main.c        **** 		else if (receivedChar == GBA_READ_ROM) {
 2188               		.loc 3 167 0
 2189 011c 9237      		cpi r25,lo8(114)
 2190 011e 01F4      		brne .L101
 168:main.c        **** 			gba_mode(); 
 2191               		.loc 3 168 0
 2192 0120 00D0      		rcall gba_mode
 2193               	.LVL194:
 169:main.c        **** 			
 170:main.c        **** 			receivedChar = '1';
 2194               		.loc 3 170 0
 2195 0122 81E3      		ldi r24,lo8(49)
 2196               	.LVL195:
 2197               	.L189:
 171:main.c        **** 			while (receivedChar == '1') {
 172:main.c        **** 				PORTD |= (1<<ACTIVITY_LED);
 173:main.c        **** 				for (uint8_t x = 0; x < 32; x++) {
 174:main.c        **** 					uint16_t dataRead = gba_read_16bit_data(address);
 175:main.c        **** 					
 176:main.c        **** 					// Low byte & High byte
 177:main.c        **** 					USART_Transmit(dataRead & 0xFF);
 178:main.c        **** 					USART_Transmit(dataRead >> 8);
 179:main.c        **** 					
 180:main.c        **** 					address++;
 181:main.c        **** 				}
 182:main.c        **** 				
 183:main.c        **** 				PORTD &= ~(1<<ACTIVITY_LED);
 184:main.c        **** 				receivedChar = USART_Receive();
 2198               		.loc 3 184 0
 2199 0124 8093 0000 		sts receivedChar,r24
 2200               	.LVL196:
 171:main.c        **** 			while (receivedChar == '1') {
 2201               		.loc 3 171 0
 2202 0128 8091 0000 		lds r24,receivedChar
 2203 012c 8133      		cpi r24,lo8(49)
 2204 012e 01F0      		breq .+2
 2205 0130 00C0      		rjmp .L85
 172:main.c        **** 				for (uint8_t x = 0; x < 32; x++) {
 2206               		.loc 3 172 0
 2207 0132 939A      		sbi 0x12,3
 2208               	.LVL197:
 2209 0134 1601      		movw r2,r12
 2210 0136 2701      		movw r4,r14
 2211 0138 C0E2      		ldi r28,lo8(32)
 2212               	.LVL198:
 2213               	.L103:
 2214               	.LBB93:
 2215               	.LBB94:
 174:main.c        **** 					
 2216               		.loc 3 174 0 discriminator 3
 2217 013a C201      		movw r24,r4
 2218 013c B101      		movw r22,r2
 2219 013e 00D0      		rcall gba_read_16bit_data
 2220               	.LVL199:
 2221 0140 D92F      		mov r29,r25
 2222               	.LVL200:
 177:main.c        **** 					USART_Transmit(dataRead >> 8);
 2223               		.loc 3 177 0 discriminator 3
 2224 0142 00D0      		rcall USART_Transmit
 2225               	.LVL201:
 178:main.c        **** 					
 2226               		.loc 3 178 0 discriminator 3
 2227 0144 8D2F      		mov r24,r29
 2228 0146 00D0      		rcall USART_Transmit
 2229               	.LVL202:
 180:main.c        **** 				}
 2230               		.loc 3 180 0 discriminator 3
 2231 0148 2FEF      		ldi r18,-1
 2232 014a 221A      		sub r2,r18
 2233 014c 320A      		sbc r3,r18
 2234 014e 420A      		sbc r4,r18
 2235 0150 520A      		sbc r5,r18
 2236               	.LVL203:
 2237 0152 C150      		subi r28,lo8(-(-1))
 2238               	.LBE94:
 173:main.c        **** 					uint16_t dataRead = gba_read_16bit_data(address);
 2239               		.loc 3 173 0 discriminator 3
 2240 0154 01F4      		brne .L103
 2241 0156 80E2      		ldi r24,32
 2242 0158 C80E      		add r12,r24
 2243 015a D11C      		adc r13,__zero_reg__
 2244 015c E11C      		adc r14,__zero_reg__
 2245 015e F11C      		adc r15,__zero_reg__
 2246               	.LVL204:
 2247               	.LBE93:
 183:main.c        **** 				receivedChar = USART_Receive();
 2248               		.loc 3 183 0
 2249 0160 9398      		cbi 0x12,3
 2250               		.loc 3 184 0
 2251 0162 00D0      		rcall USART_Receive
 2252               	.LVL205:
 2253 0164 00C0      		rjmp .L189
 2254               	.LVL206:
 2255               	.L101:
 185:main.c        **** 			}
 186:main.c        **** 		}
 187:main.c        **** 		
 188:main.c        **** 		
 189:main.c        **** 		// ---------- SRAM ----------
 190:main.c        **** 		// Read RAM from address (and increment) until anything but 1 is received
 191:main.c        **** 		else if (receivedChar == GBA_READ_SRAM) {
 2256               		.loc 3 191 0
 2257 0166 9D36      		cpi r25,lo8(109)
 2258 0168 01F4      		brne .L105
 192:main.c        **** 			gb_mode(); // Set GB mode as it uses 16 bit address with 8 bit data
 2259               		.loc 3 192 0
 2260 016a 00D0      		rcall gb_mode
 2261               	.LVL207:
 193:main.c        **** 			
 194:main.c        **** 			receivedChar = '1';
 2262               		.loc 3 194 0
 2263 016c 81E3      		ldi r24,lo8(49)
 2264               	.LVL208:
 2265               	.L190:
 195:main.c        **** 			while (receivedChar == '1') {
 196:main.c        **** 				PORTD |= (1<<ACTIVITY_LED);
 197:main.c        **** 				for (uint8_t x = 0; x < 64; x++) {
 198:main.c        **** 					USART_Transmit(gba_read_ram_8bit_data(address));
 199:main.c        **** 					address++;
 200:main.c        **** 				}
 201:main.c        **** 				
 202:main.c        **** 				PORTD &= ~(1<<ACTIVITY_LED);
 203:main.c        **** 				receivedChar = USART_Receive();
 2266               		.loc 3 203 0
 2267 016e 8093 0000 		sts receivedChar,r24
 2268               	.LVL209:
 195:main.c        **** 			while (receivedChar == '1') {
 2269               		.loc 3 195 0
 2270 0172 8091 0000 		lds r24,receivedChar
 2271 0176 8133      		cpi r24,lo8(49)
 2272 0178 01F4      		brne .L185
 196:main.c        **** 				for (uint8_t x = 0; x < 64; x++) {
 2273               		.loc 3 196 0
 2274 017a 939A      		sbi 0x12,3
 2275               	.LVL210:
 2276 017c C0E0      		ldi r28,0
 2277 017e D0E0      		ldi r29,0
 2278               	.LVL211:
 2279               	.L107:
 2280               	.LBB95:
 198:main.c        **** 					address++;
 2281               		.loc 3 198 0 discriminator 3
 2282 0180 CE01      		movw r24,r28
 2283 0182 8C0D      		add r24,r12
 2284 0184 9D1D      		adc r25,r13
 2285 0186 00D0      		rcall gba_read_ram_8bit_data
 2286               	.LVL212:
 2287 0188 00D0      		rcall USART_Transmit
 2288               	.LVL213:
 2289 018a 2196      		adiw r28,1
 2290               	.LVL214:
 197:main.c        **** 					USART_Transmit(gba_read_ram_8bit_data(address));
 2291               		.loc 3 197 0 discriminator 3
 2292 018c C034      		cpi r28,64
 2293 018e D105      		cpc r29,__zero_reg__
 2294 0190 01F4      		brne .L107
 2295 0192 90E4      		ldi r25,64
 2296 0194 C90E      		add r12,r25
 2297 0196 D11C      		adc r13,__zero_reg__
 2298 0198 E11C      		adc r14,__zero_reg__
 2299 019a F11C      		adc r15,__zero_reg__
 2300               	.LBE95:
 202:main.c        **** 				receivedChar = USART_Receive();
 2301               		.loc 3 202 0
 2302 019c 9398      		cbi 0x12,3
 2303               		.loc 3 203 0
 2304 019e 00D0      		rcall USART_Receive
 2305               	.LVL215:
 2306 01a0 00C0      		rjmp .L190
 2307               	.LVL216:
 2308               	.L105:
 204:main.c        **** 			}
 205:main.c        **** 			
 206:main.c        **** 			gba_mode(); // Set back
 207:main.c        **** 		}
 208:main.c        **** 		
 209:main.c        **** 		// Write to RAM on address (and increment) with 64 bytes of data
 210:main.c        **** 		else if (receivedChar == GBA_WRITE_SRAM) {
 2309               		.loc 3 210 0
 2310 01a2 9737      		cpi r25,lo8(119)
 2311 01a4 01F4      		brne .L109
 211:main.c        **** 			gb_mode();
 2312               		.loc 3 211 0
 2313 01a6 00D0      		rcall gb_mode
 2314               	.LVL217:
 212:main.c        **** 			
 213:main.c        **** 			usart_read_bytes(64);
 2315               		.loc 3 213 0
 2316 01a8 80E4      		ldi r24,lo8(64)
 2317 01aa 00D0      		rcall usart_read_bytes
 2318               	.LVL218:
 214:main.c        **** 			
 215:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 2319               		.loc 3 215 0
 2320 01ac 939A      		sbi 0x12,3
 2321               	.LVL219:
 2322 01ae C0E0      		ldi r28,lo8(receivedBuffer)
 2323 01b0 D0E0      		ldi r29,hi8(receivedBuffer)
 2324 01b2 A12C      		mov r10,__zero_reg__
 2325 01b4 B12C      		mov r11,__zero_reg__
 2326               	.LVL220:
 2327               	.L110:
 2328               	.LBB96:
 216:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 217:main.c        **** 				gba_write_ram_8bit_data(address, receivedBuffer[x]);
 2329               		.loc 3 217 0 discriminator 3
 2330 01b6 6991      		ld r22,Y+
 2331 01b8 C501      		movw r24,r10
 2332 01ba 8C0D      		add r24,r12
 2333 01bc 9D1D      		adc r25,r13
 2334 01be 00D0      		rcall gba_write_ram_8bit_data
 2335               	.LVL221:
 2336 01c0 EFEF      		ldi r30,-1
 2337 01c2 AE1A      		sub r10,r30
 2338 01c4 BE0A      		sbc r11,r30
 2339               	.LVL222:
 216:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 2340               		.loc 3 216 0 discriminator 3
 2341 01c6 F0E4      		ldi r31,64
 2342 01c8 AF16      		cp r10,r31
 2343 01ca B104      		cpc r11,__zero_reg__
 2344 01cc 01F4      		brne .L110
 2345 01ce 20E4      		ldi r18,64
 2346 01d0 C20E      		add r12,r18
 2347 01d2 D11C      		adc r13,__zero_reg__
 2348 01d4 E11C      		adc r14,__zero_reg__
 2349 01d6 F11C      		adc r15,__zero_reg__
 2350               	.LVL223:
 2351               	.L187:
 2352               	.LBE96:
 218:main.c        **** 				address++;
 219:main.c        **** 			}
 220:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 2353               		.loc 3 220 0
 2354 01d8 81E3      		ldi r24,lo8(49)
 2355 01da 00D0      		rcall USART_Transmit
 2356               	.LVL224:
 221:main.c        **** 			
 222:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 2357               		.loc 3 222 0
 2358 01dc 9398      		cbi 0x12,3
 2359               	.L185:
 223:main.c        **** 			gba_mode(); // Set back
 2360               		.loc 3 223 0
 2361 01de 00D0      		rcall gba_mode
 2362               	.LVL225:
 2363 01e0 00C0      		rjmp .L85
 2364               	.LVL226:
 2365               	.L109:
 224:main.c        **** 		}
 225:main.c        **** 		
 226:main.c        **** 		// Write 1 byte to SRAM address
 227:main.c        **** 		else if (receivedChar == GBA_WRITE_ONE_BYTE_SRAM) {
 2366               		.loc 3 227 0
 2367 01e2 9F36      		cpi r25,lo8(111)
 2368 01e4 01F4      		brne .L111
 2369               	.LBB97:
 228:main.c        **** 			gb_mode();
 2370               		.loc 3 228 0
 2371 01e6 00D0      		rcall gb_mode
 2372               	.LVL227:
 229:main.c        **** 			
 230:main.c        **** 			uint8_t data = USART_Receive();
 2373               		.loc 3 230 0
 2374 01e8 00D0      		rcall USART_Receive
 2375               	.LVL228:
 231:main.c        **** 			gba_write_ram_8bit_data(address, data);
 2376               		.loc 3 231 0
 2377 01ea 682F      		mov r22,r24
 2378 01ec C601      		movw r24,r12
 2379               	.LVL229:
 2380 01ee 00D0      		rcall gba_write_ram_8bit_data
 2381               	.LVL230:
 2382 01f0 00C0      		rjmp .L192
 2383               	.LVL231:
 2384               	.L111:
 2385               	.LBE97:
 232:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 233:main.c        **** 			
 234:main.c        **** 			gba_mode(); // Set back
 235:main.c        **** 		}
 236:main.c        **** 		
 237:main.c        **** 		
 238:main.c        **** 		// ---------- FLASH ----------
 239:main.c        **** 		// Read the Flash Manufacturer and Device ID
 240:main.c        **** 		else if (receivedChar == GBA_FLASH_READ_ID) {
 2386               		.loc 3 240 0
 2387 01f2 9936      		cpi r25,lo8(105)
 2388 01f4 01F4      		brne .L112
 241:main.c        **** 			gb_mode();
 2389               		.loc 3 241 0
 2390 01f6 00D0      		rcall gb_mode
 2391               	.LVL232:
 242:main.c        **** 			
 243:main.c        **** 			flash_read_chip_id();
 2392               		.loc 3 243 0
 2393 01f8 00D0      		rcall flash_read_chip_id
 2394               	.LVL233:
 244:main.c        **** 			USART_Transmit(flashChipIdBuffer[0]);
 2395               		.loc 3 244 0
 2396 01fa 8091 0000 		lds r24,flashChipIdBuffer
 2397 01fe 00D0      		rcall USART_Transmit
 2398               	.LVL234:
 245:main.c        **** 			USART_Transmit(flashChipIdBuffer[1]);
 2399               		.loc 3 245 0
 2400 0200 8091 0000 		lds r24,flashChipIdBuffer+1
 2401               	.L191:
 2402 0204 00D0      		rcall USART_Transmit
 2403               	.LVL235:
 2404 0206 00C0      		rjmp .L185
 2405               	.LVL236:
 2406               	.L112:
 246:main.c        **** 			
 247:main.c        **** 			gba_mode(); // Set back
 248:main.c        **** 		}
 249:main.c        **** 		
 250:main.c        **** 		// Change bank
 251:main.c        **** 		else if (receivedChar == GBA_FLASH_SET_BANK) {
 2407               		.loc 3 251 0
 2408 0208 9B36      		cpi r25,lo8(107)
 2409 020a 01F4      		brne .L113
 2410               	.LBB98:
 252:main.c        **** 			usart_read_chars(); // Read data
 2411               		.loc 3 252 0
 2412 020c 00D0      		rcall usart_read_chars
 2413               	.LVL237:
 253:main.c        **** 			uint8_t bank = atoi(receivedBuffer); // Convert data string to dec
 2414               		.loc 3 253 0
 2415 020e 80E0      		ldi r24,lo8(receivedBuffer)
 2416 0210 90E0      		ldi r25,hi8(receivedBuffer)
 2417 0212 00D0      		rcall atoi
 2418               	.LVL238:
 2419 0214 C82F      		mov r28,r24
 2420               	.LVL239:
 254:main.c        **** 			
 255:main.c        **** 			gb_mode();
 2421               		.loc 3 255 0
 2422 0216 00D0      		rcall gb_mode
 2423               	.LVL240:
 256:main.c        **** 			flash_switch_bank(bank);
 2424               		.loc 3 256 0
 2425 0218 8C2F      		mov r24,r28
 2426 021a 00D0      		rcall flash_switch_bank
 2427               	.LVL241:
 2428 021c 00C0      		rjmp .L185
 2429               	.LVL242:
 2430               	.L113:
 2431               	.LBE98:
 257:main.c        **** 			
 258:main.c        **** 			gba_mode(); // Set back
 259:main.c        **** 		}
 260:main.c        **** 		
 261:main.c        **** 		// Erase 4K sector on Flash (sector 0 to 15 for 512Kbit)
 262:main.c        **** 		else if (receivedChar == GBA_FLASH_4K_SECTOR_ERASE) {
 2432               		.loc 3 262 0
 2433 021e 9337      		cpi r25,lo8(115)
 2434 0220 01F4      		brne .L114
 2435               	.LBB99:
 263:main.c        **** 			gb_mode();
 2436               		.loc 3 263 0
 2437 0222 00D0      		rcall gb_mode
 2438               	.LVL243:
 264:main.c        **** 			
 265:main.c        **** 			usart_read_chars(); // Read sector
 2439               		.loc 3 265 0
 2440 0224 00D0      		rcall usart_read_chars
 2441               	.LVL244:
 266:main.c        **** 			uint8_t sectorAddress = strtol(receivedBuffer, NULL, 16); // Convert address string in hex to de
 2442               		.loc 3 266 0
 2443 0226 40E1      		ldi r20,lo8(16)
 2444 0228 50E0      		ldi r21,0
 2445 022a 60E0      		ldi r22,0
 2446 022c 70E0      		ldi r23,0
 2447 022e 80E0      		ldi r24,lo8(receivedBuffer)
 2448 0230 90E0      		ldi r25,hi8(receivedBuffer)
 2449 0232 00D0      		rcall strtol
 2450               	.LVL245:
 2451 0234 862F      		mov r24,r22
 2452               	.LVL246:
 267:main.c        **** 			
 268:main.c        **** 			flash_erase_4k_sector(sectorAddress);
 2453               		.loc 3 268 0
 2454 0236 00D0      		rcall flash_erase_4k_sector
 2455               	.LVL247:
 2456               	.L192:
 269:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 2457               		.loc 3 269 0
 2458 0238 81E3      		ldi r24,lo8(49)
 2459 023a 00C0      		rjmp .L191
 2460               	.LVL248:
 2461               	.L114:
 2462               	.LBE99:
 270:main.c        **** 			
 271:main.c        **** 			gba_mode(); // Set back
 272:main.c        **** 		}
 273:main.c        **** 		
 274:main.c        **** 		// Write 64 bytes to Flash address one byte write at a time (and increment)
 275:main.c        **** 		else if (receivedChar == GBA_FLASH_WRITE_BYTE) {
 2463               		.loc 3 275 0
 2464 023c 9236      		cpi r25,lo8(98)
 2465 023e 01F4      		brne .L115
 276:main.c        **** 			gb_mode();
 2466               		.loc 3 276 0
 2467 0240 00D0      		rcall gb_mode
 2468               	.LVL249:
 277:main.c        **** 			
 278:main.c        **** 			usart_read_bytes(64);
 2469               		.loc 3 278 0
 2470 0242 80E4      		ldi r24,lo8(64)
 2471 0244 00D0      		rcall usart_read_bytes
 2472               	.LVL250:
 279:main.c        **** 			
 280:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 2473               		.loc 3 280 0
 2474 0246 939A      		sbi 0x12,3
 2475               	.LVL251:
 2476 0248 20E0      		ldi r18,lo8(receivedBuffer)
 2477 024a A22E      		mov r10,r18
 2478 024c 20E0      		ldi r18,hi8(receivedBuffer)
 2479 024e B22E      		mov r11,r18
 2480 0250 C0E0      		ldi r28,0
 2481 0252 D0E0      		ldi r29,0
 2482               	.LVL252:
 2483               	.L116:
 2484               	.LBB100:
 281:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 282:main.c        **** 				flash_write_byte(address, receivedBuffer[x]);
 2485               		.loc 3 282 0 discriminator 3
 2486 0254 F501      		movw r30,r10
 2487 0256 6191      		ld r22,Z+
 2488 0258 5F01      		movw r10,r30
 2489 025a CE01      		movw r24,r28
 2490 025c 8C0D      		add r24,r12
 2491 025e 9D1D      		adc r25,r13
 2492 0260 00D0      		rcall flash_write_byte
 2493               	.LVL253:
 2494 0262 2196      		adiw r28,1
 2495               	.LVL254:
 281:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 2496               		.loc 3 281 0 discriminator 3
 2497 0264 C034      		cpi r28,64
 2498 0266 D105      		cpc r29,__zero_reg__
 2499 0268 01F4      		brne .L116
 2500 026a F0E4      		ldi r31,64
 2501 026c CF0E      		add r12,r31
 2502 026e D11C      		adc r13,__zero_reg__
 2503 0270 E11C      		adc r14,__zero_reg__
 2504 0272 F11C      		adc r15,__zero_reg__
 2505 0274 00C0      		rjmp .L187
 2506               	.LVL255:
 2507               	.L115:
 2508               	.LBE100:
 283:main.c        **** 				address++;
 284:main.c        **** 			}
 285:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 286:main.c        **** 			
 287:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 288:main.c        **** 			gba_mode(); // Set back
 289:main.c        **** 		}
 290:main.c        **** 		
 291:main.c        **** 		// Write 128 bytes to flash sector for Atmel flash (and increment)
 292:main.c        **** 		else if (receivedChar == GBA_FLASH_WRITE_ATMEL) {
 2509               		.loc 3 292 0
 2510 0276 9136      		cpi r25,lo8(97)
 2511 0278 01F4      		brne .L117
 293:main.c        **** 			gb_mode();
 2512               		.loc 3 293 0
 2513 027a 00D0      		rcall gb_mode
 2514               	.LVL256:
 294:main.c        **** 			
 295:main.c        **** 			usart_read_bytes(128);
 2515               		.loc 3 295 0
 2516 027c 80E8      		ldi r24,lo8(-128)
 2517 027e 00D0      		rcall usart_read_bytes
 2518               	.LVL257:
 296:main.c        **** 			
 297:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 2519               		.loc 3 297 0
 2520 0280 939A      		sbi 0x12,3
 298:main.c        **** 			flash_write_sector(address); // Address used as sector number
 2521               		.loc 3 298 0
 2522 0282 C601      		movw r24,r12
 2523 0284 00D0      		rcall flash_write_sector
 2524               	.LVL258:
 299:main.c        **** 			address++;
 2525               		.loc 3 299 0
 2526 0286 2FEF      		ldi r18,-1
 2527 0288 C21A      		sub r12,r18
 2528 028a D20A      		sbc r13,r18
 2529 028c E20A      		sbc r14,r18
 2530 028e F20A      		sbc r15,r18
 2531               	.LVL259:
 2532 0290 00C0      		rjmp .L187
 2533               	.LVL260:
 2534               	.L117:
 300:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 301:main.c        **** 			
 302:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 303:main.c        **** 			gba_mode(); // Set back
 304:main.c        **** 		}
 305:main.c        **** 		
 306:main.c        **** 		
 307:main.c        **** 		// ---------- EEPROM ----------
 308:main.c        **** 		// Set EEPROM size
 309:main.c        **** 		else if (receivedChar == GBA_SET_EEPROM_SIZE) {
 2535               		.loc 3 309 0
 2536 0292 9335      		cpi r25,lo8(83)
 2537 0294 01F4      		brne .L118
 310:main.c        **** 			usart_read_chars(); // Read size
 2538               		.loc 3 310 0
 2539 0296 00D0      		rcall usart_read_chars
 2540               	.LVL261:
 311:main.c        **** 			eepromSize = strtol(receivedBuffer, NULL, 16); // Convert size to dec
 2541               		.loc 3 311 0
 2542 0298 40E1      		ldi r20,lo8(16)
 2543 029a 50E0      		ldi r21,0
 2544 029c 60E0      		ldi r22,0
 2545 029e 70E0      		ldi r23,0
 2546 02a0 80E0      		ldi r24,lo8(receivedBuffer)
 2547 02a2 90E0      		ldi r25,hi8(receivedBuffer)
 2548 02a4 00D0      		rcall strtol
 2549               	.LVL262:
 2550 02a6 962E      		mov r9,r22
 2551               	.LVL263:
 2552 02a8 00C0      		rjmp .L85
 2553               	.LVL264:
 2554               	.L118:
 312:main.c        **** 		}
 313:main.c        **** 		
 314:main.c        **** 		// Read the EEPROM on address (and increment) until anything but 1 is received
 315:main.c        **** 		else if (receivedChar == GBA_READ_EEPROM) {
 2555               		.loc 3 315 0
 2556 02aa 9536      		cpi r25,lo8(101)
 2557 02ac 01F4      		brne .L119
 316:main.c        **** 			gba_eeprom_mode();
 2558               		.loc 3 316 0
 2559 02ae 00D0      		rcall gba_eeprom_mode
 2560               	.LVL265:
 317:main.c        **** 			
 318:main.c        **** 			receivedChar = '1';
 2561               		.loc 3 318 0
 2562 02b0 81E3      		ldi r24,lo8(49)
 2563               	.L193:
 319:main.c        **** 			while (receivedChar == '1') {
 320:main.c        **** 				PORTD |= (1<<ACTIVITY_LED);
 321:main.c        **** 				gba_eeprom_read(address, eepromSize);
 322:main.c        **** 				
 323:main.c        **** 				// Send back the 8 bytes of data
 324:main.c        **** 				for (uint8_t c = 0; c < 8; c++) {
 325:main.c        **** 					USART_Transmit(eepromBuffer[c]);
 326:main.c        **** 				}
 327:main.c        **** 				address++; // Increment to next 8 bytes
 328:main.c        **** 				
 329:main.c        **** 				PORTD &= ~(1<<ACTIVITY_LED);
 330:main.c        **** 				receivedChar = USART_Receive();
 2564               		.loc 3 330 0
 2565 02b2 8093 0000 		sts receivedChar,r24
 319:main.c        **** 			while (receivedChar == '1') {
 2566               		.loc 3 319 0
 2567 02b6 8091 0000 		lds r24,receivedChar
 2568 02ba 8133      		cpi r24,lo8(49)
 2569 02bc 01F0      		breq .+2
 2570 02be 00C0      		rjmp .L185
 320:main.c        **** 				gba_eeprom_read(address, eepromSize);
 2571               		.loc 3 320 0
 2572 02c0 939A      		sbi 0x12,3
 321:main.c        **** 				
 2573               		.loc 3 321 0
 2574 02c2 692D      		mov r22,r9
 2575 02c4 C601      		movw r24,r12
 2576 02c6 00D0      		rcall gba_eeprom_read
 2577               	.LVL266:
 2578 02c8 C0E0      		ldi r28,lo8(eepromBuffer)
 2579 02ca D0E0      		ldi r29,hi8(eepromBuffer)
 2580               	.LVL267:
 2581               	.L121:
 2582               	.LBB101:
 325:main.c        **** 				}
 2583               		.loc 3 325 0 discriminator 3
 2584 02cc 8991      		ld r24,Y+
 2585               	.LVL268:
 2586 02ce 00D0      		rcall USART_Transmit
 2587               	.LVL269:
 324:main.c        **** 					USART_Transmit(eepromBuffer[c]);
 2588               		.loc 3 324 0 discriminator 3
 2589 02d0 0C17      		cp r16,r28
 2590 02d2 1D07      		cpc r17,r29
 2591 02d4 01F4      		brne .L121
 2592               	.LBE101:
 327:main.c        **** 				
 2593               		.loc 3 327 0
 2594 02d6 8FEF      		ldi r24,-1
 2595 02d8 C81A      		sub r12,r24
 2596 02da D80A      		sbc r13,r24
 2597 02dc E80A      		sbc r14,r24
 2598 02de F80A      		sbc r15,r24
 2599               	.LVL270:
 329:main.c        **** 				receivedChar = USART_Receive();
 2600               		.loc 3 329 0
 2601 02e0 9398      		cbi 0x12,3
 2602               		.loc 3 330 0
 2603 02e2 00D0      		rcall USART_Receive
 2604               	.LVL271:
 2605 02e4 00C0      		rjmp .L193
 2606               	.LVL272:
 2607               	.L119:
 331:main.c        **** 			}
 332:main.c        **** 			
 333:main.c        **** 			gba_mode(); // Set back
 334:main.c        **** 		}
 335:main.c        **** 		
 336:main.c        **** 		// Write 8 bytes to the EEPROM address (and increment)
 337:main.c        **** 		else if (receivedChar == GBA_WRITE_EEPROM) {
 2608               		.loc 3 337 0
 2609 02e6 9037      		cpi r25,lo8(112)
 2610 02e8 01F4      		brne .L123
 338:main.c        **** 			gba_eeprom_mode();
 2611               		.loc 3 338 0
 2612 02ea 00D0      		rcall gba_eeprom_mode
 2613               	.LVL273:
 2614 02ec C0E0      		ldi r28,lo8(eepromBuffer)
 2615 02ee D0E0      		ldi r29,hi8(eepromBuffer)
 2616               	.LVL274:
 2617               	.L124:
 2618               	.LBB102:
 339:main.c        **** 			
 340:main.c        **** 			// Read 8 bytes from USART and place in buffer
 341:main.c        **** 			for (uint8_t x = 0; x < 8; x++) {
 342:main.c        **** 				eepromBuffer[x] = USART_Receive();
 2619               		.loc 3 342 0 discriminator 3
 2620 02f0 00D0      		rcall USART_Receive
 2621               	.LVL275:
 2622 02f2 8993      		st Y+,r24
 2623               	.LVL276:
 341:main.c        **** 				eepromBuffer[x] = USART_Receive();
 2624               		.loc 3 341 0 discriminator 3
 2625 02f4 90E0      		ldi r25,hi8(eepromBuffer+8)
 2626 02f6 C030      		cpi r28,lo8(eepromBuffer+8)
 2627 02f8 D907      		cpc r29,r25
 2628 02fa 01F4      		brne .L124
 2629               	.LBE102:
 343:main.c        **** 			}
 344:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 2630               		.loc 3 344 0
 2631 02fc 939A      		sbi 0x12,3
 345:main.c        **** 			
 346:main.c        **** 			gba_eeprom_write(address, eepromSize);
 2632               		.loc 3 346 0
 2633 02fe 692D      		mov r22,r9
 2634 0300 C601      		movw r24,r12
 2635 0302 00D0      		rcall gba_eeprom_write
 2636               	.LVL277:
 347:main.c        **** 			address++;
 2637               		.loc 3 347 0
 2638 0304 EFEF      		ldi r30,-1
 2639 0306 CE1A      		sub r12,r30
 2640 0308 DE0A      		sbc r13,r30
 2641 030a EE0A      		sbc r14,r30
 2642 030c FE0A      		sbc r15,r30
 2643               	.LVL278:
 2644               	.LBB103:
 2645               	.LBB104:
 187:c:\winavr-20100110\avr\include\util\delay.h **** 
 2646               		.loc 2 187 0
 2647 030e 8FE7      		ldi r24,lo8(15999)
 2648 0310 9EE3      		ldi r25,hi8(15999)
 2649 0312 0197      	1:	sbiw r24,1
 2650 0314 01F4      		brne 1b
 2651 0316 00C0      		rjmp .
 2652 0318 0000      		nop
 2653               	.LVL279:
 2654 031a 00C0      		rjmp .L187
 2655               	.LVL280:
 2656               	.L123:
 2657               	.LBE104:
 2658               	.LBE103:
 348:main.c        **** 			
 349:main.c        **** 			_delay_ms(8); // Wait for EEPROM to write data (8ms)
 350:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 351:main.c        **** 			
 352:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 353:main.c        **** 			gba_mode(); // Set back
 354:main.c        **** 		}
 355:main.c        **** 		
 356:main.c        **** 		
 357:main.c        **** 		// ---------- GB FLASH CARTS ----------
 358:main.c        **** 		// Select which pin need to pulse as WE (Audio or WR)
 359:main.c        **** 		else if (receivedChar == GB_FLASH_WE_PIN) {
 2659               		.loc 3 359 0
 2660 031c 9035      		cpi r25,lo8(80)
 2661 031e 01F4      		brne .L125
 360:main.c        **** 			flashWriteWePin = USART_Receive();
 2662               		.loc 3 360 0
 2663 0320 00D0      		rcall USART_Receive
 2664               	.LVL281:
 2665 0322 8093 0000 		sts flashWriteWePin,r24
 361:main.c        **** 			
 362:main.c        **** 			if (flashWriteWePin == WE_AS_AUDIO_PIN) {
 2666               		.loc 3 362 0
 2667 0326 8134      		cpi r24,lo8(65)
 2668 0328 01F0      		breq .+2
 2669 032a 00C0      		rjmp .L85
 363:main.c        **** 				DDRE |= (1<<AUDIO_PIN);
 2670               		.loc 3 363 0
 2671 032c 319A      		sbi 0x6,1
 364:main.c        **** 				audioPin_high;
 2672               		.loc 3 364 0
 2673 032e 399A      		sbi 0x7,1
 2674 0330 00C0      		rjmp .L85
 2675               	.LVL282:
 2676               	.L125:
 365:main.c        **** 			}
 366:main.c        **** 		}
 367:main.c        **** 		
 368:main.c        **** 		// Load the program method to use
 369:main.c        **** 		else if (receivedChar == GB_FLASH_PROGRAM_METHOD) {
 2677               		.loc 3 369 0
 2678 0332 9534      		cpi r25,lo8(69)
 2679 0334 01F4      		brne .L126
 2680 0336 C0E0      		ldi r28,lo8(flashWriteCycle)
 2681 0338 D0E0      		ldi r29,hi8(flashWriteCycle)
 2682               	.LVL283:
 2683               	.L127:
 2684               	.LBB105:
 370:main.c        **** 			for (uint8_t x = 0; x < 3; x++) {
 371:main.c        **** 				usart_read_chars(); // Address
 2685               		.loc 3 371 0 discriminator 3
 2686 033a 00D0      		rcall usart_read_chars
 2687               	.LVL284:
 372:main.c        **** 				flashWriteCycle[x][0] = strtol(receivedBuffer, NULL, 16);
 2688               		.loc 3 372 0 discriminator 3
 2689 033c 40E1      		ldi r20,lo8(16)
 2690 033e 50E0      		ldi r21,0
 2691 0340 60E0      		ldi r22,0
 2692 0342 70E0      		ldi r23,0
 2693 0344 80E0      		ldi r24,lo8(receivedBuffer)
 2694 0346 90E0      		ldi r25,hi8(receivedBuffer)
 2695 0348 00D0      		rcall strtol
 2696               	.LVL285:
 2697 034a 7983      		std Y+1,r23
 2698 034c 6883      		st Y,r22
 373:main.c        **** 				USART_Transmit(SEND_ACK);
 2699               		.loc 3 373 0 discriminator 3
 2700 034e 81E3      		ldi r24,lo8(49)
 2701 0350 00D0      		rcall USART_Transmit
 2702               	.LVL286:
 374:main.c        **** 				
 375:main.c        **** 				usart_read_chars(); // Data
 2703               		.loc 3 375 0 discriminator 3
 2704 0352 00D0      		rcall usart_read_chars
 2705               	.LVL287:
 376:main.c        **** 				flashWriteCycle[x][1] = strtol(receivedBuffer, NULL, 16);
 2706               		.loc 3 376 0 discriminator 3
 2707 0354 40E1      		ldi r20,lo8(16)
 2708 0356 50E0      		ldi r21,0
 2709 0358 60E0      		ldi r22,0
 2710 035a 70E0      		ldi r23,0
 2711 035c 80E0      		ldi r24,lo8(receivedBuffer)
 2712 035e 90E0      		ldi r25,hi8(receivedBuffer)
 2713 0360 00D0      		rcall strtol
 2714               	.LVL288:
 2715 0362 7B83      		std Y+3,r23
 2716 0364 6A83      		std Y+2,r22
 377:main.c        **** 				USART_Transmit(SEND_ACK);
 2717               		.loc 3 377 0 discriminator 3
 2718 0366 81E3      		ldi r24,lo8(49)
 2719 0368 00D0      		rcall USART_Transmit
 2720               	.LVL289:
 2721 036a 2496      		adiw r28,4
 370:main.c        **** 				usart_read_chars(); // Address
 2722               		.loc 3 370 0 discriminator 3
 2723 036c 6C16      		cp r6,r28
 2724 036e 7D06      		cpc r7,r29
 2725 0370 01F4      		brne .L127
 2726 0372 00C0      		rjmp .L85
 2727               	.LVL290:
 2728               	.L126:
 2729               	.LBE105:
 378:main.c        **** 			}
 379:main.c        **** 		}
 380:main.c        **** 		
 381:main.c        **** 		// Write address and one byte to Flash, pulse a pin
 382:main.c        **** 		else if (receivedChar == GB_FLASH_WRITE_BYTE) {
 2730               		.loc 3 382 0
 2731 0374 9634      		cpi r25,lo8(70)
 2732 0376 01F4      		brne .L128
 2733               	.LBB106:
 383:main.c        **** 			usart_read_chars(); // Read address
 2734               		.loc 3 383 0
 2735 0378 00D0      		rcall usart_read_chars
 2736               	.LVL291:
 384:main.c        **** 			uint16_t flashAddress = strtol(receivedBuffer, NULL, 16);
 2737               		.loc 3 384 0
 2738 037a 40E1      		ldi r20,lo8(16)
 2739 037c 50E0      		ldi r21,0
 2740 037e 60E0      		ldi r22,0
 2741 0380 70E0      		ldi r23,0
 2742 0382 80E0      		ldi r24,lo8(receivedBuffer)
 2743 0384 90E0      		ldi r25,hi8(receivedBuffer)
 2744 0386 00D0      		rcall strtol
 2745               	.LVL292:
 2746 0388 1B01      		movw r2,r22
 2747 038a 2C01      		movw r4,r24
 2748               	.LVL293:
 385:main.c        **** 			
 386:main.c        **** 			usart_read_chars(); // Read data byte
 2749               		.loc 3 386 0
 2750 038c 00D0      		rcall usart_read_chars
 2751               	.LVL294:
 387:main.c        **** 			uint8_t flashByte = strtol(receivedBuffer, NULL, 16);
 2752               		.loc 3 387 0
 2753 038e 40E1      		ldi r20,lo8(16)
 2754 0390 50E0      		ldi r21,0
 2755 0392 60E0      		ldi r22,0
 2756 0394 70E0      		ldi r23,0
 2757 0396 80E0      		ldi r24,lo8(receivedBuffer)
 2758 0398 90E0      		ldi r25,hi8(receivedBuffer)
 2759 039a 00D0      		rcall strtol
 2760               	.LVL295:
 388:main.c        **** 			
 389:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 2761               		.loc 3 389 0
 2762 039c 939A      		sbi 0x12,3
 390:main.c        **** 			gb_flash_write_bus_cycle(flashAddress, flashByte);
 2763               		.loc 3 390 0
 2764 039e C101      		movw r24,r2
 2765 03a0 00D0      		rcall gb_flash_write_bus_cycle
 2766               	.LVL296:
 2767 03a2 00C0      		rjmp .L205
 2768               	.LVL297:
 2769               	.L128:
 2770               	.LBE106:
 391:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 392:main.c        **** 			
 393:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 394:main.c        **** 		}
 395:main.c        **** 		
 396:main.c        **** 		// Write 64 bytes to Flash address one byte write at a time (and increment), pulse a pin
 397:main.c        **** 		else if (receivedChar == GB_FLASH_WRITE_64BYTE) {
 2771               		.loc 3 397 0
 2772 03a4 9435      		cpi r25,lo8(84)
 2773 03a6 01F4      		brne .L129
 398:main.c        **** 			usart_read_bytes(64);
 2774               		.loc 3 398 0
 2775 03a8 80E4      		ldi r24,lo8(64)
 2776               	.LVL298:
 2777 03aa 00D0      		rcall usart_read_bytes
 2778               	.LVL299:
 399:main.c        **** 			
 400:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 2779               		.loc 3 400 0
 2780 03ac 939A      		sbi 0x12,3
 2781               	.LVL300:
 2782 03ae 90E0      		ldi r25,lo8(receivedBuffer)
 2783 03b0 A92E      		mov r10,r25
 2784 03b2 90E0      		ldi r25,hi8(receivedBuffer)
 2785 03b4 B92E      		mov r11,r25
 2786 03b6 C0E0      		ldi r28,0
 2787 03b8 D0E0      		ldi r29,0
 2788               	.LVL301:
 2789               	.L130:
 2790               	.LBB107:
 401:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 402:main.c        **** 				gb_flash_write_byte(address, receivedBuffer[x]);
 2791               		.loc 3 402 0 discriminator 3
 2792 03ba F501      		movw r30,r10
 2793 03bc 6191      		ld r22,Z+
 2794 03be 5F01      		movw r10,r30
 2795 03c0 CE01      		movw r24,r28
 2796 03c2 8C0D      		add r24,r12
 2797 03c4 9D1D      		adc r25,r13
 2798 03c6 00D0      		rcall gb_flash_write_byte
 2799               	.LVL302:
 2800 03c8 2196      		adiw r28,1
 2801               	.LVL303:
 401:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 2802               		.loc 3 401 0 discriminator 3
 2803 03ca C034      		cpi r28,64
 2804 03cc D105      		cpc r29,__zero_reg__
 2805 03ce 01F4      		brne .L130
 2806 03d0 F0E4      		ldi r31,64
 2807 03d2 CF0E      		add r12,r31
 2808 03d4 D11C      		adc r13,__zero_reg__
 2809 03d6 E11C      		adc r14,__zero_reg__
 2810 03d8 F11C      		adc r15,__zero_reg__
 2811 03da 00C0      		rjmp .L194
 2812               	.LVL304:
 2813               	.L129:
 2814               	.LBE107:
 403:main.c        **** 				address++;
 404:main.c        **** 			}
 405:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 406:main.c        **** 			
 407:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 408:main.c        **** 		}
 409:main.c        **** 		
 410:main.c        **** 		
 411:main.c        **** 		// ---------- GBA FLASH CARTS ----------
 412:main.c        **** 		// Write 24 bit address, 16 bit data and pulse a pin
 413:main.c        **** 		else if (receivedChar == GBA_FLASH_CART_WRITE_BYTE) {
 2815               		.loc 3 413 0
 2816 03dc 9E36      		cpi r25,lo8(110)
 2817 03de 01F4      		brne .L131
 2818               	.LBB108:
 414:main.c        **** 			usart_read_chars(); // Read address
 2819               		.loc 3 414 0
 2820 03e0 00D0      		rcall usart_read_chars
 2821               	.LVL305:
 415:main.c        **** 			uint32_t flashAddress = strtol(receivedBuffer, NULL, 16); // Convert address string in hex to de
 2822               		.loc 3 415 0
 2823 03e2 40E1      		ldi r20,lo8(16)
 2824 03e4 50E0      		ldi r21,0
 2825 03e6 60E0      		ldi r22,0
 2826 03e8 70E0      		ldi r23,0
 2827 03ea 80E0      		ldi r24,lo8(receivedBuffer)
 2828 03ec 90E0      		ldi r25,hi8(receivedBuffer)
 2829 03ee 00D0      		rcall strtol
 2830               	.LVL306:
 2831 03f0 1B01      		movw r2,r22
 2832 03f2 2C01      		movw r4,r24
 2833               	.LVL307:
 416:main.c        **** 			
 417:main.c        **** 			receivedChar = USART_Receive(); // Wait for byte
 2834               		.loc 3 417 0
 2835 03f4 00D0      		rcall USART_Receive
 2836               	.LVL308:
 2837 03f6 8093 0000 		sts receivedChar,r24
 418:main.c        **** 			if (receivedChar == GBA_FLASH_CART_WRITE_BYTE) {
 2838               		.loc 3 418 0
 2839 03fa 8E36      		cpi r24,lo8(110)
 2840 03fc 01F0      		breq .+2
 2841 03fe 00C0      		rjmp .L85
 2842               	.LBB109:
 419:main.c        **** 				usart_read_chars(); // Read data
 2843               		.loc 3 419 0
 2844 0400 00D0      		rcall usart_read_chars
 2845               	.LVL309:
 420:main.c        **** 				uint16_t flashByte = strtol(receivedBuffer, NULL, 16); // Convert data byte in hex to dec
 2846               		.loc 3 420 0
 2847 0402 40E1      		ldi r20,lo8(16)
 2848 0404 50E0      		ldi r21,0
 2849 0406 60E0      		ldi r22,0
 2850 0408 70E0      		ldi r23,0
 2851 040a 80E0      		ldi r24,lo8(receivedBuffer)
 2852 040c 90E0      		ldi r25,hi8(receivedBuffer)
 2853 040e 00D0      		rcall strtol
 2854               	.LVL310:
 421:main.c        **** 				
 422:main.c        **** 				PORTD |= (1<<ACTIVITY_LED);
 2855               		.loc 3 422 0
 2856 0410 939A      		sbi 0x12,3
 423:main.c        **** 				gba_flash_write_bus_cycle(flashAddress, flashByte);
 2857               		.loc 3 423 0
 2858 0412 AB01      		movw r20,r22
 2859 0414 C201      		movw r24,r4
 2860 0416 B101      		movw r22,r2
 2861               	.LVL311:
 2862 0418 00D0      		rcall gba_flash_write_bus_cycle
 2863               	.LVL312:
 2864               	.L205:
 424:main.c        **** 				PORTD &= ~(1<<ACTIVITY_LED);
 2865               		.loc 3 424 0
 2866 041a 9398      		cbi 0x12,3
 425:main.c        **** 				
 426:main.c        **** 				USART_Transmit(SEND_ACK); // Send back acknowledgement
 2867               		.loc 3 426 0
 2868 041c 81E3      		ldi r24,lo8(49)
 2869 041e 00C0      		rjmp .L183
 2870               	.LVL313:
 2871               	.L131:
 2872               	.LBE109:
 2873               	.LBE108:
 427:main.c        **** 			}
 428:main.c        **** 		}
 429:main.c        **** 		
 430:main.c        **** 		// Write 64 bytes to Flash address, combine 2 bytes and write at a time (and increment address by
 431:main.c        **** 		else if (receivedChar == GBA_FLASH_WRITE_64BYTE) {
 2874               		.loc 3 431 0
 2875 0420 9137      		cpi r25,lo8(113)
 2876 0422 01F4      		brne .L132
 432:main.c        **** 			usart_read_bytes(64);
 2877               		.loc 3 432 0
 2878 0424 80E4      		ldi r24,lo8(64)
 2879               	.LVL314:
 2880 0426 00D0      		rcall usart_read_bytes
 2881               	.LVL315:
 433:main.c        **** 			
 434:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 2882               		.loc 3 434 0
 2883 0428 939A      		sbi 0x12,3
 2884               	.LVL316:
 2885 042a C0E0      		ldi r28,lo8(receivedBuffer)
 2886 042c D0E0      		ldi r29,hi8(receivedBuffer)
 2887 042e 1601      		movw r2,r12
 2888 0430 2701      		movw r4,r14
 2889               	.LVL317:
 2890               	.L133:
 2891               	.LBB110:
 2892               	.LBB111:
 435:main.c        **** 			for (uint8_t x = 0; x < 64; x += 2) {
 436:main.c        **** 				uint16_t combinedBytes = (uint16_t) receivedBuffer[x+1] << 8 | (uint16_t) receivedBuffer[x];
 437:main.c        **** 				gba_flash_write_byte_swapped(address, combinedBytes);
 2893               		.loc 3 437 0 discriminator 3
 2894 0432 4981      		ldd r20,Y+1
 2895 0434 50E0      		ldi r21,0
 2896 0436 542F      		mov r21,r20
 2897 0438 4427      		clr r20
 2898 043a 8881      		ld r24,Y
 2899 043c 482B      		or r20,r24
 2900 043e C201      		movw r24,r4
 2901 0440 B101      		movw r22,r2
 2902 0442 00D0      		rcall gba_flash_write_byte_swapped
 2903               	.LVL318:
 438:main.c        **** 				address++;
 2904               		.loc 3 438 0 discriminator 3
 2905 0444 2FEF      		ldi r18,-1
 2906 0446 221A      		sub r2,r18
 2907 0448 320A      		sbc r3,r18
 2908 044a 420A      		sbc r4,r18
 2909 044c 520A      		sbc r5,r18
 2910               	.LVL319:
 2911 044e 2296      		adiw r28,2
 2912               	.LVL320:
 2913               	.LBE111:
 435:main.c        **** 			for (uint8_t x = 0; x < 64; x += 2) {
 2914               		.loc 3 435 0 discriminator 3
 2915 0450 80E0      		ldi r24,lo8(receivedBuffer+64)
 2916 0452 90E0      		ldi r25,hi8(receivedBuffer+64)
 2917 0454 8C17      		cp r24,r28
 2918 0456 9D07      		cpc r25,r29
 2919 0458 01F4      		brne .L133
 2920 045a 90E2      		ldi r25,32
 2921 045c C90E      		add r12,r25
 2922 045e D11C      		adc r13,__zero_reg__
 2923 0460 E11C      		adc r14,__zero_reg__
 2924 0462 F11C      		adc r15,__zero_reg__
 2925               	.LVL321:
 2926               	.L194:
 2927               	.LBE110:
 439:main.c        **** 			}
 440:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 2928               		.loc 3 440 0
 2929 0464 81E3      		ldi r24,lo8(49)
 2930 0466 00C0      		rjmp .L186
 2931               	.LVL322:
 2932               	.L132:
 441:main.c        **** 			
 442:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 443:main.c        **** 		}
 444:main.c        **** 		
 445:main.c        **** 		
 446:main.c        **** 		// ---------- General commands ----------
 447:main.c        **** 		// Set any pin as input/output
 448:main.c        **** 		// Reads the DDR/PORT (e.g. DDRB/PORTB is 'B') and the hex value that represents pins to set to a
 449:main.c        **** 		else if (receivedChar == SET_INPUT || receivedChar == SET_OUTPUT) {
 2933               		.loc 3 449 0
 2934 0468 9934      		cpi r25,lo8(73)
 2935 046a 01F0      		breq .L134
 2936               		.loc 3 449 0 is_stmt 0 discriminator 1
 2937 046c 9F34      		cpi r25,lo8(79)
 2938 046e 01F0      		breq .+2
 2939 0470 00C0      		rjmp .L135
 2940               	.L134:
 2941               	.LBB112:
 450:main.c        **** 			char portChar = USART_Receive();
 2942               		.loc 3 450 0 is_stmt 1
 2943 0472 00D0      		rcall USART_Receive
 2944               	.LVL323:
 2945 0474 C82F      		mov r28,r24
 2946               	.LVL324:
 451:main.c        **** 			usart_read_chars();
 2947               		.loc 3 451 0
 2948 0476 00D0      		rcall usart_read_chars
 2949               	.LVL325:
 452:main.c        **** 			uint8_t setValue = strtol(receivedBuffer, NULL, 16);
 2950               		.loc 3 452 0
 2951 0478 40E1      		ldi r20,lo8(16)
 2952 047a 50E0      		ldi r21,0
 2953 047c 60E0      		ldi r22,0
 2954 047e 70E0      		ldi r23,0
 2955 0480 80E0      		ldi r24,lo8(receivedBuffer)
 2956 0482 90E0      		ldi r25,hi8(receivedBuffer)
 2957 0484 00D0      		rcall strtol
 2958               	.LVL326:
 453:main.c        **** 			
 454:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 2959               		.loc 3 454 0
 2960 0486 939A      		sbi 0x12,3
 455:main.c        **** 			if (receivedChar == SET_INPUT) {
 2961               		.loc 3 455 0
 2962 0488 8091 0000 		lds r24,receivedChar
 2963 048c 8934      		cpi r24,lo8(73)
 2964 048e 01F4      		brne .L136
 456:main.c        **** 				if (portChar == 'A') {
 2965               		.loc 3 456 0
 2966 0490 C134      		cpi r28,lo8(65)
 2967 0492 01F4      		brne .L137
 457:main.c        **** 					DDRA &= ~(setValue);
 2968               		.loc 3 457 0
 2969 0494 8AB3      		in r24,0x1a
 2970 0496 6095      		com r22
 2971               	.LVL327:
 2972 0498 6823      		and r22,r24
 2973               	.LVL328:
 2974 049a 00C0      		rjmp .L196
 2975               	.LVL329:
 2976               	.L137:
 458:main.c        **** 				}
 459:main.c        **** 				else if (portChar == 'B') {
 2977               		.loc 3 459 0
 2978 049c C234      		cpi r28,lo8(66)
 2979 049e 01F4      		brne .L139
 460:main.c        **** 					DDRB &= ~(setValue);
 2980               		.loc 3 460 0
 2981 04a0 87B3      		in r24,0x17
 2982 04a2 6095      		com r22
 2983               	.LVL330:
 2984 04a4 6823      		and r22,r24
 2985               	.LVL331:
 2986 04a6 00C0      		rjmp .L197
 2987               	.LVL332:
 2988               	.L139:
 461:main.c        **** 				}
 462:main.c        **** 				else if (portChar == 'C') {
 2989               		.loc 3 462 0
 2990 04a8 C334      		cpi r28,lo8(67)
 2991 04aa 01F4      		brne .L140
 463:main.c        **** 					DDRC &= ~(setValue);
 2992               		.loc 3 463 0
 2993 04ac 84B3      		in r24,0x14
 2994 04ae 6095      		com r22
 2995               	.LVL333:
 2996 04b0 6823      		and r22,r24
 2997               	.LVL334:
 2998 04b2 00C0      		rjmp .L202
 2999               	.LVL335:
 3000               	.L140:
 464:main.c        **** 				}
 465:main.c        **** 				else if (portChar == 'D') {
 3001               		.loc 3 465 0
 3002 04b4 C434      		cpi r28,lo8(68)
 3003 04b6 01F4      		brne .L141
 466:main.c        **** 					DDRD &= ~(setValue);
 3004               		.loc 3 466 0
 3005 04b8 81B3      		in r24,0x11
 3006 04ba 6095      		com r22
 3007               	.LVL336:
 3008 04bc 6823      		and r22,r24
 3009               	.LVL337:
 3010 04be 00C0      		rjmp .L203
 3011               	.LVL338:
 3012               	.L141:
 467:main.c        **** 				}
 468:main.c        **** 				else if (portChar == 'E') {
 3013               		.loc 3 468 0
 3014 04c0 C534      		cpi r28,lo8(69)
 3015 04c2 01F0      		breq .+2
 3016 04c4 00C0      		rjmp .L160
 469:main.c        **** 					DDRE &= ~(setValue);
 3017               		.loc 3 469 0
 3018 04c6 86B1      		in r24,0x6
 3019 04c8 6095      		com r22
 3020               	.LVL339:
 3021 04ca 6823      		and r22,r24
 3022               	.LVL340:
 3023 04cc 00C0      		rjmp .L204
 3024               	.LVL341:
 3025               	.L136:
 470:main.c        **** 				}
 471:main.c        **** 			}
 472:main.c        **** 			else if (receivedChar == SET_OUTPUT) {
 3026               		.loc 3 472 0
 3027 04ce 8F34      		cpi r24,lo8(79)
 3028 04d0 01F0      		breq .+2
 3029 04d2 00C0      		rjmp .L160
 473:main.c        **** 				if (portChar == 'A') {
 3030               		.loc 3 473 0
 3031 04d4 C134      		cpi r28,lo8(65)
 3032 04d6 01F4      		brne .L142
 474:main.c        **** 					DDRA |= (setValue);
 3033               		.loc 3 474 0
 3034 04d8 8AB3      		in r24,0x1a
 3035 04da 682B      		or r22,r24
 3036               	.LVL342:
 3037               	.L196:
 3038 04dc 6ABB      		out 0x1a,r22
 3039 04de 00C0      		rjmp .L160
 3040               	.LVL343:
 3041               	.L142:
 475:main.c        **** 				}
 476:main.c        **** 				else if (portChar == 'B') {
 3042               		.loc 3 476 0
 3043 04e0 C234      		cpi r28,lo8(66)
 3044 04e2 01F4      		brne .L143
 477:main.c        **** 					DDRB |= (setValue);
 3045               		.loc 3 477 0
 3046 04e4 87B3      		in r24,0x17
 3047 04e6 682B      		or r22,r24
 3048               	.LVL344:
 3049               	.L197:
 3050 04e8 67BB      		out 0x17,r22
 3051 04ea 00C0      		rjmp .L160
 3052               	.LVL345:
 3053               	.L143:
 478:main.c        **** 				}
 479:main.c        **** 				else if (portChar == 'C') {
 3054               		.loc 3 479 0
 3055 04ec C334      		cpi r28,lo8(67)
 3056 04ee 01F4      		brne .L144
 480:main.c        **** 					DDRC |= (setValue);
 3057               		.loc 3 480 0
 3058 04f0 84B3      		in r24,0x14
 3059 04f2 682B      		or r22,r24
 3060               	.LVL346:
 3061               	.L202:
 3062 04f4 64BB      		out 0x14,r22
 3063 04f6 00C0      		rjmp .L160
 3064               	.LVL347:
 3065               	.L144:
 481:main.c        **** 				}
 482:main.c        **** 				else if (portChar == 'D') {
 3066               		.loc 3 482 0
 3067 04f8 C434      		cpi r28,lo8(68)
 3068 04fa 01F4      		brne .L145
 483:main.c        **** 					DDRD |= (setValue);
 3069               		.loc 3 483 0
 3070 04fc 81B3      		in r24,0x11
 3071 04fe 682B      		or r22,r24
 3072               	.LVL348:
 3073               	.L203:
 3074 0500 61BB      		out 0x11,r22
 3075 0502 00C0      		rjmp .L160
 3076               	.LVL349:
 3077               	.L145:
 484:main.c        **** 				}
 485:main.c        **** 				else if (portChar == 'E') {
 3078               		.loc 3 485 0
 3079 0504 C534      		cpi r28,lo8(69)
 3080 0506 01F0      		breq .+2
 3081 0508 00C0      		rjmp .L160
 486:main.c        **** 					DDRE |= (setValue);
 3082               		.loc 3 486 0
 3083 050a 86B1      		in r24,0x6
 3084 050c 682B      		or r22,r24
 3085               	.LVL350:
 3086               	.L204:
 3087 050e 66B9      		out 0x6,r22
 3088 0510 00C0      		rjmp .L160
 3089               	.LVL351:
 3090               	.L135:
 3091               	.LBE112:
 487:main.c        **** 				}
 488:main.c        **** 			}
 489:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 490:main.c        **** 		}
 491:main.c        **** 		
 492:main.c        **** 		// Set pin output as low
 493:main.c        **** 		else if (receivedChar == SET_OUTPUT_LOW) {
 3092               		.loc 3 493 0
 3093 0512 9C34      		cpi r25,lo8(76)
 3094 0514 01F4      		brne .L146
 3095               	.LBB113:
 494:main.c        **** 			char portChar = USART_Receive();			
 3096               		.loc 3 494 0
 3097 0516 00D0      		rcall USART_Receive
 3098               	.LVL352:
 3099 0518 C82F      		mov r28,r24
 3100               	.LVL353:
 495:main.c        **** 			usart_read_chars();
 3101               		.loc 3 495 0
 3102 051a 00D0      		rcall usart_read_chars
 3103               	.LVL354:
 496:main.c        **** 			uint8_t setValue = strtol(receivedBuffer, NULL, 16);
 3104               		.loc 3 496 0
 3105 051c 40E1      		ldi r20,lo8(16)
 3106 051e 50E0      		ldi r21,0
 3107 0520 60E0      		ldi r22,0
 3108 0522 70E0      		ldi r23,0
 3109 0524 80E0      		ldi r24,lo8(receivedBuffer)
 3110 0526 90E0      		ldi r25,hi8(receivedBuffer)
 3111 0528 00D0      		rcall strtol
 3112               	.LVL355:
 497:main.c        **** 			
 498:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 3113               		.loc 3 498 0
 3114 052a 939A      		sbi 0x12,3
 499:main.c        **** 			if (portChar == 'A') {
 3115               		.loc 3 499 0
 3116 052c C134      		cpi r28,lo8(65)
 3117 052e 01F4      		brne .L147
 500:main.c        **** 				PORTA &= ~(setValue);
 3118               		.loc 3 500 0
 3119 0530 8BB3      		in r24,0x1b
 3120 0532 6095      		com r22
 3121               	.LVL356:
 3122 0534 6823      		and r22,r24
 3123               	.LVL357:
 3124 0536 00C0      		rjmp .L201
 3125               	.LVL358:
 3126               	.L147:
 501:main.c        **** 			}
 502:main.c        **** 			else if (portChar == 'B') {
 3127               		.loc 3 502 0
 3128 0538 C234      		cpi r28,lo8(66)
 3129 053a 01F4      		brne .L149
 503:main.c        **** 				PORTB &= ~(setValue);
 3130               		.loc 3 503 0
 3131 053c 88B3      		in r24,0x18
 3132 053e 6095      		com r22
 3133               	.LVL359:
 3134 0540 6823      		and r22,r24
 3135               	.LVL360:
 3136 0542 00C0      		rjmp .L200
 3137               	.LVL361:
 3138               	.L149:
 504:main.c        **** 			}
 505:main.c        **** 			else if (portChar == 'C') {
 3139               		.loc 3 505 0
 3140 0544 C334      		cpi r28,lo8(67)
 3141 0546 01F4      		brne .L150
 506:main.c        **** 				PORTC &= ~(setValue);
 3142               		.loc 3 506 0
 3143 0548 85B3      		in r24,0x15
 3144 054a 6095      		com r22
 3145               	.LVL362:
 3146 054c 6823      		and r22,r24
 3147               	.LVL363:
 3148 054e 00C0      		rjmp .L199
 3149               	.LVL364:
 3150               	.L150:
 507:main.c        **** 			}
 508:main.c        **** 			else if (portChar == 'D') {
 3151               		.loc 3 508 0
 3152 0550 C434      		cpi r28,lo8(68)
 3153 0552 01F4      		brne .L151
 509:main.c        **** 				PORTD &= ~(setValue);
 3154               		.loc 3 509 0
 3155 0554 82B3      		in r24,0x12
 3156 0556 6095      		com r22
 3157               	.LVL365:
 3158 0558 6823      		and r22,r24
 3159               	.LVL366:
 3160 055a 00C0      		rjmp .L198
 3161               	.LVL367:
 3162               	.L151:
 510:main.c        **** 			}
 511:main.c        **** 			else if (portChar == 'E') {
 3163               		.loc 3 511 0
 3164 055c C534      		cpi r28,lo8(69)
 3165 055e 01F0      		breq .+2
 3166 0560 00C0      		rjmp .L160
 512:main.c        **** 				PORTE &= ~(setValue);
 3167               		.loc 3 512 0
 3168 0562 87B1      		in r24,0x7
 3169 0564 6095      		com r22
 3170               	.LVL368:
 3171 0566 6823      		and r22,r24
 3172               	.LVL369:
 3173 0568 00C0      		rjmp .L195
 3174               	.LVL370:
 3175               	.L146:
 3176               	.LBE113:
 513:main.c        **** 			}
 514:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 515:main.c        **** 		}
 516:main.c        **** 		
 517:main.c        **** 		// Set pin output as high
 518:main.c        **** 		else if (receivedChar == SET_OUTPUT_HIGH) {
 3177               		.loc 3 518 0
 3178 056a 9834      		cpi r25,lo8(72)
 3179 056c 01F4      		brne .L152
 3180               	.LBB114:
 519:main.c        **** 			char portChar = USART_Receive();			
 3181               		.loc 3 519 0
 3182 056e 00D0      		rcall USART_Receive
 3183               	.LVL371:
 3184 0570 C82F      		mov r28,r24
 3185               	.LVL372:
 520:main.c        **** 			usart_read_chars();
 3186               		.loc 3 520 0
 3187 0572 00D0      		rcall usart_read_chars
 3188               	.LVL373:
 521:main.c        **** 			uint8_t setValue = strtol(receivedBuffer, NULL, 16);
 3189               		.loc 3 521 0
 3190 0574 40E1      		ldi r20,lo8(16)
 3191 0576 50E0      		ldi r21,0
 3192 0578 60E0      		ldi r22,0
 3193 057a 70E0      		ldi r23,0
 3194 057c 80E0      		ldi r24,lo8(receivedBuffer)
 3195 057e 90E0      		ldi r25,hi8(receivedBuffer)
 3196 0580 00D0      		rcall strtol
 3197               	.LVL374:
 522:main.c        **** 			
 523:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 3198               		.loc 3 523 0
 3199 0582 939A      		sbi 0x12,3
 524:main.c        **** 			if (portChar == 'A') {
 3200               		.loc 3 524 0
 3201 0584 C134      		cpi r28,lo8(65)
 3202 0586 01F4      		brne .L153
 525:main.c        **** 				PORTA |= (setValue);
 3203               		.loc 3 525 0
 3204 0588 8BB3      		in r24,0x1b
 3205 058a 682B      		or r22,r24
 3206               	.LVL375:
 3207               	.L201:
 3208 058c 6BBB      		out 0x1b,r22
 3209 058e 00C0      		rjmp .L160
 3210               	.LVL376:
 3211               	.L153:
 526:main.c        **** 			}
 527:main.c        **** 			else if (portChar == 'B') {
 3212               		.loc 3 527 0
 3213 0590 C234      		cpi r28,lo8(66)
 3214 0592 01F4      		brne .L155
 528:main.c        **** 				PORTB |= (setValue);
 3215               		.loc 3 528 0
 3216 0594 88B3      		in r24,0x18
 3217 0596 682B      		or r22,r24
 3218               	.LVL377:
 3219               	.L200:
 3220 0598 68BB      		out 0x18,r22
 3221 059a 00C0      		rjmp .L160
 3222               	.LVL378:
 3223               	.L155:
 529:main.c        **** 			}
 530:main.c        **** 			else if (portChar == 'C') {
 3224               		.loc 3 530 0
 3225 059c C334      		cpi r28,lo8(67)
 3226 059e 01F4      		brne .L156
 531:main.c        **** 				PORTC |= (setValue);
 3227               		.loc 3 531 0
 3228 05a0 85B3      		in r24,0x15
 3229 05a2 682B      		or r22,r24
 3230               	.LVL379:
 3231               	.L199:
 3232 05a4 65BB      		out 0x15,r22
 3233 05a6 00C0      		rjmp .L160
 3234               	.LVL380:
 3235               	.L156:
 532:main.c        **** 			}
 533:main.c        **** 			else if (portChar == 'D') {
 3236               		.loc 3 533 0
 3237 05a8 C434      		cpi r28,lo8(68)
 3238 05aa 01F4      		brne .L157
 534:main.c        **** 				PORTD |= (setValue);
 3239               		.loc 3 534 0
 3240 05ac 82B3      		in r24,0x12
 3241 05ae 682B      		or r22,r24
 3242               	.LVL381:
 3243               	.L198:
 3244 05b0 62BB      		out 0x12,r22
 3245 05b2 00C0      		rjmp .L160
 3246               	.LVL382:
 3247               	.L157:
 535:main.c        **** 			}
 536:main.c        **** 			else if (portChar == 'E') {
 3248               		.loc 3 536 0
 3249 05b4 C534      		cpi r28,lo8(69)
 3250 05b6 01F4      		brne .L160
 537:main.c        **** 				PORTE |= (setValue);
 3251               		.loc 3 537 0
 3252 05b8 87B1      		in r24,0x7
 3253 05ba 682B      		or r22,r24
 3254               	.LVL383:
 3255               	.L195:
 3256 05bc 67B9      		out 0x7,r22
 3257 05be 00C0      		rjmp .L160
 3258               	.LVL384:
 3259               	.L152:
 3260               	.LBE114:
 538:main.c        **** 			}
 539:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 540:main.c        **** 		}
 541:main.c        **** 		
 542:main.c        **** 		// Read all pins of a PORT and return the value
 543:main.c        **** 		else if (receivedChar == READ_INPUT) {
 3261               		.loc 3 543 0
 3262 05c0 9434      		cpi r25,lo8(68)
 3263 05c2 01F4      		brne .L158
 3264               	.LBB115:
 544:main.c        **** 			char portChar = USART_Receive();			
 3265               		.loc 3 544 0
 3266 05c4 00D0      		rcall USART_Receive
 3267               	.LVL385:
 545:main.c        **** 			
 546:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 3268               		.loc 3 546 0
 3269 05c6 939A      		sbi 0x12,3
 547:main.c        **** 			if (portChar == 'A') {
 3270               		.loc 3 547 0
 3271 05c8 8134      		cpi r24,lo8(65)
 3272 05ca 01F4      		brne .L159
 548:main.c        **** 				USART_Transmit(PINA);
 3273               		.loc 3 548 0
 3274 05cc 89B3      		in r24,0x19
 3275               	.LVL386:
 3276 05ce 00C0      		rjmp .L186
 3277               	.LVL387:
 3278               	.L159:
 549:main.c        **** 			}
 550:main.c        **** 			else if (portChar == 'B') {
 3279               		.loc 3 550 0
 3280 05d0 8234      		cpi r24,lo8(66)
 3281 05d2 01F4      		brne .L161
 551:main.c        **** 				USART_Transmit(PINB);
 3282               		.loc 3 551 0
 3283 05d4 86B3      		in r24,0x16
 3284               	.LVL388:
 3285 05d6 00C0      		rjmp .L186
 3286               	.LVL389:
 3287               	.L161:
 552:main.c        **** 			}
 553:main.c        **** 			else if (portChar == 'C') {
 3288               		.loc 3 553 0
 3289 05d8 8334      		cpi r24,lo8(67)
 3290 05da 01F4      		brne .L162
 554:main.c        **** 				USART_Transmit(PINC);
 3291               		.loc 3 554 0
 3292 05dc 83B3      		in r24,0x13
 3293               	.LVL390:
 3294 05de 00C0      		rjmp .L186
 3295               	.LVL391:
 3296               	.L162:
 555:main.c        **** 			}
 556:main.c        **** 			else if (portChar == 'D') {
 3297               		.loc 3 556 0
 3298 05e0 8434      		cpi r24,lo8(68)
 3299 05e2 01F4      		brne .L163
 557:main.c        **** 				USART_Transmit(PIND);
 3300               		.loc 3 557 0
 3301 05e4 80B3      		in r24,0x10
 3302               	.LVL392:
 3303 05e6 00C0      		rjmp .L186
 3304               	.LVL393:
 3305               	.L163:
 558:main.c        **** 			}
 559:main.c        **** 			else if (portChar == 'E') {
 3306               		.loc 3 559 0
 3307 05e8 8534      		cpi r24,lo8(69)
 3308 05ea 01F4      		brne .L160
 560:main.c        **** 				USART_Transmit(PINE);
 3309               		.loc 3 560 0
 3310 05ec 85B1      		in r24,0x5
 3311               	.LVL394:
 3312               	.L186:
 3313 05ee 00D0      		rcall USART_Transmit
 3314               	.LVL395:
 3315               	.L160:
 561:main.c        **** 			}
 562:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 3316               		.loc 3 562 0
 3317 05f0 9398      		cbi 0x12,3
 3318               	.LBE115:
 3319 05f2 00C0      		rjmp .L85
 3320               	.LVL396:
 3321               	.L158:
 563:main.c        **** 		}
 564:main.c        **** 		
 565:main.c        **** 		// Set the reset common lines variable on or off, useful if you are controlling all the pins dire
 566:main.c        **** 		else if (receivedChar == RESET_COMMON_LINES) {
 3322               		.loc 3 566 0
 3323 05f4 9D34      		cpi r25,lo8(77)
 3324 05f6 01F4      		brne .L164
 3325               	.LBB116:
 567:main.c        **** 			char commonChar = USART_Receive();
 3326               		.loc 3 567 0
 3327 05f8 00D0      		rcall USART_Receive
 3328               	.LVL397:
 568:main.c        **** 			if (commonChar == '1') {
 3329               		.loc 3 568 0
 3330 05fa 8133      		cpi r24,lo8(49)
 3331 05fc 01F4      		brne .L206
 569:main.c        **** 				resetCommonLines = 1;
 3332               		.loc 3 569 0
 3333 05fe 8824      		clr r8
 3334 0600 8394      		inc r8
 3335 0602 00C0      		rjmp .L182
 3336               	.L206:
 570:main.c        **** 			}
 571:main.c        **** 			else if (commonChar == '0') {
 3337               		.loc 3 571 0
 3338 0604 8033      		cpi r24,lo8(48)
 3339 0606 01F0      		breq .+2
 3340 0608 00C0      		rjmp .L85
 572:main.c        **** 				resetCommonLines = 0;
 3341               		.loc 3 572 0
 3342 060a 812C      		mov r8,__zero_reg__
 3343 060c 00C0      		rjmp .L86
 3344               	.LVL398:
 3345               	.L164:
 3346               	.LBE116:
 573:main.c        **** 			}
 574:main.c        **** 		}
 575:main.c        **** 		
 576:main.c        **** 		// Send back the PCB version number
 577:main.c        **** 		else if (receivedChar == READ_PCB_VERSION) {
 3347               		.loc 3 577 0
 3348 060e 9836      		cpi r25,lo8(104)
 3349 0610 01F4      		brne .L165
 578:main.c        **** 			USART_Transmit(PCB_VERSION);
 3350               		.loc 3 578 0
 3351 0612 82E0      		ldi r24,lo8(2)
 3352               	.LVL399:
 3353 0614 00C0      		rjmp .L183
 3354               	.LVL400:
 3355               	.L165:
 579:main.c        **** 		}
 580:main.c        **** 		
 581:main.c        **** 		// Send back the firmware version number
 582:main.c        **** 		else if (receivedChar == READ_FIRMWARE_VERSION) {
 3356               		.loc 3 582 0
 3357 0616 9635      		cpi r25,lo8(86)
 3358 0618 01F4      		brne .L166
 583:main.c        **** 			USART_Transmit(FIRMWARE_VERSION);
 3359               		.loc 3 583 0
 3360 061a 89E0      		ldi r24,lo8(9)
 3361               	.LVL401:
 3362               	.L183:
 3363 061c 00D0      		rcall USART_Transmit
 3364               	.LVL402:
 3365 061e 00C0      		rjmp .L85
 3366               	.LVL403:
 3367               	.L166:
 584:main.c        **** 		}
 585:main.c        **** 		
 586:main.c        **** 		// Reset the AVR if it matches the number
 587:main.c        **** 		else if (receivedChar == RESET_AVR) {
 3368               		.loc 3 587 0
 3369 0620 9A32      		cpi r25,lo8(42)
 3370 0622 01F0      		breq .+2
 3371 0624 00C0      		rjmp .L85
 3372               	.LBB117:
 588:main.c        **** 			usart_read_chars();
 3373               		.loc 3 588 0
 3374 0626 00D0      		rcall usart_read_chars
 3375               	.LVL404:
 589:main.c        **** 			uint32_t resetValue = strtol(receivedBuffer, NULL, 16);
 3376               		.loc 3 589 0
 3377 0628 40E1      		ldi r20,lo8(16)
 3378 062a 50E0      		ldi r21,0
 3379 062c 60E0      		ldi r22,0
 3380 062e 70E0      		ldi r23,0
 3381 0630 80E0      		ldi r24,lo8(receivedBuffer)
 3382 0632 90E0      		ldi r25,hi8(receivedBuffer)
 3383 0634 00D0      		rcall strtol
 3384               	.LVL405:
 590:main.c        **** 			if (resetValue == RESET_VALUE) {
 3385               		.loc 3 590 0
 3386 0636 613E      		cpi r22,-31
 3387 0638 754E      		sbci r23,-27
 3388 063a 8740      		sbci r24,7
 3389 063c 9105      		cpc r25,__zero_reg__
 3390 063e 01F0      		breq .+2
 3391 0640 00C0      		rjmp .L85
 591:main.c        **** 				// Clear watchdog flag
 592:main.c        **** 				MCUCSR &= ~(1<<WDRF);
 3392               		.loc 3 592 0
 3393 0642 84B7      		in r24,0x34
 3394 0644 877F      		andi r24,lo8(-9)
 3395 0646 84BF      		out 0x34,r24
 593:main.c        **** 				
 594:main.c        **** 				// Start timed sequence
 595:main.c        **** 				WDTCR = (1<<WDCE) | (1<<WDE);
 3396               		.loc 3 595 0
 3397 0648 F8E1      		ldi r31,lo8(24)
 3398 064a F1BD      		out 0x21,r31
 596:main.c        **** 				
 597:main.c        **** 				// Reset in 250 ms
 598:main.c        **** 				WDTCR = (1<<WDP2) | (1<<WDE);
 3399               		.loc 3 598 0
 3400 064c 2CE0      		ldi r18,lo8(12)
 3401 064e 21BD      		out 0x21,r18
 3402               	.LVL406:
 3403               	.LBB118:
 3404               	.LBB119:
 3405               		.file 4 "c:\\winavr-20100110\\avr\\include\\util\\delay_basic.h"
   1:c:\winavr-20100110\avr\include\util\delay_basic.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:c:\winavr-20100110\avr\include\util\delay_basic.h ****    Copyright (c) 2007 Joerg Wunsch
   3:c:\winavr-20100110\avr\include\util\delay_basic.h ****    All rights reserved.
   4:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
   5:c:\winavr-20100110\avr\include\util\delay_basic.h ****    Redistribution and use in source and binary forms, with or without
   6:c:\winavr-20100110\avr\include\util\delay_basic.h ****    modification, are permitted provided that the following conditions are met:
   7:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
   8:c:\winavr-20100110\avr\include\util\delay_basic.h ****    * Redistributions of source code must retain the above copyright
   9:c:\winavr-20100110\avr\include\util\delay_basic.h ****      notice, this list of conditions and the following disclaimer.
  10:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  11:c:\winavr-20100110\avr\include\util\delay_basic.h ****    * Redistributions in binary form must reproduce the above copyright
  12:c:\winavr-20100110\avr\include\util\delay_basic.h ****      notice, this list of conditions and the following disclaimer in
  13:c:\winavr-20100110\avr\include\util\delay_basic.h ****      the documentation and/or other materials provided with the
  14:c:\winavr-20100110\avr\include\util\delay_basic.h ****      distribution.
  15:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  16:c:\winavr-20100110\avr\include\util\delay_basic.h ****    * Neither the name of the copyright holders nor the names of
  17:c:\winavr-20100110\avr\include\util\delay_basic.h ****      contributors may be used to endorse or promote products derived
  18:c:\winavr-20100110\avr\include\util\delay_basic.h ****      from this software without specific prior written permission.
  19:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  20:c:\winavr-20100110\avr\include\util\delay_basic.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  21:c:\winavr-20100110\avr\include\util\delay_basic.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  22:c:\winavr-20100110\avr\include\util\delay_basic.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  23:c:\winavr-20100110\avr\include\util\delay_basic.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  24:c:\winavr-20100110\avr\include\util\delay_basic.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  25:c:\winavr-20100110\avr\include\util\delay_basic.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  26:c:\winavr-20100110\avr\include\util\delay_basic.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  27:c:\winavr-20100110\avr\include\util\delay_basic.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  28:c:\winavr-20100110\avr\include\util\delay_basic.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  29:c:\winavr-20100110\avr\include\util\delay_basic.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  30:c:\winavr-20100110\avr\include\util\delay_basic.h ****   POSSIBILITY OF SUCH DAMAGE. */
  31:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  32:c:\winavr-20100110\avr\include\util\delay_basic.h **** /* $Id$ */
  33:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  34:c:\winavr-20100110\avr\include\util\delay_basic.h **** #ifndef _UTIL_DELAY_BASIC_H_
  35:c:\winavr-20100110\avr\include\util\delay_basic.h **** #define _UTIL_DELAY_BASIC_H_ 1
  36:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  37:c:\winavr-20100110\avr\include\util\delay_basic.h **** #include <inttypes.h>
  38:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  39:c:\winavr-20100110\avr\include\util\delay_basic.h **** #if !defined(__DOXYGEN__)
  40:c:\winavr-20100110\avr\include\util\delay_basic.h **** static __inline__ void _delay_loop_1(uint8_t __count) __attribute__((__always_inline__));
  41:c:\winavr-20100110\avr\include\util\delay_basic.h **** static __inline__ void _delay_loop_2(uint16_t __count) __attribute__((__always_inline__));
  42:c:\winavr-20100110\avr\include\util\delay_basic.h **** #endif
  43:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  44:c:\winavr-20100110\avr\include\util\delay_basic.h **** /** \file */
  45:c:\winavr-20100110\avr\include\util\delay_basic.h **** /** \defgroup util_delay_basic <util/delay_basic.h>: Basic busy-wait delay loops
  46:c:\winavr-20100110\avr\include\util\delay_basic.h ****     \code
  47:c:\winavr-20100110\avr\include\util\delay_basic.h ****     #include <util/delay_basic.h>
  48:c:\winavr-20100110\avr\include\util\delay_basic.h ****     \endcode
  49:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  50:c:\winavr-20100110\avr\include\util\delay_basic.h ****     The functions in this header file implement simple delay loops
  51:c:\winavr-20100110\avr\include\util\delay_basic.h ****     that perform a busy-waiting.  They are typically used to
  52:c:\winavr-20100110\avr\include\util\delay_basic.h ****     facilitate short delays in the program execution.  They are
  53:c:\winavr-20100110\avr\include\util\delay_basic.h ****     implemented as count-down loops with a well-known CPU cycle
  54:c:\winavr-20100110\avr\include\util\delay_basic.h ****     count per loop iteration.  As such, no other processing can
  55:c:\winavr-20100110\avr\include\util\delay_basic.h ****     occur simultaneously.  It should be kept in mind that the
  56:c:\winavr-20100110\avr\include\util\delay_basic.h ****     functions described here do not disable interrupts.
  57:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  58:c:\winavr-20100110\avr\include\util\delay_basic.h ****     In general, for long delays, the use of hardware timers is
  59:c:\winavr-20100110\avr\include\util\delay_basic.h ****     much preferrable, as they free the CPU, and allow for
  60:c:\winavr-20100110\avr\include\util\delay_basic.h ****     concurrent processing of other events while the timer is
  61:c:\winavr-20100110\avr\include\util\delay_basic.h ****     running.  However, in particular for very short delays, the
  62:c:\winavr-20100110\avr\include\util\delay_basic.h ****     overhead of setting up a hardware timer is too much compared
  63:c:\winavr-20100110\avr\include\util\delay_basic.h ****     to the overall delay time.
  64:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  65:c:\winavr-20100110\avr\include\util\delay_basic.h ****     Two inline functions are provided for the actual delay algorithms.
  66:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  67:c:\winavr-20100110\avr\include\util\delay_basic.h **** */
  68:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  69:c:\winavr-20100110\avr\include\util\delay_basic.h **** /** \ingroup util_delay_basic
  70:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  71:c:\winavr-20100110\avr\include\util\delay_basic.h ****     Delay loop using an 8-bit counter \c __count, so up to 256
  72:c:\winavr-20100110\avr\include\util\delay_basic.h ****     iterations are possible.  (The value 256 would have to be passed
  73:c:\winavr-20100110\avr\include\util\delay_basic.h ****     as 0.)  The loop executes three CPU cycles per iteration, not
  74:c:\winavr-20100110\avr\include\util\delay_basic.h ****     including the overhead the compiler needs to setup the counter
  75:c:\winavr-20100110\avr\include\util\delay_basic.h ****     register.
  76:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  77:c:\winavr-20100110\avr\include\util\delay_basic.h ****     Thus, at a CPU speed of 1 MHz, delays of up to 768 microseconds
  78:c:\winavr-20100110\avr\include\util\delay_basic.h ****     can be achieved.
  79:c:\winavr-20100110\avr\include\util\delay_basic.h **** */
  80:c:\winavr-20100110\avr\include\util\delay_basic.h **** void
  81:c:\winavr-20100110\avr\include\util\delay_basic.h **** _delay_loop_1(uint8_t __count)
  82:c:\winavr-20100110\avr\include\util\delay_basic.h **** {
  83:c:\winavr-20100110\avr\include\util\delay_basic.h **** 	__asm__ volatile (
  84:c:\winavr-20100110\avr\include\util\delay_basic.h **** 		"1: dec %0" "\n\t"
  85:c:\winavr-20100110\avr\include\util\delay_basic.h **** 		"brne 1b"
  86:c:\winavr-20100110\avr\include\util\delay_basic.h **** 		: "=r" (__count)
  87:c:\winavr-20100110\avr\include\util\delay_basic.h **** 		: "0" (__count)
  88:c:\winavr-20100110\avr\include\util\delay_basic.h **** 	);
  89:c:\winavr-20100110\avr\include\util\delay_basic.h **** }
  90:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  91:c:\winavr-20100110\avr\include\util\delay_basic.h **** /** \ingroup util_delay_basic
  92:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  93:c:\winavr-20100110\avr\include\util\delay_basic.h ****     Delay loop using a 16-bit counter \c __count, so up to 65536
  94:c:\winavr-20100110\avr\include\util\delay_basic.h ****     iterations are possible.  (The value 65536 would have to be
  95:c:\winavr-20100110\avr\include\util\delay_basic.h ****     passed as 0.)  The loop executes four CPU cycles per iteration,
  96:c:\winavr-20100110\avr\include\util\delay_basic.h ****     not including the overhead the compiler requires to setup the
  97:c:\winavr-20100110\avr\include\util\delay_basic.h ****     counter register pair.
  98:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  99:c:\winavr-20100110\avr\include\util\delay_basic.h ****     Thus, at a CPU speed of 1 MHz, delays of up to about 262.1
 100:c:\winavr-20100110\avr\include\util\delay_basic.h ****     milliseconds can be achieved.
 101:c:\winavr-20100110\avr\include\util\delay_basic.h ****  */
 102:c:\winavr-20100110\avr\include\util\delay_basic.h **** void
 103:c:\winavr-20100110\avr\include\util\delay_basic.h **** _delay_loop_2(uint16_t __count)
 104:c:\winavr-20100110\avr\include\util\delay_basic.h **** {
 105:c:\winavr-20100110\avr\include\util\delay_basic.h **** 	__asm__ volatile (
 3406               		.loc 4 105 0
 3407 0650 8FEF      		ldi r24,lo8(-1)
 3408 0652 9FEF      		ldi r25,lo8(-1)
 3409               	/* #APP */
 3410               	 ;  105 "c:\winavr-20100110\avr\include\util\delay_basic.h" 1
 3411 0654 0197      		1: sbiw r24,1
 3412 0656 01F4      		brne 1b
 3413               	 ;  0 "" 2
 3414               	.LVL407:
 3415               	/* #NOAPP */
 3416 0658 00C0      		rjmp .L85
 3417               	.LBE119:
 3418               	.LBE118:
 3419               	.LBE117:
 3420               		.cfi_endproc
 3421               	.LFE42:
 3423               		.comm	flashWriteCycle,12,1
 3424               		.comm	flashWriteWePin,1,1
 3425               		.comm	flashChipIdBuffer,2,1
 3426               		.comm	eepromBuffer,8,1
 3427               		.comm	receivedChar,1,1
 3428               		.comm	receivedBuffer,129,1
 3429               		.text
 3430               	.Letext0:
 3431               		.file 5 "c:\\winavr-20100110\\avr\\include\\stdint.h"
 3432               		.file 6 "c:\\winavr-20100110\\avr\\include\\stdlib.h"
DEFINED SYMBOLS
                            *ABS*:00000000 main.c
C:\Users\Alex\AppData\Local\Temp\ccfKGI7f.s:2      *ABS*:0000003e __SP_H__
C:\Users\Alex\AppData\Local\Temp\ccfKGI7f.s:3      *ABS*:0000003d __SP_L__
C:\Users\Alex\AppData\Local\Temp\ccfKGI7f.s:4      *ABS*:0000003f __SREG__
C:\Users\Alex\AppData\Local\Temp\ccfKGI7f.s:5      *ABS*:00000000 __tmp_reg__
C:\Users\Alex\AppData\Local\Temp\ccfKGI7f.s:6      *ABS*:00000001 __zero_reg__
C:\Users\Alex\AppData\Local\Temp\ccfKGI7f.s:12     .text:00000000 USART_Receive
C:\Users\Alex\AppData\Local\Temp\ccfKGI7f.s:34     .text:00000008 USART_Transmit
C:\Users\Alex\AppData\Local\Temp\ccfKGI7f.s:55     .text:00000010 usart_read_bytes
                            *COM*:00000081 receivedBuffer
C:\Users\Alex\AppData\Local\Temp\ccfKGI7f.s:118    .text:0000003a usart_read_chars
C:\Users\Alex\AppData\Local\Temp\ccfKGI7f.s:162    .text:00000056 rd_wr_csmreq_cs2_reset
C:\Users\Alex\AppData\Local\Temp\ccfKGI7f.s:184    .text:00000060 gb_mode
C:\Users\Alex\AppData\Local\Temp\ccfKGI7f.s:211    .text:00000070 set_16bit_address
C:\Users\Alex\AppData\Local\Temp\ccfKGI7f.s:230    .text:00000076 read_8bit_data
C:\Users\Alex\AppData\Local\Temp\ccfKGI7f.s:270    .text:00000088 write_8bit_data
C:\Users\Alex\AppData\Local\Temp\ccfKGI7f.s:335    .text:000000b4 gba_mode
C:\Users\Alex\AppData\Local\Temp\ccfKGI7f.s:362    .text:000000c4 gba_set_24bit_address
C:\Users\Alex\AppData\Local\Temp\ccfKGI7f.s:415    .text:000000f0 gba_read_16bit_data
C:\Users\Alex\AppData\Local\Temp\ccfKGI7f.s:463    .text:0000010e gba_read_ram_8bit_data
C:\Users\Alex\AppData\Local\Temp\ccfKGI7f.s:503    .text:00000120 gba_write_ram_8bit_data
C:\Users\Alex\AppData\Local\Temp\ccfKGI7f.s:557    .text:00000140 gba_eeprom_mode
C:\Users\Alex\AppData\Local\Temp\ccfKGI7f.s:585    .text:00000152 gba_eeprom_set_address
C:\Users\Alex\AppData\Local\Temp\ccfKGI7f.s:724    .text:000001ba gba_eeprom_read
                            *COM*:00000008 eepromBuffer
C:\Users\Alex\AppData\Local\Temp\ccfKGI7f.s:856    .text:00000214 gba_eeprom_write
C:\Users\Alex\AppData\Local\Temp\ccfKGI7f.s:972    .text:00000268 flash_write_bus_cycle
C:\Users\Alex\AppData\Local\Temp\ccfKGI7f.s:1018   .text:00000282 flash_read_chip_id
                            *COM*:00000002 flashChipIdBuffer
C:\Users\Alex\AppData\Local\Temp\ccfKGI7f.s:1123   .text:000002ec flash_switch_bank
C:\Users\Alex\AppData\Local\Temp\ccfKGI7f.s:1172   .text:00000312 flash_erase_4k_sector
C:\Users\Alex\AppData\Local\Temp\ccfKGI7f.s:1247   .text:0000035a flash_write_byte
C:\Users\Alex\AppData\Local\Temp\ccfKGI7f.s:1318   .text:00000392 flash_write_sector
C:\Users\Alex\AppData\Local\Temp\ccfKGI7f.s:1431   .text:000003fe gb_flash_read_byte
C:\Users\Alex\AppData\Local\Temp\ccfKGI7f.s:1471   .text:00000410 gb_flash_write_bus_cycle
                            *COM*:00000001 flashWriteWePin
C:\Users\Alex\AppData\Local\Temp\ccfKGI7f.s:1552   .text:0000043e gb_flash_write_byte
                            *COM*:0000000c flashWriteCycle
C:\Users\Alex\AppData\Local\Temp\ccfKGI7f.s:1652   .text:000004a2 gba_flash_write_bus_cycle
C:\Users\Alex\AppData\Local\Temp\ccfKGI7f.s:1715   .text:000004c8 gba_flash_write_byte_swapped
C:\Users\Alex\AppData\Local\Temp\ccfKGI7f.s:1839   .text:0000053e setup
C:\Users\Alex\AppData\Local\Temp\ccfKGI7f.s:1934   .text.startup:00000000 main
                            *COM*:00000001 receivedChar

UNDEFINED SYMBOLS
strtol
atoi
__do_clear_bss
