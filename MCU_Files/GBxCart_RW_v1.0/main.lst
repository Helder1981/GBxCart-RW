   1               		.file	"main.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               	.global	USART_Receive
  12               	USART_Receive:
  13               	.LFB10:
  14               		.file 1 "setup.c"
   1:setup.c       **** /*
   2:setup.c       ****  GBxCart RW
   3:setup.c       ****  Version: 1.0
   4:setup.c       ****  Author: Alex from insideGadgets (www.insidegadgets.com)
   5:setup.c       ****  Created: 7/11/2016
   6:setup.c       ****  Last Modified: 11/03/2017
   7:setup.c       **** 
   8:setup.c       ****  */
   9:setup.c       ****  
  10:setup.c       **** #ifndef cbi
  11:setup.c       **** #define cbi(sfr, bit) (_SFR_BYTE(sfr) &= ~_BV(bit))
  12:setup.c       **** #endif
  13:setup.c       **** #ifndef sbi
  14:setup.c       **** #define sbi(sfr, bit) (_SFR_BYTE(sfr) |= _BV(bit))
  15:setup.c       **** #endif
  16:setup.c       **** 
  17:setup.c       **** #ifndef NULL
  18:setup.c       **** #define NULL ((void *)0)
  19:setup.c       **** #endif
  20:setup.c       **** 
  21:setup.c       **** #define LOW 0
  22:setup.c       **** #define HIGH 1
  23:setup.c       **** #define false 0
  24:setup.c       **** #define true 1
  25:setup.c       **** 
  26:setup.c       **** #define SWITCH_DETECT PD2
  27:setup.c       **** #define LED PD3
  28:setup.c       **** #define WR_PIN PD4
  29:setup.c       **** #define RD_PIN PD5
  30:setup.c       **** #define CS_MREQ_PIN PD6
  31:setup.c       **** #define CS2_PIN PD7
  32:setup.c       **** 
  33:setup.c       **** #define wrPin_high	PORTD |= (1<<WR_PIN);
  34:setup.c       **** #define wrPin_low		PORTD &= ~(1<<WR_PIN);
  35:setup.c       **** #define rdPin_high	PORTD |= (1<<RD_PIN);
  36:setup.c       **** #define rdPin_low		PORTD &= ~(1<<RD_PIN);
  37:setup.c       **** #define cs_mreqPin_high		PORTD |= (1<<CS_MREQ_PIN);
  38:setup.c       **** #define cs_mreqPin_low		PORTD &= ~(1<<CS_MREQ_PIN);
  39:setup.c       **** #define cs2Pin_high		PORTD |= (1<<CS2_PIN);
  40:setup.c       **** #define cs2Pin_low		PORTD &= ~(1<<CS2_PIN);
  41:setup.c       **** 
  42:setup.c       **** #define GB_MODE 1
  43:setup.c       **** #define GBA_MODE 2
  44:setup.c       **** 
  45:setup.c       **** // GB/GBC
  46:setup.c       **** #define PORT_ADDR7_0 PORTB
  47:setup.c       **** #define PORT_ADDR15_8 PORTA
  48:setup.c       **** #define PORT_DATA7_0 PORTC
  49:setup.c       **** 
  50:setup.c       **** #define DDR_ADDR7_0 DDRB
  51:setup.c       **** #define DDR_ADDR15_8 DDRA
  52:setup.c       **** #define DDR_DATA7_0 DDRC
  53:setup.c       **** 
  54:setup.c       **** #define PIN_ADDR7_0 PINB
  55:setup.c       **** #define PIN_ADDR15_8 PINA
  56:setup.c       **** #define PIN_DATA7_0 PINC
  57:setup.c       **** 
  58:setup.c       **** #define BANK_WRITE 0
  59:setup.c       **** #define MEMORY_WRITE 1
  60:setup.c       **** 
  61:setup.c       **** // GBA
  62:setup.c       **** #define EEPROM_WRITE 1
  63:setup.c       **** #define EEPROM_READ 0
  64:setup.c       **** #define EEPROM_NONE 0
  65:setup.c       **** #define EEPROM_4KBIT 1
  66:setup.c       **** #define EEPROM_64KBIT 2
  67:setup.c       **** 
  68:setup.c       **** #define AD0 PB0
  69:setup.c       **** #define ad0Pin_high		PORTB |= (1<<AD0);
  70:setup.c       **** #define ad0Pin_low		PORTB &= ~(1<<AD0);
  71:setup.c       **** 
  72:setup.c       **** #define A23 PC7
  73:setup.c       **** #define a23Pin_high		PORTC |= (1<<A23);
  74:setup.c       **** #define a23Pin_low		PORTC &= ~(1<<A23);
  75:setup.c       **** 
  76:setup.c       **** #define GBA_DDR_ROM_ADDR7_0 DDRB
  77:setup.c       **** #define GBA_DDR_ROM_ADDR15_8 DDRA
  78:setup.c       **** #define GBA_DDR_ROM_ADDR23_16 DDRC
  79:setup.c       **** #define GBA_DDR_ROM_DATA7_0 DDRB
  80:setup.c       **** #define GBA_DDR_ROM_DATA15_8 DDRA
  81:setup.c       **** #define GBA_DDR_RAM_DATA7_0 DDRC
  82:setup.c       **** #define GBA_DDR_EEPROM_DATA7_0 DDRB
  83:setup.c       **** 
  84:setup.c       **** #define GBA_PORT_ROM_ADDR7_0 PORTB
  85:setup.c       **** #define GBA_PORT_ROM_ADDR15_8 PORTA
  86:setup.c       **** #define GBA_PORT_ROM_ADDR23_16 PORTC
  87:setup.c       **** #define GBA_PORT_ROM_DATA7_0 PORTB
  88:setup.c       **** #define GBA_PORT_ROM_DATA15_8 PORTA
  89:setup.c       **** #define GBA_PORT_RAM_DATA7_0 PORTC
  90:setup.c       **** #define GBA_PORT_EEPROM_DATA7_0 PORTB
  91:setup.c       **** 
  92:setup.c       **** #define GBA_PIN_ROM_DATA7_0 PINB
  93:setup.c       **** #define GBA_PIN_ROM_DATA15_8 PINA
  94:setup.c       **** #define GBA_PIN_RAM_DATA7_0 PINC
  95:setup.c       **** #define GBA_PIN_EEPROM_DATA7_0 PINB
  96:setup.c       **** 
  97:setup.c       **** // GB/GBC commands
  98:setup.c       **** #define SET_START_ADDRESS 'A'
  99:setup.c       **** #define READ_ROM_RAM 'R'
 100:setup.c       **** #define WRITE_RAM 'W'
 101:setup.c       **** #define SET_BANK 'B'
 102:setup.c       **** #define GB_CART_MODE 'G'
 103:setup.c       **** 
 104:setup.c       **** // GBA commands
 105:setup.c       **** #define GBA_READ_ROM 'r'
 106:setup.c       **** #define GBA_READ_SRAM 'm'
 107:setup.c       **** #define GBA_WRITE_SRAM 'w'
 108:setup.c       **** #define GBA_WRITE_ONE_BYTE_SRAM 'o'
 109:setup.c       **** #define GBA_CART_MODE 'g'
 110:setup.c       **** 
 111:setup.c       **** #define GBA_FLASH_READ_ID 'i'
 112:setup.c       **** #define GBA_FLASH_SET_BANK 'k'
 113:setup.c       **** #define GBA_FLASH_4K_SECTOR_ERASE 's'
 114:setup.c       **** #define GBA_FLASH_WRITE_BYTE 'b'
 115:setup.c       **** #define GBA_FLASH_WRITE_ATMEL 'a'
 116:setup.c       **** 
 117:setup.c       **** #define GBA_SET_EEPROM_SIZE 'S'
 118:setup.c       **** #define GBA_READ_EEPROM 'e'
 119:setup.c       **** #define GBA_WRITE_EEPROM 'p'
 120:setup.c       **** 
 121:setup.c       **** // General commands
 122:setup.c       **** #define CART_MODE 'C'
 123:setup.c       **** #define SET_INPUT 'I'
 124:setup.c       **** #define SET_OUTPUT 'O'
 125:setup.c       **** #define SET_OUTPUT_LOW 'L'
 126:setup.c       **** #define SET_OUTPUT_HIGH 'H'
 127:setup.c       **** #define READ_INPUT 'D'
 128:setup.c       **** #define RESET_COMMON_LINES 'M'
 129:setup.c       **** #define READ_BUILD_VERSION 'V'
 130:setup.c       **** 
 131:setup.c       **** char receivedBuffer[129];
 132:setup.c       **** char receivedChar;
 133:setup.c       **** uint8_t eepromBuffer[8];
 134:setup.c       **** uint8_t flashChipIdBuffer[2];
 135:setup.c       **** 
 136:setup.c       **** // Receive USART data
 137:setup.c       **** uint8_t USART_Receive(void) {
  15               		.loc 1 137 0
  16               		.cfi_startproc
  17               	/* prologue: function */
  18               	/* frame size = 0 */
  19               	/* stack size = 0 */
  20               	.L__stack_usage = 0
  21               	.L3:
 138:setup.c       **** 	while ( !(UCSRA & (1<<RXC)) ); // Wait for data to be received
  22               		.loc 1 138 0 discriminator 1
  23 0000 5F9B      		sbis 0xb,7
  24 0002 00C0      		rjmp .L3
 139:setup.c       **** 	return UDR; // Get and return received data from buffer
  25               		.loc 1 139 0
  26 0004 8CB1      		in r24,0xc
 140:setup.c       **** }
  27               		.loc 1 140 0
  28 0006 0895      		ret
  29               		.cfi_endproc
  30               	.LFE10:
  32               	.global	USART_Transmit
  34               	USART_Transmit:
  35               	.LFB11:
 141:setup.c       **** 
 142:setup.c       **** // Transmit USART data
 143:setup.c       **** void USART_Transmit(unsigned char data) {
  36               		.loc 1 143 0
  37               		.cfi_startproc
  38               	/* prologue: function */
  39               	/* frame size = 0 */
  40               	/* stack size = 0 */
  41               	.L__stack_usage = 0
  42               	.LVL0:
  43               	.L7:
 144:setup.c       **** 	while ( !( UCSRA & (1<<UDRE)) ); // Wait for empty transmit buffer
  44               		.loc 1 144 0 discriminator 1
  45 0008 5D9B      		sbis 0xb,5
  46 000a 00C0      		rjmp .L7
 145:setup.c       **** 	UDR = data;
  47               		.loc 1 145 0
  48 000c 8CB9      		out 0xc,r24
  49 000e 0895      		ret
  50               		.cfi_endproc
  51               	.LFE11:
  53               	.global	usart_read_bytes
  55               	usart_read_bytes:
  56               	.LFB12:
 146:setup.c       **** }
 147:setup.c       **** 
 148:setup.c       **** // Read 1-128 bytes from the USART 
 149:setup.c       **** void usart_read_bytes(uint8_t count) {
  57               		.loc 1 149 0
  58               		.cfi_startproc
  59               	.LVL1:
  60 0010 FF92      		push r15
  61               	.LCFI0:
  62               		.cfi_def_cfa_offset 3
  63               		.cfi_offset 15, -2
  64 0012 0F93      		push r16
  65               	.LCFI1:
  66               		.cfi_def_cfa_offset 4
  67               		.cfi_offset 16, -3
  68 0014 1F93      		push r17
  69               	.LCFI2:
  70               		.cfi_def_cfa_offset 5
  71               		.cfi_offset 17, -4
  72 0016 CF93      		push r28
  73               	.LCFI3:
  74               		.cfi_def_cfa_offset 6
  75               		.cfi_offset 28, -5
  76 0018 DF93      		push r29
  77               	.LCFI4:
  78               		.cfi_def_cfa_offset 7
  79               		.cfi_offset 29, -6
  80               	/* prologue: function */
  81               	/* frame size = 0 */
  82               	/* stack size = 5 */
  83               	.L__stack_usage = 5
  84 001a F82E      		mov r15,r24
  85               	.LVL2:
  86 001c 00E0      		ldi r16,lo8(receivedBuffer)
  87 001e 10E0      		ldi r17,hi8(receivedBuffer)
  88               	.LBB36:
 150:setup.c       **** 	for (uint8_t x = 0; x < count; x++) {
  89               		.loc 1 150 0
  90 0020 E801      		movw r28,r16
  91               	.LVL3:
  92               	.L9:
  93 0022 8C2F      		mov r24,r28
  94 0024 801B      		sub r24,r16
  95               		.loc 1 150 0 is_stmt 0 discriminator 1
  96 0026 8F15      		cp r24,r15
  97 0028 00F4      		brsh .L11
 151:setup.c       **** 		receivedBuffer[x] = USART_Receive();
  98               		.loc 1 151 0 is_stmt 1 discriminator 2
  99 002a 0E94 0000 		call USART_Receive
 100               	.LVL4:
 101 002e 8993      		st Y+,r24
 102               	.LVL5:
 103 0030 00C0      		rjmp .L9
 104               	.L11:
 105               	/* epilogue start */
 106               	.LBE36:
 152:setup.c       **** 	}
 153:setup.c       **** }
 107               		.loc 1 153 0
 108 0032 DF91      		pop r29
 109 0034 CF91      		pop r28
 110               	.LVL6:
 111 0036 1F91      		pop r17
 112 0038 0F91      		pop r16
 113 003a FF90      		pop r15
 114               	.LVL7:
 115 003c 0895      		ret
 116               		.cfi_endproc
 117               	.LFE12:
 119               	.global	usart_read_chars
 121               	usart_read_chars:
 122               	.LFB13:
 154:setup.c       **** 
 155:setup.c       **** // Read the USART until a 0 (string terminator byte) is received
 156:setup.c       **** void usart_read_chars(void) {
 123               		.loc 1 156 0
 124               		.cfi_startproc
 125 003e CF93      		push r28
 126               	.LCFI5:
 127               		.cfi_def_cfa_offset 3
 128               		.cfi_offset 28, -2
 129               	/* prologue: function */
 130               	/* frame size = 0 */
 131               	/* stack size = 1 */
 132               	.L__stack_usage = 1
 133               	.LVL8:
 157:setup.c       **** 	uint8_t x = 0;
 134               		.loc 1 157 0
 135 0040 C0E0      		ldi r28,0
 136               	.LVL9:
 137               	.L14:
 158:setup.c       **** 	while (1) {
 159:setup.c       **** 		receivedBuffer[x] = USART_Receive();
 138               		.loc 1 159 0
 139 0042 0E94 0000 		call USART_Receive
 140               	.LVL10:
 141 0046 EC2F      		mov r30,r28
 142 0048 F0E0      		ldi r31,0
 143 004a E050      		subi r30,lo8(-(receivedBuffer))
 144 004c F040      		sbci r31,hi8(-(receivedBuffer))
 145 004e 8083      		st Z,r24
 160:setup.c       **** 		if (receivedBuffer[x] == 0) {
 146               		.loc 1 160 0
 147 0050 8823      		tst r24
 148 0052 01F0      		breq .L12
 161:setup.c       **** 			break;
 162:setup.c       **** 		}
 163:setup.c       **** 		x++;
 149               		.loc 1 163 0
 150 0054 CF5F      		subi r28,lo8(-(1))
 151               	.LVL11:
 164:setup.c       **** 	}
 152               		.loc 1 164 0
 153 0056 00C0      		rjmp .L14
 154               	.L12:
 155               	/* epilogue start */
 165:setup.c       **** }
 156               		.loc 1 165 0
 157 0058 CF91      		pop r28
 158               	.LVL12:
 159 005a 0895      		ret
 160               		.cfi_endproc
 161               	.LFE13:
 163               	.global	rd_wr_csmreq_cs2_reset
 165               	rd_wr_csmreq_cs2_reset:
 166               	.LFB14:
 166:setup.c       **** 
 167:setup.c       **** // Turn RD, WR, CS/MREQ and CS2 to high so they are deselected (reset state)
 168:setup.c       **** void rd_wr_csmreq_cs2_reset(void) {
 167               		.loc 1 168 0
 168               		.cfi_startproc
 169               	/* prologue: function */
 170               	/* frame size = 0 */
 171               	/* stack size = 0 */
 172               	.L__stack_usage = 0
 169:setup.c       **** 	cs2Pin_high; // CS2 off
 173               		.loc 1 169 0
 174 005c 979A      		sbi 0x12,7
 170:setup.c       **** 	cs_mreqPin_high; // CS/MREQ off
 175               		.loc 1 170 0
 176 005e 969A      		sbi 0x12,6
 171:setup.c       **** 	rdPin_high; // RD off
 177               		.loc 1 171 0
 178 0060 959A      		sbi 0x12,5
 172:setup.c       **** 	wrPin_high; // WR off
 179               		.loc 1 172 0
 180 0062 949A      		sbi 0x12,4
 181 0064 0895      		ret
 182               		.cfi_endproc
 183               	.LFE14:
 185               	.global	gb_mode
 187               	gb_mode:
 188               	.LFB15:
 173:setup.c       **** }
 174:setup.c       **** 
 175:setup.c       **** 
 176:setup.c       **** 
 177:setup.c       **** // ****** Gameboy / Gameboy Colour functions ******
 178:setup.c       **** 
 179:setup.c       **** // Set Gameboy mode
 180:setup.c       **** void gb_mode(void) {
 189               		.loc 1 180 0
 190               		.cfi_startproc
 191               	/* prologue: function */
 192               	/* frame size = 0 */
 193               	/* stack size = 0 */
 194               	.L__stack_usage = 0
 181:setup.c       **** 	// Set inputs
 182:setup.c       **** 	PORT_DATA7_0 = 0;
 195               		.loc 1 182 0
 196 0066 15BA      		out 0x15,__zero_reg__
 183:setup.c       **** 	DDR_DATA7_0 = 0;
 197               		.loc 1 183 0
 198 0068 14BA      		out 0x14,__zero_reg__
 184:setup.c       **** 	
 185:setup.c       **** 	// Set outputs
 186:setup.c       **** 	PORT_ADDR7_0 = 0;
 199               		.loc 1 186 0
 200 006a 18BA      		out 0x18,__zero_reg__
 187:setup.c       **** 	PORT_ADDR15_8 = 0;
 201               		.loc 1 187 0
 202 006c 1BBA      		out 0x1b,__zero_reg__
 188:setup.c       **** 	DDR_ADDR7_0 = 0xFF;
 203               		.loc 1 188 0
 204 006e 8FEF      		ldi r24,lo8(-1)
 205 0070 87BB      		out 0x17,r24
 189:setup.c       **** 	DDR_ADDR15_8 = 0xFF;
 206               		.loc 1 189 0
 207 0072 8ABB      		out 0x1a,r24
 208 0074 0895      		ret
 209               		.cfi_endproc
 210               	.LFE15:
 212               	.global	set_16bit_address
 214               	set_16bit_address:
 215               	.LFB16:
 190:setup.c       **** }
 191:setup.c       **** 
 192:setup.c       **** // Set the 16 bit address on A15-0
 193:setup.c       **** void set_16bit_address(uint16_t address) {
 216               		.loc 1 193 0
 217               		.cfi_startproc
 218               	.LVL13:
 219               	/* prologue: function */
 220               	/* frame size = 0 */
 221               	/* stack size = 0 */
 222               	.L__stack_usage = 0
 194:setup.c       **** 	PORT_ADDR15_8 = (address >> 8);
 223               		.loc 1 194 0
 224 0076 9BBB      		out 0x1b,r25
 195:setup.c       **** 	PORT_ADDR7_0 = (address & 0xFF);
 225               		.loc 1 195 0
 226 0078 88BB      		out 0x18,r24
 227 007a 0895      		ret
 228               		.cfi_endproc
 229               	.LFE16:
 231               	.global	read_8bit_data
 233               	read_8bit_data:
 234               	.LFB17:
 196:setup.c       **** }
 197:setup.c       **** 
 198:setup.c       **** // Set the address and read a byte from the 8 bit data line
 199:setup.c       **** uint8_t read_8bit_data(uint16_t address) {
 235               		.loc 1 199 0
 236               		.cfi_startproc
 237               	.LVL14:
 238               	/* prologue: function */
 239               	/* frame size = 0 */
 240               	/* stack size = 0 */
 241               	.L__stack_usage = 0
 200:setup.c       **** 	set_16bit_address(address);
 242               		.loc 1 200 0
 243 007c 0E94 0000 		call set_16bit_address
 244               	.LVL15:
 201:setup.c       **** 	
 202:setup.c       **** 	cs_mreqPin_low;
 245               		.loc 1 202 0
 246 0080 9698      		cbi 0x12,6
 203:setup.c       **** 	rdPin_low;
 247               		.loc 1 203 0
 248 0082 9598      		cbi 0x12,5
 204:setup.c       **** 	asm volatile("nop"); // Delay a little (minimum needed is 1 nops)
 249               		.loc 1 204 0
 250               	/* #APP */
 251               	 ;  204 "setup.c" 1
 252 0084 0000      		nop
 253               	 ;  0 "" 2
 205:setup.c       **** 	uint8_t data = PIN_DATA7_0; // Read data
 254               		.loc 1 205 0
 255               	/* #NOAPP */
 256 0086 83B3      		in r24,0x13
 257               	.LVL16:
 206:setup.c       **** 	
 207:setup.c       **** 	rdPin_high;
 258               		.loc 1 207 0
 259 0088 959A      		sbi 0x12,5
 208:setup.c       **** 	cs_mreqPin_high;
 260               		.loc 1 208 0
 261 008a 969A      		sbi 0x12,6
 209:setup.c       **** 	
 210:setup.c       **** 	return data;
 211:setup.c       **** }
 262               		.loc 1 211 0
 263 008c 0895      		ret
 264               		.cfi_endproc
 265               	.LFE17:
 267               	.global	write_8bit_data
 269               	write_8bit_data:
 270               	.LFB18:
 212:setup.c       **** 
 213:setup.c       **** // Set the address and write a byte to the 8 bit data line and pulse cs/mREQ if writing to RAM
 214:setup.c       **** void write_8bit_data(uint16_t address, uint8_t data, uint8_t type) {
 271               		.loc 1 214 0
 272               		.cfi_startproc
 273               	.LVL17:
 274 008e CF93      		push r28
 275               	.LCFI6:
 276               		.cfi_def_cfa_offset 3
 277               		.cfi_offset 28, -2
 278 0090 DF93      		push r29
 279               	.LCFI7:
 280               		.cfi_def_cfa_offset 4
 281               		.cfi_offset 29, -3
 282 0092 00D0      		rcall .
 283               	.LCFI8:
 284               		.cfi_def_cfa_offset 6
 285 0094 CDB7      		in r28,__SP_L__
 286 0096 DEB7      		in r29,__SP_H__
 287               	.LCFI9:
 288               		.cfi_def_cfa_register 28
 289               	/* prologue: function */
 290               	/* frame size = 2 */
 291               	/* stack size = 4 */
 292               	.L__stack_usage = 4
 215:setup.c       **** 	set_16bit_address(address);
 293               		.loc 1 215 0
 294 0098 4A83      		std Y+2,r20
 295 009a 6983      		std Y+1,r22
 296 009c 0E94 0000 		call set_16bit_address
 297               	.LVL18:
 216:setup.c       **** 	
 217:setup.c       **** 	DDR_DATA7_0 = 0xFF; // Set data pins as outputs
 298               		.loc 1 217 0
 299 00a0 8FEF      		ldi r24,lo8(-1)
 300 00a2 84BB      		out 0x14,r24
 218:setup.c       **** 	PORT_DATA7_0 = data; // Set data
 301               		.loc 1 218 0
 302 00a4 6981      		ldd r22,Y+1
 303 00a6 65BB      		out 0x15,r22
 219:setup.c       **** 	
 220:setup.c       **** 	// Pulse WR and mREQ if the type matches
 221:setup.c       **** 	wrPin_low;
 304               		.loc 1 221 0
 305 00a8 9498      		cbi 0x12,4
 222:setup.c       **** 	if (type == MEMORY_WRITE) {
 306               		.loc 1 222 0
 307 00aa 4A81      		ldd r20,Y+2
 308 00ac 4130      		cpi r20,lo8(1)
 309 00ae 01F4      		brne .L20
 223:setup.c       **** 		cs_mreqPin_low;
 310               		.loc 1 223 0
 311 00b0 9698      		cbi 0x12,6
 312               	.L20:
 224:setup.c       **** 	}
 225:setup.c       **** 	
 226:setup.c       **** 	asm volatile("nop");
 313               		.loc 1 226 0
 314               	/* #APP */
 315               	 ;  226 "setup.c" 1
 316 00b2 0000      		nop
 317               	 ;  0 "" 2
 227:setup.c       **** 	
 228:setup.c       **** 	if (type == MEMORY_WRITE) {
 318               		.loc 1 228 0
 319               	/* #NOAPP */
 320 00b4 4130      		cpi r20,lo8(1)
 321 00b6 01F4      		brne .L21
 229:setup.c       **** 		cs_mreqPin_high;
 322               		.loc 1 229 0
 323 00b8 969A      		sbi 0x12,6
 324               	.L21:
 230:setup.c       **** 	}
 231:setup.c       **** 	wrPin_high;
 325               		.loc 1 231 0
 326 00ba 949A      		sbi 0x12,4
 232:setup.c       **** 	
 233:setup.c       **** 	// Clear data outputs and set data pins as inputs
 234:setup.c       **** 	PORT_DATA7_0 = 0;
 327               		.loc 1 234 0
 328 00bc 15BA      		out 0x15,__zero_reg__
 235:setup.c       **** 	DDR_DATA7_0 = 0;
 329               		.loc 1 235 0
 330 00be 14BA      		out 0x14,__zero_reg__
 331               	/* epilogue start */
 236:setup.c       **** }
 332               		.loc 1 236 0
 333 00c0 0F90      		pop __tmp_reg__
 334 00c2 0F90      		pop __tmp_reg__
 335 00c4 DF91      		pop r29
 336 00c6 CF91      		pop r28
 337 00c8 0895      		ret
 338               		.cfi_endproc
 339               	.LFE18:
 341               	.global	gba_mode
 343               	gba_mode:
 344               	.LFB19:
 237:setup.c       **** 
 238:setup.c       **** 
 239:setup.c       **** 
 240:setup.c       **** // ****** Gameboy Advance functions ****** 
 241:setup.c       **** 
 242:setup.c       **** // Set GBA mode
 243:setup.c       **** void gba_mode(void) {
 345               		.loc 1 243 0
 346               		.cfi_startproc
 347               	/* prologue: function */
 348               	/* frame size = 0 */
 349               	/* stack size = 0 */
 350               	.L__stack_usage = 0
 244:setup.c       **** 	// Set outputs for reading ROM addresses as default
 245:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = 0;
 351               		.loc 1 245 0
 352 00ca 18BA      		out 0x18,__zero_reg__
 246:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = 0;
 353               		.loc 1 246 0
 354 00cc 1BBA      		out 0x1b,__zero_reg__
 247:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = 0;
 355               		.loc 1 247 0
 356 00ce 15BA      		out 0x15,__zero_reg__
 248:setup.c       **** 	GBA_DDR_ROM_ADDR7_0 = 0xFF;
 357               		.loc 1 248 0
 358 00d0 8FEF      		ldi r24,lo8(-1)
 359 00d2 87BB      		out 0x17,r24
 249:setup.c       **** 	GBA_DDR_ROM_ADDR15_8 = 0xFF;
 360               		.loc 1 249 0
 361 00d4 8ABB      		out 0x1a,r24
 250:setup.c       **** 	GBA_DDR_ROM_ADDR23_16 = 0xFF;
 362               		.loc 1 250 0
 363 00d6 84BB      		out 0x14,r24
 364 00d8 0895      		ret
 365               		.cfi_endproc
 366               	.LFE19:
 368               	.global	gba_set_24bit_address
 370               	gba_set_24bit_address:
 371               	.LFB20:
 251:setup.c       **** }
 252:setup.c       **** 
 253:setup.c       **** // Set the 24 bit address on A23-0
 254:setup.c       **** void gba_set_24bit_address(uint32_t address) {	
 372               		.loc 1 254 0
 373               		.cfi_startproc
 374               	.LVL19:
 375 00da 0F93      		push r16
 376               	.LCFI10:
 377               		.cfi_def_cfa_offset 3
 378               		.cfi_offset 16, -2
 379 00dc 1F93      		push r17
 380               	.LCFI11:
 381               		.cfi_def_cfa_offset 4
 382               		.cfi_offset 17, -3
 383               	/* prologue: function */
 384               	/* frame size = 0 */
 385               	/* stack size = 2 */
 386               	.L__stack_usage = 2
 255:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = 0; // Set 0-23 address lines low and set as outputs
 387               		.loc 1 255 0
 388 00de 15BA      		out 0x15,__zero_reg__
 256:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = 0;
 389               		.loc 1 256 0
 390 00e0 1BBA      		out 0x1b,__zero_reg__
 257:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = 0;
 391               		.loc 1 257 0
 392 00e2 18BA      		out 0x18,__zero_reg__
 258:setup.c       **** 	GBA_DDR_ROM_ADDR23_16 = 0xFF;
 393               		.loc 1 258 0
 394 00e4 2FEF      		ldi r18,lo8(-1)
 395 00e6 24BB      		out 0x14,r18
 259:setup.c       **** 	GBA_DDR_ROM_ADDR15_8 = 0xFF;
 396               		.loc 1 259 0
 397 00e8 2ABB      		out 0x1a,r18
 260:setup.c       **** 	GBA_DDR_ROM_ADDR7_0 = 0xFF;
 398               		.loc 1 260 0
 399 00ea 27BB      		out 0x17,r18
 261:setup.c       **** 	
 262:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = (address >> 16);
 400               		.loc 1 262 0
 401 00ec 8C01      		movw r16,r24
 402 00ee 2227      		clr r18
 403 00f0 3327      		clr r19
 404 00f2 05BB      		out 0x15,r16
 263:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = (address >> 8);
 405               		.loc 1 263 0
 406 00f4 072F      		mov r16,r23
 407 00f6 182F      		mov r17,r24
 408 00f8 292F      		mov r18,r25
 409 00fa 3327      		clr r19
 410 00fc 0BBB      		out 0x1b,r16
 264:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = (address & 0xFF);
 411               		.loc 1 264 0
 412 00fe 68BB      		out 0x18,r22
 413               	/* epilogue start */
 265:setup.c       **** }
 414               		.loc 1 265 0
 415 0100 1F91      		pop r17
 416 0102 0F91      		pop r16
 417 0104 0895      		ret
 418               		.cfi_endproc
 419               	.LFE20:
 421               	.global	gba_read_16bit_data
 423               	gba_read_16bit_data:
 424               	.LFB21:
 266:setup.c       **** 
 267:setup.c       **** 
 268:setup.c       **** 
 269:setup.c       **** // ---------- ROM/SRAM ----------
 270:setup.c       **** 
 271:setup.c       **** // Read a byte from the 16 bit data line non-sequentially
 272:setup.c       **** uint16_t gba_read_16bit_data(uint32_t address) {
 425               		.loc 1 272 0
 426               		.cfi_startproc
 427               	.LVL20:
 428               	/* prologue: function */
 429               	/* frame size = 0 */
 430               	/* stack size = 0 */
 431               	.L__stack_usage = 0
 273:setup.c       **** 	gba_set_24bit_address(address);
 432               		.loc 1 273 0
 433 0106 0E94 0000 		call gba_set_24bit_address
 434               	.LVL21:
 274:setup.c       **** 	
 275:setup.c       **** 	cs_mreqPin_low;
 435               		.loc 1 275 0
 436 010a 9698      		cbi 0x12,6
 276:setup.c       **** 	
 277:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = 0; // Set address lines low and set as inputs
 437               		.loc 1 277 0
 438 010c 1BBA      		out 0x1b,__zero_reg__
 278:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = 0;
 439               		.loc 1 278 0
 440 010e 18BA      		out 0x18,__zero_reg__
 279:setup.c       **** 	GBA_DDR_ROM_ADDR15_8 = 0;
 441               		.loc 1 279 0
 442 0110 1ABA      		out 0x1a,__zero_reg__
 280:setup.c       **** 	GBA_DDR_ROM_ADDR7_0 = 0;
 443               		.loc 1 280 0
 444 0112 17BA      		out 0x17,__zero_reg__
 281:setup.c       **** 	
 282:setup.c       **** 	rdPin_low;
 445               		.loc 1 282 0
 446 0114 9598      		cbi 0x12,5
 283:setup.c       **** 	asm volatile("nop");
 447               		.loc 1 283 0
 448               	/* #APP */
 449               	 ;  283 "setup.c" 1
 450 0116 0000      		nop
 451               	 ;  0 "" 2
 284:setup.c       **** 	
 285:setup.c       **** 	uint16_t data = (GBA_PIN_ROM_DATA15_8 << 8) | GBA_PIN_ROM_DATA7_0; // Read data
 452               		.loc 1 285 0
 453               	/* #NOAPP */
 454 0118 29B3      		in r18,0x19
 455 011a 86B3      		in r24,0x16
 456               	.LVL22:
 286:setup.c       **** 	
 287:setup.c       **** 	rdPin_high;
 457               		.loc 1 287 0
 458 011c 959A      		sbi 0x12,5
 288:setup.c       **** 	cs_mreqPin_high;
 459               		.loc 1 288 0
 460 011e 969A      		sbi 0x12,6
 285:setup.c       **** 	
 461               		.loc 1 285 0
 462 0120 90E0      		ldi r25,0
 289:setup.c       **** 	
 290:setup.c       **** 	return data;
 291:setup.c       **** }
 463               		.loc 1 291 0
 464 0122 922B      		or r25,r18
 465 0124 0895      		ret
 466               		.cfi_endproc
 467               	.LFE21:
 469               	.global	gba_read_ram_8bit_data
 471               	gba_read_ram_8bit_data:
 472               	.LFB22:
 292:setup.c       **** 
 293:setup.c       **** // Set the address and read a byte from the 8 bit data line
 294:setup.c       **** uint8_t gba_read_ram_8bit_data(uint16_t address) {
 473               		.loc 1 294 0
 474               		.cfi_startproc
 475               	.LVL23:
 476               	/* prologue: function */
 477               	/* frame size = 0 */
 478               	/* stack size = 0 */
 479               	.L__stack_usage = 0
 295:setup.c       **** 	set_16bit_address(address);
 480               		.loc 1 295 0
 481 0126 0E94 0000 		call set_16bit_address
 482               	.LVL24:
 296:setup.c       **** 	
 297:setup.c       **** 	rdPin_low;
 483               		.loc 1 297 0
 484 012a 9598      		cbi 0x12,5
 298:setup.c       **** 	cs2Pin_low; // CS2 pin low for SRAM/Flash select
 485               		.loc 1 298 0
 486 012c 9798      		cbi 0x12,7
 299:setup.c       **** 	
 300:setup.c       **** 	asm volatile("nop"); // Delay a little (minimum needed is 2)
 487               		.loc 1 300 0
 488               	/* #APP */
 489               	 ;  300 "setup.c" 1
 490 012e 0000      		nop
 491               	 ;  0 "" 2
 301:setup.c       **** 	asm volatile("nop");
 492               		.loc 1 301 0
 493               	 ;  301 "setup.c" 1
 494 0130 0000      		nop
 495               	 ;  0 "" 2
 302:setup.c       **** 	uint8_t data = GBA_PIN_RAM_DATA7_0; // Read data
 496               		.loc 1 302 0
 497               	/* #NOAPP */
 498 0132 83B3      		in r24,0x13
 499               	.LVL25:
 303:setup.c       **** 	
 304:setup.c       **** 	cs2Pin_high;
 500               		.loc 1 304 0
 501 0134 979A      		sbi 0x12,7
 305:setup.c       **** 	rdPin_high;
 502               		.loc 1 305 0
 503 0136 959A      		sbi 0x12,5
 306:setup.c       **** 	
 307:setup.c       **** 	return data;
 308:setup.c       **** }
 504               		.loc 1 308 0
 505 0138 0895      		ret
 506               		.cfi_endproc
 507               	.LFE22:
 509               	.global	gba_write_ram_8bit_data
 511               	gba_write_ram_8bit_data:
 512               	.LFB23:
 309:setup.c       **** 
 310:setup.c       **** // Set the address and write a byte to the 8 bit data line 
 311:setup.c       **** void gba_write_ram_8bit_data(uint16_t address, uint8_t data) {
 513               		.loc 1 311 0
 514               		.cfi_startproc
 515               	.LVL26:
 516 013a CF93      		push r28
 517               	.LCFI12:
 518               		.cfi_def_cfa_offset 3
 519               		.cfi_offset 28, -2
 520 013c DF93      		push r29
 521               	.LCFI13:
 522               		.cfi_def_cfa_offset 4
 523               		.cfi_offset 29, -3
 524 013e 1F92      		push __zero_reg__
 525               	.LCFI14:
 526               		.cfi_def_cfa_offset 5
 527 0140 CDB7      		in r28,__SP_L__
 528 0142 DEB7      		in r29,__SP_H__
 529               	.LCFI15:
 530               		.cfi_def_cfa_register 28
 531               	/* prologue: function */
 532               	/* frame size = 1 */
 533               	/* stack size = 3 */
 534               	.L__stack_usage = 3
 312:setup.c       **** 	set_16bit_address(address);
 535               		.loc 1 312 0
 536 0144 6983      		std Y+1,r22
 537 0146 0E94 0000 		call set_16bit_address
 538               	.LVL27:
 313:setup.c       **** 	
 314:setup.c       **** 	GBA_DDR_RAM_DATA7_0 = 0xFF; // Set data pins as outputs
 539               		.loc 1 314 0
 540 014a 8FEF      		ldi r24,lo8(-1)
 541 014c 84BB      		out 0x14,r24
 315:setup.c       **** 	GBA_PORT_RAM_DATA7_0 = data; // Set data
 542               		.loc 1 315 0
 543 014e 6981      		ldd r22,Y+1
 544 0150 65BB      		out 0x15,r22
 316:setup.c       **** 	
 317:setup.c       **** 	// Pulse WR
 318:setup.c       **** 	wrPin_low;
 545               		.loc 1 318 0
 546 0152 9498      		cbi 0x12,4
 319:setup.c       **** 	cs2Pin_low; // CS2 pin low for SRAM/Flash select
 547               		.loc 1 319 0
 548 0154 9798      		cbi 0x12,7
 320:setup.c       **** 	
 321:setup.c       **** 	asm volatile("nop");
 549               		.loc 1 321 0
 550               	/* #APP */
 551               	 ;  321 "setup.c" 1
 552 0156 0000      		nop
 553               	 ;  0 "" 2
 322:setup.c       **** 	asm volatile("nop");
 554               		.loc 1 322 0
 555               	 ;  322 "setup.c" 1
 556 0158 0000      		nop
 557               	 ;  0 "" 2
 323:setup.c       **** 	
 324:setup.c       **** 	cs2Pin_high;
 558               		.loc 1 324 0
 559               	/* #NOAPP */
 560 015a 979A      		sbi 0x12,7
 325:setup.c       **** 	wrPin_high;
 561               		.loc 1 325 0
 562 015c 949A      		sbi 0x12,4
 326:setup.c       **** 	
 327:setup.c       **** 	// Clear data outputs and set data pins as inputs
 328:setup.c       **** 	GBA_PORT_RAM_DATA7_0 = 0;
 563               		.loc 1 328 0
 564 015e 15BA      		out 0x15,__zero_reg__
 329:setup.c       **** 	GBA_DDR_RAM_DATA7_0 = 0;
 565               		.loc 1 329 0
 566 0160 14BA      		out 0x14,__zero_reg__
 567               	/* epilogue start */
 330:setup.c       **** }
 568               		.loc 1 330 0
 569 0162 0F90      		pop __tmp_reg__
 570 0164 DF91      		pop r29
 571 0166 CF91      		pop r28
 572 0168 0895      		ret
 573               		.cfi_endproc
 574               	.LFE23:
 576               	.global	gba_eeprom_mode
 578               	gba_eeprom_mode:
 579               	.LFB24:
 331:setup.c       **** 
 332:setup.c       **** 
 333:setup.c       **** 
 334:setup.c       **** // ---------- EEPROM ----------
 335:setup.c       **** 
 336:setup.c       **** // Set address/data all high (includes AD0/A23)
 337:setup.c       **** void gba_eeprom_mode (void) {
 580               		.loc 1 337 0
 581               		.cfi_startproc
 582               	/* prologue: function */
 583               	/* frame size = 0 */
 584               	/* stack size = 0 */
 585               	.L__stack_usage = 0
 338:setup.c       **** 	GBA_DDR_ROM_ADDR7_0 = 0xFF;
 586               		.loc 1 338 0
 587 016a 8FEF      		ldi r24,lo8(-1)
 588 016c 87BB      		out 0x17,r24
 339:setup.c       **** 	GBA_DDR_ROM_ADDR15_8 = 0xFF;
 589               		.loc 1 339 0
 590 016e 8ABB      		out 0x1a,r24
 340:setup.c       **** 	GBA_DDR_ROM_ADDR23_16 = 0xFF;
 591               		.loc 1 340 0
 592 0170 84BB      		out 0x14,r24
 341:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = 0xFF;
 593               		.loc 1 341 0
 594 0172 88BB      		out 0x18,r24
 342:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = 0xFF;
 595               		.loc 1 342 0
 596 0174 8BBB      		out 0x1b,r24
 343:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = 0xFF;
 597               		.loc 1 343 0
 598 0176 85BB      		out 0x15,r24
 599 0178 0895      		ret
 600               		.cfi_endproc
 601               	.LFE24:
 603               	.global	gba_eeprom_set_address
 605               	gba_eeprom_set_address:
 606               	.LFB25:
 344:setup.c       **** }
 345:setup.c       **** 
 346:setup.c       **** // Send out EEPROM address serially (WR clock, AD0 data out)
 347:setup.c       **** void gba_eeprom_set_address(uint16_t address, uint8_t eepromSize, uint8_t command) {
 607               		.loc 1 347 0
 608               		.cfi_startproc
 609               	.LVL28:
 610               	/* prologue: function */
 611               	/* frame size = 0 */
 612               	/* stack size = 0 */
 613               	.L__stack_usage = 0
 348:setup.c       **** 	cs_mreqPin_low;
 614               		.loc 1 348 0
 615 017a 9698      		cbi 0x12,6
 616               	.LVL29:
 349:setup.c       **** 	
 350:setup.c       **** 	int8_t x = 0;
 351:setup.c       **** 	if (eepromSize == EEPROM_64KBIT) {
 617               		.loc 1 351 0
 618 017c 6230      		cpi r22,lo8(2)
 619 017e 01F4      		brne .L29
 352:setup.c       **** 		if (command == EEPROM_READ) {
 620               		.loc 1 352 0
 621 0180 4111      		cpse r20,__zero_reg__
 622 0182 00C0      		rjmp .L30
 353:setup.c       **** 			address |= (1<<15) | (1<<14); // Set upper 2 bits high for read request
 623               		.loc 1 353 0
 624 0184 906C      		ori r25,192
 625               	.LVL30:
 626               	.L39:
 354:setup.c       **** 		}
 355:setup.c       **** 		else {
 356:setup.c       **** 			address |= (1<<15); // Set upper 1 bit high for write request
 357:setup.c       **** 		}
 358:setup.c       **** 		x = 15;
 627               		.loc 1 358 0
 628 0186 5FE0      		ldi r21,lo8(15)
 629               	.L32:
 630               	.LVL31:
 359:setup.c       **** 	}
 360:setup.c       **** 	else {
 361:setup.c       **** 		if (command == EEPROM_READ) {
 362:setup.c       **** 			address |= (1<<7) | (1<<6);
 363:setup.c       **** 		}
 364:setup.c       **** 		else {
 365:setup.c       **** 			address |= (1<<7);
 366:setup.c       **** 		}
 367:setup.c       **** 		x = 7;
 368:setup.c       **** 	}
 369:setup.c       **** 	
 370:setup.c       **** 	// Loop through address, 8 or 16 bits depending on EEPROM (includes the 2 bits for request type)
 371:setup.c       **** 	while (x >= 0) {
 372:setup.c       **** 		if (address & (1<<x)) {
 631               		.loc 1 372 0 discriminator 1
 632 0188 61E0      		ldi r22,lo8(1)
 633 018a 70E0      		ldi r23,0
 634               	.LVL32:
 635 018c 00C0      		rjmp .L31
 636               	.LVL33:
 637               	.L30:
 356:setup.c       **** 		}
 638               		.loc 1 356 0
 639 018e 9068      		ori r25,128
 640               	.LVL34:
 641 0190 00C0      		rjmp .L39
 642               	.L29:
 361:setup.c       **** 			address |= (1<<7) | (1<<6);
 643               		.loc 1 361 0
 644 0192 4111      		cpse r20,__zero_reg__
 645 0194 00C0      		rjmp .L33
 362:setup.c       **** 		}
 646               		.loc 1 362 0
 647 0196 806C      		ori r24,192
 648               	.LVL35:
 649 0198 00C0      		rjmp .L38
 650               	.L33:
 365:setup.c       **** 		}
 651               		.loc 1 365 0
 652 019a 8068      		ori r24,128
 653               	.LVL36:
 654               	.L38:
 367:setup.c       **** 	}
 655               		.loc 1 367 0
 656 019c 57E0      		ldi r21,lo8(7)
 657 019e 00C0      		rjmp .L32
 658               	.LVL37:
 659               	.L34:
 373:setup.c       **** 			ad0Pin_high;
 374:setup.c       **** 		}
 375:setup.c       **** 		else {
 376:setup.c       **** 			ad0Pin_low;
 660               		.loc 1 376 0
 661 01a0 C098      		cbi 0x18,0
 662               	.L35:
 377:setup.c       **** 		}
 378:setup.c       **** 		
 379:setup.c       **** 		wrPin_low; // CLK
 663               		.loc 1 379 0
 664 01a2 9498      		cbi 0x12,4
 380:setup.c       **** 		asm ("nop");
 665               		.loc 1 380 0
 666               	/* #APP */
 667               	 ;  380 "setup.c" 1
 668 01a4 0000      		nop
 669               	 ;  0 "" 2
 381:setup.c       **** 		asm ("nop");
 670               		.loc 1 381 0
 671               	 ;  381 "setup.c" 1
 672 01a6 0000      		nop
 673               	 ;  0 "" 2
 382:setup.c       **** 		wrPin_high; 
 674               		.loc 1 382 0
 675               	/* #NOAPP */
 676 01a8 949A      		sbi 0x12,4
 383:setup.c       **** 		asm ("nop");
 677               		.loc 1 383 0
 678               	/* #APP */
 679               	 ;  383 "setup.c" 1
 680 01aa 0000      		nop
 681               	 ;  0 "" 2
 384:setup.c       **** 		asm ("nop");
 682               		.loc 1 384 0
 683               	 ;  384 "setup.c" 1
 684 01ac 0000      		nop
 685               	 ;  0 "" 2
 686               	/* #NOAPP */
 687 01ae 5150      		subi r21,lo8(-(-1))
 688               	.LVL38:
 371:setup.c       **** 		if (address & (1<<x)) {
 689               		.loc 1 371 0
 690 01b0 57FD      		sbrc r21,7
 691 01b2 00C0      		rjmp .L40
 692               	.L31:
 372:setup.c       **** 			ad0Pin_high;
 693               		.loc 1 372 0
 694 01b4 9B01      		movw r18,r22
 695 01b6 052E      		mov r0,r21
 696 01b8 00C0      		rjmp 2f
 697               		1:
 698 01ba 220F      		lsl r18
 699 01bc 331F      		rol r19
 700               		2:
 701 01be 0A94      		dec r0
 702 01c0 02F4      		brpl 1b
 703 01c2 2823      		and r18,r24
 704 01c4 3923      		and r19,r25
 705 01c6 232B      		or r18,r19
 706 01c8 01F0      		breq .L34
 373:setup.c       **** 		}
 707               		.loc 1 373 0
 708 01ca C09A      		sbi 0x18,0
 709 01cc 00C0      		rjmp .L35
 710               	.L40:
 385:setup.c       **** 		
 386:setup.c       **** 		x--;
 387:setup.c       **** 	}
 388:setup.c       **** 	
 389:setup.c       **** 	// Only send stop bit (0) and WR/CS high if reading, as writing is done in 1 continuous chunk
 390:setup.c       **** 	if (command == EEPROM_READ) {  
 711               		.loc 1 390 0
 712 01ce 4111      		cpse r20,__zero_reg__
 713 01d0 00C0      		rjmp .L28
 391:setup.c       **** 		ad0Pin_low;
 714               		.loc 1 391 0
 715 01d2 C098      		cbi 0x18,0
 392:setup.c       **** 		asm ("nop");
 716               		.loc 1 392 0
 717               	/* #APP */
 718               	 ;  392 "setup.c" 1
 719 01d4 0000      		nop
 720               	 ;  0 "" 2
 393:setup.c       **** 		wrPin_low;
 721               		.loc 1 393 0
 722               	/* #NOAPP */
 723 01d6 9498      		cbi 0x12,4
 394:setup.c       **** 		asm ("nop");
 724               		.loc 1 394 0
 725               	/* #APP */
 726               	 ;  394 "setup.c" 1
 727 01d8 0000      		nop
 728               	 ;  0 "" 2
 395:setup.c       **** 		asm ("nop");
 729               		.loc 1 395 0
 730               	 ;  395 "setup.c" 1
 731 01da 0000      		nop
 732               	 ;  0 "" 2
 396:setup.c       **** 		
 397:setup.c       **** 		wrPin_high;
 733               		.loc 1 397 0
 734               	/* #NOAPP */
 735 01dc 949A      		sbi 0x12,4
 398:setup.c       **** 		cs_mreqPin_high;
 736               		.loc 1 398 0
 737 01de 969A      		sbi 0x12,6
 738               	.L28:
 739 01e0 0895      		ret
 740               		.cfi_endproc
 741               	.LFE25:
 743               	.global	gba_eeprom_read
 745               	gba_eeprom_read:
 746               	.LFB26:
 399:setup.c       **** 	}
 400:setup.c       **** }
 401:setup.c       **** 
 402:setup.c       **** // Read 8 bytes from the EEPROM address, data is valid on rising edge
 403:setup.c       **** void gba_eeprom_read(uint16_t address, uint8_t eepromSize) {
 747               		.loc 1 403 0
 748               		.cfi_startproc
 749               	.LVL39:
 750               	/* prologue: function */
 751               	/* frame size = 0 */
 752               	/* stack size = 0 */
 753               	.L__stack_usage = 0
 404:setup.c       **** 	gba_eeprom_set_address(address, eepromSize, EEPROM_READ);
 754               		.loc 1 404 0
 755 01e2 40E0      		ldi r20,0
 756 01e4 0E94 0000 		call gba_eeprom_set_address
 757               	.LVL40:
 405:setup.c       **** 	
 406:setup.c       **** 	// Set AD0 pin as input
 407:setup.c       **** 	GBA_PORT_EEPROM_DATA7_0 &= ~(1<<AD0);
 758               		.loc 1 407 0
 759 01e8 C098      		cbi 0x18,0
 408:setup.c       **** 	GBA_DDR_EEPROM_DATA7_0 &= ~(1<<AD0);
 760               		.loc 1 408 0
 761 01ea B898      		cbi 0x17,0
 409:setup.c       **** 	
 410:setup.c       **** 	cs_mreqPin_low;
 762               		.loc 1 410 0
 763 01ec 9698      		cbi 0x12,6
 764               	.LVL41:
 765 01ee 84E0      		ldi r24,lo8(4)
 766               	.LVL42:
 767               	.L44:
 768               	.LBB37:
 411:setup.c       **** 	
 412:setup.c       **** 	// Ignore first 4 bits
 413:setup.c       **** 	for (int8_t x = 0; x < 4; x++) {
 414:setup.c       **** 		rdPin_low; // CLK
 769               		.loc 1 414 0 discriminator 2
 770 01f0 9598      		cbi 0x12,5
 415:setup.c       **** 		asm ("nop");
 771               		.loc 1 415 0 discriminator 2
 772               	/* #APP */
 773               	 ;  415 "setup.c" 1
 774 01f2 0000      		nop
 775               	 ;  0 "" 2
 416:setup.c       **** 		asm ("nop");
 776               		.loc 1 416 0 discriminator 2
 777               	 ;  416 "setup.c" 1
 778 01f4 0000      		nop
 779               	 ;  0 "" 2
 417:setup.c       **** 		rdPin_high; 
 780               		.loc 1 417 0 discriminator 2
 781               	/* #NOAPP */
 782 01f6 959A      		sbi 0x12,5
 418:setup.c       **** 		asm ("nop");
 783               		.loc 1 418 0 discriminator 2
 784               	/* #APP */
 785               	 ;  418 "setup.c" 1
 786 01f8 0000      		nop
 787               	 ;  0 "" 2
 419:setup.c       **** 		asm ("nop");
 788               		.loc 1 419 0 discriminator 2
 789               	 ;  419 "setup.c" 1
 790 01fa 0000      		nop
 791               	 ;  0 "" 2
 792               	.LVL43:
 793               	/* #NOAPP */
 794 01fc 8150      		subi r24,lo8(-(-1))
 795               	.LVL44:
 413:setup.c       **** 		rdPin_low; // CLK
 796               		.loc 1 413 0 discriminator 2
 797 01fe 01F4      		brne .L44
 798 0200 E0E0      		ldi r30,lo8(eepromBuffer)
 799 0202 F0E0      		ldi r31,hi8(eepromBuffer)
 800               	.LBE37:
 801               	.LBB38:
 802               	.LBB39:
 803               	.LBB40:
 420:setup.c       **** 	}
 421:setup.c       **** 	
 422:setup.c       **** 	// Read out 64 bits
 423:setup.c       **** 	for (uint8_t c = 0; c < 8; c++) {
 424:setup.c       **** 		uint8_t data = 0;
 425:setup.c       **** 		for (int8_t x = 7; x >= 0; x--) {
 426:setup.c       **** 			rdPin_low; // CLK
 427:setup.c       **** 			asm ("nop");
 428:setup.c       **** 			asm ("nop");
 429:setup.c       **** 			rdPin_high;
 430:setup.c       **** 			
 431:setup.c       **** 			if (GBA_PIN_EEPROM_DATA7_0 & (1<<AD0)) {
 432:setup.c       **** 				data |= (1<<x);
 804               		.loc 1 432 0
 805 0204 21E0      		ldi r18,lo8(1)
 806 0206 30E0      		ldi r19,0
 807               	.LVL45:
 808               	.L43:
 809               	.LBE40:
 810               	.LBE39:
 811               	.LBE38:
 410:setup.c       **** 	
 812               		.loc 1 410 0 discriminator 1
 813 0208 87E0      		ldi r24,lo8(7)
 814 020a 90E0      		ldi r25,0
 815 020c 60E0      		ldi r22,0
 816               	.LVL46:
 817               	.L48:
 818               	.LBB43:
 819               	.LBB42:
 820               	.LBB41:
 426:setup.c       **** 			asm ("nop");
 821               		.loc 1 426 0
 822 020e 9598      		cbi 0x12,5
 427:setup.c       **** 			asm ("nop");
 823               		.loc 1 427 0
 824               	/* #APP */
 825               	 ;  427 "setup.c" 1
 826 0210 0000      		nop
 827               	 ;  0 "" 2
 428:setup.c       **** 			rdPin_high;
 828               		.loc 1 428 0
 829               	 ;  428 "setup.c" 1
 830 0212 0000      		nop
 831               	 ;  0 "" 2
 429:setup.c       **** 			
 832               		.loc 1 429 0
 833               	/* #NOAPP */
 834 0214 959A      		sbi 0x12,5
 431:setup.c       **** 				data |= (1<<x);
 835               		.loc 1 431 0
 836 0216 B09B      		sbis 0x16,0
 837 0218 00C0      		rjmp .L45
 838               		.loc 1 432 0
 839 021a A901      		movw r20,r18
 840 021c 082E      		mov r0,r24
 841 021e 00C0      		rjmp 2f
 842               		1:
 843 0220 440F      		lsl r20
 844               		2:
 845 0222 0A94      		dec r0
 846 0224 02F4      		brpl 1b
 847 0226 642B      		or r22,r20
 848               	.LVL47:
 849               	.L45:
 850               	.LVL48:
 851 0228 0197      		sbiw r24,1
 852 022a 00F4      		brcc .L48
 853               	.LBE41:
 433:setup.c       **** 			}
 434:setup.c       **** 		}
 435:setup.c       **** 		eepromBuffer[c] = data;
 854               		.loc 1 435 0
 855 022c 6193      		st Z+,r22
 856               	.LVL49:
 857               	.LBE42:
 423:setup.c       **** 		uint8_t data = 0;
 858               		.loc 1 423 0
 859 022e 80E0      		ldi r24,hi8(eepromBuffer+8)
 860 0230 E030      		cpi r30,lo8(eepromBuffer+8)
 861 0232 F807      		cpc r31,r24
 862               	.LVL50:
 863 0234 01F4      		brne .L43
 864               	.LBE43:
 436:setup.c       **** 	}
 437:setup.c       **** 	
 438:setup.c       **** 	cs_mreqPin_high;
 865               		.loc 1 438 0
 866 0236 969A      		sbi 0x12,6
 439:setup.c       **** 	
 440:setup.c       **** 	// Set AD0 pin as output
 441:setup.c       **** 	GBA_PORT_EEPROM_DATA7_0 |= (1<<AD0);
 867               		.loc 1 441 0
 868 0238 C09A      		sbi 0x18,0
 442:setup.c       **** 	GBA_DDR_EEPROM_DATA7_0 |= (1<<AD0);
 869               		.loc 1 442 0
 870 023a B89A      		sbi 0x17,0
 871 023c 0895      		ret
 872               		.cfi_endproc
 873               	.LFE26:
 875               	.global	gba_eeprom_write
 877               	gba_eeprom_write:
 878               	.LFB27:
 443:setup.c       **** }
 444:setup.c       **** 
 445:setup.c       **** // Write 8 bytes to the EEPROM address
 446:setup.c       **** void gba_eeprom_write(uint16_t address, uint8_t eepromSize) {
 879               		.loc 1 446 0
 880               		.cfi_startproc
 881               	.LVL51:
 882               	/* prologue: function */
 883               	/* frame size = 0 */
 884               	/* stack size = 0 */
 885               	.L__stack_usage = 0
 447:setup.c       **** 	gba_eeprom_set_address(address, eepromSize, EEPROM_WRITE);
 886               		.loc 1 447 0
 887 023e 41E0      		ldi r20,lo8(1)
 888 0240 0E94 0000 		call gba_eeprom_set_address
 889               	.LVL52:
 890 0244 E0E0      		ldi r30,lo8(eepromBuffer)
 891 0246 F0E0      		ldi r31,hi8(eepromBuffer)
 892               	.LVL53:
 893               	.L53:
 446:setup.c       **** 	gba_eeprom_set_address(address, eepromSize, EEPROM_WRITE);
 894               		.loc 1 446 0 discriminator 1
 895 0248 87E0      		ldi r24,lo8(7)
 896 024a 90E0      		ldi r25,0
 897               	.LVL54:
 898               	.L58:
 899               	.LBB44:
 900               	.LBB45:
 448:setup.c       **** 	
 449:setup.c       **** 	// Write 64 bits
 450:setup.c       **** 	for (uint8_t c = 0; c < 8; c++) {
 451:setup.c       **** 		for (int8_t x = 7; x >= 0; x--) {
 452:setup.c       **** 			if (eepromBuffer[c] & (1<<x)) {
 901               		.loc 1 452 0
 902 024c 2081      		ld r18,Z
 903 024e 30E0      		ldi r19,0
 904 0250 082E      		mov r0,r24
 905 0252 00C0      		rjmp 2f
 906               		1:
 907 0254 3595      		asr r19
 908 0256 2795      		ror r18
 909               		2:
 910 0258 0A94      		dec r0
 911 025a 02F4      		brpl 1b
 912 025c 20FF      		sbrs r18,0
 913 025e 00C0      		rjmp .L54
 453:setup.c       **** 				ad0Pin_high;
 914               		.loc 1 453 0
 915 0260 C09A      		sbi 0x18,0
 916 0262 00C0      		rjmp .L55
 917               	.L54:
 454:setup.c       **** 			}
 455:setup.c       **** 			else {
 456:setup.c       **** 				ad0Pin_low;
 918               		.loc 1 456 0
 919 0264 C098      		cbi 0x18,0
 920               	.L55:
 457:setup.c       **** 			}
 458:setup.c       **** 			
 459:setup.c       **** 			wrPin_low; // CLK
 921               		.loc 1 459 0
 922 0266 9498      		cbi 0x12,4
 460:setup.c       **** 			asm ("nop");
 923               		.loc 1 460 0
 924               	/* #APP */
 925               	 ;  460 "setup.c" 1
 926 0268 0000      		nop
 927               	 ;  0 "" 2
 461:setup.c       **** 			asm ("nop");
 928               		.loc 1 461 0
 929               	 ;  461 "setup.c" 1
 930 026a 0000      		nop
 931               	 ;  0 "" 2
 462:setup.c       **** 			wrPin_high; 
 932               		.loc 1 462 0
 933               	/* #NOAPP */
 934 026c 949A      		sbi 0x12,4
 463:setup.c       **** 			asm ("nop");
 935               		.loc 1 463 0
 936               	/* #APP */
 937               	 ;  463 "setup.c" 1
 938 026e 0000      		nop
 939               	 ;  0 "" 2
 464:setup.c       **** 			asm ("nop");
 940               		.loc 1 464 0
 941               	 ;  464 "setup.c" 1
 942 0270 0000      		nop
 943               	 ;  0 "" 2
 944               	.LVL55:
 945               	/* #NOAPP */
 946               	.LVL56:
 947 0272 0197      		sbiw r24,1
 948 0274 00F4      		brcc .L58
 949 0276 3196      		adiw r30,1
 950               	.LVL57:
 951               	.LBE45:
 450:setup.c       **** 		for (int8_t x = 7; x >= 0; x--) {
 952               		.loc 1 450 0
 953 0278 80E0      		ldi r24,hi8(eepromBuffer+8)
 954 027a E030      		cpi r30,lo8(eepromBuffer+8)
 955 027c F807      		cpc r31,r24
 956               	.LVL58:
 957 027e 01F4      		brne .L53
 958               	.LBE44:
 465:setup.c       **** 		}
 466:setup.c       **** 	}
 467:setup.c       **** 	
 468:setup.c       **** 	// Last bit low
 469:setup.c       **** 	ad0Pin_low;
 959               		.loc 1 469 0
 960 0280 C098      		cbi 0x18,0
 470:setup.c       **** 	wrPin_low; // CLK
 961               		.loc 1 470 0
 962 0282 9498      		cbi 0x12,4
 471:setup.c       **** 	asm ("nop");
 963               		.loc 1 471 0
 964               	/* #APP */
 965               	 ;  471 "setup.c" 1
 966 0284 0000      		nop
 967               	 ;  0 "" 2
 472:setup.c       **** 	asm ("nop");
 968               		.loc 1 472 0
 969               	 ;  472 "setup.c" 1
 970 0286 0000      		nop
 971               	 ;  0 "" 2
 473:setup.c       **** 	wrPin_high; 
 972               		.loc 1 473 0
 973               	/* #NOAPP */
 974 0288 949A      		sbi 0x12,4
 474:setup.c       **** 	asm ("nop");
 975               		.loc 1 474 0
 976               	/* #APP */
 977               	 ;  474 "setup.c" 1
 978 028a 0000      		nop
 979               	 ;  0 "" 2
 475:setup.c       **** 	asm ("nop");
 980               		.loc 1 475 0
 981               	 ;  475 "setup.c" 1
 982 028c 0000      		nop
 983               	 ;  0 "" 2
 476:setup.c       **** 	
 477:setup.c       **** 	cs_mreqPin_high;
 984               		.loc 1 477 0
 985               	/* #NOAPP */
 986 028e 969A      		sbi 0x12,6
 987 0290 0895      		ret
 988               		.cfi_endproc
 989               	.LFE27:
 991               	.global	flash_write_bus_cycle
 993               	flash_write_bus_cycle:
 994               	.LFB28:
 478:setup.c       **** }
 479:setup.c       **** 
 480:setup.c       **** 
 481:setup.c       **** 
 482:setup.c       **** // ---------- FLASH ----------
 483:setup.c       **** 
 484:setup.c       **** // Set the address and data for the write byte cycle to the flash
 485:setup.c       **** void flash_write_bus_cycle(uint16_t address, uint8_t data) {
 995               		.loc 1 485 0
 996               		.cfi_startproc
 997               	.LVL59:
 998 0292 CF93      		push r28
 999               	.LCFI16:
 1000               		.cfi_def_cfa_offset 3
 1001               		.cfi_offset 28, -2
 1002 0294 DF93      		push r29
 1003               	.LCFI17:
 1004               		.cfi_def_cfa_offset 4
 1005               		.cfi_offset 29, -3
 1006 0296 1F92      		push __zero_reg__
 1007               	.LCFI18:
 1008               		.cfi_def_cfa_offset 5
 1009 0298 CDB7      		in r28,__SP_L__
 1010 029a DEB7      		in r29,__SP_H__
 1011               	.LCFI19:
 1012               		.cfi_def_cfa_register 28
 1013               	/* prologue: function */
 1014               	/* frame size = 1 */
 1015               	/* stack size = 3 */
 1016               	.L__stack_usage = 3
 486:setup.c       **** 	GBA_DDR_RAM_DATA7_0 = 0xFF; // Set data pins as outputs
 1017               		.loc 1 486 0
 1018 029c 2FEF      		ldi r18,lo8(-1)
 1019 029e 24BB      		out 0x14,r18
 487:setup.c       **** 	set_16bit_address(address);
 1020               		.loc 1 487 0
 1021 02a0 6983      		std Y+1,r22
 1022 02a2 0E94 0000 		call set_16bit_address
 1023               	.LVL60:
 488:setup.c       **** 	GBA_PORT_RAM_DATA7_0 = data;
 1024               		.loc 1 488 0
 1025 02a6 6981      		ldd r22,Y+1
 1026 02a8 65BB      		out 0x15,r22
 489:setup.c       **** 	
 490:setup.c       **** 	wrPin_low;
 1027               		.loc 1 490 0
 1028 02aa 9498      		cbi 0x12,4
 491:setup.c       **** 	cs2Pin_low;
 1029               		.loc 1 491 0
 1030 02ac 9798      		cbi 0x12,7
 492:setup.c       **** 	asm volatile("nop");
 1031               		.loc 1 492 0
 1032               	/* #APP */
 1033               	 ;  492 "setup.c" 1
 1034 02ae 0000      		nop
 1035               	 ;  0 "" 2
 493:setup.c       **** 	wrPin_high;
 1036               		.loc 1 493 0
 1037               	/* #NOAPP */
 1038 02b0 949A      		sbi 0x12,4
 494:setup.c       **** 	cs2Pin_high;
 1039               		.loc 1 494 0
 1040 02b2 979A      		sbi 0x12,7
 1041               	/* epilogue start */
 495:setup.c       **** }
 1042               		.loc 1 495 0
 1043 02b4 0F90      		pop __tmp_reg__
 1044 02b6 DF91      		pop r29
 1045 02b8 CF91      		pop r28
 1046 02ba 0895      		ret
 1047               		.cfi_endproc
 1048               	.LFE28:
 1050               	.global	flash_read_chip_id
 1052               	flash_read_chip_id:
 1053               	.LFB29:
 496:setup.c       **** 
 497:setup.c       **** // Read the flash manufacturer and device ID (Software ID)
 498:setup.c       **** void flash_read_chip_id(void) {
 1054               		.loc 1 498 0
 1055               		.cfi_startproc
 1056               	/* prologue: function */
 1057               	/* frame size = 0 */
 1058               	/* stack size = 0 */
 1059               	.L__stack_usage = 0
 499:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xAA);
 1060               		.loc 1 499 0
 1061 02bc 6AEA      		ldi r22,lo8(-86)
 1062 02be 85E5      		ldi r24,lo8(85)
 1063 02c0 95E5      		ldi r25,lo8(85)
 1064 02c2 0E94 0000 		call flash_write_bus_cycle
 1065               	.LVL61:
 500:setup.c       **** 	flash_write_bus_cycle(0x2AAA, 0x55);
 1066               		.loc 1 500 0
 1067 02c6 65E5      		ldi r22,lo8(85)
 1068 02c8 8AEA      		ldi r24,lo8(-86)
 1069 02ca 9AE2      		ldi r25,lo8(42)
 1070 02cc 0E94 0000 		call flash_write_bus_cycle
 1071               	.LVL62:
 501:setup.c       **** 	flash_write_bus_cycle(0x5555, 0x90); // Software ID entry
 1072               		.loc 1 501 0
 1073 02d0 60E9      		ldi r22,lo8(-112)
 1074 02d2 85E5      		ldi r24,lo8(85)
 1075 02d4 95E5      		ldi r25,lo8(85)
 1076 02d6 0E94 0000 		call flash_write_bus_cycle
 1077               	.LVL63:
 1078               	.LBB46:
 1079               	.LBB47:
 1080               		.file 2 "c:\\winavr-20100110\\avr\\include\\util\\delay.h"
   1:c:\winavr-20100110\avr\include\util\delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:c:\winavr-20100110\avr\include\util\delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:c:\winavr-20100110\avr\include\util\delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:c:\winavr-20100110\avr\include\util\delay.h ****    All rights reserved.
   5:c:\winavr-20100110\avr\include\util\delay.h **** 
   6:c:\winavr-20100110\avr\include\util\delay.h ****    Redistribution and use in source and binary forms, with or without
   7:c:\winavr-20100110\avr\include\util\delay.h ****    modification, are permitted provided that the following conditions are met:
   8:c:\winavr-20100110\avr\include\util\delay.h **** 
   9:c:\winavr-20100110\avr\include\util\delay.h ****    * Redistributions of source code must retain the above copyright
  10:c:\winavr-20100110\avr\include\util\delay.h ****      notice, this list of conditions and the following disclaimer.
  11:c:\winavr-20100110\avr\include\util\delay.h **** 
  12:c:\winavr-20100110\avr\include\util\delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:c:\winavr-20100110\avr\include\util\delay.h ****      notice, this list of conditions and the following disclaimer in
  14:c:\winavr-20100110\avr\include\util\delay.h ****      the documentation and/or other materials provided with the
  15:c:\winavr-20100110\avr\include\util\delay.h ****      distribution.
  16:c:\winavr-20100110\avr\include\util\delay.h **** 
  17:c:\winavr-20100110\avr\include\util\delay.h ****    * Neither the name of the copyright holders nor the names of
  18:c:\winavr-20100110\avr\include\util\delay.h ****      contributors may be used to endorse or promote products derived
  19:c:\winavr-20100110\avr\include\util\delay.h ****      from this software without specific prior written permission.
  20:c:\winavr-20100110\avr\include\util\delay.h **** 
  21:c:\winavr-20100110\avr\include\util\delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:c:\winavr-20100110\avr\include\util\delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:c:\winavr-20100110\avr\include\util\delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:c:\winavr-20100110\avr\include\util\delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:c:\winavr-20100110\avr\include\util\delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:c:\winavr-20100110\avr\include\util\delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:c:\winavr-20100110\avr\include\util\delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:c:\winavr-20100110\avr\include\util\delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:c:\winavr-20100110\avr\include\util\delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:c:\winavr-20100110\avr\include\util\delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:c:\winavr-20100110\avr\include\util\delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:c:\winavr-20100110\avr\include\util\delay.h **** 
  33:c:\winavr-20100110\avr\include\util\delay.h **** /* $Id$ */
  34:c:\winavr-20100110\avr\include\util\delay.h **** 
  35:c:\winavr-20100110\avr\include\util\delay.h **** #ifndef _UTIL_DELAY_H_
  36:c:\winavr-20100110\avr\include\util\delay.h **** #define _UTIL_DELAY_H_ 1
  37:c:\winavr-20100110\avr\include\util\delay.h **** 
  38:c:\winavr-20100110\avr\include\util\delay.h **** #ifndef __HAS_DELAY_CYCLES
  39:c:\winavr-20100110\avr\include\util\delay.h **** #define __HAS_DELAY_CYCLES 1
  40:c:\winavr-20100110\avr\include\util\delay.h **** #endif
  41:c:\winavr-20100110\avr\include\util\delay.h **** 
  42:c:\winavr-20100110\avr\include\util\delay.h **** #include <inttypes.h>
  43:c:\winavr-20100110\avr\include\util\delay.h **** #include <util/delay_basic.h>
  44:c:\winavr-20100110\avr\include\util\delay.h **** #include <math.h>
  45:c:\winavr-20100110\avr\include\util\delay.h **** 
  46:c:\winavr-20100110\avr\include\util\delay.h **** /** \file */
  47:c:\winavr-20100110\avr\include\util\delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  48:c:\winavr-20100110\avr\include\util\delay.h ****     \code
  49:c:\winavr-20100110\avr\include\util\delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  50:c:\winavr-20100110\avr\include\util\delay.h ****     //#define F_CPU 14.7456E6
  51:c:\winavr-20100110\avr\include\util\delay.h ****     #include <util/delay.h>
  52:c:\winavr-20100110\avr\include\util\delay.h ****     \endcode
  53:c:\winavr-20100110\avr\include\util\delay.h **** 
  54:c:\winavr-20100110\avr\include\util\delay.h ****     \note As an alternative method, it is possible to pass the
  55:c:\winavr-20100110\avr\include\util\delay.h ****     F_CPU macro down to the compiler from the Makefile.
  56:c:\winavr-20100110\avr\include\util\delay.h ****     Obviously, in that case, no \c \#define statement should be
  57:c:\winavr-20100110\avr\include\util\delay.h ****     used.
  58:c:\winavr-20100110\avr\include\util\delay.h **** 
  59:c:\winavr-20100110\avr\include\util\delay.h ****     The functions in this header file are wrappers around the basic
  60:c:\winavr-20100110\avr\include\util\delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  61:c:\winavr-20100110\avr\include\util\delay.h ****     convenience functions where actual time values can be specified
  62:c:\winavr-20100110\avr\include\util\delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  63:c:\winavr-20100110\avr\include\util\delay.h ****     that compile-time constant expressions will be eliminated by
  64:c:\winavr-20100110\avr\include\util\delay.h ****     compiler optimization so floating-point expressions can be used
  65:c:\winavr-20100110\avr\include\util\delay.h ****     to calculate the number of delay cycles needed based on the CPU
  66:c:\winavr-20100110\avr\include\util\delay.h ****     frequency passed by the macro F_CPU.
  67:c:\winavr-20100110\avr\include\util\delay.h **** 
  68:c:\winavr-20100110\avr\include\util\delay.h ****     \note In order for these functions to work as intended, compiler
  69:c:\winavr-20100110\avr\include\util\delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  70:c:\winavr-20100110\avr\include\util\delay.h ****     <em>must</em> be an expression that is a known constant at
  71:c:\winavr-20100110\avr\include\util\delay.h ****     compile-time.  If these requirements are not met, the resulting
  72:c:\winavr-20100110\avr\include\util\delay.h ****     delay will be much longer (and basically unpredictable), and
  73:c:\winavr-20100110\avr\include\util\delay.h ****     applications that otherwise do not use floating-point calculations
  74:c:\winavr-20100110\avr\include\util\delay.h ****     will experience severe code bloat by the floating-point library
  75:c:\winavr-20100110\avr\include\util\delay.h ****     routines linked into the application.
  76:c:\winavr-20100110\avr\include\util\delay.h **** 
  77:c:\winavr-20100110\avr\include\util\delay.h ****     The functions available allow the specification of microsecond, and
  78:c:\winavr-20100110\avr\include\util\delay.h ****     millisecond delays directly, using the application-supplied macro
  79:c:\winavr-20100110\avr\include\util\delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  80:c:\winavr-20100110\avr\include\util\delay.h **** 
  81:c:\winavr-20100110\avr\include\util\delay.h **** */
  82:c:\winavr-20100110\avr\include\util\delay.h **** 
  83:c:\winavr-20100110\avr\include\util\delay.h **** #if !defined(__DOXYGEN__)
  84:c:\winavr-20100110\avr\include\util\delay.h **** static inline void _delay_us(double __us) __attribute__((always_inline));
  85:c:\winavr-20100110\avr\include\util\delay.h **** static inline void _delay_ms(double __ms) __attribute__((always_inline));
  86:c:\winavr-20100110\avr\include\util\delay.h **** #endif
  87:c:\winavr-20100110\avr\include\util\delay.h **** 
  88:c:\winavr-20100110\avr\include\util\delay.h **** #ifndef F_CPU
  89:c:\winavr-20100110\avr\include\util\delay.h **** /* prevent compiler error by supplying a default */
  90:c:\winavr-20100110\avr\include\util\delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  91:c:\winavr-20100110\avr\include\util\delay.h **** # define F_CPU 1000000UL
  92:c:\winavr-20100110\avr\include\util\delay.h **** #endif
  93:c:\winavr-20100110\avr\include\util\delay.h **** 
  94:c:\winavr-20100110\avr\include\util\delay.h **** #ifndef __OPTIMIZE__
  95:c:\winavr-20100110\avr\include\util\delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
  96:c:\winavr-20100110\avr\include\util\delay.h **** #endif
  97:c:\winavr-20100110\avr\include\util\delay.h **** 
  98:c:\winavr-20100110\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
  99:c:\winavr-20100110\avr\include\util\delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 100:c:\winavr-20100110\avr\include\util\delay.h ****   __STDC_HOSTED__
 101:c:\winavr-20100110\avr\include\util\delay.h **** #  include <math.h>
 102:c:\winavr-20100110\avr\include\util\delay.h **** #endif
 103:c:\winavr-20100110\avr\include\util\delay.h **** 
 104:c:\winavr-20100110\avr\include\util\delay.h **** /**
 105:c:\winavr-20100110\avr\include\util\delay.h ****    \ingroup util_delay
 106:c:\winavr-20100110\avr\include\util\delay.h **** 
 107:c:\winavr-20100110\avr\include\util\delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 108:c:\winavr-20100110\avr\include\util\delay.h **** 
 109:c:\winavr-20100110\avr\include\util\delay.h ****    The macro F_CPU is supposed to be defined to a
 110:c:\winavr-20100110\avr\include\util\delay.h ****    constant defining the CPU clock frequency (in Hertz).
 111:c:\winavr-20100110\avr\include\util\delay.h **** 
 112:c:\winavr-20100110\avr\include\util\delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 113:c:\winavr-20100110\avr\include\util\delay.h **** 
 114:c:\winavr-20100110\avr\include\util\delay.h ****    When the user request delay which exceed the maximum possible one,
 115:c:\winavr-20100110\avr\include\util\delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 116:c:\winavr-20100110\avr\include\util\delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 117:c:\winavr-20100110\avr\include\util\delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 118:c:\winavr-20100110\avr\include\util\delay.h ****    user will not be informed about decreased resolution.
 119:c:\winavr-20100110\avr\include\util\delay.h **** 
 120:c:\winavr-20100110\avr\include\util\delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 121:c:\winavr-20100110\avr\include\util\delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 122:c:\winavr-20100110\avr\include\util\delay.h ****    values greater than the maximal possible delay, overflows results in
 123:c:\winavr-20100110\avr\include\util\delay.h ****    no delay i.e., 0ms.
 124:c:\winavr-20100110\avr\include\util\delay.h **** 
 125:c:\winavr-20100110\avr\include\util\delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 126:c:\winavr-20100110\avr\include\util\delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 127:c:\winavr-20100110\avr\include\util\delay.h ****    the user gets atleast __us microseconds of delay.
 128:c:\winavr-20100110\avr\include\util\delay.h **** 
 129:c:\winavr-20100110\avr\include\util\delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 130:c:\winavr-20100110\avr\include\util\delay.h ****    to round down and round to closest integer.
 131:c:\winavr-20100110\avr\include\util\delay.h **** 
 132:c:\winavr-20100110\avr\include\util\delay.h ****    Note: The new implementation of _delay_ms(double __ms) with 
 133:c:\winavr-20100110\avr\include\util\delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible. 
 134:c:\winavr-20100110\avr\include\util\delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 135:c:\winavr-20100110\avr\include\util\delay.h ****    Also, the backward compatible
 136:c:\winavr-20100110\avr\include\util\delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 137:c:\winavr-20100110\avr\include\util\delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 138:c:\winavr-20100110\avr\include\util\delay.h ****    required for rounding are not available to the compiler then.
 139:c:\winavr-20100110\avr\include\util\delay.h **** 
 140:c:\winavr-20100110\avr\include\util\delay.h ****  */
 141:c:\winavr-20100110\avr\include\util\delay.h **** void
 142:c:\winavr-20100110\avr\include\util\delay.h **** _delay_ms(double __ms)
 143:c:\winavr-20100110\avr\include\util\delay.h **** {
 144:c:\winavr-20100110\avr\include\util\delay.h **** 	double __tmp ; 
 145:c:\winavr-20100110\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 146:c:\winavr-20100110\avr\include\util\delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 147:c:\winavr-20100110\avr\include\util\delay.h ****   __STDC_HOSTED__
 148:c:\winavr-20100110\avr\include\util\delay.h **** 	uint32_t __ticks_dc;
 149:c:\winavr-20100110\avr\include\util\delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 150:c:\winavr-20100110\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 151:c:\winavr-20100110\avr\include\util\delay.h **** 
 152:c:\winavr-20100110\avr\include\util\delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 153:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 154:c:\winavr-20100110\avr\include\util\delay.h **** 
 155:c:\winavr-20100110\avr\include\util\delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 156:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 157:c:\winavr-20100110\avr\include\util\delay.h **** 
 158:c:\winavr-20100110\avr\include\util\delay.h **** 	#else
 159:c:\winavr-20100110\avr\include\util\delay.h **** 		//round up by default
 160:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 161:c:\winavr-20100110\avr\include\util\delay.h **** 	#endif
 162:c:\winavr-20100110\avr\include\util\delay.h **** 
 163:c:\winavr-20100110\avr\include\util\delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 1081               		.loc 2 163 0
 1082 02da 8FE3      		ldi r24,lo8(-25537)
 1083 02dc 9CE9      		ldi r25,hi8(-25537)
 1084 02de 0197      		1: sbiw r24,1
 1085 02e0 01F4      		brne 1b
 1086 02e2 00C0      		rjmp .
 1087 02e4 0000      		nop
 1088               	.LBE47:
 1089               	.LBE46:
 502:setup.c       **** 	_delay_ms(20); // Wait a little (for Atmel chip)
 503:setup.c       **** 	
 504:setup.c       **** 	// Set data as inputs
 505:setup.c       **** 	GBA_PORT_RAM_DATA7_0 = 0;
 1090               		.loc 1 505 0
 1091 02e6 15BA      		out 0x15,__zero_reg__
 506:setup.c       **** 	GBA_DDR_RAM_DATA7_0 = 0;
 1092               		.loc 1 506 0
 1093 02e8 14BA      		out 0x14,__zero_reg__
 507:setup.c       **** 	
 508:setup.c       **** 	// Read and transmit the 2 bytes
 509:setup.c       **** 	flashChipIdBuffer[0] = gba_read_ram_8bit_data(0x0000);
 1094               		.loc 1 509 0
 1095 02ea 80E0      		ldi r24,0
 1096 02ec 90E0      		ldi r25,0
 1097 02ee 0E94 0000 		call gba_read_ram_8bit_data
 1098               	.LVL64:
 1099 02f2 8093 0000 		sts flashChipIdBuffer,r24
 510:setup.c       **** 	flashChipIdBuffer[1] = gba_read_ram_8bit_data(0x0001);
 1100               		.loc 1 510 0
 1101 02f6 81E0      		ldi r24,lo8(1)
 1102 02f8 90E0      		ldi r25,0
 1103 02fa 0E94 0000 		call gba_read_ram_8bit_data
 1104               	.LVL65:
 1105 02fe 8093 0000 		sts flashChipIdBuffer+1,r24
 511:setup.c       **** 	
 512:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xAA);
 1106               		.loc 1 512 0
 1107 0302 6AEA      		ldi r22,lo8(-86)
 1108 0304 85E5      		ldi r24,lo8(85)
 1109 0306 95E5      		ldi r25,lo8(85)
 1110 0308 0E94 0000 		call flash_write_bus_cycle
 1111               	.LVL66:
 513:setup.c       **** 	flash_write_bus_cycle(0x2AAA, 0x55);
 1112               		.loc 1 513 0
 1113 030c 65E5      		ldi r22,lo8(85)
 1114 030e 8AEA      		ldi r24,lo8(-86)
 1115 0310 9AE2      		ldi r25,lo8(42)
 1116 0312 0E94 0000 		call flash_write_bus_cycle
 1117               	.LVL67:
 514:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xF0); // Software ID exit
 1118               		.loc 1 514 0
 1119 0316 60EF      		ldi r22,lo8(-16)
 1120 0318 85E5      		ldi r24,lo8(85)
 1121 031a 95E5      		ldi r25,lo8(85)
 1122 031c 0E94 0000 		call flash_write_bus_cycle
 1123               	.LVL68:
 1124               	.LBB48:
 1125               	.LBB49:
 1126               		.loc 2 163 0
 1127 0320 8FE3      		ldi r24,lo8(-25537)
 1128 0322 9CE9      		ldi r25,hi8(-25537)
 1129 0324 0197      		1: sbiw r24,1
 1130 0326 01F4      		brne 1b
 1131 0328 00C0      		rjmp .
 1132 032a 0000      		nop
 1133 032c 0895      		ret
 1134               	.LBE49:
 1135               	.LBE48:
 1136               		.cfi_endproc
 1137               	.LFE29:
 1139               	.global	flash_switch_bank
 1141               	flash_switch_bank:
 1142               	.LFB30:
 515:setup.c       **** 	_delay_ms(20); // Wait a little (for Atmel chip)
 516:setup.c       **** }
 517:setup.c       **** 
 518:setup.c       **** // Switch banks on the Flash
 519:setup.c       **** void flash_switch_bank(uint8_t bank) {
 1143               		.loc 1 519 0
 1144               		.cfi_startproc
 1145               	.LVL69:
 1146 032e CF93      		push r28
 1147               	.LCFI20:
 1148               		.cfi_def_cfa_offset 3
 1149               		.cfi_offset 28, -2
 1150               	/* prologue: function */
 1151               	/* frame size = 0 */
 1152               	/* stack size = 1 */
 1153               	.L__stack_usage = 1
 1154 0330 C82F      		mov r28,r24
 520:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xAA);
 1155               		.loc 1 520 0
 1156 0332 6AEA      		ldi r22,lo8(-86)
 1157 0334 85E5      		ldi r24,lo8(85)
 1158 0336 95E5      		ldi r25,lo8(85)
 1159               	.LVL70:
 1160 0338 0E94 0000 		call flash_write_bus_cycle
 1161               	.LVL71:
 521:setup.c       **** 	flash_write_bus_cycle(0x2AAA, 0x55);
 1162               		.loc 1 521 0
 1163 033c 65E5      		ldi r22,lo8(85)
 1164 033e 8AEA      		ldi r24,lo8(-86)
 1165 0340 9AE2      		ldi r25,lo8(42)
 1166 0342 0E94 0000 		call flash_write_bus_cycle
 1167               	.LVL72:
 522:setup.c       **** 	
 523:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xB0);
 1168               		.loc 1 523 0
 1169 0346 60EB      		ldi r22,lo8(-80)
 1170 0348 85E5      		ldi r24,lo8(85)
 1171 034a 95E5      		ldi r25,lo8(85)
 1172 034c 0E94 0000 		call flash_write_bus_cycle
 1173               	.LVL73:
 524:setup.c       **** 	flash_write_bus_cycle(0x0000, bank);
 1174               		.loc 1 524 0
 1175 0350 6C2F      		mov r22,r28
 1176 0352 80E0      		ldi r24,0
 1177 0354 90E0      		ldi r25,0
 1178               	/* epilogue start */
 525:setup.c       **** }
 1179               		.loc 1 525 0
 1180 0356 CF91      		pop r28
 1181               	.LVL74:
 524:setup.c       **** 	flash_write_bus_cycle(0x0000, bank);
 1182               		.loc 1 524 0
 1183 0358 0C94 0000 		jmp flash_write_bus_cycle
 1184               	.LVL75:
 1185               		.cfi_endproc
 1186               	.LFE30:
 1188               	.global	flash_erase_4k_sector
 1190               	flash_erase_4k_sector:
 1191               	.LFB31:
 526:setup.c       **** 
 527:setup.c       **** // Erase 4K sector on Flash, expects first sector to start at 0, left shifts by 12 (A15-A12 to sele
 528:setup.c       **** // Takes 25ms after last command to erase sector
 529:setup.c       **** void flash_erase_4k_sector(uint8_t sector) {
 1192               		.loc 1 529 0
 1193               		.cfi_startproc
 1194               	.LVL76:
 1195 035c CF93      		push r28
 1196               	.LCFI21:
 1197               		.cfi_def_cfa_offset 3
 1198               		.cfi_offset 28, -2
 1199               	/* prologue: function */
 1200               	/* frame size = 0 */
 1201               	/* stack size = 1 */
 1202               	.L__stack_usage = 1
 1203 035e C82F      		mov r28,r24
 530:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xAA);
 1204               		.loc 1 530 0
 1205 0360 6AEA      		ldi r22,lo8(-86)
 1206 0362 85E5      		ldi r24,lo8(85)
 1207 0364 95E5      		ldi r25,lo8(85)
 1208               	.LVL77:
 1209 0366 0E94 0000 		call flash_write_bus_cycle
 1210               	.LVL78:
 531:setup.c       **** 	flash_write_bus_cycle(0x2AAA, 0x55);
 1211               		.loc 1 531 0
 1212 036a 65E5      		ldi r22,lo8(85)
 1213 036c 8AEA      		ldi r24,lo8(-86)
 1214 036e 9AE2      		ldi r25,lo8(42)
 1215 0370 0E94 0000 		call flash_write_bus_cycle
 1216               	.LVL79:
 532:setup.c       **** 	flash_write_bus_cycle(0x5555, 0x80);
 1217               		.loc 1 532 0
 1218 0374 60E8      		ldi r22,lo8(-128)
 1219 0376 85E5      		ldi r24,lo8(85)
 1220 0378 95E5      		ldi r25,lo8(85)
 1221 037a 0E94 0000 		call flash_write_bus_cycle
 1222               	.LVL80:
 533:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xAA);
 1223               		.loc 1 533 0
 1224 037e 6AEA      		ldi r22,lo8(-86)
 1225 0380 85E5      		ldi r24,lo8(85)
 1226 0382 95E5      		ldi r25,lo8(85)
 1227 0384 0E94 0000 		call flash_write_bus_cycle
 1228               	.LVL81:
 534:setup.c       **** 	flash_write_bus_cycle(0x2AAA, 0x55);
 1229               		.loc 1 534 0
 1230 0388 65E5      		ldi r22,lo8(85)
 1231 038a 8AEA      		ldi r24,lo8(-86)
 1232 038c 9AE2      		ldi r25,lo8(42)
 1233 038e 0E94 0000 		call flash_write_bus_cycle
 1234               	.LVL82:
 535:setup.c       **** 	
 536:setup.c       **** 	flash_write_bus_cycle((uint16_t) sector << 12, 0x30);
 1235               		.loc 1 536 0
 1236 0392 60E3      		ldi r22,lo8(48)
 1237 0394 80E0      		ldi r24,0
 1238 0396 9C2F      		mov r25,r28
 1239 0398 9295      		swap r25
 1240 039a 907F      		andi r25,lo8(-16)
 1241 039c 0E94 0000 		call flash_write_bus_cycle
 1242               	.LVL83:
 1243               	.LBB50:
 1244               	.LBB51:
 1245               		.loc 2 163 0
 1246 03a0 8FE4      		ldi r24,lo8(-15537)
 1247 03a2 93EC      		ldi r25,hi8(-15537)
 1248 03a4 0197      		1: sbiw r24,1
 1249 03a6 01F4      		brne 1b
 1250 03a8 00C0      		rjmp .
 1251 03aa 0000      		nop
 1252               	/* epilogue start */
 1253               	.LBE51:
 1254               	.LBE50:
 537:setup.c       **** 	_delay_ms(25); // Wait 25ms for sector erase
 538:setup.c       **** }
 1255               		.loc 1 538 0
 1256 03ac CF91      		pop r28
 1257               	.LVL84:
 1258 03ae 0895      		ret
 1259               		.cfi_endproc
 1260               	.LFE31:
 1262               	.global	flash_write_byte
 1264               	flash_write_byte:
 1265               	.LFB32:
 539:setup.c       **** 
 540:setup.c       **** // Write a single byte to the Flash address
 541:setup.c       **** // Takes 20us to program Flash
 542:setup.c       **** void flash_write_byte(uint16_t address, uint8_t data) {
 1266               		.loc 1 542 0
 1267               		.cfi_startproc
 1268               	.LVL85:
 1269 03b0 1F93      		push r17
 1270               	.LCFI22:
 1271               		.cfi_def_cfa_offset 3
 1272               		.cfi_offset 17, -2
 1273 03b2 CF93      		push r28
 1274               	.LCFI23:
 1275               		.cfi_def_cfa_offset 4
 1276               		.cfi_offset 28, -3
 1277 03b4 DF93      		push r29
 1278               	.LCFI24:
 1279               		.cfi_def_cfa_offset 5
 1280               		.cfi_offset 29, -4
 1281               	/* prologue: function */
 1282               	/* frame size = 0 */
 1283               	/* stack size = 3 */
 1284               	.L__stack_usage = 3
 1285 03b6 EC01      		movw r28,r24
 1286 03b8 162F      		mov r17,r22
 543:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xAA);
 1287               		.loc 1 543 0
 1288 03ba 6AEA      		ldi r22,lo8(-86)
 1289               	.LVL86:
 1290 03bc 85E5      		ldi r24,lo8(85)
 1291 03be 95E5      		ldi r25,lo8(85)
 1292               	.LVL87:
 1293 03c0 0E94 0000 		call flash_write_bus_cycle
 1294               	.LVL88:
 544:setup.c       **** 	flash_write_bus_cycle(0x2AAA, 0x55);
 1295               		.loc 1 544 0
 1296 03c4 65E5      		ldi r22,lo8(85)
 1297 03c6 8AEA      		ldi r24,lo8(-86)
 1298 03c8 9AE2      		ldi r25,lo8(42)
 1299 03ca 0E94 0000 		call flash_write_bus_cycle
 1300               	.LVL89:
 545:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xA0);
 1301               		.loc 1 545 0
 1302 03ce 60EA      		ldi r22,lo8(-96)
 1303 03d0 85E5      		ldi r24,lo8(85)
 1304 03d2 95E5      		ldi r25,lo8(85)
 1305 03d4 0E94 0000 		call flash_write_bus_cycle
 1306               	.LVL90:
 546:setup.c       **** 	
 547:setup.c       **** 	flash_write_bus_cycle(address, data);
 1307               		.loc 1 547 0
 1308 03d8 612F      		mov r22,r17
 1309 03da CE01      		movw r24,r28
 1310 03dc 0E94 0000 		call flash_write_bus_cycle
 1311               	.LVL91:
 1312               	.LBB52:
 1313               	.LBB53:
 164:c:\winavr-20100110\avr\include\util\delay.h **** 
 165:c:\winavr-20100110\avr\include\util\delay.h **** #else
 166:c:\winavr-20100110\avr\include\util\delay.h **** 	uint16_t __ticks;
 167:c:\winavr-20100110\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 4e3) * __ms;
 168:c:\winavr-20100110\avr\include\util\delay.h **** 	if (__tmp < 1.0)
 169:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks = 1;
 170:c:\winavr-20100110\avr\include\util\delay.h **** 	else if (__tmp > 65535)
 171:c:\winavr-20100110\avr\include\util\delay.h **** 	{
 172:c:\winavr-20100110\avr\include\util\delay.h **** 		//	__ticks = requested delay in 1/10 ms
 173:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 174:c:\winavr-20100110\avr\include\util\delay.h **** 		while(__ticks)
 175:c:\winavr-20100110\avr\include\util\delay.h **** 		{
 176:c:\winavr-20100110\avr\include\util\delay.h **** 			// wait 1/10 ms
 177:c:\winavr-20100110\avr\include\util\delay.h **** 			_delay_loop_2(((F_CPU) / 4e3) / 10);
 178:c:\winavr-20100110\avr\include\util\delay.h **** 			__ticks --;
 179:c:\winavr-20100110\avr\include\util\delay.h **** 		}
 180:c:\winavr-20100110\avr\include\util\delay.h **** 		return;
 181:c:\winavr-20100110\avr\include\util\delay.h **** 	}
 182:c:\winavr-20100110\avr\include\util\delay.h **** 	else
 183:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks = (uint16_t)__tmp;
 184:c:\winavr-20100110\avr\include\util\delay.h **** 	_delay_loop_2(__ticks);
 185:c:\winavr-20100110\avr\include\util\delay.h **** #endif
 186:c:\winavr-20100110\avr\include\util\delay.h **** }
 187:c:\winavr-20100110\avr\include\util\delay.h **** 
 188:c:\winavr-20100110\avr\include\util\delay.h **** /**
 189:c:\winavr-20100110\avr\include\util\delay.h ****    \ingroup util_delay
 190:c:\winavr-20100110\avr\include\util\delay.h **** 
 191:c:\winavr-20100110\avr\include\util\delay.h ****    Perform a delay of \c __us microseconds, using _delay_loop_1().
 192:c:\winavr-20100110\avr\include\util\delay.h **** 
 193:c:\winavr-20100110\avr\include\util\delay.h ****    The macro F_CPU is supposed to be defined to a
 194:c:\winavr-20100110\avr\include\util\delay.h ****    constant defining the CPU clock frequency (in Hertz).
 195:c:\winavr-20100110\avr\include\util\delay.h **** 
 196:c:\winavr-20100110\avr\include\util\delay.h ****    The maximal possible delay is 768 us / F_CPU in MHz.
 197:c:\winavr-20100110\avr\include\util\delay.h **** 
 198:c:\winavr-20100110\avr\include\util\delay.h ****    If the user requests a delay greater than the maximal possible one,
 199:c:\winavr-20100110\avr\include\util\delay.h ****    _delay_us() will automatically call _delay_ms() instead.  The user
 200:c:\winavr-20100110\avr\include\util\delay.h ****    will not be informed about this case.
 201:c:\winavr-20100110\avr\include\util\delay.h **** 
 202:c:\winavr-20100110\avr\include\util\delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 203:c:\winavr-20100110\avr\include\util\delay.h ****    support, maximal possible delay is 4294967.295 us/ F_CPU in MHz. For
 204:c:\winavr-20100110\avr\include\util\delay.h ****    values greater than the maximal possible delay, overflow results in
 205:c:\winavr-20100110\avr\include\util\delay.h ****    no delay i.e., 0us.
 206:c:\winavr-20100110\avr\include\util\delay.h ****   
 207:c:\winavr-20100110\avr\include\util\delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 208:c:\winavr-20100110\avr\include\util\delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 209:c:\winavr-20100110\avr\include\util\delay.h ****    the user gets atleast __us microseconds of delay.
 210:c:\winavr-20100110\avr\include\util\delay.h **** 
 211:c:\winavr-20100110\avr\include\util\delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 212:c:\winavr-20100110\avr\include\util\delay.h ****    to round down and round to closest integer.
 213:c:\winavr-20100110\avr\include\util\delay.h ****  
 214:c:\winavr-20100110\avr\include\util\delay.h ****    Note: The new implementation of _delay_us(double __us) with 
 215:c:\winavr-20100110\avr\include\util\delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible.
 216:c:\winavr-20100110\avr\include\util\delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 217:c:\winavr-20100110\avr\include\util\delay.h ****    Also, the backward compatible
 218:c:\winavr-20100110\avr\include\util\delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 219:c:\winavr-20100110\avr\include\util\delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 220:c:\winavr-20100110\avr\include\util\delay.h ****    required for rounding are not available to the compiler then.
 221:c:\winavr-20100110\avr\include\util\delay.h **** 
 222:c:\winavr-20100110\avr\include\util\delay.h ****  */
 223:c:\winavr-20100110\avr\include\util\delay.h **** void
 224:c:\winavr-20100110\avr\include\util\delay.h **** _delay_us(double __us)
 225:c:\winavr-20100110\avr\include\util\delay.h **** {
 226:c:\winavr-20100110\avr\include\util\delay.h **** 	double __tmp ; 
 227:c:\winavr-20100110\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 228:c:\winavr-20100110\avr\include\util\delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 229:c:\winavr-20100110\avr\include\util\delay.h ****   __STDC_HOSTED__
 230:c:\winavr-20100110\avr\include\util\delay.h **** 	uint32_t __ticks_dc;
 231:c:\winavr-20100110\avr\include\util\delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 232:c:\winavr-20100110\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 233:c:\winavr-20100110\avr\include\util\delay.h **** 
 234:c:\winavr-20100110\avr\include\util\delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 235:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 236:c:\winavr-20100110\avr\include\util\delay.h **** 
 237:c:\winavr-20100110\avr\include\util\delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 238:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 239:c:\winavr-20100110\avr\include\util\delay.h **** 
 240:c:\winavr-20100110\avr\include\util\delay.h **** 	#else
 241:c:\winavr-20100110\avr\include\util\delay.h **** 		//round up by default
 242:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 243:c:\winavr-20100110\avr\include\util\delay.h **** 	#endif
 244:c:\winavr-20100110\avr\include\util\delay.h **** 
 245:c:\winavr-20100110\avr\include\util\delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 1314               		.loc 2 245 0
 1315 03e0 85E3      		ldi r24,lo8(53)
 1316 03e2 8A95      		1: dec r24
 1317 03e4 01F4      		brne 1b
 1318 03e6 0000      		nop
 1319               	/* epilogue start */
 1320               	.LBE53:
 1321               	.LBE52:
 548:setup.c       **** 	_delay_us(20); // Wait byte program time
 549:setup.c       **** }
 1322               		.loc 1 549 0
 1323 03e8 DF91      		pop r29
 1324 03ea CF91      		pop r28
 1325               	.LVL92:
 1326 03ec 1F91      		pop r17
 1327               	.LVL93:
 1328 03ee 0895      		ret
 1329               		.cfi_endproc
 1330               	.LFE32:
 1332               	.global	flash_write_sector
 1334               	flash_write_sector:
 1335               	.LFB33:
 550:setup.c       **** 
 551:setup.c       **** // Write a sector (128 bytes) to the Atmel flash
 552:setup.c       **** // Takes 20ms for write cycle
 553:setup.c       **** void flash_write_sector(uint16_t sector) {
 1336               		.loc 1 553 0
 1337               		.cfi_startproc
 1338               	.LVL94:
 1339 03f0 EF92      		push r14
 1340               	.LCFI25:
 1341               		.cfi_def_cfa_offset 3
 1342               		.cfi_offset 14, -2
 1343 03f2 FF92      		push r15
 1344               	.LCFI26:
 1345               		.cfi_def_cfa_offset 4
 1346               		.cfi_offset 15, -3
 1347 03f4 0F93      		push r16
 1348               	.LCFI27:
 1349               		.cfi_def_cfa_offset 5
 1350               		.cfi_offset 16, -4
 1351 03f6 1F93      		push r17
 1352               	.LCFI28:
 1353               		.cfi_def_cfa_offset 6
 1354               		.cfi_offset 17, -5
 1355 03f8 CF93      		push r28
 1356               	.LCFI29:
 1357               		.cfi_def_cfa_offset 7
 1358               		.cfi_offset 28, -6
 1359 03fa DF93      		push r29
 1360               	.LCFI30:
 1361               		.cfi_def_cfa_offset 8
 1362               		.cfi_offset 29, -7
 1363               	/* prologue: function */
 1364               	/* frame size = 0 */
 1365               	/* stack size = 6 */
 1366               	.L__stack_usage = 6
 1367 03fc 8C01      		movw r16,r24
 554:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xAA);
 1368               		.loc 1 554 0
 1369 03fe 6AEA      		ldi r22,lo8(-86)
 1370 0400 85E5      		ldi r24,lo8(85)
 1371 0402 95E5      		ldi r25,lo8(85)
 1372               	.LVL95:
 1373 0404 0E94 0000 		call flash_write_bus_cycle
 1374               	.LVL96:
 555:setup.c       **** 	flash_write_bus_cycle(0x2AAA, 0x55);
 1375               		.loc 1 555 0
 1376 0408 65E5      		ldi r22,lo8(85)
 1377 040a 8AEA      		ldi r24,lo8(-86)
 1378 040c 9AE2      		ldi r25,lo8(42)
 1379 040e 0E94 0000 		call flash_write_bus_cycle
 1380               	.LVL97:
 556:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xA0);
 1381               		.loc 1 556 0
 1382 0412 60EA      		ldi r22,lo8(-96)
 1383 0414 85E5      		ldi r24,lo8(85)
 1384 0416 95E5      		ldi r25,lo8(85)
 1385 0418 0E94 0000 		call flash_write_bus_cycle
 1386               	.LVL98:
 1387               	.LBB54:
 557:setup.c       **** 	
 558:setup.c       **** 	// Write the bytes (A0-A6 byte address, A7-A15 sector address)
 559:setup.c       **** 	for (uint8_t x = 0; x < 128; x++) {
 560:setup.c       **** 		flash_write_bus_cycle((uint16_t) (sector << 7) | (uint16_t) x, receivedBuffer[x]);
 1388               		.loc 1 560 0
 1389 041c 1695      		lsr r17
 1390 041e 102F      		mov r17,r16
 1391 0420 0027      		clr r16
 1392 0422 1795      		ror r17
 1393 0424 0795      		ror r16
 1394               	.LVL99:
 1395 0426 50E0      		ldi r21,lo8(receivedBuffer)
 1396 0428 E52E      		mov r14,r21
 1397 042a 50E0      		ldi r21,hi8(receivedBuffer)
 1398 042c F52E      		mov r15,r21
 1399 042e C0E0      		ldi r28,0
 1400 0430 D0E0      		ldi r29,0
 1401               	.LVL100:
 1402               	.L65:
 1403               		.loc 1 560 0 is_stmt 0 discriminator 2
 1404 0432 F701      		movw r30,r14
 1405 0434 6191      		ld r22,Z+
 1406 0436 7F01      		movw r14,r30
 1407 0438 CE01      		movw r24,r28
 1408 043a 802B      		or r24,r16
 1409 043c 912B      		or r25,r17
 1410 043e 0E94 0000 		call flash_write_bus_cycle
 1411               	.LVL101:
 1412 0442 2196      		adiw r28,1
 1413               	.LVL102:
 559:setup.c       **** 		flash_write_bus_cycle((uint16_t) (sector << 7) | (uint16_t) x, receivedBuffer[x]);
 1414               		.loc 1 559 0 is_stmt 1 discriminator 2
 1415 0444 C038      		cpi r28,-128
 1416 0446 D105      		cpc r29,__zero_reg__
 1417 0448 01F4      		brne .L65
 1418               	.LVL103:
 1419               	.LBE54:
 1420               	.LBB55:
 1421               	.LBB56:
 163:c:\winavr-20100110\avr\include\util\delay.h **** 
 1422               		.loc 2 163 0
 1423 044a 8FE3      		ldi r24,lo8(-25537)
 1424 044c 9CE9      		ldi r25,hi8(-25537)
 1425 044e 0197      		1: sbiw r24,1
 1426 0450 01F4      		brne 1b
 1427 0452 00C0      		rjmp .
 1428 0454 0000      		nop
 1429               	/* epilogue start */
 1430               	.LBE56:
 1431               	.LBE55:
 561:setup.c       **** 	}
 562:setup.c       **** 	_delay_ms(20); // Wait sector program time
 563:setup.c       **** }
 1432               		.loc 1 563 0
 1433 0456 DF91      		pop r29
 1434 0458 CF91      		pop r28
 1435               	.LVL104:
 1436 045a 1F91      		pop r17
 1437 045c 0F91      		pop r16
 1438 045e FF90      		pop r15
 1439 0460 EF90      		pop r14
 1440 0462 0895      		ret
 1441               		.cfi_endproc
 1442               	.LFE33:
 1444               	.global	setup
 1446               	setup:
 1447               	.LFB34:
 564:setup.c       **** 
 565:setup.c       **** // Setup
 566:setup.c       **** void setup(void) {
 1448               		.loc 1 566 0
 1449               		.cfi_startproc
 1450               	/* prologue: function */
 1451               	/* frame size = 0 */
 1452               	/* stack size = 0 */
 1453               	.L__stack_usage = 0
 567:setup.c       **** 	// Reset common lines
 568:setup.c       **** 	rd_wr_csmreq_cs2_reset();
 1454               		.loc 1 568 0
 1455 0464 0E94 0000 		call rd_wr_csmreq_cs2_reset
 1456               	.LVL105:
 569:setup.c       **** 	
 570:setup.c       **** 	// Set outputs
 571:setup.c       **** 	DDRD |= (1<<LED) | (1<<WR_PIN) | (1<<RD_PIN) | (1<<CS_MREQ_PIN) | (1<<CS2_PIN);
 1457               		.loc 1 571 0
 1458 0468 81B3      		in r24,0x11
 1459 046a 886F      		ori r24,lo8(-8)
 1460 046c 81BB      		out 0x11,r24
 572:setup.c       **** 	
 573:setup.c       **** 	// Set all pins as inputs
 574:setup.c       **** 	PORT_DATA7_0 = 0;
 1461               		.loc 1 574 0
 1462 046e 15BA      		out 0x15,__zero_reg__
 575:setup.c       **** 	DDR_DATA7_0 = 0;
 1463               		.loc 1 575 0
 1464 0470 14BA      		out 0x14,__zero_reg__
 576:setup.c       **** 	PORT_ADDR7_0 = 0;
 1465               		.loc 1 576 0
 1466 0472 18BA      		out 0x18,__zero_reg__
 577:setup.c       **** 	DDR_ADDR7_0 = 0;
 1467               		.loc 1 577 0
 1468 0474 17BA      		out 0x17,__zero_reg__
 578:setup.c       **** 	PORT_ADDR15_8 = 0;
 1469               		.loc 1 578 0
 1470 0476 1BBA      		out 0x1b,__zero_reg__
 579:setup.c       **** 	DDR_ADDR15_8 = 0;
 1471               		.loc 1 579 0
 1472 0478 1ABA      		out 0x1a,__zero_reg__
 580:setup.c       **** 	
 581:setup.c       **** 	// Light LED
 582:setup.c       **** 	PORTD |= (1<<LED);
 1473               		.loc 1 582 0
 1474 047a 939A      		sbi 0x12,3
 1475               	.LVL106:
 1476               	.LBB57:
 1477               	.LBB58:
 163:c:\winavr-20100110\avr\include\util\delay.h **** 
 1478               		.loc 2 163 0
 1479 047c 2FEF      		ldi r18,lo8(799999)
 1480 047e 84E3      		ldi r24,hi8(799999)
 1481 0480 9CE0      		ldi r25,hlo8(799999)
 1482 0482 2150      		1: subi r18,1
 1483 0484 8040      		sbci r24,0
 1484 0486 9040      		sbci r25,0
 1485 0488 01F4      		brne 1b
 1486 048a 00C0      		rjmp .
 1487 048c 0000      		nop
 1488               	.LBE58:
 1489               	.LBE57:
 583:setup.c       **** 	_delay_ms(500);
 584:setup.c       **** 	PORTD &= ~(1<<LED);
 1490               		.loc 1 584 0
 1491 048e 9398      		cbi 0x12,3
 585:setup.c       **** 	
 586:setup.c       **** 	// Setup USART
 587:setup.c       **** 	UBRRL = 0; // 1Mbps Baud rate
 1492               		.loc 1 587 0
 1493 0490 19B8      		out 0x9,__zero_reg__
 588:setup.c       **** 	sbi(UCSRA, U2X); // Double rate
 1494               		.loc 1 588 0
 1495 0492 599A      		sbi 0xb,1
 589:setup.c       **** 	sbi(UCSRB, TXEN); // Transmitter enable
 1496               		.loc 1 589 0
 1497 0494 539A      		sbi 0xa,3
 590:setup.c       **** 	sbi(UCSRB, RXEN); // Receiver enable
 1498               		.loc 1 590 0
 1499 0496 549A      		sbi 0xa,4
 591:setup.c       **** 	
 592:setup.c       **** 	// Turn on interrupts
 593:setup.c       **** 	sei();
 1500               		.loc 1 593 0
 1501               	/* #APP */
 1502               	 ;  593 "setup.c" 1
 1503 0498 7894      		sei
 1504               	 ;  0 "" 2
 1505               	/* #NOAPP */
 1506 049a 0895      		ret
 1507               		.cfi_endproc
 1508               	.LFE34:
 1510               		.section	.text.startup,"ax",@progbits
 1511               	.global	main
 1513               	main:
 1514               	.LFB35:
 1515               		.file 3 "main.c"
   1:main.c        **** /*
   2:main.c        ****  GBxCart RW
   3:main.c        ****  Version: 1.0
   4:main.c        ****  Author: Alex from insideGadgets (www.insidegadgets.com)
   5:main.c        ****  Created: 7/11/2016
   6:main.c        ****  Last Modified: 11/03/2017
   7:main.c        ****  
   8:main.c        ****  GBxCart RW allows you to dump your Gameboy/Gameboy Colour/Gameboy Advance games ROM, save the RAM 
   9:main.c        ****  
  10:main.c        ****  The ATmega32A talks to the cartridge and interfaces with the CH340G serial to USB converter with t
  11:main.c        ****  
  12:main.c        ****  Remember to change your fuse bits so the ATmega32A uses an external 8MHz crystal, divide clock by 
  13:main.c        ****  avrdude -c usbtiny -p atmega32 -U lfuse:w:0xef:m -U hfuse:w:0xd9:m
  14:main.c        ****  
  15:main.c        ****  */
  16:main.c        **** 
  17:main.c        **** // ATmega32A Pin Map
  18:main.c        **** //
  19:main.c        **** // VCC (5, 17, 38)		GND (6, 18, 28, 39)		AVCC (27)				XTAL (7 ,8)		LED PD3 (12)		Switch sense PD2 (
  20:main.c        **** // SCK PB7 (3)				MOSI PB5 (1)				MISO PB6 (2)			RST (4)			RXD PD0 (9)			TXD PD1 (10)
  21:main.c        **** // 
  22:main.c        **** // Gameboy / Gameboy Colour
  23:main.c        **** // A0-A7 PB0-7 (40-44, 1-3) 		A8-A15 PA0-7 (37-30)			D0-D7 PC0-7 (19-26)
  24:main.c        **** // 
  25:main.c        **** // Gameboy Advance
  26:main.c        **** // AD0-AD7 PB0-7 (40-44, 1-3) 	AD8-AD15 PA0-7 (37-30)		A16-23 / D0-D7 PC0-7 (19-26)
  27:main.c        **** // *WR PD4 (13)						*RD PD5 (14)					*MREQ/CS PD6 (15)			CS2/RST PD7 (16)
  28:main.c        **** 
  29:main.c        **** #define F_CPU 8000000 // 8 MHz
  30:main.c        **** #define BUILD 1
  31:main.c        **** 
  32:main.c        **** #include <avr/io.h>
  33:main.c        **** #include <avr/wdt.h>
  34:main.c        **** #include <avr/eeprom.h>
  35:main.c        **** #include <avr/interrupt.h>
  36:main.c        **** #include <avr/sleep.h>
  37:main.c        **** #include <util/delay.h>
  38:main.c        **** #include <stdlib.h>
  39:main.c        **** #include <string.h>
  40:main.c        **** #include "setup.c" // See defines, variables, constants, functions here
  41:main.c        **** 
  42:main.c        **** 
  43:main.c        **** int main(void) {
 1516               		.loc 3 43 0
 1517               		.cfi_startproc
 1518 0000 CF93      		push r28
 1519               	.LCFI31:
 1520               		.cfi_def_cfa_offset 3
 1521               		.cfi_offset 28, -2
 1522 0002 DF93      		push r29
 1523               	.LCFI32:
 1524               		.cfi_def_cfa_offset 4
 1525               		.cfi_offset 29, -3
 1526 0004 1F92      		push __zero_reg__
 1527               	.LCFI33:
 1528               		.cfi_def_cfa_offset 5
 1529 0006 CDB7      		in r28,__SP_L__
 1530 0008 DEB7      		in r29,__SP_H__
 1531               	.LCFI34:
 1532               		.cfi_def_cfa_register 28
 1533               	/* prologue: function */
 1534               	/* frame size = 1 */
 1535               	/* stack size = 3 */
 1536               	.L__stack_usage = 3
  44:main.c        **** 	setup();
 1537               		.loc 3 44 0
 1538 000a 0E94 0000 		call setup
 1539               	.LVL107:
  45:main.c        **** 	
  46:main.c        **** 	uint32_t address = 0;
  47:main.c        **** 	uint8_t eepromSize = EEPROM_4KBIT;
  48:main.c        **** 	uint8_t cartMode = GB_MODE;
  49:main.c        **** 	uint8_t resetCommonLines = 1;
 1540               		.loc 3 49 0
 1541 000e 6624      		clr r6
 1542 0010 6394      		inc r6
  47:main.c        **** 	uint8_t cartMode = GB_MODE;
 1543               		.loc 3 47 0
 1544 0012 7724      		clr r7
 1545 0014 7394      		inc r7
  46:main.c        **** 	uint8_t eepromSize = EEPROM_4KBIT;
 1546               		.loc 3 46 0
 1547 0016 C12C      		mov r12,__zero_reg__
 1548 0018 D12C      		mov r13,__zero_reg__
 1549 001a 7601      		movw r14,r12
 1550               	.LVL108:
 1551               	.L69:
  50:main.c        **** 	
  51:main.c        **** 	while(1) {
  52:main.c        **** 		if (resetCommonLines == 1) {
 1552               		.loc 3 52 0
 1553 001c 81E0      		ldi r24,lo8(1)
 1554 001e 6812      		cpse r6,r24
 1555 0020 00C0      		rjmp .L70
 1556               	.LVL109:
 1557               	.L148:
  53:main.c        **** 			rd_wr_csmreq_cs2_reset();
 1558               		.loc 3 53 0
 1559 0022 0E94 0000 		call rd_wr_csmreq_cs2_reset
 1560               	.LVL110:
 1561               	.L70:
  54:main.c        **** 		}
  55:main.c        **** 		receivedChar = USART_Receive(); // Wait for 1 byte of data
 1562               		.loc 3 55 0
 1563 0026 0E94 0000 		call USART_Receive
 1564               	.LVL111:
 1565 002a 8093 0000 		sts receivedChar,r24
  56:main.c        **** 		
  57:main.c        **** 		// Read the pin to find out which mode we are in, if high (3.3V), we are powered by 5V
  58:main.c        **** 		if (PIND & (1<<SWITCH_DETECT)) {
 1566               		.loc 3 58 0
 1567 002e 829B      		sbis 0x10,2
 1568 0030 00C0      		rjmp .L142
  59:main.c        **** 			cartMode = GB_MODE;
 1569               		.loc 3 59 0
 1570 0032 91E0      		ldi r25,lo8(1)
 1571 0034 00C0      		rjmp .L71
 1572               	.L142:
  60:main.c        **** 		}
  61:main.c        **** 		else {
  62:main.c        **** 			cartMode = GBA_MODE;
 1573               		.loc 3 62 0
 1574 0036 92E0      		ldi r25,lo8(2)
 1575               	.L71:
 1576               	.LVL112:
  63:main.c        **** 		}
  64:main.c        **** 		
  65:main.c        **** 		// Return the cart mode in use
  66:main.c        **** 		if (receivedChar == CART_MODE) {
 1577               		.loc 3 66 0
 1578 0038 8334      		cpi r24,lo8(67)
 1579 003a 01F4      		brne .L72
  67:main.c        **** 			USART_Transmit(cartMode);
 1580               		.loc 3 67 0
 1581 003c 892F      		mov r24,r25
 1582 003e 00C0      		rjmp .L153
 1583               	.L72:
  68:main.c        **** 		}
  69:main.c        **** 		
  70:main.c        **** 		// Change to GB mode or GBA mode if requested
  71:main.c        **** 		else if (receivedChar == GB_CART_MODE) {
 1584               		.loc 3 71 0
 1585 0040 8734      		cpi r24,lo8(71)
 1586 0042 01F4      		brne .L74
  72:main.c        **** 			gb_mode();
 1587               		.loc 3 72 0
 1588 0044 0E94 0000 		call gb_mode
 1589               	.LVL113:
 1590 0048 00C0      		rjmp .L73
 1591               	.LVL114:
 1592               	.L74:
  73:main.c        **** 		}
  74:main.c        **** 		else if (receivedChar == GBA_CART_MODE) {
 1593               		.loc 3 74 0
 1594 004a 8736      		cpi r24,lo8(103)
 1595 004c 01F4      		brne .+2
 1596 004e 00C0      		rjmp .L155
  75:main.c        **** 			gba_mode();
  76:main.c        **** 		}
  77:main.c        **** 		
  78:main.c        **** 		// Set address
  79:main.c        **** 		else if (receivedChar == SET_START_ADDRESS) {
 1597               		.loc 3 79 0
 1598 0050 8134      		cpi r24,lo8(65)
 1599 0052 01F4      		brne .L76
  80:main.c        **** 			usart_read_chars(); // Read start address
 1600               		.loc 3 80 0
 1601 0054 0E94 0000 		call usart_read_chars
 1602               	.LVL115:
  81:main.c        **** 			address = strtol(receivedBuffer, NULL, 16); // Convert address string in hex to dec
 1603               		.loc 3 81 0
 1604 0058 40E1      		ldi r20,lo8(16)
 1605 005a 50E0      		ldi r21,0
 1606 005c 60E0      		ldi r22,0
 1607 005e 70E0      		ldi r23,0
 1608 0060 80E0      		ldi r24,lo8(receivedBuffer)
 1609 0062 90E0      		ldi r25,hi8(receivedBuffer)
 1610 0064 0E94 0000 		call strtol
 1611               	.LVL116:
 1612 0068 6B01      		movw r12,r22
 1613 006a 7C01      		movw r14,r24
 1614               	.LVL117:
 1615 006c 00C0      		rjmp .L73
 1616               	.LVL118:
 1617               	.L76:
  82:main.c        **** 		}
  83:main.c        **** 		
  84:main.c        **** 		
  85:main.c        **** 		// ****** Gameboy / Gameboy Colour ******
  86:main.c        **** 		
  87:main.c        **** 		// Read 64 bytes of ROM/RAM from address (and increment) until anything but 1 is received
  88:main.c        **** 		else if (receivedChar == READ_ROM_RAM) {
 1618               		.loc 3 88 0
 1619 006e 8235      		cpi r24,lo8(82)
 1620 0070 01F4      		brne .L77
  89:main.c        **** 			gb_mode();
 1621               		.loc 3 89 0
 1622 0072 0E94 0000 		call gb_mode
 1623               	.LVL119:
  90:main.c        **** 			receivedChar = '1';
 1624               		.loc 3 90 0
 1625 0076 81E3      		ldi r24,lo8(49)
 1626               	.LVL120:
 1627               	.L150:
  91:main.c        **** 			while (receivedChar == '1') {
  92:main.c        **** 				PORTD |= (1<<LED);
  93:main.c        **** 				for (uint8_t x = 0; x < 64; x++) {
  94:main.c        **** 					USART_Transmit(read_8bit_data(address));
  95:main.c        **** 					address++;
  96:main.c        **** 				}
  97:main.c        **** 				
  98:main.c        **** 				PORTD &= ~(1<<LED);
  99:main.c        **** 				receivedChar = USART_Receive();
 1628               		.loc 3 99 0
 1629 0078 8093 0000 		sts receivedChar,r24
 1630               	.LVL121:
  91:main.c        **** 			while (receivedChar == '1') {
 1631               		.loc 3 91 0
 1632 007c 8091 0000 		lds r24,receivedChar
 1633 0080 8133      		cpi r24,lo8(49)
 1634 0082 01F0      		breq .+2
 1635 0084 00C0      		rjmp .L73
  92:main.c        **** 				for (uint8_t x = 0; x < 64; x++) {
 1636               		.loc 3 92 0
 1637 0086 939A      		sbi 0x12,3
 1638               	.LVL122:
 1639 0088 A12C      		mov r10,__zero_reg__
 1640 008a B12C      		mov r11,__zero_reg__
 1641               	.LVL123:
 1642               	.L80:
 1643 008c C501      		movw r24,r10
 1644 008e 8C0D      		add r24,r12
 1645 0090 9D1D      		adc r25,r13
 1646               	.LBB59:
  94:main.c        **** 					address++;
 1647               		.loc 3 94 0 discriminator 2
 1648 0092 0E94 0000 		call read_8bit_data
 1649               	.LVL124:
 1650 0096 0E94 0000 		call USART_Transmit
 1651               	.LVL125:
 1652 009a 9FEF      		ldi r25,-1
 1653 009c A91A      		sub r10,r25
 1654 009e B90A      		sbc r11,r25
 1655               	.LVL126:
  93:main.c        **** 					USART_Transmit(read_8bit_data(address));
 1656               		.loc 3 93 0 discriminator 2
 1657 00a0 E0E4      		ldi r30,64
 1658 00a2 AE16      		cp r10,r30
 1659 00a4 B104      		cpc r11,__zero_reg__
 1660 00a6 01F4      		brne .L80
 1661 00a8 F0E4      		ldi r31,64
 1662 00aa CF0E      		add r12,r31
 1663 00ac D11C      		adc r13,__zero_reg__
 1664 00ae E11C      		adc r14,__zero_reg__
 1665 00b0 F11C      		adc r15,__zero_reg__
 1666               	.LBE59:
  98:main.c        **** 				receivedChar = USART_Receive();
 1667               		.loc 3 98 0
 1668 00b2 9398      		cbi 0x12,3
 1669               		.loc 3 99 0
 1670 00b4 0E94 0000 		call USART_Receive
 1671               	.LVL127:
 1672 00b8 00C0      		rjmp .L150
 1673               	.LVL128:
 1674               	.L77:
 100:main.c        **** 			}
 101:main.c        **** 		}
 102:main.c        **** 		
 103:main.c        **** 		// Write 64 bytes to RAM on address (and increment)
 104:main.c        **** 		else if (receivedChar == WRITE_RAM) {
 1675               		.loc 3 104 0
 1676 00ba 8735      		cpi r24,lo8(87)
 1677 00bc 01F4      		brne .L82
 105:main.c        **** 			gb_mode();
 1678               		.loc 3 105 0
 1679 00be 0E94 0000 		call gb_mode
 1680               	.LVL129:
 106:main.c        **** 			
 107:main.c        **** 			// Read 64 bytes first as CH340G sends them all at once
 108:main.c        **** 			usart_read_bytes(64);
 1681               		.loc 3 108 0
 1682 00c2 80E4      		ldi r24,lo8(64)
 1683 00c4 0E94 0000 		call usart_read_bytes
 1684               	.LVL130:
 109:main.c        **** 			
 110:main.c        **** 			PORTD |= (1<<LED);
 1685               		.loc 3 110 0
 1686 00c8 939A      		sbi 0x12,3
 1687               	.LVL131:
 1688 00ca 00E0      		ldi r16,lo8(receivedBuffer)
 1689 00cc 10E0      		ldi r17,hi8(receivedBuffer)
 1690 00ce A12C      		mov r10,__zero_reg__
 1691 00d0 B12C      		mov r11,__zero_reg__
 1692               	.LVL132:
 1693               	.L84:
 1694               	.LBB60:
 111:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 112:main.c        **** 				write_8bit_data(address, receivedBuffer[x], MEMORY_WRITE);
 1695               		.loc 3 112 0 discriminator 2
 1696 00d2 F801      		movw r30,r16
 1697 00d4 6191      		ld r22,Z+
 1698 00d6 8F01      		movw r16,r30
 1699 00d8 C501      		movw r24,r10
 1700 00da 8C0D      		add r24,r12
 1701 00dc 9D1D      		adc r25,r13
 1702 00de 41E0      		ldi r20,lo8(1)
 1703 00e0 0E94 0000 		call write_8bit_data
 1704               	.LVL133:
 1705 00e4 FFEF      		ldi r31,-1
 1706 00e6 AF1A      		sub r10,r31
 1707 00e8 BF0A      		sbc r11,r31
 1708               	.LVL134:
 111:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 1709               		.loc 3 111 0 discriminator 2
 1710 00ea 80E4      		ldi r24,64
 1711 00ec A816      		cp r10,r24
 1712 00ee B104      		cpc r11,__zero_reg__
 1713 00f0 01F4      		brne .L84
 1714 00f2 90E4      		ldi r25,64
 1715 00f4 C90E      		add r12,r25
 1716 00f6 D11C      		adc r13,__zero_reg__
 1717 00f8 E11C      		adc r14,__zero_reg__
 1718 00fa F11C      		adc r15,__zero_reg__
 1719               	.LBE60:
 113:main.c        **** 				address++;
 114:main.c        **** 			}
 115:main.c        **** 			
 116:main.c        **** 			PORTD &= ~(1<<LED);
 1720               		.loc 3 116 0
 1721 00fc 9398      		cbi 0x12,3
 117:main.c        **** 			USART_Transmit('1'); // Send back acknowledgement
 1722               		.loc 3 117 0
 1723 00fe 81E3      		ldi r24,lo8(49)
 1724               	.LVL135:
 1725               	.L153:
 1726 0100 0E94 0000 		call USART_Transmit
 1727               	.LVL136:
 1728 0104 00C0      		rjmp .L73
 1729               	.LVL137:
 1730               	.L82:
 118:main.c        **** 		}
 119:main.c        **** 		
 120:main.c        **** 		// Set bank address and write a byte
 121:main.c        **** 		else if (receivedChar == SET_BANK) {
 1731               		.loc 3 121 0
 1732 0106 8234      		cpi r24,lo8(66)
 1733 0108 01F4      		brne .L85
 1734               	.LBB61:
 122:main.c        **** 			gb_mode();
 1735               		.loc 3 122 0
 1736 010a 0E94 0000 		call gb_mode
 1737               	.LVL138:
 123:main.c        **** 			
 124:main.c        **** 			usart_read_chars(); // Read start address
 1738               		.loc 3 124 0
 1739 010e 0E94 0000 		call usart_read_chars
 1740               	.LVL139:
 125:main.c        **** 			uint16_t bankaddress = strtol(receivedBuffer, NULL, 16); // Convert address string in hex to dec
 1741               		.loc 3 125 0
 1742 0112 40E1      		ldi r20,lo8(16)
 1743 0114 50E0      		ldi r21,0
 1744 0116 60E0      		ldi r22,0
 1745 0118 70E0      		ldi r23,0
 1746 011a 80E0      		ldi r24,lo8(receivedBuffer)
 1747 011c 90E0      		ldi r25,hi8(receivedBuffer)
 1748 011e 0E94 0000 		call strtol
 1749               	.LVL140:
 1750 0122 4B01      		movw r8,r22
 1751 0124 5C01      		movw r10,r24
 1752               	.LVL141:
 126:main.c        **** 			
 127:main.c        **** 			receivedChar = USART_Receive(); // Wait for bank number
 1753               		.loc 3 127 0
 1754 0126 0E94 0000 		call USART_Receive
 1755               	.LVL142:
 1756 012a 8093 0000 		sts receivedChar,r24
 128:main.c        **** 			if (receivedChar == 'B') {
 1757               		.loc 3 128 0
 1758 012e 8234      		cpi r24,lo8(66)
 1759 0130 01F0      		breq .+2
 1760 0132 00C0      		rjmp .L73
 1761               	.LBB62:
 129:main.c        **** 				usart_read_chars(); // Read data
 1762               		.loc 3 129 0
 1763 0134 0E94 0000 		call usart_read_chars
 1764               	.LVL143:
 130:main.c        **** 				uint8_t data = atoi(receivedBuffer); // Convert data string to dec
 1765               		.loc 3 130 0
 1766 0138 80E0      		ldi r24,lo8(receivedBuffer)
 1767 013a 90E0      		ldi r25,hi8(receivedBuffer)
 1768 013c 0E94 0000 		call atoi
 1769               	.LVL144:
 131:main.c        **** 				
 132:main.c        **** 				write_8bit_data(bankaddress, data, BANK_WRITE);
 1770               		.loc 3 132 0
 1771 0140 40E0      		ldi r20,0
 1772 0142 682F      		mov r22,r24
 1773 0144 C401      		movw r24,r8
 1774               	.LVL145:
 1775 0146 0E94 0000 		call write_8bit_data
 1776               	.LVL146:
 1777 014a 00C0      		rjmp .L73
 1778               	.LVL147:
 1779               	.L85:
 1780               	.LBE62:
 1781               	.LBE61:
 133:main.c        **** 			}
 134:main.c        **** 		}
 135:main.c        **** 		
 136:main.c        **** 		
 137:main.c        **** 		// ****** Gameboy Advance ******
 138:main.c        **** 		
 139:main.c        **** 		// ---------- ROM ----------
 140:main.c        **** 		// Read one 16bit byte from ROM using address (and increment) until anything but 1 is received
 141:main.c        **** 		else if (receivedChar == GBA_READ_ROM) {
 1782               		.loc 3 141 0
 1783 014c 8237      		cpi r24,lo8(114)
 1784 014e 01F4      		brne .L86
 142:main.c        **** 			gba_mode(); 
 1785               		.loc 3 142 0
 1786 0150 0E94 0000 		call gba_mode
 1787               	.LVL148:
 143:main.c        **** 			
 144:main.c        **** 			receivedChar = '1';
 1788               		.loc 3 144 0
 1789 0154 81E3      		ldi r24,lo8(49)
 1790               	.LVL149:
 1791               	.L151:
 145:main.c        **** 			while (receivedChar == '1') {
 146:main.c        **** 				PORTD |= (1<<LED);
 147:main.c        **** 				for (uint8_t x = 0; x < 32; x++) {
 148:main.c        **** 					uint16_t dataRead = gba_read_16bit_data(address);
 149:main.c        **** 					
 150:main.c        **** 					// Low byte & High byte
 151:main.c        **** 					USART_Transmit(dataRead & 0xFF);
 152:main.c        **** 					USART_Transmit(dataRead >> 8);
 153:main.c        **** 					
 154:main.c        **** 					address++;
 155:main.c        **** 				}
 156:main.c        **** 				
 157:main.c        **** 				PORTD &= ~(1<<LED);
 158:main.c        **** 				receivedChar = USART_Receive();
 1792               		.loc 3 158 0
 1793 0156 8093 0000 		sts receivedChar,r24
 1794               	.LVL150:
 145:main.c        **** 			while (receivedChar == '1') {
 1795               		.loc 3 145 0
 1796 015a 8091 0000 		lds r24,receivedChar
 1797 015e 8133      		cpi r24,lo8(49)
 1798 0160 01F0      		breq .+2
 1799 0162 00C0      		rjmp .L73
 146:main.c        **** 				for (uint8_t x = 0; x < 32; x++) {
 1800               		.loc 3 146 0
 1801 0164 939A      		sbi 0x12,3
 1802               	.LVL151:
 1803 0166 4601      		movw r8,r12
 1804 0168 5701      		movw r10,r14
 1805 016a 10E2      		ldi r17,lo8(32)
 1806 016c 1C0D      		add r17,r12
 1807               	.LVL152:
 1808               	.L89:
 1809               	.LBB63:
 1810               	.LBB64:
 148:main.c        **** 					
 1811               		.loc 3 148 0 discriminator 2
 1812 016e C501      		movw r24,r10
 1813 0170 B401      		movw r22,r8
 1814 0172 0E94 0000 		call gba_read_16bit_data
 1815               	.LVL153:
 151:main.c        **** 					USART_Transmit(dataRead >> 8);
 1816               		.loc 3 151 0 discriminator 2
 1817 0176 9983      		std Y+1,r25
 1818 0178 0E94 0000 		call USART_Transmit
 1819               	.LVL154:
 152:main.c        **** 					
 1820               		.loc 3 152 0 discriminator 2
 1821 017c 9981      		ldd r25,Y+1
 1822 017e 892F      		mov r24,r25
 1823 0180 0E94 0000 		call USART_Transmit
 1824               	.LVL155:
 154:main.c        **** 				}
 1825               		.loc 3 154 0 discriminator 2
 1826 0184 EFEF      		ldi r30,-1
 1827 0186 8E1A      		sub r8,r30
 1828 0188 9E0A      		sbc r9,r30
 1829 018a AE0A      		sbc r10,r30
 1830 018c BE0A      		sbc r11,r30
 1831               	.LVL156:
 1832               	.LBE64:
 147:main.c        **** 					uint16_t dataRead = gba_read_16bit_data(address);
 1833               		.loc 3 147 0 discriminator 2
 1834 018e 1811      		cpse r17,r8
 1835 0190 00C0      		rjmp .L89
 1836 0192 F0E2      		ldi r31,32
 1837 0194 CF0E      		add r12,r31
 1838 0196 D11C      		adc r13,__zero_reg__
 1839 0198 E11C      		adc r14,__zero_reg__
 1840 019a F11C      		adc r15,__zero_reg__
 1841               	.LVL157:
 1842               	.LBE63:
 157:main.c        **** 				receivedChar = USART_Receive();
 1843               		.loc 3 157 0
 1844 019c 9398      		cbi 0x12,3
 1845               		.loc 3 158 0
 1846 019e 0E94 0000 		call USART_Receive
 1847               	.LVL158:
 1848 01a2 00C0      		rjmp .L151
 1849               	.LVL159:
 1850               	.L86:
 159:main.c        **** 			}
 160:main.c        **** 		}
 161:main.c        **** 		
 162:main.c        **** 		
 163:main.c        **** 		// ---------- SRAM ----------
 164:main.c        **** 		// Read RAM from address (and increment) until anything but 1 is received
 165:main.c        **** 		else if (receivedChar == GBA_READ_SRAM) {
 1851               		.loc 3 165 0
 1852 01a4 8D36      		cpi r24,lo8(109)
 1853 01a6 01F4      		brne .L91
 166:main.c        **** 			gb_mode(); // Set GB mode as it uses 16 bit address with 8 bit data
 1854               		.loc 3 166 0
 1855 01a8 0E94 0000 		call gb_mode
 1856               	.LVL160:
 167:main.c        **** 			
 168:main.c        **** 			receivedChar = '1';
 1857               		.loc 3 168 0
 1858 01ac 81E3      		ldi r24,lo8(49)
 1859               	.LVL161:
 1860               	.L152:
 169:main.c        **** 			while (receivedChar == '1') {
 170:main.c        **** 				PORTD |= (1<<LED);
 171:main.c        **** 				for (uint8_t x = 0; x < 64; x++) {
 172:main.c        **** 					USART_Transmit(gba_read_ram_8bit_data(address));
 173:main.c        **** 					address++;
 174:main.c        **** 				}
 175:main.c        **** 				
 176:main.c        **** 				PORTD &= ~(1<<LED);
 177:main.c        **** 				receivedChar = USART_Receive();
 1861               		.loc 3 177 0
 1862 01ae 8093 0000 		sts receivedChar,r24
 1863               	.LVL162:
 169:main.c        **** 			while (receivedChar == '1') {
 1864               		.loc 3 169 0
 1865 01b2 8091 0000 		lds r24,receivedChar
 1866 01b6 8133      		cpi r24,lo8(49)
 1867 01b8 01F0      		breq .+2
 1868 01ba 00C0      		rjmp .L155
 170:main.c        **** 				for (uint8_t x = 0; x < 64; x++) {
 1869               		.loc 3 170 0
 1870 01bc 939A      		sbi 0x12,3
 1871               	.LVL163:
 1872 01be A12C      		mov r10,__zero_reg__
 1873 01c0 B12C      		mov r11,__zero_reg__
 1874               	.LVL164:
 1875               	.L94:
 1876 01c2 C501      		movw r24,r10
 1877 01c4 8C0D      		add r24,r12
 1878 01c6 9D1D      		adc r25,r13
 1879               	.LBB65:
 172:main.c        **** 					address++;
 1880               		.loc 3 172 0 discriminator 2
 1881 01c8 0E94 0000 		call gba_read_ram_8bit_data
 1882               	.LVL165:
 1883 01cc 0E94 0000 		call USART_Transmit
 1884               	.LVL166:
 1885 01d0 8FEF      		ldi r24,-1
 1886 01d2 A81A      		sub r10,r24
 1887 01d4 B80A      		sbc r11,r24
 1888               	.LVL167:
 171:main.c        **** 					USART_Transmit(gba_read_ram_8bit_data(address));
 1889               		.loc 3 171 0 discriminator 2
 1890 01d6 90E4      		ldi r25,64
 1891 01d8 A916      		cp r10,r25
 1892 01da B104      		cpc r11,__zero_reg__
 1893 01dc 01F4      		brne .L94
 1894 01de E0E4      		ldi r30,64
 1895 01e0 CE0E      		add r12,r30
 1896 01e2 D11C      		adc r13,__zero_reg__
 1897 01e4 E11C      		adc r14,__zero_reg__
 1898 01e6 F11C      		adc r15,__zero_reg__
 1899               	.LBE65:
 176:main.c        **** 				receivedChar = USART_Receive();
 1900               		.loc 3 176 0
 1901 01e8 9398      		cbi 0x12,3
 1902               		.loc 3 177 0
 1903 01ea 0E94 0000 		call USART_Receive
 1904               	.LVL168:
 1905 01ee 00C0      		rjmp .L152
 1906               	.LVL169:
 1907               	.L91:
 178:main.c        **** 			}
 179:main.c        **** 			
 180:main.c        **** 			gba_mode(); // Set back
 181:main.c        **** 		}
 182:main.c        **** 		
 183:main.c        **** 		// Write to RAM on address (and increment) with 64 bytes of data
 184:main.c        **** 		else if (receivedChar == GBA_WRITE_SRAM) {
 1908               		.loc 3 184 0
 1909 01f0 8737      		cpi r24,lo8(119)
 1910 01f2 01F4      		brne .L96
 185:main.c        **** 			gb_mode();
 1911               		.loc 3 185 0
 1912 01f4 0E94 0000 		call gb_mode
 1913               	.LVL170:
 186:main.c        **** 			
 187:main.c        **** 			usart_read_bytes(64);
 1914               		.loc 3 187 0
 1915 01f8 80E4      		ldi r24,lo8(64)
 1916 01fa 0E94 0000 		call usart_read_bytes
 1917               	.LVL171:
 188:main.c        **** 			
 189:main.c        **** 			PORTD |= (1<<LED);
 1918               		.loc 3 189 0
 1919 01fe 939A      		sbi 0x12,3
 1920               	.LVL172:
 1921 0200 00E0      		ldi r16,lo8(receivedBuffer)
 1922 0202 10E0      		ldi r17,hi8(receivedBuffer)
 1923 0204 A12C      		mov r10,__zero_reg__
 1924 0206 B12C      		mov r11,__zero_reg__
 1925               	.LVL173:
 1926               	.L98:
 1927               	.LBB66:
 190:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 191:main.c        **** 				gba_write_ram_8bit_data(address, receivedBuffer[x]);
 1928               		.loc 3 191 0 discriminator 2
 1929 0208 F801      		movw r30,r16
 1930 020a 6191      		ld r22,Z+
 1931 020c 8F01      		movw r16,r30
 1932 020e C501      		movw r24,r10
 1933 0210 8C0D      		add r24,r12
 1934 0212 9D1D      		adc r25,r13
 1935 0214 0E94 0000 		call gba_write_ram_8bit_data
 1936               	.LVL174:
 1937 0218 FFEF      		ldi r31,-1
 1938 021a AF1A      		sub r10,r31
 1939 021c BF0A      		sbc r11,r31
 1940               	.LVL175:
 190:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 1941               		.loc 3 190 0 discriminator 2
 1942 021e 80E4      		ldi r24,64
 1943 0220 A816      		cp r10,r24
 1944 0222 B104      		cpc r11,__zero_reg__
 1945 0224 01F4      		brne .L98
 1946 0226 00C0      		rjmp .L158
 1947               	.LVL176:
 1948               	.L96:
 1949               	.LBE66:
 192:main.c        **** 				address++;
 193:main.c        **** 			}
 194:main.c        **** 			USART_Transmit('1'); // Send back acknowledgement
 195:main.c        **** 			
 196:main.c        **** 			PORTD &= ~(1<<LED);
 197:main.c        **** 			gba_mode(); // Set back
 198:main.c        **** 		}
 199:main.c        **** 		
 200:main.c        **** 		// 'o' - Write 1 byte to SRAM address
 201:main.c        **** 		else if (receivedChar == GBA_WRITE_ONE_BYTE_SRAM) {
 1950               		.loc 3 201 0
 1951 0228 8F36      		cpi r24,lo8(111)
 1952 022a 01F4      		brne .L99
 1953               	.LBB67:
 202:main.c        **** 			gb_mode();
 1954               		.loc 3 202 0
 1955 022c 0E94 0000 		call gb_mode
 1956               	.LVL177:
 203:main.c        **** 			
 204:main.c        **** 			uint8_t data = USART_Receive();
 1957               		.loc 3 204 0
 1958 0230 0E94 0000 		call USART_Receive
 1959               	.LVL178:
 205:main.c        **** 			gba_write_ram_8bit_data(address, data);
 1960               		.loc 3 205 0
 1961 0234 682F      		mov r22,r24
 1962 0236 C601      		movw r24,r12
 1963               	.LVL179:
 1964 0238 0E94 0000 		call gba_write_ram_8bit_data
 1965               	.LVL180:
 1966 023c 00C0      		rjmp .L160
 1967               	.LVL181:
 1968               	.L99:
 1969               	.LBE67:
 206:main.c        **** 			USART_Transmit('1'); // Send back acknowledgement
 207:main.c        **** 			
 208:main.c        **** 			gba_mode(); // Set back
 209:main.c        **** 		}
 210:main.c        **** 		
 211:main.c        **** 		
 212:main.c        **** 		// ---------- FLASH ----------
 213:main.c        **** 		// Read the Flash Manufacturer and Device ID
 214:main.c        **** 		else if (receivedChar == GBA_FLASH_READ_ID) {
 1970               		.loc 3 214 0
 1971 023e 8936      		cpi r24,lo8(105)
 1972 0240 01F4      		brne .L100
 215:main.c        **** 			gb_mode();
 1973               		.loc 3 215 0
 1974 0242 0E94 0000 		call gb_mode
 1975               	.LVL182:
 216:main.c        **** 			
 217:main.c        **** 			flash_read_chip_id();
 1976               		.loc 3 217 0
 1977 0246 0E94 0000 		call flash_read_chip_id
 1978               	.LVL183:
 218:main.c        **** 			USART_Transmit(flashChipIdBuffer[0]);
 1979               		.loc 3 218 0
 1980 024a 8091 0000 		lds r24,flashChipIdBuffer
 1981 024e 0E94 0000 		call USART_Transmit
 1982               	.LVL184:
 219:main.c        **** 			USART_Transmit(flashChipIdBuffer[1]);
 1983               		.loc 3 219 0
 1984 0252 8091 0000 		lds r24,flashChipIdBuffer+1
 1985 0256 00C0      		rjmp .L159
 1986               	.LVL185:
 1987               	.L100:
 220:main.c        **** 			
 221:main.c        **** 			gba_mode(); // Set back
 222:main.c        **** 		}
 223:main.c        **** 		
 224:main.c        **** 		// Change bank
 225:main.c        **** 		else if (receivedChar == GBA_FLASH_SET_BANK) {
 1988               		.loc 3 225 0
 1989 0258 8B36      		cpi r24,lo8(107)
 1990 025a 01F4      		brne .L101
 1991               	.LBB68:
 226:main.c        **** 			usart_read_chars(); // Read data
 1992               		.loc 3 226 0
 1993 025c 0E94 0000 		call usart_read_chars
 1994               	.LVL186:
 227:main.c        **** 			uint8_t bank = atoi(receivedBuffer); // Convert data string to dec
 1995               		.loc 3 227 0
 1996 0260 80E0      		ldi r24,lo8(receivedBuffer)
 1997 0262 90E0      		ldi r25,hi8(receivedBuffer)
 1998 0264 0E94 0000 		call atoi
 1999               	.LVL187:
 228:main.c        **** 			
 229:main.c        **** 			gb_mode();
 2000               		.loc 3 229 0
 2001 0268 8983      		std Y+1,r24
 2002 026a 0E94 0000 		call gb_mode
 2003               	.LVL188:
 230:main.c        **** 			flash_switch_bank(bank);
 2004               		.loc 3 230 0
 2005 026e 8981      		ldd r24,Y+1
 2006 0270 0E94 0000 		call flash_switch_bank
 2007               	.LVL189:
 2008 0274 00C0      		rjmp .L155
 2009               	.LVL190:
 2010               	.L101:
 2011               	.LBE68:
 231:main.c        **** 			
 232:main.c        **** 			gba_mode(); // Set back
 233:main.c        **** 		}
 234:main.c        **** 		
 235:main.c        **** 		// Erase 4K sector on Flash (sector 0 to 15 for 512Kbit)
 236:main.c        **** 		else if (receivedChar == GBA_FLASH_4K_SECTOR_ERASE) {
 2012               		.loc 3 236 0
 2013 0276 8337      		cpi r24,lo8(115)
 2014 0278 01F4      		brne .L102
 2015               	.LBB69:
 237:main.c        **** 			gb_mode();
 2016               		.loc 3 237 0
 2017 027a 0E94 0000 		call gb_mode
 2018               	.LVL191:
 238:main.c        **** 			
 239:main.c        **** 			usart_read_chars(); // Read sector
 2019               		.loc 3 239 0
 2020 027e 0E94 0000 		call usart_read_chars
 2021               	.LVL192:
 240:main.c        **** 			uint8_t sectorAddress = strtol(receivedBuffer, NULL, 16); // Convert address string in hex to de
 2022               		.loc 3 240 0
 2023 0282 40E1      		ldi r20,lo8(16)
 2024 0284 50E0      		ldi r21,0
 2025 0286 60E0      		ldi r22,0
 2026 0288 70E0      		ldi r23,0
 2027 028a 80E0      		ldi r24,lo8(receivedBuffer)
 2028 028c 90E0      		ldi r25,hi8(receivedBuffer)
 2029 028e 0E94 0000 		call strtol
 2030               	.LVL193:
 2031 0292 862F      		mov r24,r22
 2032               	.LVL194:
 241:main.c        **** 			
 242:main.c        **** 			flash_erase_4k_sector(sectorAddress);
 2033               		.loc 3 242 0
 2034 0294 0E94 0000 		call flash_erase_4k_sector
 2035               	.LVL195:
 2036               	.L160:
 243:main.c        **** 			USART_Transmit('1'); // Send back acknowledgement
 2037               		.loc 3 243 0
 2038 0298 81E3      		ldi r24,lo8(49)
 2039               	.L159:
 2040 029a 0E94 0000 		call USART_Transmit
 2041               	.LVL196:
 2042 029e 00C0      		rjmp .L155
 2043               	.LVL197:
 2044               	.L102:
 2045               	.LBE69:
 244:main.c        **** 			
 245:main.c        **** 			gba_mode(); // Set back
 246:main.c        **** 		}
 247:main.c        **** 		
 248:main.c        **** 		// Write 64 bytes to Flash address one byte write at a time (and increment)
 249:main.c        **** 		else if (receivedChar == GBA_FLASH_WRITE_BYTE) {
 2046               		.loc 3 249 0
 2047 02a0 8236      		cpi r24,lo8(98)
 2048 02a2 01F4      		brne .L103
 250:main.c        **** 			gb_mode();
 2049               		.loc 3 250 0
 2050 02a4 0E94 0000 		call gb_mode
 2051               	.LVL198:
 251:main.c        **** 			
 252:main.c        **** 			usart_read_bytes(64);
 2052               		.loc 3 252 0
 2053 02a8 80E4      		ldi r24,lo8(64)
 2054 02aa 0E94 0000 		call usart_read_bytes
 2055               	.LVL199:
 253:main.c        **** 			
 254:main.c        **** 			PORTD |= (1<<LED);
 2056               		.loc 3 254 0
 2057 02ae 939A      		sbi 0x12,3
 2058               	.LVL200:
 2059 02b0 00E0      		ldi r16,lo8(receivedBuffer)
 2060 02b2 10E0      		ldi r17,hi8(receivedBuffer)
 2061 02b4 A12C      		mov r10,__zero_reg__
 2062 02b6 B12C      		mov r11,__zero_reg__
 2063               	.LVL201:
 2064               	.L105:
 2065               	.LBB70:
 255:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 256:main.c        **** 				flash_write_byte(address, receivedBuffer[x]);
 2066               		.loc 3 256 0 discriminator 2
 2067 02b8 F801      		movw r30,r16
 2068 02ba 6191      		ld r22,Z+
 2069 02bc 8F01      		movw r16,r30
 2070 02be C501      		movw r24,r10
 2071 02c0 8C0D      		add r24,r12
 2072 02c2 9D1D      		adc r25,r13
 2073 02c4 0E94 0000 		call flash_write_byte
 2074               	.LVL202:
 2075 02c8 FFEF      		ldi r31,-1
 2076 02ca AF1A      		sub r10,r31
 2077 02cc BF0A      		sbc r11,r31
 2078               	.LVL203:
 255:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 2079               		.loc 3 255 0 discriminator 2
 2080 02ce 80E4      		ldi r24,64
 2081 02d0 A816      		cp r10,r24
 2082 02d2 B104      		cpc r11,__zero_reg__
 2083 02d4 01F4      		brne .L105
 2084               	.LVL204:
 2085               	.L158:
 2086 02d6 90E4      		ldi r25,64
 2087 02d8 C90E      		add r12,r25
 2088 02da D11C      		adc r13,__zero_reg__
 2089 02dc E11C      		adc r14,__zero_reg__
 2090 02de F11C      		adc r15,__zero_reg__
 2091 02e0 00C0      		rjmp .L154
 2092               	.LVL205:
 2093               	.L103:
 2094               	.LBE70:
 257:main.c        **** 				address++;
 258:main.c        **** 			}
 259:main.c        **** 			USART_Transmit('1'); // Send back acknowledgement
 260:main.c        **** 			
 261:main.c        **** 			PORTD &= ~(1<<LED);
 262:main.c        **** 			gba_mode(); // Set back
 263:main.c        **** 		}
 264:main.c        **** 		
 265:main.c        **** 		// Write 128 bytes to flash sector for Atmel flash (and increment)
 266:main.c        **** 		else if (receivedChar == GBA_FLASH_WRITE_ATMEL) {
 2095               		.loc 3 266 0
 2096 02e2 8136      		cpi r24,lo8(97)
 2097 02e4 01F4      		brne .L73
 267:main.c        **** 			gb_mode();
 2098               		.loc 3 267 0
 2099 02e6 0E94 0000 		call gb_mode
 2100               	.LVL206:
 268:main.c        **** 			
 269:main.c        **** 			usart_read_bytes(128);
 2101               		.loc 3 269 0
 2102 02ea 80E8      		ldi r24,lo8(-128)
 2103 02ec 0E94 0000 		call usart_read_bytes
 2104               	.LVL207:
 270:main.c        **** 			
 271:main.c        **** 			PORTD |= (1<<LED);
 2105               		.loc 3 271 0
 2106 02f0 939A      		sbi 0x12,3
 272:main.c        **** 			flash_write_sector(address); // Address used as sector number
 2107               		.loc 3 272 0
 2108 02f2 C601      		movw r24,r12
 2109 02f4 0E94 0000 		call flash_write_sector
 2110               	.LVL208:
 273:main.c        **** 			address++;
 2111               		.loc 3 273 0
 2112 02f8 EFEF      		ldi r30,-1
 2113 02fa CE1A      		sub r12,r30
 2114 02fc DE0A      		sbc r13,r30
 2115 02fe EE0A      		sbc r14,r30
 2116 0300 FE0A      		sbc r15,r30
 2117               	.LVL209:
 2118               	.L154:
 274:main.c        **** 			USART_Transmit('1'); // Send back acknowledgement
 2119               		.loc 3 274 0
 2120 0302 81E3      		ldi r24,lo8(49)
 2121 0304 0E94 0000 		call USART_Transmit
 2122               	.LVL210:
 275:main.c        **** 			
 276:main.c        **** 			PORTD &= ~(1<<LED);
 2123               		.loc 3 276 0
 2124 0308 9398      		cbi 0x12,3
 2125               	.L155:
 277:main.c        **** 			gba_mode(); // Set back
 2126               		.loc 3 277 0
 2127 030a 0E94 0000 		call gba_mode
 2128               	.LVL211:
 2129               	.L73:
 278:main.c        **** 		}
 279:main.c        **** 		
 280:main.c        **** 		
 281:main.c        **** 		// ---------- EEPROM ----------
 282:main.c        **** 		// Set EEPROM size
 283:main.c        **** 		if (receivedChar == GBA_SET_EEPROM_SIZE) {
 2130               		.loc 3 283 0
 2131 030e 8091 0000 		lds r24,receivedChar
 2132 0312 8335      		cpi r24,lo8(83)
 2133 0314 01F4      		brne .L106
 284:main.c        **** 			usart_read_chars(); // Read size
 2134               		.loc 3 284 0
 2135 0316 0E94 0000 		call usart_read_chars
 2136               	.LVL212:
 285:main.c        **** 			eepromSize = strtol(receivedBuffer, NULL, 16); // Convert size to dec
 2137               		.loc 3 285 0
 2138 031a 40E1      		ldi r20,lo8(16)
 2139 031c 50E0      		ldi r21,0
 2140 031e 60E0      		ldi r22,0
 2141 0320 70E0      		ldi r23,0
 2142 0322 80E0      		ldi r24,lo8(receivedBuffer)
 2143 0324 90E0      		ldi r25,hi8(receivedBuffer)
 2144 0326 0E94 0000 		call strtol
 2145               	.LVL213:
 2146 032a 762E      		mov r7,r22
 2147               	.LVL214:
 2148 032c 00C0      		rjmp .L69
 2149               	.L106:
 286:main.c        **** 		}
 287:main.c        **** 		
 288:main.c        **** 		// Read the EERPOM on address (and increment) until anything but 1 is received
 289:main.c        **** 		else if (receivedChar == GBA_READ_EEPROM) {
 2150               		.loc 3 289 0
 2151 032e 8536      		cpi r24,lo8(101)
 2152 0330 01F4      		brne .L108
 290:main.c        **** 			gba_eeprom_mode();
 2153               		.loc 3 290 0
 2154 0332 0E94 0000 		call gba_eeprom_mode
 2155               	.LVL215:
 291:main.c        **** 			
 292:main.c        **** 			receivedChar = '1';
 2156               		.loc 3 292 0
 2157 0336 81E3      		ldi r24,lo8(49)
 2158               	.L156:
 293:main.c        **** 			while (receivedChar == '1') {
 294:main.c        **** 				PORTD |= (1<<LED);
 295:main.c        **** 				gba_eeprom_read(address, eepromSize);
 296:main.c        **** 				
 297:main.c        **** 				// Send back the 8 bytes of data
 298:main.c        **** 				for (uint8_t c = 0; c < 8; c++) {
 299:main.c        **** 					USART_Transmit(eepromBuffer[c]);
 300:main.c        **** 				}
 301:main.c        **** 				address++; // Increment to next 8 bytes
 302:main.c        **** 				
 303:main.c        **** 				PORTD &= ~(1<<LED);
 304:main.c        **** 				receivedChar = USART_Receive();
 2159               		.loc 3 304 0
 2160 0338 8093 0000 		sts receivedChar,r24
 293:main.c        **** 			while (receivedChar == '1') {
 2161               		.loc 3 293 0
 2162 033c 8091 0000 		lds r24,receivedChar
 2163 0340 8133      		cpi r24,lo8(49)
 2164 0342 01F4      		brne .L149
 294:main.c        **** 				gba_eeprom_read(address, eepromSize);
 2165               		.loc 3 294 0
 2166 0344 939A      		sbi 0x12,3
 295:main.c        **** 				
 2167               		.loc 3 295 0
 2168 0346 672D      		mov r22,r7
 2169 0348 C601      		movw r24,r12
 2170 034a 0E94 0000 		call gba_eeprom_read
 2171               	.LVL216:
 2172 034e 00E0      		ldi r16,lo8(eepromBuffer)
 2173 0350 10E0      		ldi r17,hi8(eepromBuffer)
 2174               	.LVL217:
 2175               	.L111:
 2176               	.LBB71:
 299:main.c        **** 				}
 2177               		.loc 3 299 0 discriminator 2
 2178 0352 F801      		movw r30,r16
 2179 0354 8191      		ld r24,Z+
 2180 0356 8F01      		movw r16,r30
 2181               	.LVL218:
 2182 0358 0E94 0000 		call USART_Transmit
 2183               	.LVL219:
 298:main.c        **** 					USART_Transmit(eepromBuffer[c]);
 2184               		.loc 3 298 0 discriminator 2
 2185 035c F0E0      		ldi r31,hi8(eepromBuffer+8)
 2186 035e 0030      		cpi r16,lo8(eepromBuffer+8)
 2187 0360 1F07      		cpc r17,r31
 2188 0362 01F4      		brne .L111
 2189               	.LBE71:
 301:main.c        **** 				
 2190               		.loc 3 301 0
 2191 0364 8FEF      		ldi r24,-1
 2192 0366 C81A      		sub r12,r24
 2193 0368 D80A      		sbc r13,r24
 2194 036a E80A      		sbc r14,r24
 2195 036c F80A      		sbc r15,r24
 2196               	.LVL220:
 303:main.c        **** 				receivedChar = USART_Receive();
 2197               		.loc 3 303 0
 2198 036e 9398      		cbi 0x12,3
 2199               		.loc 3 304 0
 2200 0370 0E94 0000 		call USART_Receive
 2201               	.LVL221:
 2202 0374 00C0      		rjmp .L156
 2203               	.LVL222:
 2204               	.L108:
 305:main.c        **** 			}
 306:main.c        **** 			
 307:main.c        **** 			gba_mode(); // Set back
 308:main.c        **** 		}
 309:main.c        **** 		
 310:main.c        **** 		// Write 8 bytes to the EEPROM address (and increment)
 311:main.c        **** 		else if (receivedChar == GBA_WRITE_EEPROM) {
 2205               		.loc 3 311 0
 2206 0376 8037      		cpi r24,lo8(112)
 2207 0378 01F4      		brne .L113
 312:main.c        **** 			gba_eeprom_mode();
 2208               		.loc 3 312 0
 2209 037a 0E94 0000 		call gba_eeprom_mode
 2210               	.LVL223:
 2211 037e 00E0      		ldi r16,lo8(eepromBuffer)
 2212 0380 10E0      		ldi r17,hi8(eepromBuffer)
 2213               	.LVL224:
 2214               	.L115:
 2215               	.LBB72:
 313:main.c        **** 			
 314:main.c        **** 			// Read 8 bytes from USART and place in buffer
 315:main.c        **** 			for (uint8_t x = 0; x < 8; x++) {
 316:main.c        **** 				eepromBuffer[x] = USART_Receive();
 2216               		.loc 3 316 0 discriminator 2
 2217 0382 0E94 0000 		call USART_Receive
 2218               	.LVL225:
 2219 0386 F801      		movw r30,r16
 2220 0388 8193      		st Z+,r24
 2221 038a 8F01      		movw r16,r30
 2222               	.LVL226:
 315:main.c        **** 				eepromBuffer[x] = USART_Receive();
 2223               		.loc 3 315 0 discriminator 2
 2224 038c F0E0      		ldi r31,hi8(eepromBuffer+8)
 2225 038e 0030      		cpi r16,lo8(eepromBuffer+8)
 2226 0390 1F07      		cpc r17,r31
 2227 0392 01F4      		brne .L115
 2228               	.LBE72:
 317:main.c        **** 			}
 318:main.c        **** 			PORTD |= (1<<LED);
 2229               		.loc 3 318 0
 2230 0394 939A      		sbi 0x12,3
 319:main.c        **** 			
 320:main.c        **** 			gba_eeprom_write(address, eepromSize);
 2231               		.loc 3 320 0
 2232 0396 672D      		mov r22,r7
 2233 0398 C601      		movw r24,r12
 2234 039a 0E94 0000 		call gba_eeprom_write
 2235               	.LVL227:
 321:main.c        **** 			address++;
 2236               		.loc 3 321 0
 2237 039e 8FEF      		ldi r24,-1
 2238 03a0 C81A      		sub r12,r24
 2239 03a2 D80A      		sbc r13,r24
 2240 03a4 E80A      		sbc r14,r24
 2241 03a6 F80A      		sbc r15,r24
 2242               	.LVL228:
 2243               	.LBB73:
 2244               	.LBB74:
 163:c:\winavr-20100110\avr\include\util\delay.h **** 
 2245               		.loc 2 163 0
 2246 03a8 EFE7      		ldi r30,lo8(15999)
 2247 03aa FEE3      		ldi r31,hi8(15999)
 2248 03ac 3197      		1: sbiw r30,1
 2249 03ae 01F4      		brne 1b
 2250 03b0 00C0      		rjmp .
 2251 03b2 0000      		nop
 2252               	.LBE74:
 2253               	.LBE73:
 322:main.c        **** 			
 323:main.c        **** 			_delay_ms(8); // Wait for EEPROM to write data (8ms)
 324:main.c        **** 			USART_Transmit('1'); // Send back acknowledgement
 2254               		.loc 3 324 0
 2255 03b4 81E3      		ldi r24,lo8(49)
 2256 03b6 0E94 0000 		call USART_Transmit
 2257               	.LVL229:
 325:main.c        **** 			
 326:main.c        **** 			PORTD &= ~(1<<LED);
 2258               		.loc 3 326 0
 2259 03ba 9398      		cbi 0x12,3
 2260               	.LVL230:
 2261               	.L149:
 327:main.c        **** 			gba_mode(); // Set back
 2262               		.loc 3 327 0
 2263 03bc 0E94 0000 		call gba_mode
 2264               	.LVL231:
 2265 03c0 00C0      		rjmp .L69
 2266               	.L113:
 328:main.c        **** 		}
 329:main.c        **** 		
 330:main.c        **** 		
 331:main.c        **** 		// ---------- General commands ----------
 332:main.c        **** 		// Set any pin as input/output
 333:main.c        **** 		// Reads the DDR/PORT (e.g. DDRB/PORTB is 'B') and the hex value that represents pins to set to a
 334:main.c        **** 		else if (receivedChar == SET_INPUT || receivedChar == SET_OUTPUT) {
 2267               		.loc 3 334 0
 2268 03c2 8934      		cpi r24,lo8(73)
 2269 03c4 01F0      		breq .L116
 2270               		.loc 3 334 0 is_stmt 0 discriminator 1
 2271 03c6 8F34      		cpi r24,lo8(79)
 2272 03c8 01F0      		breq .+2
 2273 03ca 00C0      		rjmp .L117
 2274               	.L116:
 2275               	.LBB75:
 335:main.c        **** 			char portChar = USART_Receive();
 2276               		.loc 3 335 0 is_stmt 1
 2277 03cc 0E94 0000 		call USART_Receive
 2278               	.LVL232:
 2279 03d0 182F      		mov r17,r24
 2280               	.LVL233:
 336:main.c        **** 			usart_read_chars();
 2281               		.loc 3 336 0
 2282 03d2 0E94 0000 		call usart_read_chars
 2283               	.LVL234:
 337:main.c        **** 			uint8_t setValue = strtol(receivedBuffer, NULL, 16);
 2284               		.loc 3 337 0
 2285 03d6 40E1      		ldi r20,lo8(16)
 2286 03d8 50E0      		ldi r21,0
 2287 03da 60E0      		ldi r22,0
 2288 03dc 70E0      		ldi r23,0
 2289 03de 80E0      		ldi r24,lo8(receivedBuffer)
 2290 03e0 90E0      		ldi r25,hi8(receivedBuffer)
 2291 03e2 0E94 0000 		call strtol
 2292               	.LVL235:
 338:main.c        **** 			
 339:main.c        **** 			PORTD |= (1<<LED);
 2293               		.loc 3 339 0
 2294 03e6 939A      		sbi 0x12,3
 340:main.c        **** 			if (receivedChar == SET_INPUT) {
 2295               		.loc 3 340 0
 2296 03e8 8091 0000 		lds r24,receivedChar
 2297 03ec 8934      		cpi r24,lo8(73)
 2298 03ee 01F4      		brne .L118
 341:main.c        **** 				if (portChar == 'A') {
 2299               		.loc 3 341 0
 2300 03f0 1134      		cpi r17,lo8(65)
 2301 03f2 01F4      		brne .L119
 342:main.c        **** 					DDRA &= ~(setValue);
 2302               		.loc 3 342 0
 2303 03f4 8AB3      		in r24,0x1a
 2304 03f6 6095      		com r22
 2305               	.LVL236:
 2306 03f8 6823      		and r22,r24
 2307               	.LVL237:
 2308 03fa 6ABB      		out 0x1a,r22
 2309 03fc 00C0      		rjmp .L138
 2310               	.LVL238:
 2311               	.L119:
 343:main.c        **** 				}
 344:main.c        **** 				else if (portChar == 'B') {
 2312               		.loc 3 344 0
 2313 03fe 1234      		cpi r17,lo8(66)
 2314 0400 01F4      		brne .L121
 345:main.c        **** 					DDRB &= ~(setValue);
 2315               		.loc 3 345 0
 2316 0402 87B3      		in r24,0x17
 2317 0404 6095      		com r22
 2318               	.LVL239:
 2319 0406 6823      		and r22,r24
 2320               	.LVL240:
 2321 0408 67BB      		out 0x17,r22
 2322 040a 00C0      		rjmp .L138
 2323               	.LVL241:
 2324               	.L121:
 346:main.c        **** 				}
 347:main.c        **** 				else if (portChar == 'C') {
 2325               		.loc 3 347 0
 2326 040c 1334      		cpi r17,lo8(67)
 2327 040e 01F4      		brne .L122
 348:main.c        **** 					DDRC &= ~(setValue);
 2328               		.loc 3 348 0
 2329 0410 84B3      		in r24,0x14
 2330 0412 6095      		com r22
 2331               	.LVL242:
 2332 0414 6823      		and r22,r24
 2333               	.LVL243:
 2334 0416 64BB      		out 0x14,r22
 2335 0418 00C0      		rjmp .L138
 2336               	.LVL244:
 2337               	.L122:
 349:main.c        **** 				}
 350:main.c        **** 				else if (portChar == 'D') {
 2338               		.loc 3 350 0
 2339 041a 1434      		cpi r17,lo8(68)
 2340 041c 01F0      		breq .+2
 2341 041e 00C0      		rjmp .L138
 351:main.c        **** 					DDRD &= ~(setValue);
 2342               		.loc 3 351 0
 2343 0420 81B3      		in r24,0x11
 2344 0422 6095      		com r22
 2345               	.LVL245:
 2346 0424 6823      		and r22,r24
 2347               	.LVL246:
 2348 0426 61BB      		out 0x11,r22
 2349 0428 00C0      		rjmp .L138
 2350               	.LVL247:
 2351               	.L118:
 352:main.c        **** 				}
 353:main.c        **** 			}
 354:main.c        **** 			else if (receivedChar == SET_OUTPUT) {
 2352               		.loc 3 354 0
 2353 042a 8F34      		cpi r24,lo8(79)
 2354 042c 01F0      		breq .+2
 2355 042e 00C0      		rjmp .L138
 355:main.c        **** 				if (portChar == 'A') {
 2356               		.loc 3 355 0
 2357 0430 1134      		cpi r17,lo8(65)
 2358 0432 01F4      		brne .L123
 356:main.c        **** 					DDRA |= (setValue);
 2359               		.loc 3 356 0
 2360 0434 8AB3      		in r24,0x1a
 2361 0436 862B      		or r24,r22
 2362 0438 8ABB      		out 0x1a,r24
 2363 043a 00C0      		rjmp .L138
 2364               	.L123:
 357:main.c        **** 				}
 358:main.c        **** 				else if (portChar == 'B') {
 2365               		.loc 3 358 0
 2366 043c 1234      		cpi r17,lo8(66)
 2367 043e 01F4      		brne .L124
 359:main.c        **** 					DDRB |= (setValue);
 2368               		.loc 3 359 0
 2369 0440 87B3      		in r24,0x17
 2370 0442 862B      		or r24,r22
 2371 0444 87BB      		out 0x17,r24
 2372 0446 00C0      		rjmp .L138
 2373               	.L124:
 360:main.c        **** 				}
 361:main.c        **** 				else if (portChar == 'C') {
 2374               		.loc 3 361 0
 2375 0448 1334      		cpi r17,lo8(67)
 2376 044a 01F4      		brne .L125
 362:main.c        **** 					DDRC |= (setValue);
 2377               		.loc 3 362 0
 2378 044c 84B3      		in r24,0x14
 2379 044e 862B      		or r24,r22
 2380 0450 84BB      		out 0x14,r24
 2381 0452 00C0      		rjmp .L138
 2382               	.L125:
 363:main.c        **** 				}
 364:main.c        **** 				else if (portChar == 'D') {
 2383               		.loc 3 364 0
 2384 0454 1434      		cpi r17,lo8(68)
 2385 0456 01F0      		breq .+2
 2386 0458 00C0      		rjmp .L138
 365:main.c        **** 					DDRD |= (setValue);
 2387               		.loc 3 365 0
 2388 045a 81B3      		in r24,0x11
 2389 045c 862B      		or r24,r22
 2390 045e 81BB      		out 0x11,r24
 2391 0460 00C0      		rjmp .L138
 2392               	.LVL248:
 2393               	.L117:
 2394               	.LBE75:
 366:main.c        **** 				}
 367:main.c        **** 			}
 368:main.c        **** 			PORTD &= ~(1<<LED);
 369:main.c        **** 		}
 370:main.c        **** 		
 371:main.c        **** 		// Set pin output as low
 372:main.c        **** 		else if (receivedChar == SET_OUTPUT_LOW) {
 2395               		.loc 3 372 0
 2396 0462 8C34      		cpi r24,lo8(76)
 2397 0464 01F4      		brne .L126
 2398               	.LBB76:
 373:main.c        **** 			char portChar = USART_Receive();			
 2399               		.loc 3 373 0
 2400 0466 0E94 0000 		call USART_Receive
 2401               	.LVL249:
 2402 046a 182F      		mov r17,r24
 2403               	.LVL250:
 374:main.c        **** 			usart_read_chars();
 2404               		.loc 3 374 0
 2405 046c 0E94 0000 		call usart_read_chars
 2406               	.LVL251:
 375:main.c        **** 			uint8_t setValue = strtol(receivedBuffer, NULL, 16);
 2407               		.loc 3 375 0
 2408 0470 40E1      		ldi r20,lo8(16)
 2409 0472 50E0      		ldi r21,0
 2410 0474 60E0      		ldi r22,0
 2411 0476 70E0      		ldi r23,0
 2412 0478 80E0      		ldi r24,lo8(receivedBuffer)
 2413 047a 90E0      		ldi r25,hi8(receivedBuffer)
 2414 047c 0E94 0000 		call strtol
 2415               	.LVL252:
 376:main.c        **** 			
 377:main.c        **** 			PORTD |= (1<<LED);
 2416               		.loc 3 377 0
 2417 0480 939A      		sbi 0x12,3
 378:main.c        **** 			if (portChar == 'A') {
 2418               		.loc 3 378 0
 2419 0482 1134      		cpi r17,lo8(65)
 2420 0484 01F4      		brne .L127
 379:main.c        **** 				PORTA &= ~(setValue);
 2421               		.loc 3 379 0
 2422 0486 8BB3      		in r24,0x1b
 2423 0488 6095      		com r22
 2424               	.LVL253:
 2425 048a 6823      		and r22,r24
 2426               	.LVL254:
 2427 048c 6BBB      		out 0x1b,r22
 2428 048e 00C0      		rjmp .L138
 2429               	.LVL255:
 2430               	.L127:
 380:main.c        **** 			}
 381:main.c        **** 			else if (portChar == 'B') {
 2431               		.loc 3 381 0
 2432 0490 1234      		cpi r17,lo8(66)
 2433 0492 01F4      		brne .L129
 382:main.c        **** 				PORTB &= ~(setValue);
 2434               		.loc 3 382 0
 2435 0494 88B3      		in r24,0x18
 2436 0496 6095      		com r22
 2437               	.LVL256:
 2438 0498 6823      		and r22,r24
 2439               	.LVL257:
 2440 049a 68BB      		out 0x18,r22
 2441 049c 00C0      		rjmp .L138
 2442               	.LVL258:
 2443               	.L129:
 383:main.c        **** 			}
 384:main.c        **** 			else if (portChar == 'C') {
 2444               		.loc 3 384 0
 2445 049e 1334      		cpi r17,lo8(67)
 2446 04a0 01F4      		brne .L130
 385:main.c        **** 				PORTC &= ~(setValue);
 2447               		.loc 3 385 0
 2448 04a2 85B3      		in r24,0x15
 2449 04a4 6095      		com r22
 2450               	.LVL259:
 2451 04a6 6823      		and r22,r24
 2452               	.LVL260:
 2453 04a8 65BB      		out 0x15,r22
 2454 04aa 00C0      		rjmp .L138
 2455               	.LVL261:
 2456               	.L130:
 386:main.c        **** 			}
 387:main.c        **** 			else if (portChar == 'D') {
 2457               		.loc 3 387 0
 2458 04ac 1434      		cpi r17,lo8(68)
 2459 04ae 01F0      		breq .+2
 2460 04b0 00C0      		rjmp .L138
 388:main.c        **** 				PORTD &= ~(setValue);
 2461               		.loc 3 388 0
 2462 04b2 82B3      		in r24,0x12
 2463 04b4 6095      		com r22
 2464               	.LVL262:
 2465 04b6 6823      		and r22,r24
 2466               	.LVL263:
 2467 04b8 62BB      		out 0x12,r22
 2468 04ba 00C0      		rjmp .L138
 2469               	.LVL264:
 2470               	.L126:
 2471               	.LBE76:
 389:main.c        **** 			}
 390:main.c        **** 			PORTD &= ~(1<<LED);
 391:main.c        **** 		}
 392:main.c        **** 		
 393:main.c        **** 		// Set pin output as high
 394:main.c        **** 		else if (receivedChar == SET_OUTPUT_HIGH) {
 2472               		.loc 3 394 0
 2473 04bc 8834      		cpi r24,lo8(72)
 2474 04be 01F4      		brne .L131
 2475               	.LBB77:
 395:main.c        **** 			char portChar = USART_Receive();			
 2476               		.loc 3 395 0
 2477 04c0 0E94 0000 		call USART_Receive
 2478               	.LVL265:
 2479 04c4 182F      		mov r17,r24
 2480               	.LVL266:
 396:main.c        **** 			usart_read_chars();
 2481               		.loc 3 396 0
 2482 04c6 0E94 0000 		call usart_read_chars
 2483               	.LVL267:
 397:main.c        **** 			uint8_t setValue = strtol(receivedBuffer, NULL, 16);
 2484               		.loc 3 397 0
 2485 04ca 40E1      		ldi r20,lo8(16)
 2486 04cc 50E0      		ldi r21,0
 2487 04ce 60E0      		ldi r22,0
 2488 04d0 70E0      		ldi r23,0
 2489 04d2 80E0      		ldi r24,lo8(receivedBuffer)
 2490 04d4 90E0      		ldi r25,hi8(receivedBuffer)
 2491 04d6 0E94 0000 		call strtol
 2492               	.LVL268:
 398:main.c        **** 			
 399:main.c        **** 			PORTD |= (1<<LED);
 2493               		.loc 3 399 0
 2494 04da 939A      		sbi 0x12,3
 400:main.c        **** 			if (portChar == 'A') {
 2495               		.loc 3 400 0
 2496 04dc 1134      		cpi r17,lo8(65)
 2497 04de 01F4      		brne .L132
 401:main.c        **** 				PORTA |= (setValue);
 2498               		.loc 3 401 0
 2499 04e0 8BB3      		in r24,0x1b
 2500 04e2 862B      		or r24,r22
 2501 04e4 8BBB      		out 0x1b,r24
 2502 04e6 00C0      		rjmp .L138
 2503               	.L132:
 402:main.c        **** 			}
 403:main.c        **** 			else if (portChar == 'B') {
 2504               		.loc 3 403 0
 2505 04e8 1234      		cpi r17,lo8(66)
 2506 04ea 01F4      		brne .L134
 404:main.c        **** 				PORTB |= (setValue);
 2507               		.loc 3 404 0
 2508 04ec 88B3      		in r24,0x18
 2509 04ee 862B      		or r24,r22
 2510 04f0 88BB      		out 0x18,r24
 2511 04f2 00C0      		rjmp .L138
 2512               	.L134:
 405:main.c        **** 			}
 406:main.c        **** 			else if (portChar == 'C') {
 2513               		.loc 3 406 0
 2514 04f4 1334      		cpi r17,lo8(67)
 2515 04f6 01F4      		brne .L135
 407:main.c        **** 				PORTC |= (setValue);
 2516               		.loc 3 407 0
 2517 04f8 85B3      		in r24,0x15
 2518 04fa 862B      		or r24,r22
 2519 04fc 85BB      		out 0x15,r24
 2520 04fe 00C0      		rjmp .L138
 2521               	.L135:
 408:main.c        **** 			}
 409:main.c        **** 			else if (portChar == 'D') {
 2522               		.loc 3 409 0
 2523 0500 1434      		cpi r17,lo8(68)
 2524 0502 01F4      		brne .L138
 410:main.c        **** 				PORTD |= (setValue);
 2525               		.loc 3 410 0
 2526 0504 82B3      		in r24,0x12
 2527 0506 862B      		or r24,r22
 2528 0508 82BB      		out 0x12,r24
 2529 050a 00C0      		rjmp .L138
 2530               	.LVL269:
 2531               	.L131:
 2532               	.LBE77:
 411:main.c        **** 			}
 412:main.c        **** 			PORTD &= ~(1<<LED);
 413:main.c        **** 		}
 414:main.c        **** 		
 415:main.c        **** 		// Read all pins of a PORT and return the value
 416:main.c        **** 		else if (receivedChar == READ_INPUT) {
 2533               		.loc 3 416 0
 2534 050c 8434      		cpi r24,lo8(68)
 2535 050e 01F4      		brne .L136
 2536               	.LBB78:
 417:main.c        **** 			char portChar = USART_Receive();			
 2537               		.loc 3 417 0
 2538 0510 0E94 0000 		call USART_Receive
 2539               	.LVL270:
 418:main.c        **** 			
 419:main.c        **** 			PORTD |= (1<<LED);
 2540               		.loc 3 419 0
 2541 0514 939A      		sbi 0x12,3
 420:main.c        **** 			if (portChar == 'A') {
 2542               		.loc 3 420 0
 2543 0516 8134      		cpi r24,lo8(65)
 2544 0518 01F4      		brne .L137
 421:main.c        **** 				USART_Transmit(PINA);
 2545               		.loc 3 421 0
 2546 051a 89B3      		in r24,0x19
 2547               	.LVL271:
 2548 051c 00C0      		rjmp .L157
 2549               	.LVL272:
 2550               	.L137:
 422:main.c        **** 			}
 423:main.c        **** 			else if (portChar == 'B') {
 2551               		.loc 3 423 0
 2552 051e 8234      		cpi r24,lo8(66)
 2553 0520 01F4      		brne .L139
 424:main.c        **** 				USART_Transmit(PINB);
 2554               		.loc 3 424 0
 2555 0522 86B3      		in r24,0x16
 2556               	.LVL273:
 2557 0524 00C0      		rjmp .L157
 2558               	.LVL274:
 2559               	.L139:
 425:main.c        **** 			}
 426:main.c        **** 			else if (portChar == 'C') {
 2560               		.loc 3 426 0
 2561 0526 8334      		cpi r24,lo8(67)
 2562 0528 01F4      		brne .L140
 427:main.c        **** 				USART_Transmit(PINC);
 2563               		.loc 3 427 0
 2564 052a 83B3      		in r24,0x13
 2565               	.LVL275:
 2566 052c 00C0      		rjmp .L157
 2567               	.LVL276:
 2568               	.L140:
 428:main.c        **** 			}
 429:main.c        **** 			else if (portChar == 'D') {
 2569               		.loc 3 429 0
 2570 052e 8434      		cpi r24,lo8(68)
 2571 0530 01F4      		brne .L138
 430:main.c        **** 				USART_Transmit(PIND);
 2572               		.loc 3 430 0
 2573 0532 80B3      		in r24,0x10
 2574               	.LVL277:
 2575               	.L157:
 2576 0534 0E94 0000 		call USART_Transmit
 2577               	.LVL278:
 2578               	.L138:
 431:main.c        **** 			}
 432:main.c        **** 			PORTD &= ~(1<<LED);
 2579               		.loc 3 432 0 discriminator 1
 2580 0538 9398      		cbi 0x12,3
 2581               	.LBE78:
 2582 053a 00C0      		rjmp .L69
 2583               	.L136:
 433:main.c        **** 		}
 434:main.c        **** 		
 435:main.c        **** 		// Set the reset common lines variable on or off, useful if you are controlling all the pins dire
 436:main.c        **** 		else if (receivedChar == RESET_COMMON_LINES) {
 2584               		.loc 3 436 0
 2585 053c 8D34      		cpi r24,lo8(77)
 2586 053e 01F4      		brne .L141
 2587               	.LBB79:
 437:main.c        **** 			char commonChar = USART_Receive();
 2588               		.loc 3 437 0
 2589 0540 0E94 0000 		call USART_Receive
 2590               	.LVL279:
 438:main.c        **** 			if (commonChar == '1') {
 2591               		.loc 3 438 0
 2592 0544 8133      		cpi r24,lo8(49)
 2593 0546 01F4      		brne .L161
 439:main.c        **** 				resetCommonLines = 1;
 2594               		.loc 3 439 0
 2595 0548 6624      		clr r6
 2596 054a 6394      		inc r6
 2597 054c 00C0      		rjmp .L148
 2598               	.L161:
 440:main.c        **** 			}
 441:main.c        **** 			else if (commonChar == '0') {
 2599               		.loc 3 441 0
 2600 054e 8033      		cpi r24,lo8(48)
 2601 0550 01F0      		breq .+2
 2602 0552 00C0      		rjmp .L69
 442:main.c        **** 				resetCommonLines = 0;
 2603               		.loc 3 442 0
 2604 0554 612C      		mov r6,__zero_reg__
 2605 0556 00C0      		rjmp .L70
 2606               	.LVL280:
 2607               	.L141:
 2608               	.LBE79:
 443:main.c        **** 			}
 444:main.c        **** 		}
 445:main.c        **** 		
 446:main.c        **** 		// Send back the build version number
 447:main.c        **** 		else if (receivedChar == READ_BUILD_VERSION) {
 2609               		.loc 3 447 0
 2610 0558 8635      		cpi r24,lo8(86)
 2611 055a 01F0      		breq .+2
 2612 055c 00C0      		rjmp .L69
 448:main.c        **** 			USART_Transmit(BUILD);
 2613               		.loc 3 448 0
 2614 055e 81E0      		ldi r24,lo8(1)
 2615 0560 0E94 0000 		call USART_Transmit
 2616               	.LVL281:
 2617 0564 00C0      		rjmp .L69
 2618               		.cfi_endproc
 2619               	.LFE35:
 2621               		.comm	flashChipIdBuffer,2,1
 2622               		.comm	eepromBuffer,8,1
 2623               		.comm	receivedChar,1,1
 2624               		.comm	receivedBuffer,129,1
 2625               		.text
 2626               	.Letext0:
 2627               		.file 4 "c:\\winavr-20100110\\avr\\include\\stdint.h"
 2628               		.file 5 "c:\\winavr-20100110\\avr\\include\\stdlib.h"
DEFINED SYMBOLS
                            *ABS*:00000000 main.c
C:\Users\Alex\AppData\Local\Temp\ccGT11rt.s:2      *ABS*:0000003e __SP_H__
C:\Users\Alex\AppData\Local\Temp\ccGT11rt.s:3      *ABS*:0000003d __SP_L__
C:\Users\Alex\AppData\Local\Temp\ccGT11rt.s:4      *ABS*:0000003f __SREG__
C:\Users\Alex\AppData\Local\Temp\ccGT11rt.s:5      *ABS*:00000000 __tmp_reg__
C:\Users\Alex\AppData\Local\Temp\ccGT11rt.s:6      *ABS*:00000001 __zero_reg__
C:\Users\Alex\AppData\Local\Temp\ccGT11rt.s:12     .text:00000000 USART_Receive
C:\Users\Alex\AppData\Local\Temp\ccGT11rt.s:34     .text:00000008 USART_Transmit
C:\Users\Alex\AppData\Local\Temp\ccGT11rt.s:55     .text:00000010 usart_read_bytes
                            *COM*:00000081 receivedBuffer
C:\Users\Alex\AppData\Local\Temp\ccGT11rt.s:121    .text:0000003e usart_read_chars
C:\Users\Alex\AppData\Local\Temp\ccGT11rt.s:165    .text:0000005c rd_wr_csmreq_cs2_reset
C:\Users\Alex\AppData\Local\Temp\ccGT11rt.s:187    .text:00000066 gb_mode
C:\Users\Alex\AppData\Local\Temp\ccGT11rt.s:214    .text:00000076 set_16bit_address
C:\Users\Alex\AppData\Local\Temp\ccGT11rt.s:233    .text:0000007c read_8bit_data
C:\Users\Alex\AppData\Local\Temp\ccGT11rt.s:269    .text:0000008e write_8bit_data
C:\Users\Alex\AppData\Local\Temp\ccGT11rt.s:343    .text:000000ca gba_mode
C:\Users\Alex\AppData\Local\Temp\ccGT11rt.s:370    .text:000000da gba_set_24bit_address
C:\Users\Alex\AppData\Local\Temp\ccGT11rt.s:423    .text:00000106 gba_read_16bit_data
C:\Users\Alex\AppData\Local\Temp\ccGT11rt.s:471    .text:00000126 gba_read_ram_8bit_data
C:\Users\Alex\AppData\Local\Temp\ccGT11rt.s:511    .text:0000013a gba_write_ram_8bit_data
C:\Users\Alex\AppData\Local\Temp\ccGT11rt.s:578    .text:0000016a gba_eeprom_mode
C:\Users\Alex\AppData\Local\Temp\ccGT11rt.s:605    .text:0000017a gba_eeprom_set_address
C:\Users\Alex\AppData\Local\Temp\ccGT11rt.s:745    .text:000001e2 gba_eeprom_read
                            *COM*:00000008 eepromBuffer
C:\Users\Alex\AppData\Local\Temp\ccGT11rt.s:877    .text:0000023e gba_eeprom_write
C:\Users\Alex\AppData\Local\Temp\ccGT11rt.s:993    .text:00000292 flash_write_bus_cycle
C:\Users\Alex\AppData\Local\Temp\ccGT11rt.s:1052   .text:000002bc flash_read_chip_id
                            *COM*:00000002 flashChipIdBuffer
C:\Users\Alex\AppData\Local\Temp\ccGT11rt.s:1141   .text:0000032e flash_switch_bank
C:\Users\Alex\AppData\Local\Temp\ccGT11rt.s:1190   .text:0000035c flash_erase_4k_sector
C:\Users\Alex\AppData\Local\Temp\ccGT11rt.s:1264   .text:000003b0 flash_write_byte
C:\Users\Alex\AppData\Local\Temp\ccGT11rt.s:1334   .text:000003f0 flash_write_sector
C:\Users\Alex\AppData\Local\Temp\ccGT11rt.s:1446   .text:00000464 setup
C:\Users\Alex\AppData\Local\Temp\ccGT11rt.s:1513   .text.startup:00000000 main
                            *COM*:00000001 receivedChar

UNDEFINED SYMBOLS
strtol
atoi
__do_clear_bss
